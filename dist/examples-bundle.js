(function () {
	'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var arguments$1 = arguments;

		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments$1[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
	60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){
	var arguments$1 = arguments;
	for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++){ b+="&args[]="+encodeURIComponent(arguments$1[c]); }return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
	var D={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D;}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a){ throw Error(C(85)); }this.updater.enqueueSetState(this,a,b,"setState");};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};
	function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D;}var I=H.prototype=new G;I.constructor=H;objectAssign(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
	function M(a,b,c){
	var arguments$1 = arguments;
	var e,d={},g=null,k=null;if(null!=b){ for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b){ K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]); } }var f=arguments.length-2;if(1===f){ d.children=c; }else if(1<f){for(var h=Array(f),m=0;m<f;m++){ h[m]=arguments$1[m+2]; }d.children=h;}if(a&&a.defaultProps){ for(e in f=a.defaultProps,f){ void 0===d[e]&&(d[e]=f[e]); } }return {$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
	function N(a,b){return {$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return "object"===typeof a&&null!==a&&a.$$typeof===p}function escape$1(a){var b={"=":"=0",":":"=2"};return "$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return {result:a,keyPrefix:b,func:c,context:e,count:0}}
	function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a);}
	function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d){ a=null; }var g=!1;if(null===a){ g=!0; }else { switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0;}} }if(g){ return c(e,a,""===b?"."+U(a,0):b),1; }g=0;b=""===b?".":b+":";if(Array.isArray(a)){ for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e);} }else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f){ for(a=f.call(a),k=
	0;!(d=a.next()).done;){ d=d.value,f=b+U(d,k++),g+=T(d,f,c,e); } }else if("object"===d){ throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,"")); }return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape$1(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++);}
	function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a));}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b);}var Y={current:null};function Z(){var a=Y.current;if(null===a){ throw Error(C(321)); }return a}
	var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:objectAssign};var Children={map:function(a,b,c){if(null==a){ return a; }var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a){ return a; }b=R(null,null,b,c);V(a,W,b);S(b);},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a)){ throw Error(C(143)); }return a}};
	var Component=F;var Fragment=r;var Profiler=u;var PureComponent=H;var StrictMode=t;var Suspense=y;var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
	var cloneElement=function(a,b,c){
	var arguments$1 = arguments;
	if(null===a||void 0===a){ throw Error(C(267,a)); }var e=objectAssign({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps){ var f=a.type.defaultProps; }for(h in b){ K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h]); }}var h=arguments.length-2;if(1===h){ e.children=c; }else if(1<h){f=Array(h);for(var m=0;m<h;m++){ f[m]=arguments$1[m+2]; }e.children=f;}return {$$typeof:p,type:a.type,
	key:d,ref:g,props:e,_owner:k}};var createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};var createElement=M;var createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};var createRef=function(){return {current:null}};var forwardRef=function(a){return {$$typeof:x,render:a}};var isValidElement=O;
	var lazy=function(a){return {$$typeof:A,_ctor:a,_status:-1,_result:null}};var memo=function(a,b){return {$$typeof:z,type:a,compare:void 0===b?null:b}};var useCallback=function(a,b){return Z().useCallback(a,b)};var useContext=function(a,b){return Z().useContext(a,b)};var useDebugValue=function(){};var useEffect=function(a,b){return Z().useEffect(a,b)};var useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
	var useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};var useMemo=function(a,b){return Z().useMemo(a,b)};var useReducer=function(a,b,c){return Z().useReducer(a,b,c)};var useRef=function(a){return Z().useRef(a)};var useState=function(a){return Z().useState(a)};var version="16.14.0";

	var react_production_min = {
		Children: Children,
		Component: Component,
		Fragment: Fragment,
		Profiler: Profiler,
		PureComponent: PureComponent,
		StrictMode: StrictMode,
		Suspense: Suspense,
		__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
		cloneElement: cloneElement,
		createContext: createContext,
		createElement: createElement,
		createFactory: createFactory,
		createRef: createRef,
		forwardRef: forwardRef,
		isValidElement: isValidElement,
		lazy: lazy,
		memo: memo,
		useCallback: useCallback,
		useContext: useContext,
		useDebugValue: useDebugValue,
		useEffect: useEffect,
		useImperativeHandle: useImperativeHandle,
		useLayoutEffect: useLayoutEffect,
		useMemo: useMemo,
		useReducer: useReducer,
		useRef: useRef,
		useState: useState,
		version: version
	};

	var react = createCommonjsModule(function (module) {

	{
	  module.exports = react_production_min;
	}
	});
	react.Component;
	react.cloneElement;

	var scheduler_production_min = createCommonjsModule(function (module, exports) {
	var f,g,h,k,l;
	if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p){ try{var a=exports.unstable_now();p(!0,a);p=null;}catch(b){throw setTimeout(t,0),b;} }},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0));};g=function(a,b){q=setTimeout(a,b);};h=function(){clearTimeout(q);};k=function(){return !1};l=exports.unstable_forceFrameRate=function(){};}else {var w=window.performance,x=window.Date,
	y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");}if("object"===
	typeof w&&"function"===typeof w.now){ exports.unstable_now=function(){return w.now()}; }else {var B=x.now();exports.unstable_now=function(){return x.now()-B};}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5;};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
	function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null);}catch(b){throw I.postMessage(null),b;}}else { C=!1; }};f=function(a){D=a;C||(C=!0,I.postMessage(null));};g=function(a,b){E=y(function(){a(exports.unstable_now());},b);};h=function(){z(E);E=-1;};}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b)){ a[d]=b,a[c]=e,c=d; }else { break a }}}function L(a){a=a[0];return void 0===a?null:a}
	function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c)){ void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m); }else if(void 0!==r&&0>K(r,c)){ a[d]=r,a[v]=c,d=v; }else { break a }}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
	function V(a){for(var b=L(O);null!==b;){if(null===b.callback){ M(O); }else if(b.startTime<=a){ M(O),b.sortIndex=b.expirationTime,J(N,b); }else { break; }b=L(O);}}function W(a){U=!1;V(a);if(!T){ if(null!==L(N)){ T=!0,f(X); }else {var b=L(O);null!==b&&g(W,b.startTime-a);} }}
	function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b);}else { M(N); }Q=L(N);}if(null!==Q){ var m=!0; }else {var n=L(O);null!==n&&g(W,n.startTime-b);m=!1;}return m}finally{Q=null,R=c,S=!1;}}
	function Y(a){switch(a){case 1:return -1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X));};
	exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R;}var c=R;R=b;try{return a()}finally{R=c;}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=R;R=a;try{return b()}finally{R=c;}};
	exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a);}else { c=Y(a),e=d; }c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};
	exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c;}}};
	});
	scheduler_production_min.unstable_now;
	scheduler_production_min.unstable_forceFrameRate;
	scheduler_production_min.unstable_IdlePriority;
	scheduler_production_min.unstable_ImmediatePriority;
	scheduler_production_min.unstable_LowPriority;
	scheduler_production_min.unstable_NormalPriority;
	scheduler_production_min.unstable_Profiling;
	scheduler_production_min.unstable_UserBlockingPriority;
	scheduler_production_min.unstable_cancelCallback;
	scheduler_production_min.unstable_continueExecution;
	scheduler_production_min.unstable_getCurrentPriorityLevel;
	scheduler_production_min.unstable_getFirstCallbackNode;
	scheduler_production_min.unstable_next;
	scheduler_production_min.unstable_pauseExecution;
	scheduler_production_min.unstable_requestPaint;
	scheduler_production_min.unstable_runWithPriority;
	scheduler_production_min.unstable_scheduleCallback;
	scheduler_production_min.unstable_shouldYield;
	scheduler_production_min.unstable_wrapCallback;

	var scheduler = createCommonjsModule(function (module) {

	{
	  module.exports = scheduler_production_min;
	}
	});

	function u$1(a){
	var arguments$1 = arguments;
	for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++){ b+="&args[]="+encodeURIComponent(arguments$1[c]); }return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!react){ throw Error(u$1(227)); }
	function ba$1(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a;}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba$1.apply(ia,arguments);}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null;}else { throw Error(u$1(198)); }fa||(fa=!0,ha=l);}}var la=null,ma=null,na=null;
	function oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null;}var pa=null,qa={};
	function ra(){if(pa){ for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c)){ throw Error(u$1(96,a)); }if(!sa[c]){if(!b.extractEvents){ throw Error(u$1(97,a)); }sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h)){ throw Error(u$1(99,h)); }ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k){ k.hasOwnProperty(e)&&ua(k[e],g,h); }e=!0;}else { f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1; }if(!e){ throw Error(u$1(98,d,a)); }}}} }}
	function ua(a,b,c){if(va[a]){ throw Error(u$1(100,a)); }va[a]=b;wa[a]=b.eventTypes[c].dependencies;}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a){ if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c]){ throw Error(u$1(102,c)); }qa[c]=d;b=!0;}} }b&&ra();}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;
	function Ca(a){if(a=ma(a)){if("function"!==typeof za){ throw Error(u$1(280)); }var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b));}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a;}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b){ for(a=0;a<b.length;a++){ Ca(b[a]); } }}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba){ Ha(),Ea(); }}
	function Ma(a,b,c){if(Ka){ return a(b,c); }Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La();}}var Na=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};
	function Ra(a){if(Oa.call(Qa,a)){ return !0; }if(Oa.call(Pa,a)){ return !1; }if(Na.test(a)){ return Qa[a]=!0; }Pa[a]=!0;return !1}function Sa(a,b,c,d){if(null!==c&&0===c.type){ return !1; }switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d){ return !1; }if(null!==c){ return !c.acceptsBooleans; }a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
	function Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d)){ return !0; }if(d){ return !1; }if(null!==c){ switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b} }return !1}function v$1(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;}var C$1={};
	"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C$1[a]=new v$1(a,0,!1,a,null,!1);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C$1[b]=new v$1(b,1,!1,a[1],null,!1);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C$1[a]=new v$1(a,2,!1,a.toLowerCase(),null,!1);});
	["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C$1[a]=new v$1(a,2,!1,a,null,!1);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C$1[a]=new v$1(a,3,!1,a.toLowerCase(),null,!1);});
	["checked","multiple","muted","selected"].forEach(function(a){C$1[a]=new v$1(a,3,!0,a,null,!1);});["capture","download"].forEach(function(a){C$1[a]=new v$1(a,4,!1,a,null,!1);});["cols","rows","size","span"].forEach(function(a){C$1[a]=new v$1(a,6,!1,a,null,!1);});["rowSpan","start"].forEach(function(a){C$1[a]=new v$1(a,5,!1,a.toLowerCase(),null,!1);});var Ua=/[\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}
	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,
	Va);C$1[b]=new v$1(b,1,!1,a,null,!1);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C$1[b]=new v$1(b,1,!1,a,"http://www.w3.org/1999/xlink",!1);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C$1[b]=new v$1(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1);});["tabIndex","crossOrigin"].forEach(function(a){C$1[a]=new v$1(a,1,!1,a.toLowerCase(),null,!1);});
	C$1.xlinkHref=new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C$1[a]=new v$1(a,1,!1,a.toLowerCase(),null,!0);});var Wa=react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});
	function Xa(a,b,c,d){var e=C$1.hasOwnProperty(b)?C$1[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))));}
	var Ya=/^(.*)[\\\/]/,E$1="function"===typeof Symbol&&Symbol.for,Za=E$1?Symbol.for("react.element"):60103,$a=E$1?Symbol.for("react.portal"):60106,ab=E$1?Symbol.for("react.fragment"):60107,bb=E$1?Symbol.for("react.strict_mode"):60108,cb=E$1?Symbol.for("react.profiler"):60114,db=E$1?Symbol.for("react.provider"):60109,eb=E$1?Symbol.for("react.context"):60110,fb=E$1?Symbol.for("react.concurrent_mode"):60111,gb=E$1?Symbol.for("react.forward_ref"):60112,hb=E$1?Symbol.for("react.suspense"):60113,ib=E$1?Symbol.for("react.suspense_list"):
	60120,jb=E$1?Symbol.for("react.memo"):60115,kb=E$1?Symbol.for("react.lazy"):60116,lb=E$1?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a){ return null; }a=mb&&a[mb]||a["@@iterator"];return "function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b);},function(b){0===a._status&&(a._status=2,a._result=b);});}}
	function pb(a){if(null==a){ return null; }if("function"===typeof a){ return a.displayName||a.name||null; }if("string"===typeof a){ return a; }switch(a){case ab:return "Fragment";case $a:return "Portal";case cb:return "Profiler";case bb:return "StrictMode";case hb:return "Suspense";case ib:return "SuspenseList"}if("object"===typeof a){ switch(a.$$typeof){case eb:return "Context.Consumer";case db:return "Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
	"ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null){ return pb(a) }} }return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f;}b+=c;a=a.return;}while(a);return b}
	function rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return ""}}function sb(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
	function tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
	null;delete a[b];}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a));}function yb(a){if(!a){ return !1; }var b=a._valueTracker;if(!b){ return !0; }var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return objectAssign({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
	function Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1);}
	function Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c){ if("number"===d){if(0===c&&""===a.value||a.value!=c){ a.value=""+c; }}else { a.value!==""+c&&(a.value=""+c); } }else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
	function Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value)){ return; }b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
	function Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a){ null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c); }}function Fb(a){var b="";react.Children.forEach(a,function(a){null!=a&&(b+=a);});return b}function Gb(a,b){a=objectAssign({children:void 0},b);if(b=Fb(b.children)){ a.children=b; }return a}
	function Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++){ b["$"+c[e]]=!0; }for(c=0;c<a.length;c++){ e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0); }}else {c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
	function Ib(a,b){if(null!=b.dangerouslySetInnerHTML){ throw Error(u$1(91)); }return objectAssign({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b){ throw Error(u$1(92)); }if(Array.isArray(c)){if(!(1>=c.length)){ throw Error(u$1(93)); }c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:rb(c)};}
	function Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
	function Nb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
	var Pb,Qb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a){ a.innerHTML=b; }else {Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;){ a.removeChild(a.firstChild); }for(;b.firstChild;){ a.appendChild(b.firstChild); }}});
	function Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};
	ya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a]){ return Ub[a]; }if(!Tb[a]){ return a; }var b=Tb[a],c;for(c in b){ if(b.hasOwnProperty(c)&&c in Vb){ return Ub[a]=b[c]; } }return a}
	var Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}
	function dc(a){var b=a,c=a;if(a.alternate){ for(;b.return;){ b=b.return; } }else {a=b;do { b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return; }while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b){ return b.dehydrated }}return null}function fc(a){if(dc(a)!==a){ throw Error(u$1(188)); }}
	function gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b){ throw Error(u$1(188)); }return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e){ break; }var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c){ return fc(e),a; }if(f===d){ return fc(e),b; }f=f.sibling;}throw Error(u$1(188));}if(c.return!==d.return){ c=e,d=f; }else {for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
	c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}if(!g){ throw Error(u$1(189)); }}}if(c.alternate!==d){ throw Error(u$1(190)); }}if(3!==c.tag){ throw Error(u$1(188)); }return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a){ return null; }for(var b=a;;){if(5===b.tag||6===b.tag){ return b; }if(b.child){ b.child.return=b,b=b.child; }else {if(b===a){ break; }for(;!b.sibling;){if(!b.return||b.return===a){ return null; }b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return null}
	function ic(a,b){if(null==b){ throw Error(u$1(30)); }if(null==a){ return b; }if(Array.isArray(a)){if(Array.isArray(b)){ return a.push.apply(a,b),a; }a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a);}var kc=null;
	function lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b)){ for(var d=0;d<b.length&&!a.isPropagationStopped();d++){ oa(a,b[d],c[d]); } }else { b&&oa(a,b,c); }a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a);}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc){ throw Error(u$1(95)); }if(fa){ throw a=ha,fa=!1,ha=null,a; }}}
	function nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya){ return !1; }a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a);}
	function rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return {topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}
	function sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag){ d=d.stateNode.containerInfo; }else {for(;d.return;){ d=d.return; }d=3!==d.tag?null:d.stateNode.containerInfo;}if(!d){ break; }b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d);}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=
	ic(h,l));}mc(h);}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F$1(a,b);}c.set(a,null);}}
	var wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
	function Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c);});Ic.forEach(function(a){uc(a,b,c);});}function Kc(a,b,c,d,e){return {blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}
	function Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId);}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f){ return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a; }a.eventSystemFlags|=d;return a}
	function Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return !0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return !1}
	function Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c){ if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;scheduler.unstable_runWithPriority(a.priority,function(){yc(c);});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return} }}a.blockedOn=null;}function Qc(a){if(null!==a.blockedOn){ return !1; }var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return !1}return !0}
	function Sc(a,b,c){Qc(a)&&c.delete(b);}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift();}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc);}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority,Tc)));}
	function Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++){ d=Gc[c],d.blockedOn===a&&(d.blockedOn=null); }for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);){ Pc(c),null===c.blockedOn&&Gc.shift(); }}
	var Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",
	"seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f;}}
	ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);
	ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++){ Zc.set(bd[cd],0); }
	var dd=scheduler.unstable_UserBlockingPriority,ed=scheduler.unstable_runWithPriority,fd=!0;function F$1(a,b){vc(b,a,!1);}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a);}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1);}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d);}finally{(Ja=f)||La();}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d));}
	function id(a,b,c,d){if(fd){ if(0<Ac.length&&-1<Hc.indexOf(a)){ a=Kc(null,a,b,c,d),Ac.push(a); }else {var e=Rc(a,b,c,d);if(null===e){ Lc(a,d); }else if(-1<Hc.indexOf(a)){ a=Kc(e,a,b,c,d),Ac.push(a); }else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a);}finally{qc(a);}}} }}
	function Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e){ c=null; }else {var f=e.tag;if(13===f){c=ec(e);if(null!==c){ return c; }c=null;}else if(3===f){if(e.stateNode.hydrate){ return 3===e.tag?e.stateNode.containerInfo:null; }c=null;}else { e!==c&&(c=null); }}}a=rc(a,d,c,b);try{Ma(sc,a);}finally{qc(a);}return null}
	var jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
	floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a];});});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}
	function md(a,b){a=a.style;for(var c in b){ if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;} }}var nd=objectAssign({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
	function od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML)){ throw Error(u$1(137,a,"")); }if(null!=b.dangerouslySetInnerHTML){if(null!=b.children){ throw Error(u$1(60)); }if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML)){ throw Error(u$1(61)); }}if(null!=b.style&&"object"!==typeof b.style){ throw Error(u$1(62,"")); }}}
	function pd(a,b){if(-1===a.indexOf("-")){ return "string"===typeof b.is; }switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++){ uc(b[d],a,c); }}function sd(){}
	function td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a){ return null; }try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;){ a=a.firstChild; }return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b){ return {node:c,offset:b-a}; }a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=ud(c);}}
	function wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c){ a=b.contentWindow; }else { break; }b=td(a.document);}return b}
	function yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return !!b.autoFocus}return !1}
	function Gd(a,b){return "textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b){ break }}return a}
	function Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b){ return a; }b--;}else { c===Ad&&b++; }}a=a.previousSibling;}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;
	function tc(a){var b=a[Md];if(b){ return b; }for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child){ for(a=Kd(a);null!==a;){if(c=a[Md]){ return c; }a=Kd(a);} }return b}a=c;c=a.parentNode;}return null}function Nc(a){a=a[Md]||a[Od];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag){ return a.stateNode; }throw Error(u$1(33));}function Qd(a){return a[Nd]||null}
	function Rd(a){do { a=a.return; }while(a&&5!==a.tag);return a?a:null}
	function Sd(a,b){var c=a.stateNode;if(!c){ return null; }var d=la(c);if(!d){ return null; }c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a){ return null; }if(c&&"function"!==typeof c){ throw Error(u$1(231,
	b,typeof c)); }return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b])){ c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a); }}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;){ c.push(b),b=Rd(b); }for(b=c.length;0<b--;){ Td(c[b],"captured",a); }for(b=0;b<c.length;b++){ Td(c[b],"bubbled",a); }}}
	function Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a));}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a);}function Xd(a){jc(a,Ud);}var Yd=null,Zd=null,$d=null;
	function ae(){if($d){ return $d; }var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++){ }var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++){ }return $d=e.slice(a,1<d?1-d:void 0)}function be(){return !0}function ce(){return !1}
	function G$1(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a){ a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]); }this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}
	objectAssign(G$1.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be);},persist:function(){this.isPersistent=be;},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,
	b;for(b in a){ this[b]=null; }this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null;}});G$1.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
	G$1.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;objectAssign(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=objectAssign({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G$1);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
	function fe(a){if(!(a instanceof this)){ throw Error(u$1(279)); }a.destructor();10>this.eventPool.length&&this.eventPool.push(a);}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe;}var ge=G$1.extend({data:null}),he=G$1.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);
	var le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
	captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;
	function qe(a,b){switch(a){case "keyup":return -1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return !0;default:return !1}}function re(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which){ return null; }pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}
	function ue(a,b){if(se){ return "compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null; }switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length){ return b.char; }if(b.which){ return String.fromCharCode(b.which) }}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}
	var ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je){ b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0;} }else { se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart); }f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,
	b,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!we[a.type]:"textarea"===b?!0:!1}
	var ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G$1.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a);}function De(a){var b=Pd(a);if(yb(b)){ return a }}function Ee(a,b){if("change"===a){ return b }}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));
	function Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null);}function He(a){if("value"===a.propertyName&&De(Be)){ if(a=ze(Be,a,nc(a)),Ja){ mc(a); }else {Ja=!0;try{Fa(Ce,a);}finally{Ja=!1,La();}} }}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge();}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a){ return De(Be) }}function Ke(a,b){if("click"===a){ return De(b) }}function Le(a,b){if("input"===a||"change"===a){ return De(b) }}
	var Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type){ var g=Ee; }else if(xe(e)){ if(Fe){ g=Le; }else {g=Je;var h=Ie;} }else { (f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke); }if(g&&(g=g(a,b))){ return ze(g,c,d); }h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value);}},Ne=G$1.extend({view:null,detail:null}),
	Oe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}
	var Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a){ return a.movementX; }var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a){ return a.movementY; }
	var b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
	dependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f){ return null; }f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag){ b=null; }}}else { g=null; }if(g===b){ return null; }if("mouseout"===a||"mouseover"===
	a){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse";}else if("pointerout"===a||"pointerover"===a){ k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer"; }a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p){ a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a)){ g++; }a=0;for(b=m;b;b=Rd(b)){ a++; }for(;0<g-a;){ k=Rd(k),g--; }for(;0<a-g;){ m=Rd(m),a--; }for(;g--;){if(k===m||k===m.alternate){ break a; }
	k=Rd(k);m=Rd(m);}k=null;} }else { k=null; }m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m){ break; }k.push(d);d=Rd(d);}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m){ break; }d.push(p);p=Rd(p);}for(p=0;p<k.length;p++){ Vd(k[p],"bubbled",l); }for(p=d.length;0<p--;){ Vd(d[p],"captured",c); }return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;
	function bf(a,b){if($e(a,b)){ return !0; }if("object"!==typeof a||null===a||"object"!==typeof b||null===b){ return !1; }var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length){ return !1; }for(d=0;d<c.length;d++){ if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]])){ return !1; } }return !0}
	var cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;
	function jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c)){ return null; }c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G$1.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}
	var kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++){ if(!e.has(f[g])){e=!1;break a} }e=!0;}f=!e;}if(f){ return null; }e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable){ ef=e,ff=b,gf=null; }break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf){ break; }
	case "keydown":case "keyup":return jf(c,d)}return null}},lf=G$1.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G$1.extend({clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
	var pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
	116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b){ return b }}return "keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return "keypress"===
	a.type?of(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G$1.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in
	a?-a.wheelDeltaX:0},deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e){ return null; }switch(a){case "keypress":if(0===of(c)){ return null; }case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button){ return null; }case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=
	Ve;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=
	We;break;default:a=G$1;}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa){ throw Error(u$1(101)); }pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H$1(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--);}
	function I$1(a,b){zf++;yf[zf]=a.current;a.current=b;}var Af={},J$1={current:Af},K$1={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c){ return Af; }var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b){ return d.__reactInternalMemoizedMaskedChildContext; }var e={},f;for(f in c){ e[f]=b[f]; }d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L$1(a){a=a.childContextTypes;return null!==a&&void 0!==a}
	function Df(){H$1(K$1);H$1(J$1);}function Ef(a,b,c){if(J$1.current!==Af){ throw Error(u$1(168)); }I$1(J$1,b);I$1(K$1,c);}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext){ return c; }d=d.getChildContext();for(var e in d){ if(!(e in a)){ throw Error(u$1(108,pb(b)||"Unknown",e)); } }return objectAssign({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J$1.current;I$1(J$1,a);I$1(K$1,K$1.current);return !0}
	function Hf(a,b,c){var d=a.stateNode;if(!d){ throw Error(u$1(169)); }c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H$1(K$1),H$1(J$1),I$1(J$1,a)):H$1(K$1);I$1(K$1,c);}
	var If=scheduler.unstable_runWithPriority,Jf=scheduler.unstable_scheduleCallback,Kf=scheduler.unstable_cancelCallback,Lf=scheduler.unstable_requestPaint,Mf=scheduler.unstable_now,Nf=scheduler.unstable_getCurrentPriorityLevel,Of=scheduler.unstable_ImmediatePriority,Pf=scheduler.unstable_UserBlockingPriority,Qf=scheduler.unstable_NormalPriority,Rf=scheduler.unstable_LowPriority,Sf=scheduler.unstable_IdlePriority,Tf={},Uf=scheduler.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};
	function ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u$1(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u$1(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a);}fg();}
	function fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do { c=c(!0); }while(null!==c)}});Wf=null;}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1;}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=objectAssign({},b);a=a.defaultProps;for(var c in a){ void 0===b[c]&&(b[c]=a[c]); }}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null;}
	function og(a){var b=jg.current;H$1(jg);a.type._context._currentValue=b;}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b){ a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b); }else if(null!==c&&c.childExpirationTime<b){ c.childExpirationTime=b; }else { break; }a=a.return;}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null);}
	function sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b){ mg=a,b=1073741823; }b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg){ throw Error(u$1(308)); }lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null};}else { lg=lg.next=b; }}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null};}
	function vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects});}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}}
	function yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b);}
	function zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h;}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g));}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=
	ca,m=k):x=x.next=ca;g>l&&(l=g);}else {null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g){ break a; }k=objectAssign({},k,g);break a;case 2:tg=!0;}}null!==z.callback&&
	(a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z));}z=z.next;if(null===z||z===h){ if(g=e.shared.pending,null===g){ break; }else { z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null; } }}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k;}}
	function Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a){ for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d){ throw Error(u$1(191,d)); }d.call(e);}} }}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new react.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:objectAssign({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c);}
	var Jg={isMounted:function(a){return (a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;
	c=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c);}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}
	function Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L$1(b)?Bf:J$1.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
	function Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null);}
	function Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L$1(b)?Bf:J$1.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
	(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4);}var Og=Array.isArray;
	function Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag){ throw Error(u$1(309)); }var d=c.stateNode;}if(!d){ throw Error(u$1(147,a)); }var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e){ return b.ref; }b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a;};b._stringRef=e;return b}if("string"!==typeof a){ throw Error(u$1(284)); }if(!c._owner){ throw Error(u$1(290,a)); }}return a}
	function Qg(a,b){if("textarea"!==a.type){ throw Error(u$1(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")); }}
	function Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8;}}function c(c,d){if(!a){ return null; }for(;null!==d;){ b(c,d),d=d.sibling; }return null}function d(a,b){for(a=new Map;null!==b;){ null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling; }return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a){ return c; }d=b.alternate;if(null!==d){ return d=d.index,d<c?(b.effectTag=
	2,c):d; }b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag){ return b=Tg(c,a.mode,d),b.return=a,b; }b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type){ return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d; }d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
	c.implementation){ return b=Vg(c,a.mode,d),b.return=a,b; }b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag){ return b=Wg(c,a.mode,d,f),b.return=a,b; }b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b){ return b=Tg(""+b,a.mode,c),b.return=a,b; }if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||
	nb(b)){ return b=Wg(b,a.mode,c,null),b.return=a,b; }Qg(a,b);}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c){ return null!==e?null:h(a,b,""+c,d); }if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c)){ return null!==e?null:m(a,b,c,d,null); }Qg(a,c);}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d){ return a=
	a.get(c)||null,h(b,a,""+d,e); }if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d)){ return a=a.get(c)||null,m(b,a,d,e,null); }Qg(b,d);}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&
	m&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A;}if(y===h.length){ return c(e,m),l; }if(null===m){for(;y<h.length;y++){ m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m); }return l}for(m=d(e,m);y<h.length;y++){ A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A); }a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k){ throw Error(u$1(150)); }h=k.call(h);
	if(null==h){ throw Error(u$1(151)); }for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A;}if(q.done){ return c(e,t),k; }if(null===t){for(;!q.done;y++,q=h.next()){ q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q); }return k}for(t=d(e,t);!q.done;y++,q=h.next()){ q=z(t,e,y,q.value,l),null!==q&&(a&&null!==
	q.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q); }a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l){ switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,
	k.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else { b(a,k); }k=k.sibling;}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h);}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k){ if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break} }else { b(a,d); }d=
	d.sibling;}d=Vg(f,a.mode,h);d.return=a;a=d;}return g(a)} }if("string"===typeof f||"number"===typeof f){ return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a); }if(Og(f)){ return ca(a,d,f,h); }if(nb(f)){ return D(a,d,f,h); }l&&Qg(a,f);if("undefined"===typeof f&&!k){ switch(a.tag){case 1:case 0:throw a=a.type,Error(u$1(152,a.displayName||a.name||"Component"));} }return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};
	function ch(a){if(a===Zg){ throw Error(u$1(174)); }return a}function dh(a,b){I$1(bh,b);I$1(ah,a);I$1($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a);}H$1($g);I$1($g,b);}function eh(){H$1($g);H$1(ah);H$1(bh);}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I$1(ah,a),I$1($g,c));}function gh(a){ah.current===a&&(H$1($g),H$1(ah));}var M$1={current:0};
	function hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd)){ return b }}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64)){ return b }}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a){ break; }for(;null===b.sibling;){if(null===b.return||b.return===a){ return null; }b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}function ih(a,b){return {responder:a,props:b}}
	var jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N$1=null,O$1=null,P$1=null,mh=!1;function Q$1(){throw Error(u$1(321));}function nh(a,b){if(null===b){ return !1; }for(var c=0;c<b.length&&c<a.length;c++){ if(!$e(a[c],b[c])){ return !1; } }return !0}
	function oh(a,b,c,d,e,f){lh=f;N$1=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f)){ throw Error(u$1(301)); }f+=1;P$1=O$1=null;b.updateQueue=null;jh.current=rh;a=c(d,e);}while(b.expirationTime===lh)}jh.current=sh;b=null!==O$1&&null!==O$1.next;lh=0;P$1=O$1=N$1=null;mh=!1;if(b){ throw Error(u$1(300)); }return a}
	function th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P$1?N$1.memoizedState=P$1=a:P$1=P$1.next=a;return P$1}function uh(){if(null===O$1){var a=N$1.alternate;a=null!==a?a.memoizedState:null;}else { a=O$1.next; }var b=null===P$1?N$1.memoizedState:P$1.next;if(null!==b){ P$1=b,O$1=a; }else {if(null===a){ throw Error(u$1(310)); }O$1=a;a={memoizedState:O$1.memoizedState,baseState:O$1.baseState,baseQueue:O$1.baseQueue,queue:O$1.queue,next:null};null===P$1?N$1.memoizedState=P$1=a:P$1=P$1.next=a;}return P$1}
	function vh(a,b){return "function"===typeof b?b(a):b}
	function wh(a){var b=uh(),c=b.queue;if(null===c){ throw Error(u$1(311)); }c.lastRenderedReducer=a;var d=O$1,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N$1.expirationTime&&
	(N$1.expirationTime=l,Bg(l));}else { null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action); }k=k.next;}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d;}return [b.memoizedState,c.dispatch]}
	function xh(a){var b=uh(),c=b.queue;if(null===c){ throw Error(u$1(311)); }c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do { f=a(f,g.action),g=g.next; }while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}
	function yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N$1,a);return [b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N$1.updateQueue;null===b?(b={lastEffect:null},N$1.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}
	function Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N$1.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d);}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O$1){var g=O$1.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N$1.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d);}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}
	function Hh(a,b){if("function"===typeof b){ return a=a(),b(a),function(){b(null);}; }if(null!==b&&void 0!==b){ return a=a(),b.current=a,function(){b.current=null;} }}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1])){ return d[0]; }c.memoizedState=[a,b];return a}
	function Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1])){ return d[0]; }a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0);});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c();}finally{kh.suspense=d;}});}
	function zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N$1||null!==f&&f===N$1){ mh=!0,e.expirationTime=lh,N$1.expirationTime=lh; }else {if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f)){ try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g)){ return }}catch(k){}finally{} }Ig(a,
	d);}}
	var sh={readContext:sg,useCallback:Q$1,useContext:Q$1,useEffect:Q$1,useImperativeHandle:Q$1,useLayoutEffect:Q$1,useMemo:Q$1,useReducer:Q$1,useRef:Q$1,useState:Q$1,useDebugValue:Q$1,useResponder:Q$1,useDeferredValue:Q$1,useTransition:Q$1},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,
	b];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N$1,a);return [d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=
	c;}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return [Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=
	wh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,
	b,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c;}
	function Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return !1;default:return !1}}
	function Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c);}Oh=a;Ph=Jd(b.firstChild);}else { a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a; }}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;){ a=a.return; }Oh=a;}
	function Wh(a){if(a!==Oh){ return !1; }if(!Qh){ return Vh(a),Qh=!0,!1; }var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps)){ for(b=Ph;b;){ Rh(a,b),b=Jd(b.nextSibling); } }Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a){ throw Error(u$1(317)); }a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--;}else { c!==zd&&c!==Cd&&c!==Bd||b++; }}a=a.nextSibling;}Ph=null;}}else { Ph=Oh?Jd(a.stateNode.nextSibling):null; }return !0}
	function Xh(){Ph=Oh=null;Qh=!1;}var Yh=Wa.ReactCurrentOwner,rg=!1;function R$1(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d);}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg){ return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e); }b.effectTag|=1;R$1(a,b,d,e);return b.child}
	function ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps){ return b.tag=15,b.type=g,ci(a,b,g,d,e,f); }a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref)){ return $h(a,b,f); }b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
	function ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c){ b.effectTag|=128; }}function di(a,b,c,d,e){var f=L$1(c)?Bf:J$1.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg){ return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e); }b.effectTag|=1;R$1(a,b,c,e);return b.child}
	function fi(a,b,c,d,e){if(L$1(c)){var f=!0;Gf(b);}else { f=!1; }qg(b,e);if(null===b.stateNode){ null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0; }else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L$1(c)?Bf:J$1.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
	"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K$1.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
	typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1);}else { g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L$1(c)?Bf:J$1.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===
	typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K$1.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
	x,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):
	("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1); }return gi(a,b,c,d,f,e)}
	function gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g){ return e&&Hf(b,c,!1),$h(a,b,f); }d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R$1(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo);}
	var ii={dehydrated:null,retryTime:0};
	function ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M$1.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I$1(M$1,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2)){ for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;){ a.return=e,a=a.sibling; } }c=Wg(g,d,c,null);c.return=
	b;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child)){ for(c.child=g;null!==g;){ g.return=c,g=g.sibling; } }d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=
	c}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2)){ for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;){ a.return=e,a=a.sibling; } }c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}
	function ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b);}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f);}
	function mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R$1(a,b,d.children,c);d=M$1.current;if(0!==(d&2)){ d=d&1|2,b.effectTag|=64; }else {if(null!==a&&0!==(a.effectTag&64)){ a:for(a=b.child;null!==a;){if(13===a.tag){ null!==a.memoizedState&&ki(a,c); }else if(19===a.tag){ ki(a,c); }else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b){ break a; }for(;null===a.sibling;){if(null===a.return||a.return===b){ break a; }a=a.return;}a.sibling.return=a.return;a=a.sibling;} }d&=1;}I$1(M$1,d);if(0===(b.mode&2)){ b.memoizedState=
	null; }else { switch(e){case "forwards":c=b.child;for(e=null;null!==c;){ a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling; }c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null;} }return b.child}
	function $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c){ return null; }if(null!==a&&b.child!==a.child){ throw Error(u$1(153)); }if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;){ a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b; }c.sibling=null;}return b.child}var ni,oi,pi,qi;
	ni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag){ a.appendChild(c.stateNode); }else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b){ break; }for(;null===c.sibling;){if(null===c.return||c.return===b){ return; }c=c.return;}c.sibling.return=c.return;c=c.sibling;}};oi=function(){};
	pi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=objectAssign({},f,{value:void 0});d=objectAssign({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd);}od(c,d);var h,k;c=null;for(h in f){ if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h]){ if("style"===
	h){ for(k in g=f[h],g){ g.hasOwnProperty(k)&&(c||(c={}),c[k]=""); } }else { "dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null)); } } }for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g)){ if("style"===h){ if(g){for(k in g){ !g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]=""); }for(k in l){ l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),
	c[k]=l[k]); }}else { c||(a||(a=[]),a.push(h,c)),c=l; } }else { "dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l)); } }}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e){ b.effectTag|=4; }}};
	qi=function(a,b,c,d){c!==d&&(b.effectTag|=4);};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;){ null!==b.alternate&&(c=b),b=b.sibling; }null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;){ null!==c.alternate&&(d=c),c=c.sibling; }null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
	function si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L$1(b.type)&&Df(),null;case 3:return eh(),H$1(K$1),H$1(J$1),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode){ pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128); }else {if(!d){if(null===b.stateNode){ throw Error(u$1(166)); }
	return null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F$1("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++){ F$1(ac[a],d); }break;case "source":F$1("error",d);break;case "img":case "image":case "link":F$1("error",d);F$1("load",d);break;case "form":F$1("reset",d);F$1("submit",d);break;case "details":F$1("toggle",d);break;case "input":Ab(d,f);F$1("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=
	{wasMultiple:!!f.multiple};F$1("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F$1("invalid",d),rd(c,"onChange");}od(e,f);a=null;for(var g in f){ if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g);} }switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&
	(d.onclick=sd);}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4);}else {g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F$1("load",
	a);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++){ F$1(ac[h],a); }h=d;break;case "source":F$1("error",a);h=d;break;case "img":case "image":case "link":F$1("error",a);F$1("load",a);h=d;break;case "form":F$1("reset",a);F$1("submit",a);h=d;break;case "details":F$1("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F$1("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=objectAssign({},d,{value:void 0});F$1("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,
	d);h=Ib(a,d);F$1("invalid",a);rd(c,"onChange");break;default:h=d;}od(e,h);var k=h;for(f in k){ if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g));} }switch(e){case "input":xb(a);Eb(a,d,!1);
	break;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd);}Fd(e,d)&&(b.effectTag|=4);}null!==b.ref&&(b.effectTag|=128);}return null;case 6:if(a&&null!=b.stateNode){ qi(a,b,a.memoizedProps,d); }else {if("string"!==typeof d&&null===b.stateNode){ throw Error(u$1(166)); }
	c=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c);}return null;case 13:H$1(M$1);d=b.memoizedState;if(0!==(b.effectTag&64)){ return b.expirationTime=c,b; }c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=
	e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2)){ if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M$1.current&1)){ S$1===ti&&(S$1=ui); }else {if(S$1===ti||S$1===ui){ S$1=vi; }0!==wi&&null!==T$1&&(xi(T$1,U$1),yi(T$1,wi));} }if(c||d){ b.effectTag|=4; }return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L$1(b.type)&&Df(),null;case 19:H$1(M$1);d=b.memoizedState;if(null===d){ return null; }e=0!==(b.effectTag&64);f=d.rendering;if(null===f){ if(e){ ri(d,!1); }else {if(S$1!==ti||null!==a&&0!==(a.effectTag&
	64)){ for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;){ e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,
	e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling; }I$1(M$1,M$1.current&1|2);return b.child}f=f.sibling;} }} }else {if(!e){ if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate){ return b=
	b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null }}else { 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1); } }d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f);}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M$1.current,I$1(M$1,e?b&1|2:b&1),c):null}throw Error(u$1(156,
	b.tag));}function zi(a){switch(a.tag){case 1:L$1(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H$1(K$1);H$1(J$1);b=a.effectTag;if(0!==(b&64)){ throw Error(u$1(285)); }a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H$1(M$1),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H$1(M$1),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return {value:a,source:b,stack:qb(b)}}
	var Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b);}catch(e){setTimeout(function(){throw e;});}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount();}catch(c){Ei(a,c);}}function Fi(a){var b=a.ref;if(null!==b){ if("function"===typeof b){ try{b(null);}catch(c){Ei(a,c);} }else { b.current=null; } }}
	function Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b;}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u$1(163));}
	function Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d();}c=c.next;}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}
	function Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4){ if(null===b){ a.componentDidMount(); }else {var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate);} }b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child){ switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode;} }Cg(c,b,a);}return;
	case 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u$1(163));}
	function Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c();}catch(h){Ei(g,h);}}a=a.next;}while(a!==d)});}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c);}}
	function Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b);}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}
	function Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return;}throw Error(u$1(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u$1(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return;}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2){ continue b; }
	if(null===c.child||4===c.tag){ continue b; }else { c.child.return=c,c=c.child; }}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b);}
	function Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e){ a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd)); }else if(4!==d&&(a=a.child,null!==a)){ for(Qi(a,b,c),a=a.sibling;null!==a;){ Qi(a,b,c),a=a.sibling; } }}
	function Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e){ a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a); }else if(4!==d&&(a=a.child,null!==a)){ for(Ri(a,b,c),a=a.sibling;null!==a;){ Ri(a,b,c),a=a.sibling; } }}
	function Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e){ throw Error(u$1(160)); }f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return;}e=!0;}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;){ if(Ki(h,m,l),null!==m.child&&4!==m.tag){ m.child.return=m,m=m.child; }else {if(m===k){ break a; }for(;null===m.sibling;){if(null===m.return||m.return===k){ break a; }m=m.return;}m.sibling.return=m.return;m=m.sibling;} }g?(h=
	f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode);}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b){ break; }for(;null===d.sibling;){if(null===d.return||d.return===b){ return; }d=d.return;4===d.tag&&(e=!1);}d.sibling.return=d.return;d=d.sibling;}}
	function Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b);}switch(a){case "input":Cb(c,d);break;
	case "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1));}}}return;case 6:if(null===b.stateNode){ throw Error(u$1(162)); }b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?
	d=!1:(d=!0,c=b.child,Ti=$f());if(null!==c){ a:for(a=c;;){if(5===a.tag){ f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e)); }else if(6===a.tag){ a.stateNode.nodeValue=d?"":a.memoizedProps; }else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=
	f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c){ break; }for(;null===a.sibling;){if(null===a.return||a.return===c){ break a; }a=a.return;}a.sibling.return=a.return;a=a.sibling;} }Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u$1(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
	var Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b);};return c}
	function $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
	var bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V$1=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W$1=V$1,T$1=null,X$1=null,U$1=0,S$1=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y$1=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return (W$1&(fj|gj))!==V$1?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}
	function Hg(a,b,c){b=b.mode;if(0===(b&2)){ return 1073741823; }var d=ag();if(0===(b&4)){ return 99===d?1073741823:1073741822; }if((W$1&fj)!==V$1){ return U$1; }if(null!==c){ a=hg(a,c.timeoutMs|0||5E3,250); }else { switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u$1(326));} }null!==T$1&&a===U$1&&--a;return a}
	function Ig(a,b){if(50<uj){ throw uj=0,vj=null,Error(u$1(185)); }a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W$1&ej)!==V$1&&(W$1&(fj|gj))===V$1?yj(a):(Z$1(a),W$1===V$1&&gg()):Z$1(a);(W$1&4)===V$1||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)));}}
	function xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag){ e=a.stateNode; }else { for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return;} }null!==e&&(T$1===e&&(Bg(b),S$1===vi&&xi(e,U$1)),yi(e,b));return e}
	function zj(a){var b=a.lastExpiredTime;if(0!==b){ return b; }b=a.firstPendingTime;if(!Aj(a,b)){ return b; }var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}
	function Z$1(a){if(0!==a.lastExpiredTime){ a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a)); }else {var b=zj(a),c=a.callbackNode;if(0===b){ null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90); }else {var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d){ return; }c!==Tf&&Kf(c);}a.callbackExpirationTime=
	b;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b;}}}
	function Bj(a,b){wj=0;if(b){ return b=Gg(),Cj(a,b),Z$1(a),null; }var c=zj(a);if(0!==c){b=a.callbackNode;if((W$1&(fj|gj))!==V$1){ throw Error(u$1(327)); }Dj();a===T$1&&c===U$1||Ej(a,c);if(null!==X$1){var d=W$1;W$1|=fj;var e=Fj();do { try{Gj();break}catch(h){Hj(a,h);} }while(1);ng();W$1=d;cj.current=e;if(S$1===hj){ throw b=kj,Ej(a,c),xi(a,c),Z$1(a),b; }if(null===X$1){ switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S$1,T$1=null,d){case ti:case hj:throw Error(u$1(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;
	c===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c){ break; }if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c){ break; }if(0!==d&&d!==c){a.lastPingedTime=
	d;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=
	Hd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u$1(329));} }Z$1(a);if(a.callbackNode===b){ return Bj.bind(null,a) }}}return null}
	function yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W$1&(fj|gj))!==V$1){ throw Error(u$1(327)); }Dj();a===T$1&&b===U$1||Ej(a,b);if(null!==X$1){var c=W$1;W$1|=fj;var d=Fj();do { try{Kj();break}catch(e){Hj(a,e);} }while(1);ng();W$1=c;cj.current=d;if(S$1===hj){ throw c=kj,Ej(a,b),xi(a,b),Z$1(a),c; }if(null!==X$1){ throw Error(u$1(261)); }a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T$1=null;Jj(a);Z$1(a);}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z$1(c);});gg();}}
	function Mj(a,b){var c=W$1;W$1|=1;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}}function Nj(a,b){var c=W$1;W$1&=-2;W$1|=ej;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}}
	function Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X$1){ for(c=X$1.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H$1(K$1);H$1(J$1);break;case 5:gh(d);break;case 4:eh();break;case 13:H$1(M$1);break;case 19:H$1(M$1);break;case 10:og(d);}c=c.return;} }T$1=a;X$1=Sg(a.current,null);U$1=b;S$1=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1;}
	function Hj(a,b){do{try{ng();jh.current=sh;if(mh){ for(var c=N$1.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next;} }lh=0;P$1=O$1=N$1=null;mh=!1;if(null===X$1||null===X$1.return){ return S$1=hj,kj=b,X$1=null; }a:{var e=a,f=X$1.return,g=X$1,h=b;b=U$1;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=
	null,g.memoizedState=null);}var m=0!==(M$1.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z){ x=null!==z.dehydrated?!0:!1; }else {var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0;}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t;}else { D.add(k); }if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag){ if(null===g.alternate){ g.tag=17; }else {var y=wg(1073741823,null);y.tag=2;xg(g,y);} }g.expirationTime=1073741823;
	break a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q);}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return;}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g));}S$1!==
	jj&&(S$1=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return;}while(null!==p)}X$1=Pj(X$1);}catch(Xc){b=Xc;continue}break}while(1)}
	function Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b);}function Bg(a){a>wi&&(wi=a);}function Kj(){for(;null!==X$1;){ X$1=Qj(X$1); }}function Gj(){for(;null!==X$1&&!Uf();){ X$1=Qj(X$1); }}function Qj(a){var b=Rj(a.alternate,a,U$1);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}
	function Pj(a){X$1=a;do{var b=X$1.alternate;a=X$1.return;if(0===(X$1.effectTag&2048)){b=si(b,X$1,U$1);if(1===U$1||1!==X$1.childExpirationTime){for(var c=0,d=X$1.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling;}X$1.childExpirationTime=c;}if(null!==b){ return b; }null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X$1.firstEffect),null!==X$1.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X$1.firstEffect),a.lastEffect=X$1.lastEffect),1<X$1.effectTag&&(null!==
	a.lastEffect?a.lastEffect.nextEffect=X$1:a.firstEffect=X$1,a.lastEffect=X$1));}else {b=zi(X$1);if(null!==b){ return b.effectTag&=2047,b; }null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048);}b=X$1.sibling;if(null!==b){ return b; }X$1=a;}while(null!==X$1);S$1===ti&&(S$1=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}
	function Sj(a,b){do { Dj(); }while(null!==rj);if((W$1&(fj|gj))!==V$1){ throw Error(u$1(327)); }var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c){ return null; }a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current){ throw Error(u$1(177)); }a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
	d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T$1&&(X$1=T$1=null,U$1=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W$1;W$1|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g){ var h={start:g.selectionStart,end:g.selectionEnd}; }else { a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,
	m=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType;}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild)){ break; }y=t;t=A;}for(;;){if(t===g){ break b; }y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling)){ break; }t=y;y=t.parentNode;}t=A;}h=-1===x||-1===z?null:{start:x,end:z};}else { h=null; }} }h=h||{start:0,end:0};}else { h=
	null; }Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y$1=e;do { try{Tj();}catch(wb){if(null===Y$1){ throw Error(u$1(330)); }Ei(Y$1,wb);Y$1=Y$1.nextEffect;} }while(null!==Y$1);Y$1=e;do { try{for(g=a,h=b;null!==Y$1;){var q=Y$1.effectTag;q&16&&Rb(Y$1.stateNode,"");if(q&128){var B=Y$1.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null);}}switch(q&1038){case 2:Pi(Y$1);Y$1.effectTag&=-3;break;case 6:Pi(Y$1);Y$1.effectTag&=-3;Si(Y$1.alternate,Y$1);break;case 1024:Y$1.effectTag&=-1025;break;case 1028:Y$1.effectTag&=
	-1025;Si(Y$1.alternate,Y$1);break;case 4:Si(Y$1.alternate,Y$1);break;case 8:l=Y$1,Mi(g,l,h),Ni(l);}Y$1=Y$1.nextEffect;}}catch(wb){if(null===Y$1){ throw Error(u$1(330)); }Ei(Y$1,wb);Y$1=Y$1.nextEffect;} }while(null!==Y$1);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&
	(w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;){ 1===w.nodeType&&B.push({element:w,left:w.scrollLeft,
	top:w.scrollTop}); }"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++){ w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top; }}fd=!!Dd;Ed=Dd=null;a.current=c;Y$1=e;do { try{for(q=a;null!==Y$1;){var ub=Y$1.effectTag;ub&36&&Ji(q,Y$1.alternate,Y$1);if(ub&128){B=void 0;var vb=Y$1.ref;if(null!==vb){var Xc=Y$1.stateNode;switch(Y$1.tag){case 5:B=Xc;break;default:B=Xc;}"function"===typeof vb?vb(B):vb.current=B;}}Y$1=Y$1.nextEffect;}}catch(wb){if(null===Y$1){ throw Error(u$1(330)); }Ei(Y$1,wb);Y$1=Y$1.nextEffect;} }while(null!==Y$1);Y$1=
	null;Vf();W$1=f;}else { a.current=c; }if(qj){ qj=!1,rj=a,sj=b; }else { for(Y$1=e;null!==Y$1;){ b=Y$1.nextEffect,Y$1.nextEffect=null,Y$1=b; } }b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z$1(a);if(Yi){ throw Yi=!1,a=Zi,Zi=null,a; }if((W$1&ej)!==V$1){ return null; }gg();return null}function Tj(){for(;null!==Y$1;){var a=Y$1.effectTag;0!==(a&256)&&Gi(Y$1.alternate,Y$1);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y$1=Y$1.nextEffect;}}
	function Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj){ return !1; }var a=rj;rj=null;if((W$1&(fj|gj))!==V$1){ throw Error(u$1(331)); }var b=W$1;W$1|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512)){ switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c);} }}catch(d){if(null===a){ throw Error(u$1(330)); }Ei(a,d);}c=a.nextEffect;a.nextEffect=null;a=c;}W$1=b;gg();return !0}
	function Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z$1(a);}function Ei(a,b){if(3===a.tag){ Wj(a,a,b); }else { for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z$1(c);break}}c=c.return;} }}
	function Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T$1===a&&U$1===c?S$1===vi||S$1===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U$1):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z$1(a)));}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z$1(a);}var Rj;
	Rj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K$1.current){ rg=!0; }else {if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden){ return b.expirationTime=b.childExpirationTime=1,null; }break;case 1:L$1(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I$1(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
	if(0!==d&&d>=c){ return ji(a,b,c); }I$1(M$1,M$1.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I$1(M$1,M$1.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d){ return mi(a,b,c); }b.effectTag|=64;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I$1(M$1,M$1.current);if(!d){ return null }}return $h(a,b,c)}rg=!1;}}else { rg=!1; }b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J$1.current);qg(b,c);e=oh(null,
	b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L$1(d)){var f=!0;Gf(b);}else { f=!1; }b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c);}else { b.tag=0,R$1(null,b,e,c),b=b.child; }return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
	null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status){ throw e._result; }e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u$1(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);
	case 3:hi(b);d=b.updateQueue;if(null===a||null===d){ throw Error(u$1(282)); }d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e){ Xh(),b=$h(a,b,c); }else {if(e=b.stateNode.hydrate){ Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0; }if(e){ for(c=Yg(b,null,d,c),b.child=c;c;){ c.effectTag=c.effectTag&-3|1024,c=c.sibling; } }else { R$1(a,b,d,c),Xh(); }b=b.child;}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
	null,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R$1(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R$1(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R$1(a,b,b.pendingProps,c),b.child;case 8:return R$1(a,
	b,b.pendingProps.children,c),b.child;case 12:return R$1(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I$1(jg,h._currentValue);h._currentValue=f;if(null!==g){ if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K$1.current){b=$h(a,b,c);break a}}else { for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==
	k){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next;}}else { g=10===h.tag?h.type===b.type?null:h.child:h.child; }if(null!==g){ g.return=h; }else { for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return;} }h=
	g;} } }R$1(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R$1(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L$1(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,
	b,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u$1(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){ return !1; }var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber){ return !0; }try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64));}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a);}catch(e){}};}catch(d){}return !0}
	function Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null;}function Sh(a,b,c,d){return new Zj(a,b,c,d)}
	function bi(a){a=a.prototype;return !(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a){ return bi(a)?1:0; }if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb){ return 11; }if(a===jb){ return 14 }}return 2}
	function Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
	firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
	function Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a){ bi(a)&&(g=1); }else if("string"===typeof a){ g=5; }else { a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a){ switch(a.$$typeof){case db:g=
	10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a} }throw Error(u$1(130,null==a?a:typeof a,""));} }b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}
	function Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
	function ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0;}
	function Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c){ a.lastSuspendedTime=b; }b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0);}
	function yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b));}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b){ a.lastExpiredTime=b; }}
	function bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag){ throw Error(u$1(170)); }var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L$1(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return;}while(null!==h);throw Error(u$1(171));}if(1===c.tag){var k=c.type;if(L$1(k)){c=Ff(c,k,h);break a}}c=h;}else { c=Af; }null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===
	d?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child){ return null; }switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b);}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b);}
	function fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d;}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null);};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null;});};
	function gk(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b){ for(var c;c=a.lastChild;){ a.removeChild(c); } }return new fk(a,0,b?{hydrate:!0}:void 0)}
	function ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a);};}bk(b,g,a,e);}else {f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a);};}Nj(function(){bk(b,g,a,e);});}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
	wc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b);}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3));};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b);}};
	za=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;){ c=c.parentNode; }c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e){ throw Error(u$1(90)); }yb(d);Cb(d,e);}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1);}};Fa=Mj;
	Ga=function(a,b,c,d,e){var f=W$1;W$1|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W$1=f,W$1===V$1&&gg();}};Ha=function(){(W$1&(1|fj|gj))===V$1&&(Lj(),Dj());};Ia=function(a,b){var c=W$1;W$1|=2;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b)){ throw Error(u$1(200)); }return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd);},Da,Ea,id,mc,Dj,{current:!1}]};
	(function(a){var b=a.findFiberByHostInstance;return Yj(objectAssign({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.14.0",
	rendererPackageName:"react-dom"});var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1=lk;var createPortal=kk;var findDOMNode=function(a){if(null==a){ return null; }if(1===a.nodeType){ return a; }var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render){ throw Error(u$1(188)); }throw Error(u$1(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};
	var flushSync=function(a,b){if((W$1&(fj|gj))!==V$1){ throw Error(u$1(187)); }var c=W$1;W$1|=1;try{return cg(99,a.bind(null,b))}finally{W$1=c,gg();}};var hydrate=function(a,b,c){if(!gk(b)){ throw Error(u$1(200)); }return ik(null,a,b,!0,c)};var render=function(a,b,c){if(!gk(b)){ throw Error(u$1(200)); }return ik(null,a,b,!1,c)};
	var unmountComponentAtNode=function(a){if(!gk(a)){ throw Error(u$1(40)); }return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null;});}),!0):!1};var unstable_batchedUpdates=Mj;var unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
	var unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c)){ throw Error(u$1(200)); }if(null==a||void 0===a._reactInternalFiber){ throw Error(u$1(38)); }return ik(a,b,c,!1,d)};var version$1="16.14.0";

	var reactDom_production_min = {
		__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1,
		createPortal: createPortal,
		findDOMNode: findDOMNode,
		flushSync: flushSync,
		hydrate: hydrate,
		render: render,
		unmountComponentAtNode: unmountComponentAtNode,
		unstable_batchedUpdates: unstable_batchedUpdates,
		unstable_createPortal: unstable_createPortal,
		unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,
		version: version$1
	};

	var reactDom = createCommonjsModule(function (module) {

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}

	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  module.exports = reactDom_production_min;
	}
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	var factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret_1) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = factoryWithThrowingShims();
	}
	});

	///// Miscellaneous Utility Functions /////


	/**
	 * Pseudo-polyfilled shortcut for `Object.assign`. Copies own properties from
	 * second-and-after arguments onto the first object, overwriting any that already
	 * exist, and returns the first argument.
	 * @return {object}
	 */
	var assign = Object.assign || _assign;

	// Non-native impl; exported for access by tests
	function _assign(/*target, ...sources*/) {
	  var arguments$1 = arguments;

	  var target = arguments[0];
	  for (var i = 1, len = arguments.length; i < len; i++) {
	    var source = arguments$1[i];
	    if (source) {
	      for (var prop in source) {
	        if (source.hasOwnProperty(prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	}


	/**
	 * Like {@link assign}, but will ony copy properties that do _not_ already
	 * exist on the target object.
	 * @return {object}
	 */
	function assignIf(/*target, ...sources*/) {
	  var arguments$1 = arguments;

	  var target = arguments[0];
	  for (var i = 1, len = arguments.length; i < len; i++) {
	    var source = arguments$1[i];
	    if (source) {
	      for (var prop in source) {
	        if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	}

	/**
	 * Like {@link assign}, but for any property where the source and target are both
	 * sub-objects, does a deep recursive copy.
	 * @param {object} target
	 * @param {object} source
	 */
	function assignDeep(target, source) {
	  if (source) {
	    for (var prop in source) {
	      if (source.hasOwnProperty(prop)) {
	        if (target[prop] && typeof target[prop] === 'object' && typeof source[prop] === 'object') {
	          assignDeep(target[prop], source[prop]);
	        } else {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	}


	/**
	 * Iterate over an object's own (non-prototype-inherited) properties
	 * @param {object} object - The object to iterate over
	 * @param {function} fn - A function that will be invoked for each iterated property. It
	 *        will be passed three arguments:
	 *        - value (the property value)
	 *        - key (the property name)
	 *        - object (the object being iterated over)
	 * @param {*} [scope] - An optional object to be used as `this` when calling the `fn`
	 */
	function forOwn(object, fn, scope) {
	  for (var prop in object) {
	    if (object.hasOwnProperty(prop)) {
	      fn.call(scope, object[prop], prop, object);
	    }
	  }
	}


	/**
	 * Given an object instance, return a consistent unique id for it.
	 * @type function
	 * @param {Object} obj - The object instance
	 * @return {string} id
	 */
	var getIdForObject = (function () {
	  var objIds = new WeakMap();
	  var lastId = 0;
	  return function getIdForObject(obj) {
	    var id = objIds.get(obj);
	    if (!id) {
	      objIds.set(obj, (id = "$id" + (++lastId)));
	    }
	    return id
	  }
	})();


	/**
	 * Utility for the "extend-as" pattern used in several places to decorate facade
	 * classes with extra capabilities.
	 * @param {string} name - unique identifier for this class extension
	 * @param {function} doExtend - the function that creates the actual class extension,
	 *        this is passed the base class and will only be called once per base class.
	 * @return {function(class): class}
	 */
	function createClassExtender(name, doExtend) {
	  var cache = new WeakMap();
	  return function(classToExtend) {
	    var extended = cache.get(classToExtend);
	    if (!extended) { //bidir check due to inheritance of statics
	      extended = doExtend(classToExtend);
	      cache.set(classToExtend, extended);
	    }
	    return extended
	  }
	}


	/**
	 * Determine whether a given object is a React element descriptor object, i.e. the
	 * result of a JSX transpilation to React.createElement().
	 * @param obj
	 * @return {boolean}
	 */
	function isReactElement(obj) {
	  var t = obj.$$typeof;
	  return (t && t.toString && t.toString() === 'Symbol(react.element)') || false
	}

	/**
	 * The base class for all Facade classes.
	 *
	 * A Facade is basically just a class that receives property assignments from a scene descriptor
	 * and manages forwarding the resulting state to more complex underlying implementation
	 * objects, e.g. ThreeJS objects.
	 *
	 * The instantiated facade objects have a very simple lifecycle:
	 *   - The `constructor` in which the initial state and the underyling implementation object(s)
	 *     can be initialized. It will be passed a single argument: the `parent` facade object.
	 *   - Updates to the object's properties, usually by direct assignment from the scene descriptor.
	 *     These updates can be handled immediately by defining property setters that handle syncing
	 *     new values to the underyling implementation object(s).
	 *   - The `afterUpdate()` method which signals the end of all property updates; this can be
	 *     implemented to handle syncing the full set of updated properties to the underlying
	 *     implementation object(s). Useful if an aspect of the syncing relies on multiple properties
	 *     or needs things to be synced in a specific order.
	 *   - The `destructor` method which is always called when the object is removed from the scene.
	 *     Implement this to remove and clean up the underlying implementation object(s) and other
	 *     cleanup logic.
	 *
	 * Scene Descriptors:
	 *
	 * All facade instances are created, updated, and destroyed based on the current structure of
	 * a scene descriptor object. The properties in the descriptor are generally just copied
	 * directly to properties of the same names on the facade instance, which can handle them
	 * either by custom setters or in `afterUpdate`. There are a few special properties in the
	 * descriptor:
	 *
	 *   - `facade`: (required) a reference to the Facade class that will be instantiated.
	 *   - `key`: (recommended) an identifier that is unique amongst the descriptor's siblings, which
	 *     is used to associate the descriptor with its corresponding Facade instance. One will be
	 *     assigned automatically if omitted, but it's recommended that you set one manually to ensure
	 *     descriptors are predictably resolved to the same facade instances when siblings are being
	 *     added or removed. Not doing so can lead to unnecessary facade destruction/creation and/or
	 *     unpredictable facade states.
	 *   - `children`: (optional) for `Parent` facade subclasses, defines the child object descriptors.
	 *   - `ref`: (optional) a function that will be called with a reference to the instantiated Facade
	 *     on creation, and with `null` on destruction, allowing external code to maintain references
	 *     to individual facades.
	 *   - `transition`: (optional) defines a set of properties that should be transitioned smoothly
	 *     when their value changes. See `Animatable` for more details.
	 *   - `animation`: (optional) defines one or more keyframe animations. See `Animatable` for more
	 *     details.
	 *   - `exitAnimation`: (optional) defines a keyframe animation to run when the facade is removed
	 *     from its parent.
	 *   - `pointerStates`: (optional) defines sets of property values that should be used in place
	 *     of those defined on the main object, when the user's pointer (mouse, touch, vr controller,
	 *     etc.) is in `hover` or `active` interaction state with the facade. See `PointerStates`
	 *     for more details.
	 *
	 * It is also possible to define facade descriptors using JSX (https://reactjs.org/docs/introducing-jsx.html),
	 * if it is precompiled to `React.createElement` calls. In this case, use the facade class as the JSX
	 * element name instead of a `facade` property, and child descriptors are defined as nested JSX elements i
	 * nstead of a `children` property. *NOTE:* While this is often a nicer looking syntax than the plain JS object
	 * form, be aware that the creation of JSX elements does carry a slight performance cost from extra logic
	 * and object allocations, so you should avoid it when defining large numbers of facades or when updating
	 * descriptors on every frame.
	 */
	var Facade = function Facade(parent) {
	  this.$facadeId = "facade" + (idCounter++);
	  this.parent = parent;
	};

	/**
	 * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a
	 * render. This can be called in event handlers, for example, to affect changes to this facade and its
	 * subtree. This process is synchronous. Never override this method as a way to react to updates, as it
	 * is not the only way a component is updated; instead override `afterUpdate` or use setters.
	 * @param {object} [props] - A set of properties to be copied to the facade
	 */
	Facade.prototype.update = function update (props) {
	  if (props && typeof props === 'object') {
	    // Always assign transition and animation first
	    this.transition = props.transition;
	    this.animation = props.animation;
	    for (var prop in props) {
	      if (props.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	        this[prop] = props[prop];
	      }
	    }
	  }
	  this.afterUpdate();
	  this.requestRender();
	};

	/**
	 * Called at the end of an update batch, after all individual properties have been assigned.
	 */
	Facade.prototype.afterUpdate = function afterUpdate () {
	  // Handle calling ref function
	  var ref = this.ref;
	  if (ref !== this._lastRef) {
	    if (typeof this._lastRef === 'function') {
	      this._lastRef.call(null, null);
	    }
	    if (typeof ref === 'function') {
	      ref.call(null, this);
	      this._lastRef = ref;
	    } else {
	      this._lastRef = null;
	    }
	  }
	};

	/**
	 * Dispatch a message with optional data up the facade parent tree.
	 */
	Facade.prototype.notifyWorld = function notifyWorld (message, data) {
	  if (this.parent) {
	    this.parent.onNotifyWorld(this, message, data);
	  }
	};

	/**
	 * Default onNotifyWorld handler just bubbles it up the parent chain.
	 */
	Facade.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
	  var notifiableParent = this._notifiableParent;
	  if (notifiableParent) {
	    notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);
	  } else {
	    // Optimization: on first call, walk up the tree looking for the first ancestor with a
	    // non-default onNotifyWorld implementation, and save a pointer to that ancestor
	    // facade so we can just call it directly the next time without any tree walking.
	    notifiableParent = this.parent;
	    var defaultImpl = Facade.prototype.onNotifyWorld;
	    while (notifiableParent) {
	      if (notifiableParent.onNotifyWorld !== defaultImpl) {
	        this._notifiableParent = notifiableParent;
	        notifiableParent.onNotifyWorld(source, message, data);
	        break
	      }
	      notifiableParent = notifiableParent.parent;
	    }
	  }
	};

	/**
	 * Notifies the top-level world manager that this object has changed in some way that affects its
	 * visible rendering, so a rendering frame will be scheduled.
	 */
	Facade.prototype.requestRender = function requestRender () {
	  this.notifyWorld('needsRender');
	};

	Facade.prototype.traverse = function traverse (fn) {
	  fn(this);
	};

	Facade.prototype.forEachChild = function forEachChild (fn) {
	};

	/**
	 * Add an event listener for the given event type.
	 * @param {String} type
	 * @param {Function} handler
	 */
	Facade.prototype.addEventListener = function addEventListener (type, handler) {
	  this.notifyWorld('addEventListener', {type: type, handler: handler});
	};

	/**
	 * Remove an event listener for the given event type.
	 * @param {String} type
	 * @param {Function} handler
	 */
	Facade.prototype.removeEventListener = function removeEventListener (type, handler) {
	  this.notifyWorld('removeEventListener', {type: type, handler: handler});
	};

	/**
	 * Dispatch an Event object on this facade, with DOM events bubbling logic.
	 * @param {Event} event
	 */
	Facade.prototype.dispatchEvent = function dispatchEvent (event) {
	  this.notifyWorld('dispatchEvent', event);
	};

	/**
	 * Called when the instance is being removed from the scene. Override this to implement any
	 * custom cleanup logic.
	 */
	Facade.prototype.destructor = function destructor () {
	  // Unregister all event listeners from the world
	  if (this.parent) {
	    this.notifyWorld('removeAllEventListeners');
	  }

	  // Teardown refs
	  if (typeof this.ref === 'function') {
	    this.ref.call(null, null);
	  }
	  this.parent = this._notifiableParent = null;
	};

	assign(Facade.prototype, {
	  ref: null,
	  _lastRef: null,
	  _notifiableParent: null
	});


	var idCounter = 0;
	var DEF_SPECIAL_PROPS = {key:1, facade:1, transition:1, animation:1};

	/**
	 * @static
	 * Determine if a certain property name is one of the special descriptor properties
	 */
	Facade.isSpecialDescriptorProperty = function(name) {
	  return DEF_SPECIAL_PROPS.hasOwnProperty(name)
	};

	/**
	 * @static
	 * Define a property name as an event handler for a given Facade class, so that it
	 * automatically updates the global event registry when set.
	 * @param {class} facadeClass - the class whose prototype the property should be defined on
	 * @param {String} propName - the name of the event handler property, e.g. 'onMouseOver'
	 * @param {String} eventType - the type of the event that will trigger the handler, e.g. 'mouseover'
	 */
	Facade.defineEventProperty = function(facadeClass, propName, eventType) {
	  var privateProp = propName + "➤handler";
	  Object.defineProperty(facadeClass.prototype, propName, {
	    get: function get() {
	      return this[privateProp]
	    },
	    set: function set(handler) {
	      var oldHandler = this[privateProp];
	      if ((handler || null) !== (oldHandler || null)) {
	        // Remove old listener
	        if (typeof oldHandler === 'function') {
	          this.removeEventListener(eventType, oldHandler);
	        }
	        // Add new listener
	        if (typeof handler === 'function') {
	          this.addEventListener(eventType, handler);
	        }
	        this[privateProp] = handler;
	      }
	    }
	  });
	};

	/*
	 * Built-in easing functions for use in Troika animations. Any of the easings defined here
	 * may be referred to within Tweens by their exported symbol name, or by reference.
	 * 
	 * The implementations here are roughly based on the logic from the jQuery Easing plugin
	 * (original license blocks are maintained below for completeness), but they have been
	 * significantly rewritten to use a single 0-1 time argument signature, converted to ES2015
	 * syntax, and otherwise modified for succinctness or performance.
	 */

	var pow = Math.pow;
	var PI = Math.PI;
	var sqrt = Math.sqrt;
	var HALF_PI = PI / 2;
	var TWO_PI = PI * 2;


	// factories for common easing function patterns
	function makeInOut(inFn, outFn) {
	  return function (t) { return t < 0.5 ? inFn(t * 2) * 0.5 : outFn(t * 2 - 1) * 0.5 + 0.5; }
	}
	function makeExpIn(exp) {
	  return function (t) { return pow(t, exp); }
	}
	function makeExpOut(exp) {
	  return function (t) { return 1 - pow(1 - t, exp); }
	}
	function makeExpInOut(exp) {
	  return function (t) { return t < 0.5 ?
	    pow(t * 2, exp) * 0.5 :
	    (1 - pow(1 - (t * 2 - 1), exp)) * 0.5 + 0.5; }
	}


	var linear = function (t) { return t; };

	var easeInQuad = makeExpIn(2);
	var easeOutQuad = makeExpOut(2);
	var easeInOutQuad = makeExpInOut(2);

	var easeInCubic = makeExpIn(3);
	var easeOutCubic = makeExpOut(3);
	var easeInOutCubic = makeExpInOut(3);

	var easeInQuart = makeExpIn(4);
	var easeOutQuart = makeExpOut(4);
	var easeInOutQuart = makeExpInOut(4);

	var easeInQuint = makeExpIn(5);
	var easeOutQuint = makeExpOut(5);
	var easeInOutQuint = makeExpInOut(5);

	var easeInSine = function (t) { return 1 - Math.cos(t * (HALF_PI)); };
	var easeOutSine = function (t) { return Math.sin(t * (HALF_PI)); };
	var easeInOutSine = function (t) { return -0.5 * (Math.cos(PI * t) - 1); };

	var easeInExpo = function (t) { return (t === 0) ? 0 : pow(2, 10 * (t - 1)); };

	var easeOutExpo = function (t) { return (t === 1) ? 1 : 1 - pow(2, -10 * t); };

	var easeInOutExpo = function (t) { return (t === 0 || t === 1) ? t :
	  t < 0.5 ?
	    pow(2, 10 * (t * 2 - 1)) * 0.5 :
	    (1 - pow(2, -10 * (t * 2 - 1))) * 0.5 + 0.5; };

	var easeInCirc = function (t) { return 1 - sqrt(1 - t * t); };

	var easeOutCirc = function (t) { return sqrt(1 - pow(t - 1, 2)); };

	var easeInOutCirc = makeInOut(easeInCirc, easeOutCirc);

	var easeInElastic = function (t) { return (t === 0 || t === 1) ? t : 1 - easeOutElastic(1 - t); };

	var easeOutElastic = function (t) { return (t === 0 || t === 1) ? t :
	    Math.pow(2, -10 * t) * Math.sin((t - 0.075) * TWO_PI / 0.3) + 1; };

	var easeInOutElastic = makeInOut(easeInElastic, easeOutElastic);

	var easeInBack = function (t) { return t * t * (2.70158 * t - 1.70158); };

	var easeOutBack = function (t) { return (t -= 1) * t * (2.70158 * t + 1.70158) + 1; };

	var easeInOutBack = function (t) {
	  var s = 1.70158 * 1.525;
	  return (t *= 2) < 1 ? 
	    0.5 * (t * t * ((s + 1) * t - s)) : 
	    0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2)
	};

	var easeInBounce = function (t) { return 1 - easeOutBounce(1 - t); };

	var easeOutBounce = function (t) { return t < (1 / 2.75) ? 
	    (7.5625 * t * t) :
	  t < (2 / 2.75) ? 
	    (7.5625 * (t -= (1.5 / 2.75)) * t + .75) :
	  t < (2.5 / 2.75) ? 
	    (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) :
	    (7.5625 * (t -= (2.625 / 2.75)) * t + .984375); };

	var easeInOutBounce = makeInOut(easeInBounce, easeOutBounce);

	// Aliases...?
	// export {
	//   easeInBack as swingFrom,
	//   easeOutBack as swingTo,
	//   easeInOutBack as swingFromTo,
	//   easeOutBounce as bounce,
	//   easeFrom
	// }





	// ===== License blocks from originating works: =====

	/*
	 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
	 *
	 * Uses the built in easing capabilities added In jQuery 1.1
	 * to offer multiple easing options
	 *
	 * TERMS OF USE - jQuery Easing
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright Â© 2008 George McGinley Smith
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	*/

	/*
	 *
	 * TERMS OF USE - EASING EQUATIONS
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright Â© 2001 Robert Penner
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */

	var Easings = /*#__PURE__*/Object.freeze({
		__proto__: null,
		linear: linear,
		easeInQuad: easeInQuad,
		easeOutQuad: easeOutQuad,
		easeInOutQuad: easeInOutQuad,
		easeInCubic: easeInCubic,
		easeOutCubic: easeOutCubic,
		easeInOutCubic: easeInOutCubic,
		easeInQuart: easeInQuart,
		easeOutQuart: easeOutQuart,
		easeInOutQuart: easeInOutQuart,
		easeInQuint: easeInQuint,
		easeOutQuint: easeOutQuint,
		easeInOutQuint: easeInOutQuint,
		easeInSine: easeInSine,
		easeOutSine: easeOutSine,
		easeInOutSine: easeInOutSine,
		easeInExpo: easeInExpo,
		easeOutExpo: easeOutExpo,
		easeInOutExpo: easeInOutExpo,
		easeInCirc: easeInCirc,
		easeOutCirc: easeOutCirc,
		easeInOutCirc: easeInOutCirc,
		easeInElastic: easeInElastic,
		easeOutElastic: easeOutElastic,
		easeInOutElastic: easeInOutElastic,
		easeInBack: easeInBack,
		easeOutBack: easeOutBack,
		easeInOutBack: easeInOutBack,
		easeInBounce: easeInBounce,
		easeOutBounce: easeOutBounce,
		easeInOutBounce: easeInOutBounce
	});

	/**
	 * Simple numeric interpolator function
	 */
	function number(fromValue, toValue, progress) {
	  return fromValue + (toValue - fromValue) * progress
	}

	/**
	 * Interpolator for color values; decomposes the color into r/g/b channels and does
	 * numeric interpolation on each individually. The result is a 24-bit integer value
	 * holding the r/g/b channels in its 3 bytes.
	 */
	function color(fromValue, toValue, progress) {
	  fromValue = colorValueToNumber(fromValue);
	  toValue = colorValueToNumber(toValue);
	  return rgbToNumber(
	    number(fromValue >> 16 & 255, toValue >> 16 & 255, progress),
	    number(fromValue >> 8 & 255, toValue >> 8 & 255, progress),
	    number(fromValue & 255, toValue & 255, progress)
	  )
	}



	/**
	 * Utility for converting one of the supported color value types to a 24-bit numeric color
	 * representation.
	 * @param {*} value - The input value to translate. Supported types:
	 * - 24-bit number: simply returned as is
	 * - string value: evaluated using a canvas context, so supports color keywords, rgb(), hsl(), etc.
	 * - a three.js `Color` object
	 * @return {*}
	 */
	var colorValueToNumber = (function() {
	  var colorCanvas, colorCanvasCtx;

	  // Cache for evaluated string values
	  var stringCache = Object.create(null);
	  var stringCacheSize = 0;
	  var stringCacheMaxSize = 2048;

	  return function(value) {
	    if (typeof value === 'number') {
	      return value
	    }
	    else if (typeof value === 'string') {
	      if (value in stringCache) {
	        return stringCache[value]
	      }

	      // 2D canvas for evaluating string values
	      if (!colorCanvas) {
	        colorCanvas = document.createElement('canvas');
	        colorCanvasCtx = colorCanvas.getContext('2d');
	      }

	      colorCanvas.width = colorCanvas.height = 1;
	      colorCanvasCtx.fillStyle = value;
	      colorCanvasCtx.fillRect(0, 0, 1, 1);
	      var colorData = colorCanvasCtx.getImageData(0, 0, 1, 1).data;
	      var result = rgbToNumber(colorData[0], colorData[1], colorData[2]);

	      // Enforce max cache size - for now this invalidates the entire cache when reaching
	      // the max size; we could use a true LRU cache but hitting the max size should be rare
	      // in real world usage so this should suffice as a simple memory size protection.
	      if (stringCacheSize > stringCacheMaxSize) {
	        stringCache = Object.create(null);
	        stringCacheSize = 0;
	      }

	      // Put into cache
	      stringCache[value] = result;
	      stringCacheSize++;

	      return result
	    }
	    else if (value && value.isColor) {
	      return value.getHex()
	    }
	    else {
	      return 0 //fallback to black
	    }
	  }
	})();

	function rgbToNumber(r, g, b) {
	  return r << 16 ^ g << 8 ^ b
	}

	var Interpolators = /*#__PURE__*/Object.freeze({
		__proto__: null,
		number: number,
		color: color
	});

	/**
	 * @interface AbstractTween
	 * Defines the interface expected by `Runner` for tween-like things.
	 */
	var AbstractTween = function AbstractTween () {};

	AbstractTween.prototype.gotoElapsedTime = function gotoElapsedTime (time) {};

	/**
	 * @abstract
	 * Like `gotoElapsedTime` but goes to the very end of the tween.
	 */
	AbstractTween.prototype.gotoEnd = function gotoEnd () {};

	/**
	 * @abstract
	 * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
	 * @param {number} time
	 * @return {boolean}
	 */
	AbstractTween.prototype.isDoneAtElapsedTime = function isDoneAtElapsedTime (time) {};

	var linear$1 = function (v) { return v; };
	var maxSafeInteger = 0x1fffffffffffff;

	/**
	 * @class Tween
	 * Represents a transition between two values across a duration of time.
	 *
	 * Typically you will create a Tween between two values, with a callback function to handle the intermediate values,
	 * and then start the Tween in a {@link Runner} which will start invoking the tween on each animation frame until
	 * it reaches the end of its duration.
	 *
	 * @param callback {Function} a function that will be called with the current tween value at a given point in time.
	 * @param fromValue {*} the beginning value
	 * @param toValue {*} the ending value
	 * @param duration {Number} the duration of the tween in milliseconds
	 * @param [delay] {Number} optional time in milliseconds to wait before starting the tween
	 * @param [easing] {Function|String} optional easing to be applied to the tween values. Can either be a function
	 *        that takes a value from 0 to 1 and returns a corresponding "eased" value, or a string that matches the
	 *        name of one of the common Penner easing functions - see http://easings.net/ Defaults to linear easing.
	 * @param [iterations] {Number} optional number of times to repeat the tween animation. For endless repeating,
	 *        specify `Infinity`.
	 * @param [direction] {String} direction to run the tween; one of 'forward', 'reverse', or 'alternate'. For
	 *        'alternate', it will toggle between forward and reverse on each iteration.
	 * @param [interpolate] {String|Function} how tweened values should be calculated between the fromValue and toValue.
	 *        Can be the string name for one of the built-in interpolators in Interpolators.js, or a custom function that
	 *        will be passed 3 arguments: `fromValue`, `toValue`, and `progress` from 0 to 1.
	 */
	var Tween = /*@__PURE__*/(function (AbstractTween) {
	  function Tween(callback, fromValue, toValue, duration, delay, easing, iterations, direction, interpolate) {
	    if ( duration === void 0 ) duration=750;
	    if ( delay === void 0 ) delay=0;
	    if ( easing === void 0 ) easing=linear$1;
	    if ( iterations === void 0 ) iterations=1;
	    if ( direction === void 0 ) direction='forward';
	    if ( interpolate === void 0 ) interpolate='number';

	    AbstractTween.call(this);
	    this.callback = callback;
	    this.fromValue = fromValue;
	    this.toValue = toValue;
	    this.duration = duration;
	    this.delay = delay;
	    this.easing = typeof easing === 'string' ? (Easings[easing] || linear$1) : easing;
	    this.iterations = iterations;
	    this.direction = direction;
	    this.interpolate = typeof interpolate === 'function' ? interpolate : Interpolators[interpolate] || number;

	    /**
	     * @property totalElapsed
	     * @type {number}
	     * The total duration of this tween from 0 to its completion, taking into account its `duration`, `delay`, and
	     * `iterations`. This is calculated once upon instantiation, and may be used to determine whether the tween is
	     * finished or not at a given time.
	     */
	    this.totalElapsed = this.iterations < maxSafeInteger ? this.delay + (this.duration * this.iterations) : maxSafeInteger;
	  }

	  if ( AbstractTween ) Tween.__proto__ = AbstractTween;
	  Tween.prototype = Object.create( AbstractTween && AbstractTween.prototype );
	  Tween.prototype.constructor = Tween;

	  /**
	   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
	   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
	   * invoked.
	   * @param {number} time
	   */
	  Tween.prototype.gotoElapsedTime = function gotoElapsedTime (time) {
	    var duration = this.duration;
	    var delay = this.delay;
	    if (time >= delay) {
	      time = Math.min(time, this.totalElapsed) - delay; //never go past final value
	      var progress = (time % duration) / duration;
	      if (progress === 0 && time !== 0) { progress = 1; }
	      progress = this.easing(progress);
	      if (this.direction === 'reverse' || (this.direction === 'alternate' && Math.ceil(time / duration) % 2 === 0)) {
	        progress = 1 - progress;
	      }
	      this.callback(this.interpolate(this.fromValue, this.toValue, progress));
	    }
	  };

	  /**
	   * Like `gotoElapsedTime` but goes to the very end of the tween.
	   */
	  Tween.prototype.gotoEnd = function gotoEnd () {
	    this.gotoElapsedTime(this.totalElapsed);
	  };

	  /**
	   * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
	   * @param {number} time
	   * @return {boolean}
	   */
	  Tween.prototype.isDoneAtElapsedTime = function isDoneAtElapsedTime (time) {
	    return time > this.totalElapsed
	  };

	  return Tween;
	}(AbstractTween));

	/**
	 * A specialized Tween that controls one or more other tweens. The controlled tweens are treated as a
	 * single unit and the easing/iterations/etc. are applied across the total duration of all tweens.
	 */
	var MultiTween = /*@__PURE__*/(function (Tween) {
	  function MultiTween(tweens, duration, delay, easing, iterations, direction) {
	    if (typeof duration !== 'number') {
	      // Calculate duration based on the longest individual total duration
	      duration = tweens.reduce(function (dur, tween) { return Math.max(dur, tween.totalElapsed); }, 0);
	    }
	    if (duration === Infinity) {
	      // Make an infinite duration finite, so easing math still works
	      duration = Number.MAX_VALUE;
	    }

	    // Tween the total duration time
	    Tween.call(this, null, 0, duration, duration, delay, easing, iterations, direction);
	    if (tweens.length === 1) {
	      this.callback = tweens[0].gotoElapsedTime.bind(tweens[0]);
	    } else {
	      tweens.sort(endTimeComparator); //sort by end time to ensure proper iteration in syncTweens
	      this.callback = this._syncTweens;
	    }
	    this.tweens = tweens;
	  }

	  if ( Tween ) MultiTween.__proto__ = Tween;
	  MultiTween.prototype = Object.create( Tween && Tween.prototype );
	  MultiTween.prototype.constructor = MultiTween;

	  MultiTween.prototype._syncTweens = function _syncTweens (time) {
	    // NOTE: forward iteration is important here so the tweens are evaluated in order
	    // of when they end; that way later tweens will take precedence over earlier ones.
	    // TODO would be nice to ignore tweens past their totalElapsed entirely, but have to
	    // figure out how to do that while ensuring they don't get stuck with a value that is
	    // slightly prior to their end state.
	    for (var i = 0, len = this.tweens.length; i < len; i++) {
	      this.tweens[i].gotoElapsedTime(time);
	    }
	  };

	  return MultiTween;
	}(Tween));

	function endTimeComparator(a, b) {
	  return a.totalElapsed - b.totalElapsed
	}

	var runners = [];
	var nextFrameTimer = null;
	var hasStoppedRunners = false;

	function noop() {}

	function isRunnerRunning(runner) {return runner.runner$running}
	function isTweenNotStopped(tween) {return !tween.runner$stopped}

	function tick() {
	  var now = Date.now();
	  nextFrameTimer = null;

	  // Filter out any runners that were stopped since last tick
	  if (hasStoppedRunners) {
	    runners = runners.filter(isRunnerRunning);
	    hasStoppedRunners = false;
	  }

	  if (runners.length) {
	    // Sync each runner, filtering out empty ones as we go
	    for (var i = runners.length; i-- > 0;) {
	      runners[i]._tick(now);
	    }
	    // Queue next tick if there are still active runners
	    queueFrame();
	  }
	}

	var _scheduler = window;

	/**
	 * Allow the scheduler to be modified, e.g. when switching to an immersive XRSession.
	 *
	 * TODO: we may want to only do this for a subset of animations, like just those subject to
	 *  an XRSession, while letting others use the default. This global hook won't work for that.
	 *
	 * @param {{requestAnimationFrame, cancelAnimationFrame}} scheduler - an object holding
	 *        the two scheduling functions.
	 */
	function setAnimationScheduler(scheduler) {
	  scheduler = scheduler || window;
	  if (scheduler !== _scheduler) {
	    if (nextFrameTimer) {
	      _scheduler.cancelAnimationFrame(nextFrameTimer);
	      nextFrameTimer = null;
	    }
	    _scheduler = scheduler;
	    queueFrame();
	  }
	}

	function queueFrame() {
	  if (!nextFrameTimer) {
	    nextFrameTimer = _scheduler.requestAnimationFrame(tick);
	  }
	}


	function startRunner(runner) {
	  if (!runner.runner$running) {
	    runner.runner$running = true;
	    runners.push(runner);
	    queueFrame();
	  }
	}

	function stopRunner(runner) {
	  runner.runner$running = false;
	  hasStoppedRunners = true;
	}


	/**
	 * @class Runner
	 * A container for {@link Tween} instances that handles invoking them on each animation frame.
	 */
	var Runner = function Runner() {
	  this.tweens = [];
	};

	Runner.prototype.destructor = function destructor () {
	  this.tweens = null;
	  stopRunner(this);
	  this.start = this.stop = this.pause = this._tick = noop;
	};

	/**
	 * Add a tween to the runner. It will be invoked on the next frame, not immediately.
	 * @param {Tween} tween
	 */
	Runner.prototype.start = function start (tween) {
	  // If previously paused, update start time to account for the duration of the pause
	  if (tween.runner$paused && tween.runner$started) {
	    tween.runner$started += (Date.now() - tween.runner$paused);
	  } else {
	    this.tweens.push(tween);
	  }
	  tween.runner$paused = null;
	  tween.runner$stopped = false;

	  // add runner to running runners
	  startRunner(this);
	};

	/**
	 * Remove a tween from the runner.
	 * @param tween
	 */
	Runner.prototype.stop = function stop (tween) {
	  // queue tween for removal from list on next tick
	  tween.runner$stopped = true;
	  tween.runner$paused = null;
	};

	/**
	 * Pause a tween; call `runner.start(tween)` to unpause it
	 * @param tween
	 */
	Runner.prototype.pause = function pause (tween) {
	  if (!tween.runner$paused) {
	    tween.runner$paused = Date.now();
	  }
	};

	/**
	 * Stop all running tweens.
	 */
	Runner.prototype.stopAll = function stopAll () {
	  if (this.tweens) {
	    this.tweens.forEach(this.stop, this);
	  }
	};

	Runner.prototype._tick = function _tick (now) {
	  var tweens = this.tweens;
	  var hasStoppedTweens = false;
	  var hasRunningTweens = false;

	  // Sync each tween, filtering out old finished ones as we go
	  for (var i = 0, len = tweens.length; i < len; i++) {
	    var tween = tweens[i];
	    if (!tween.runner$stopped && !tween.runner$paused) {
	      // Sync the tween to current time
	      var elapsed = now - (tween.runner$started || (tween.runner$started = now));
	      tween.gotoElapsedTime(elapsed);
	      hasRunningTweens = true;

	      // Queue for removal if we're past its end time
	      if (tween.isDoneAtElapsedTime(elapsed)) {
	        this.stop(tween);
	        if (tween.onDone) {
	          tween.onDone();
	        }
	      }
	    }
	    if (tween.runner$stopped) {
	      hasStoppedTweens = true;
	    }
	  }

	  if (hasRunningTweens) {
	    this.onTick();
	  }

	  // Prune list if needed
	  // TODO perhaps batch this up so it happens less often
	  if (hasStoppedTweens) {
	    this.tweens = tweens.filter(isTweenNotStopped);

	    // remove runner from running runners if it has no tweens left
	    if (!this.tweens.length) {
	      stopRunner(this);
	      if (this.onDone) {
	        this.onDone();
	      }
	    }
	  }
	};

	/**
	 * Override to specify a function that will be called at the end of every frame, after all
	 * tweens have been updated.
	 */
	Runner.prototype.onTick = function onTick () {
	  // abstract
	};

	/**
	 * Override to specify a function that will be called after all running tweens have completed.
	 */
	Runner.prototype.onDone = function onDone () {
	  // abstract
	};

	/**
	 * Preset spring physics configurations.
	 * For convenience, these match the presets defined by react-spring: https://www.react-spring.io/docs/hooks/api
	 */
	var PRESETS = {
	  default: { mass: 1, tension: 170, friction: 26 },
	  gentle: { mass: 1, tension: 120, friction: 14 },
	  wobbly: { mass: 1, tension: 180, friction: 12 },
	  stiff: { mass: 1, tension: 210, friction: 20 },
	  slow: { mass: 1, tension: 280, friction: 60 },
	  molasses: { mass: 1, tension: 280, friction: 120 }
	};

	// Factors to be applied to the tension and friction values; these match those used by
	// react-spring internally, so that users can use the same spring configs as they would
	// in react-spring.
	var tensionFactor = 0.000001;
	var frictionFactor = 0.001;

	var DEFAULTS = PRESETS.default;

	/**
	 * @class SpringTween
	 * Represents a transition between two values based on spring physics.
	 *
	 * This is very similar to `Tween`, except that it does not have a fixed duration. Instead, it advances a simple
	 * spring physics simulation on each call to `gotoElapsedTime`. Since it depends on being advanced in forward-time
	 * order, it cannot be repeated or run in a reverse direction. It is also not usable as a member of a `MultiTween`.
	 *
	 * The `toValue` property can be modified at any time while the simulation is running, and the velocity will be
	 * maintained; this makes spring tweens more useful than duration-based tweens for objects whose target values are
	 * changed rapidly over time, e.g. drag-drop.
	 *
	 * Non-numeric interpolations are not yet supported.
	 *
	 * @param callback {Function} a function that will be called with the current tween value at a given point in time.
	 * @param {number} fromValue - the beginning value
	 * @param {number} toValue - the initial ending value; this can be modified later by setting the `toValue` property
	 * @param {string|object} springConfig - the physical configuration of the spring physics simulation. Either an object
	 *        with `mass`, `tension`, and `friction` properties, or a string corresponding to one of the presets defined
	 *        in `SpringPresets.js`. Defaults to the "default" preset.
	 * @param {number} springConfig.mass - the mass of the simulated object being moved
	 * @param {number} springConfig.tension - the spring's tension constant accelerating the simulated object
	 * @param {number} springConfig.friction - the friction force decelerating the simulated object
	 * @param {number} [initialVelocity] - velocity of the object at the start of the simulation
	 * @param {number} [delay] optional time in milliseconds to wait before starting the simulation
	 */
	var SpringTween = /*@__PURE__*/(function (AbstractTween) {
	  function SpringTween (
	    callback,
	    fromValue,
	    toValue,
	    springConfig,
	    initialVelocity,
	    delay
	  ) {
	    if ( initialVelocity === void 0 ) initialVelocity = 0;
	    if ( delay === void 0 ) delay = 0;

	    AbstractTween.call(this);
	    this.isSpring = true;
	    this.callback = callback;
	    this.currentValue = fromValue;
	    this.toValue = toValue;
	    this.velocity = initialVelocity;
	    this.delay = delay;

	    if (typeof springConfig === 'string') {
	      springConfig = PRESETS[springConfig];
	    }
	    if (!springConfig) { springConfig = DEFAULTS; }
	    var mass = springConfig.mass;
	    var tension = springConfig.tension;
	    var friction = springConfig.friction;
	    this.mass = typeof mass === 'number' ? mass : DEFAULTS.mass;
	    this.tension = (typeof tension === 'number' ? tension : DEFAULTS.tension) * tensionFactor;
	    this.friction = (typeof friction === 'number' ? friction : DEFAULTS.friction) * frictionFactor;
	    this.minAcceleration = 1e-10; // in units/ms^2 - TODO make this configurable

	    this.$lastTime = delay;
	    this.$endTime = Infinity; //unknown until simulation is stepped to the end state
	  }

	  if ( AbstractTween ) SpringTween.__proto__ = AbstractTween;
	  SpringTween.prototype = Object.create( AbstractTween && AbstractTween.prototype );
	  SpringTween.prototype.constructor = SpringTween;

	  SpringTween.prototype.gotoElapsedTime = function gotoElapsedTime (time) {
	    if (time >= this.delay) {
	      var ref = this;
	      var toValue = ref.toValue;
	      var mass = ref.mass;
	      var tension = ref.tension;
	      var friction = ref.friction;
	      var minAcceleration = ref.minAcceleration;
	      var velocity = this.velocity || 0;
	      var value = this.currentValue;

	      // Step simulation by 1ms
	      for (var t = this.$lastTime; t < time; t++) {
	        var acceleration = (tension * (toValue - value) - friction * velocity) / mass;
	        // Acceleration converges to zero near end state
	        if (Math.abs(acceleration) < minAcceleration) {
	          velocity = 0;
	          value = toValue;
	          this.$endTime = t;
	          break
	        } else {
	          velocity += acceleration;
	          value += velocity;
	        }
	      }
	      this.velocity = velocity;
	      this.$lastTime = time;
	      this.callback(this.currentValue = value);
	    }
	  };

	  SpringTween.prototype.gotoEnd = function gotoEnd () {
	    this.velocity = 0;
	    this.$lastTime = this.$endTime;
	    this.callback(this.currentValue = this.toValue);
	  };

	  SpringTween.prototype.isDoneAtElapsedTime = function isDoneAtElapsedTime (time) {
	    return time >= this.$endTime
	  };

	  return SpringTween;
	}(AbstractTween));

	var DEFAULT_DURATION = 750;
	var DEFAULT_EASING = 'easeOutCubic';

	var TEMP_ARRAY = [null];

	function animationIdJsonReplacer(key, value) {
	  return key === 'paused' ? undefined : value === Infinity ? 'Infinity' : value
	}

	function compareByTime(a, b) {
	  return a.time - b.time
	}

	var extendAsAnimatable = createClassExtender('animatable', function(BaseFacadeClass) {
	  var AnimatableFacade = /*@__PURE__*/(function (BaseFacadeClass) {
	    function AnimatableFacade() {
	      var this$1 = this;
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      BaseFacadeClass.apply(this, args);

	      // Create root runner for all this object's animation and transition tweens
	      this.animation$runner = new Runner();
	      this.animation$runner.onTick = function () {
	        this$1.afterUpdate();
	        this$1.requestRender();
	      };
	    }

	    if ( BaseFacadeClass ) AnimatableFacade.__proto__ = BaseFacadeClass;
	    AnimatableFacade.prototype = Object.create( BaseFacadeClass && BaseFacadeClass.prototype );
	    AnimatableFacade.prototype.constructor = AnimatableFacade;

	    var prototypeAccessors = { transition: { configurable: true },animation: { configurable: true } };

	    /**
	     * Handle the special "transition" property. The descriptor should be an object with
	     * transitionable property names as keys and transition parameters as values. The
	     * transition parameters can either be objects describing the transition parameters,
	     * or `true` for a default transition.
	     *
	     *   transition: {
	     *     x: true, // uses a default duration-based transition
	     *     y: 'spring', //uses a default spring-based transition
	     *     z: {
	     *       // ...custom transition config
	     *     }
	     *   }
	     *
	     * The custom transition config object can take one of two forms for duration- vs.
	     * spring-based animations:
	     *
	     * Duration-based:
	     *
	     *   {
	     *     duration: n, //in ms, defaults to 750
	     *     easing: e, //easing function, defaults to 'easeOutCubic'
	     *     delay: n, //in ms, defaults to 0
	     *     interpolate: 'number' //one of the builtin named interpolators ('number', 'color', etc.) or a custom Function
	     *   }
	     *
	     * Spring-based:
	     *
	     *   {
	     *     spring: s, //either `true`, a named preset string e.g. "wobbly", or an object with {mass, tension, friction}
	     *     delay: n //in ms, defaults to 0
	     *   }
	     *
	     * Note that spring-based transitions do not currently support custom interpolations so they should only be used
	     * for numeric values.
	     */
	    prototypeAccessors.transition.set = function (descriptor) {
	      if (descriptor) {
	        // Ensure setter/getter has been created for all props in transition
	        for (var propName in descriptor) {
	          if (descriptor.hasOwnProperty(propName)) {
	            defineTransitionPropInterceptor(propName, this);
	          }
	        }
	      }
	      this.transition$descriptor = descriptor;
	    };
	    prototypeAccessors.transition.get = function () {
	      return this.transition$descriptor
	    };


	    /**
	     * Handle the special "animation" property. The descriptor should be an object or array
	     * of objects defining a set of keyframes and their playback parameters. Keyframes are
	     * defined by numeric keys from 0 to 100, each defining an object with the target
	     * property values for that keyframe.
	     *
	     *   animation: [{
	     *     0: {rotateZ: 0, color: 0x000000}, //can also use key "from"
	     *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key "to"
	     *     delay: 0, //starting delay in ms
	     *     duration: 2000, //total anim duration in ms, defaults to 750
	     *     easing: 'linear', //easing for the whole animation, defaults to 'linear'
	     *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.
	     *     direction: 'forward', //either 'forward', 'backward', or 'alternate'
	     *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions
	     *     paused: false //if true the animation will be paused at its current position until set back to false
	     *   }, ...]
	     *
	     * Internally the animations will be built into a set of nested tweens:
	     *
	     * |--------------------------- Main MultiTween ------------------------------------|
	     *
	     * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|
	     * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|
	     * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|
	     *
	     *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|
	     *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|
	     *                             |------------------- prop4 tween --------------------|
	     *                                            |----------- prop5 tween -------------|
	     */
	    prototypeAccessors.animation.set = function (descriptor) {
	      if (this.animation$descriptor === descriptor) { return }
	      this.animation$descriptor = descriptor;
	      var oldAnimTweens = this.animation$tweens || null;
	      var newAnimTweens = this.animation$tweens = descriptor ? Object.create(null) : null;
	      var runner = this.animation$runner;
	      var hasChanged = false;

	      // Handle single object not wrapped in array
	      if (descriptor && !Array.isArray(descriptor)) {
	        TEMP_ARRAY[0] = descriptor;
	        descriptor = TEMP_ARRAY;
	      }

	      if (descriptor) {
	        for (var i = 0, len = descriptor.length; i < len; i++) {
	          var animDesc = descriptor[i];
	          if (!animDesc) { continue }

	          // Calculate an identifier for this animation based on properties whose modification requires a new tween
	          var animId = JSON.stringify(animDesc, animationIdJsonReplacer);
	          //console.log(`${animId} - is ${oldAnimTweens && oldAnimTweens[animId] ? '' : 'not'} in old tweens`)

	          // If a matching tween already exists, update it
	          if (oldAnimTweens && (animId in oldAnimTweens)) {
	            var tween = oldAnimTweens[animId];
	            if (animDesc.paused) {
	              runner.pause(tween);
	            } else {
	              runner.start(tween);
	            }
	            newAnimTweens[animId] = tween;
	          }
	          // Otherwise create a new tween
	          else {
	            var delay = 0;
	            var duration = DEFAULT_DURATION;
	            var easing = 'linear';
	            var iterations = 1;
	            var keyframes = [];
	            var direction = 'forward';

	            for (var key in animDesc) {
	              if (animDesc.hasOwnProperty(key)) {
	                switch(key) {
	                  case 'duration':
	                    duration = animDesc[key]; break
	                  case 'delay':
	                    delay = animDesc[key]; break
	                  case 'easing':
	                    easing = animDesc[key]; break
	                  case 'iterations':
	                    iterations = animDesc[key]; break
	                  case 'direction':
	                    direction = animDesc[key]; break
	                  default:
	                    var percent = key === 'from' ? 0 : key === 'to' ? 100 : parseFloat(key);
	                    if (!isNaN(percent) && percent >= 0 && percent <= 100) {
	                      keyframes.push({time: percent / 100, props: animDesc[key]});
	                      for (var animProp in animDesc[key]) {
	                        if (animDesc[key].hasOwnProperty(animProp)) {
	                          // Ensure setter is in place
	                          defineTransitionPropInterceptor(animProp, this);
	                          // Stop any active transition tweens for this property
	                          var tweenKey = animProp + '➤anim:tween';
	                          if (this[tweenKey]) {
	                            runner.stop(this[tweenKey]);
	                            this[tweenKey] = null;
	                          }
	                        }
	                      }
	                    }
	                }
	              }
	            }

	            if (keyframes.length) {
	              // Sort the keyframes by time
	              keyframes.sort(compareByTime);
	              if (keyframes[0].time > 0) {
	                keyframes.unshift(assignIf({time: 0}, keyframes[0]));
	              }

	              // Build a MultiTween with tweens for each keyframe+property
	              var keyframePropTweens = [];
	              for (var j = 1, len$1 = keyframes.length; j < len$1; j++) {
	                var keyframe = keyframes[j];
	                var props = keyframe.props;
	                for (var prop in props) {
	                  if (props.hasOwnProperty(prop)) {
	                    var prevKeyframe = null;
	                    for (var k = j; k--;) {
	                      if (prop in keyframes[k].props) {
	                        prevKeyframe = keyframes[k];
	                        break
	                      }
	                    }
	                    if (prevKeyframe) {
	                      var propTween = new Tween(
	                        this[prop + '➤anim:actuallySet'].bind(this), //callback
	                        prevKeyframe.props[prop], //fromValue
	                        props[prop], //toValue
	                        (keyframe.time - prevKeyframe.time) * duration, //duration
	                        prevKeyframe.time * duration, //delay
	                        'linear', //easing
	                        1, //iterations
	                        'forward', //direction
	                        animDesc.interpolate && animDesc.interpolate[prop] || 'number'
	                      );
	                      propTween.$$property = prop;
	                      keyframePropTweens.push(propTween);
	                    }
	                  }
	                }
	              }
	              var tween$1 = newAnimTweens[animId] = new MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);
	              if (!animDesc.paused) {
	                runner.start(tween$1);
	              }

	              // The tween runner won't do anything until next tick, so immediately sync to the first frame's
	              // properties if the animation has no delay to avoid a flash of bad initial state
	              if (delay === 0) {
	                var firstKeyframeProps = keyframes[0].props;
	                for (var prop$1 in firstKeyframeProps) {
	                  if (firstKeyframeProps.hasOwnProperty(prop$1)) {
	                    this[prop$1 + '➤anim:actuallySet'](firstKeyframeProps[prop$1]);
	                  }
	                }
	              }
	            }

	            hasChanged = true;
	          }
	        }
	      }

	      // Stop any obsolete tweens
	      if (oldAnimTweens) {
	        for (var animId$1 in oldAnimTweens) {
	          if (!newAnimTweens || !newAnimTweens[animId$1]) {
	            var tween$2 = oldAnimTweens[animId$1];
	            tween$2.gotoEnd(); //force to end value so it doesn't stick partway through
	            runner.stop(tween$2);
	            hasChanged = true;
	          }
	        }
	      }

	      // If the total set of animations has changed, recalc the set of animating properties
	      if (hasChanged) {
	        if (newAnimTweens) {
	          var animatingProps = this.animation$animatingProps = Object.create(null);
	          for (var animId$2 in newAnimTweens) {
	            var propTweens = newAnimTweens[animId$2].tweens;
	            for (var i$1 = propTweens.length; i$1--;) {
	              animatingProps[propTweens[i$1].$$property] = true;
	            }
	          }
	        } else {
	          this.animation$animatingProps = null;
	        }
	      }
	    };
	    prototypeAccessors.animation.get = function () {
	      return this.animation$descriptor
	    };

	    AnimatableFacade.prototype.destructor = function destructor () {
	      var this$1 = this;

	      var runner = this.animation$runner;
	      if (this.exitAnimation && !this.parent.isDestroying) {
	        runner.stopAll();
	        this.animation = this.exitAnimation;
	        this.exitAnimation = this.transition = null;
	        var onTick = runner.onTick;
	        runner.onTick = function () {
	          if (this$1.parent && !this$1.parent.isDestroying) {
	            onTick();
	          } else {
	            // An ancestor may have been destroyed during our exit animation, orphaning this object;
	            // catch this case and short-circuit the animation to prevent errors in subsequent ticks
	            runner.onDone = null;
	            this$1.destructor();
	          }
	        };
	        runner.onDone = function () {
	          this$1.requestRender();
	          this$1.destructor();
	        };
	      } else {
	        runner.destructor();
	        BaseFacadeClass.prototype.destructor.call(this);
	      }
	    };

	    Object.defineProperties( AnimatableFacade.prototype, prototypeAccessors );

	    return AnimatableFacade;
	  }(BaseFacadeClass));

	  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
	  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
	  // other custom setters anywhere else in the prototype chain.
	  function defineTransitionPropInterceptor(propName, currentInstance) {
	    if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {
	      var actualValueKey = propName + "➤anim:actualValue";
	      var actuallySetKey = propName + "➤anim:actuallySet";
	      var hasBeenSetKey = propName + "➤anim:hasBeenSet";
	      var activeTweenKey = propName + "➤anim:tween";

	      // Find the nearest getter/setter up the prototype chain, if one exists. Assuming the prototype won't change after the fact.
	      var superGetter, superSetter;
	      var proto = BaseFacadeClass.prototype;
	      while (proto) {
	        var desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc) {
	          superSetter = desc.set;
	          superGetter = desc.get;
	          if (superSetter && !superGetter || superGetter && !superSetter) {
	            throw new Error(("Animatable: property " + propName + " has a custom " + (superSetter ? 'setter' : 'getter') + " but no " + (superSetter ? 'getter' : 'setter') + ". Animatable properties must have both."))
	          }
	          break
	        }
	        proto = Object.getPrototypeOf(proto);
	      }

	      // Function to set the value, bypassing the interceptor setter.
	      // Use the super setter if available, otherwise store in a private-ish key
	      var actuallySet = superSetter ? function actuallySet(value) {
	        superSetter.call(this, value);
	        if (!this[hasBeenSetKey]) {
	          this[hasBeenSetKey] = true;
	        }
	      } : function actuallySet(value) {
	        this[actualValueKey] = value;
	        if (!this[hasBeenSetKey]) {
	          this[hasBeenSetKey] = true;
	        }
	      };
	      Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });


	      // Add the custom getter/setter for this property
	      Object.defineProperty(AnimatableFacade.prototype, propName, {
	        get: function get() {
	          // Always return the current actual value
	          return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName]
	        },

	        set: function set(value) {
	          var this$1 = this;

	          // Will this value be controlled by an animation? Ignore it since animations take precedence.
	          if (this.animation$animatingProps && this.animation$animatingProps[propName]) {
	            return
	          }

	          // Does this value have a transition defined, and are the old/new values transitionable?
	          var runner = this.animation$runner;
	          var transition = this.transition;
	          if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {
	            transition = transition[propName];
	            var springConfig = transition === 'spring' ? 'default' : transition.spring;
	            // If there's no active transition tween, or the new value is different than the active tween's
	            // target value, initiate a new transition tween. Otherwise ignore it.
	            var tween$1 = this[activeTweenKey];
	            var needsNewTween = false;
	            if (tween$1) {
	              // Active tween - start new one if new value is different than the old tween's target
	              // value, unless they're both springs in which case update the original
	              if (value !== tween$1.toValue) {
	                if (springConfig && tween$1.isSpring) {
	                  // TODO allow mid-simulation modification of spring config?
	                  tween$1.toValue = value;
	                } else {
	                  runner.stop(tween$1);
	                  needsNewTween = true;
	                }
	              }
	            } else if (value !== this[propName]) {
	              // No active tween - only start one if the value is changing
	              needsNewTween = true;
	            }
	            if (needsNewTween) {
	              tween$1 = this[activeTweenKey] = springConfig
	                ? new SpringTween(
	                  actuallySet.bind(this), //callback
	                  this[propName], //fromValue
	                  value, //toValue
	                  springConfig, //springConfig (mass, friction, tension)
	                  0, //initialVelocity
	                  transition.delay || 0 //delay
	                )
	                : new Tween(
	                  actuallySet.bind(this), //callback
	                  this[propName], //fromValue
	                  value, //toValue
	                  transition.duration || DEFAULT_DURATION, //duration
	                  transition.delay || 0, //delay
	                  transition.easing || DEFAULT_EASING, //easing
	                  1, //iterations
	                  'forward', //direction
	                  transition.interpolate || 'number' //interpolate
	                );
	              tween$1.onDone = function () {
	                tween$1 = this$1[activeTweenKey] = null;
	              };
	              runner.start(tween$1);
	            }
	            return
	          }

	          // No animation or transition will be started; set the value.
	          actuallySet.call(this, value);

	          // Clean up obsolete stuff
	          var tween = this[activeTweenKey];
	          if (tween) { runner.stop(tween); }
	          this[activeTweenKey] = null;
	        }
	      });
	    }


	    // If the instance had this property set before the intercepting setter was added to the
	    // prototype, that would continue to take precedence, so move its value to the private property.
	    if (currentInstance.hasOwnProperty(propName)) {
	      currentInstance[(propName + "➤anim:actualValue")] = currentInstance[propName];
	      currentInstance[(propName + "➤anim:hasBeenSet")] = true;
	      delete currentInstance[propName];
	    }

	  }

	  return AnimatableFacade
	});

	/**
	 * Allows a facade to be configured with an optional `pointerStates` property, which defines
	 * sets of property values that should be used in place of the object's actual values when
	 * the user interacts with the facade using their pointer device (mouse, touch, vr controller, etc.)
	 * This is not used directly, but is automatically wrapped by `ParentFacade` and `ListFacade` when
	 * setting up their children if the `pointerStates` property is present.
	 *
	 * The `pointerStates` property should point to an object with `hover` and/or `active` properties,
	 * each of which is an object holding the individual properties to be used in those states. Any
	 * properties defined in `active` will take precedence over those defined in `hover`.
	 *
	 * The properties will honor any `transition`s defined for them, but the `transition` must be
	 * defined on the facade's main configuration object, not within the pointerStates themselves.
	 */
	var extendAsPointerStatesAware = createClassExtender('pointerStates', function(BaseFacadeClass) {
	  var isHoveringProp = '➤pntr:isHovering';
	  var isActiveProp = '➤pntr:isActive';
	  var propsWithInterceptors = Object.create(null);

	  var PointerStatesAware = /*@__PURE__*/(function (BaseFacadeClass) {
	    function PointerStatesAware(parent) {
	      BaseFacadeClass.call(this, parent);
	      this.addEventListener('mouseover', hoverOverHandler);
	      this.addEventListener('mouseout', hoverOutHandler);
	      this.addEventListener('mousedown', activeDownHandler);
	      this.addEventListener('mouseup', activeUpHandler);
	    }

	    if ( BaseFacadeClass ) PointerStatesAware.__proto__ = BaseFacadeClass;
	    PointerStatesAware.prototype = Object.create( BaseFacadeClass && BaseFacadeClass.prototype );
	    PointerStatesAware.prototype.constructor = PointerStatesAware;

	    PointerStatesAware.prototype.afterUpdate = function afterUpdate () {
	      this._applyPointerStates();
	      BaseFacadeClass.prototype.afterUpdate.call(this);
	    };

	    PointerStatesAware.prototype._applyPointerStates = function _applyPointerStates () {
	      var pointerStates = this.pointerStates;
	      var hoverValuesToUse = (pointerStates && this[isHoveringProp] && pointerStates.hover) || null;
	      var activeValuesToUse = (pointerStates && this[isActiveProp] && pointerStates.active) || null;

	      var lastAppliedValues = this['➤pntr:lastAppliedValues'] || propsWithInterceptors;
	      var appliedValues = this['➤pntr:lastAppliedValues'] =
	        (hoverValuesToUse || activeValuesToUse) ? assign(Object.create(null), hoverValuesToUse, activeValuesToUse) : null;

	      if (appliedValues) {
	        for (var prop in appliedValues) {
	          definePropInterceptor(prop, this);
	          actuallySet(this, prop, appliedValues[prop]);
	        }
	      }

	      if (lastAppliedValues) {
	        for (var prop$1 in lastAppliedValues) {
	          if (!appliedValues || !(prop$1 in appliedValues)) {
	            actuallySet(this, prop$1, this[(prop$1 + "➤pntr:baseValue")]);
	          }
	        }
	      }
	    };

	    return PointerStatesAware;
	  }(BaseFacadeClass));

	  // Flag for identification
	  Object.defineProperty(PointerStatesAware.prototype, 'isPointerStateAware', {value: true});

	  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
	  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
	  // other custom setters anywhere else in the prototype chain.
	  function definePropInterceptor(propName, currentInstance) {
	    // On first set for this instance, move the prop's previous value, if any, to the private property
	    var hasBeenSetProp = propName + "➤pntr:hasBeenSet";
	    if (!currentInstance[hasBeenSetProp]) {
	      currentInstance[(propName + "➤pntr:baseValue")] = currentInstance[propName];
	      delete currentInstance[propName]; //remove own prop so it doesn't override the prototype getter/setter
	      currentInstance[hasBeenSetProp] = true;
	    }

	    if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {
	      propsWithInterceptors[propName] = 1;
	      var baseValueProp = propName + "➤pntr:baseValue";
	      var appliedValueProp = propName + "➤pntr:appliedValue";

	      Object.defineProperty(PointerStatesAware.prototype, propName, {
	        get: function get() {
	          var superGetter = getSuperGetter(propName);
	          return superGetter ? superGetter.call(this) :
	            (appliedValueProp in this) ? this[appliedValueProp] :
	            this[baseValueProp]
	        },

	        set: function set(value) {
	          this[baseValueProp] = value;
	        }
	      });
	    }
	  }

	  function actuallySet(instance, propName, value) {
	    var superSetter = getSuperSetter(propName);
	    if (superSetter) {
	      superSetter.call(instance, value);
	    } else {
	      instance[(propName + "➤pntr:appliedValue")] = value;
	    }
	  }

	  function getSuperGetter(propName) {
	    var proto = BaseFacadeClass.prototype;
	    if (propName in proto) { //prefilter across entire proto chain
	      while (proto) {
	        var desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc && desc.get) {
	          return desc.get
	        }
	        proto = Object.getPrototypeOf(proto);
	      }
	    }
	    return null
	  }

	  function getSuperSetter(propName) {
	    var proto = BaseFacadeClass.prototype;
	    if (propName in proto) { //prefilter across entire proto chain
	      while (proto) {
	        var desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc && desc.set) {
	          return desc.set
	        }
	        proto = Object.getPrototypeOf(proto);
	      }
	    }
	    return null
	  }

	  function hoverOverHandler(e) {
	    e.currentTarget[isHoveringProp] = true;
	    afterPointerStateChange(e);
	  }
	  function hoverOutHandler(e) {
	    e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;
	    afterPointerStateChange(e);
	  }
	  function activeDownHandler(e) {
	    e.currentTarget[isActiveProp] = true;
	    afterPointerStateChange(e);
	  }
	  function activeUpHandler(e) {
	    e.currentTarget[isActiveProp] = false;
	    afterPointerStateChange(e);
	  }

	  function afterPointerStateChange(e) {
	    var highestFacade = e.currentTarget;
	    var parent = highestFacade.parent;
	    while (parent && parent.shouldUpdateChildren()) {
	      if (parent.isPointerStateAware) {
	        highestFacade = parent;
	      }
	      parent = parent.parent;
	    }
	    highestFacade.afterUpdate();
	    highestFacade.requestRender();
	  }

	  return PointerStatesAware
	});

	/**
	 * ListFacade is an optimized way to define a large number of scene objects based on an array of data.
	 * Unlike mapping a data array to `children` objects in the scene descriptor, ListFacade allows you to
	 * define only a single "template" descriptor object whose properties are either constant values
	 * or accessor functions that get invoked for each data item. The resulting property values are
	 * then applied directly to the implementation objects, without creating any intermediary objects.
	 *
	 * Example:
	 *
	 *     {
	 *       key: 'balls',
	 *       facade: ListFacade,
	 *       data: itemsData,
	 *       template: {
	 *         key: (item, i, all) => `ball_${ item.id }`,
	 *         facade: Ball,
	 *         x: (item, i, all) => item.time,
	 *         y: (item, i, all) => item.count,
	 *         radius: 10,
	 *         color: (item, i, all) => item.important ? 0xff0000 : 0xcccccc
	 *       }
	 *     }
	 */
	var List = /*@__PURE__*/(function (Facade) {
	  function List(parent) {
	    Facade.call(this, parent);
	    this._orderedItemKeys = [];
	  }

	  if ( Facade ) List.__proto__ = Facade;
	  List.prototype = Object.create( Facade && Facade.prototype );
	  List.prototype.constructor = List;

	  List.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var data = ref.data;
	    var template = ref.template;
	    var hasData = data && data.length && Array.isArray(data);

	    if (this.shouldUpdateChildren()) {
	      var oldDict = this._itemsDict || null;
	      var newDict = this._itemsDict = hasData ? Object.create(null) : null;
	      var orderedItemKeys = this._orderedItemKeys;

	      if (hasData) {
	        orderedItemKeys.length = data.length;

	        for (var i = 0, len = data.length; i < len; i++) {
	          var childData = data[i];
	          var key = template.key(childData, i, data);
	          var facadeClass = template.facade;
	          while(newDict[key]) {
	            key += '|dupe';
	          }

	          // If a transition/animation is present, upgrade the class to a Animatable class on demand.
	          // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
	          // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
	          // definition if the object is expected to ever need transitions, even if it's temporarily empty.
	          var transition = typeof template.transition === 'function' ? template.transition(childData, i, data) : template.transition;
	          var animation = typeof template.animation === 'function' ? template.animation(childData, i, data) : template.animation;
	          var exitAnimation = typeof template.exitAnimation === 'function' ? template.exitAnimation(childData, i, data) : template.exitAnimation;
	          if (transition || animation || exitAnimation) {
	            facadeClass = extendAsAnimatable(facadeClass);
	          }

	          // Same for pointer states
	          var pointerStates = template.pointerStates;
	          if (pointerStates === 'function' ? pointerStates(childData, i, data) : pointerStates) {
	            facadeClass = extendAsPointerStatesAware(facadeClass);
	          }

	          // If we have an old instance with the same key and class, reuse it; otherwise instantiate a new one
	          var oldImpl = oldDict && oldDict[key];
	          var newImpl = (void 0);
	          if (oldImpl && oldImpl.constructor === facadeClass) {
	            newImpl = oldImpl;
	          } else {
	            // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
	            if (oldImpl) { oldImpl.destructor(); }
	            newImpl = new facadeClass(this);
	          }
	          //always set transition/animation before any other props
	          newImpl.transition = transition;
	          newImpl.animation = animation;
	          for (var prop in template) {
	            if (template.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	              newImpl[prop] = typeof template[prop] === 'function' ? template[prop](childData, i, data) : template[prop];
	            }
	          }
	          newImpl.afterUpdate();
	          newDict[key] = newImpl;
	          orderedItemKeys[i] = key;
	        }
	      }

	      // Destroy all old child instances that were not reused or replaced
	      if (oldDict) {
	        for (var key$1 in oldDict) {
	          if (!newDict || !newDict[key$1]) {
	            oldDict[key$1].destructor();
	          }
	        }
	      }
	    }

	    Facade.prototype.afterUpdate.call(this);
	  };

	  /**
	   * Override to selectively prevent updating the ListFacade's items on `afterUpdate`, for
	   * potential performance gain.
	   * @returns {boolean}
	   */
	  List.prototype.shouldUpdateChildren = function shouldUpdateChildren () {
	    return true
	  };

	  /**
	   * Walk this facade's descendant tree, invoking a function for it and each descendant.
	   * The iteration order will match the order in which the `data` items were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  List.prototype.traverse = function traverse (fn, thisArg) {
	    fn.call(thisArg, this);
	    var keys = this._orderedItemKeys;
	    var dict = this._itemsDict;
	    for (var i = 0, len = keys.length; i < len; i++) {
	      dict[keys[i]].traverse(fn, thisArg);
	    }
	  };

	  /**
	   * Iterate over this facade's direct child facades, invoking a function for each.
	   * The iteration order will match the order in which the `data` items were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  List.prototype.forEachChild = function forEachChild (fn, thisArg) {
	    var keys = this._orderedItemKeys;
	    var dict = this._itemsDict;
	    for (var i = 0, len = keys.length; i < len; i++) {
	      fn.call(thisArg, dict[keys[i]], keys[i]);
	    }
	  };

	  List.prototype.destructor = function destructor () {
	    this.isDestroying = true;
	    // Destroy all child instances
	    var dict = this._itemsDict;
	    if (dict) {
	      for (var key in dict) {
	        dict[key].destructor();
	      }
	    }
	    Facade.prototype.destructor.call(this);
	  };

	  return List;
	}(Facade));

	var TEMP_ARRAY$1 = [null];

	/**
	 * @typedef {object} FacadeDescriptor
	 * An object describing the type and properties of a child facade to be created and managed by
	 * its parent. See the detailed description in the docs for {@link Facade.js}.
	 * @property {class} facade
	 * @property {string|number} [key]
	 */


	/**
	 * Base facade class for objects that have `children`. Manages creating and destroying child
	 * facade instances as needed as its `children` array changes.
	 *
	 * If you need to create a large number of child objects based on an array of incoming data,
	 * consider using a `ListFacade` instead of a parent object with a large `children` array, since
	 * that requires only a single template descriptor object instead of one for every child.
	 */
	var ParentFacade = /*@__PURE__*/(function (Facade) {
	  function ParentFacade(parent) {
	    Facade.call(this, parent);

	    /**
	     * @member {FacadeDescriptor | Array<FacadeDescriptor>} children
	     * Descriptors for one or more child facades.
	     */
	    this.children = null;

	    this._orderedChildKeys = [];
	  }

	  if ( Facade ) ParentFacade.__proto__ = Facade;
	  ParentFacade.prototype = Object.create( Facade && Facade.prototype );
	  ParentFacade.prototype.constructor = ParentFacade;

	  ParentFacade.prototype.afterUpdate = function afterUpdate () {
	    if (this.shouldUpdateChildren()) {
	      this.updateChildren(this.describeChildren());
	    }
	    Facade.prototype.afterUpdate.call(this);
	  };

	  /**
	   * Return the descriptor(s) for the actual children to be created and managed. By default
	   * this simply returns the value of the `children` property set by the parent, but you can
	   * override it to customize how the child content should be structured, for instance to wrap
	   * the `children` within a deeper structure, add in anonymous child siblings, or modify the
	   * `children` configurations.
	   * @protected
	   * @return {FacadeDescriptor | Array<FacadeDescriptor>}
	   */
	  ParentFacade.prototype.describeChildren = function describeChildren () {
	    return this.children
	  };

	  /**
	   * Override to selectively prevent traversing to child nodes on `afterUpdate`, for
	   * potential performance gain.
	   * @returns {boolean}
	   */
	  ParentFacade.prototype.shouldUpdateChildren = function shouldUpdateChildren () {
	    return true
	  };

	  ParentFacade.prototype.updateChildren = function updateChildren (children) {
	    var oldDict = this._childrenDict || null;
	    var newDict = this._childrenDict = null;
	    var orderedChildKeys = this._orderedChildKeys;
	    orderedChildKeys.length = 0;

	    if (children) {
	      // Allow single child without wrapper array
	      if (!Array.isArray(children)) {
	        TEMP_ARRAY$1[0] = children;
	        children = TEMP_ARRAY$1;
	      }

	      for (var i = 0, len = children.length; i < len; i++) {
	        var childDesc = children[i];
	        if (!childDesc) { continue } //child members can be null
	        if (!newDict) {
	          newDict = this._childrenDict = Object.create(null);
	        }

	        // Handle child descriptors defined via a JSX->React.createElement() transforms (ReactElement objects)
	        var isJSX = isReactElement(childDesc);
	        var propsObj = isJSX ? childDesc.props : childDesc;
	        var facadeClass = isJSX ? childDesc.type : childDesc.facade;

	        // Find this child's key; if not specified by the author, build one from the facade class name
	        var key = childDesc.key;
	        if (!key) {
	          var j = 0;
	          do {
	            key = "auto:" + (facadeClass.name) + ":" + (j++);
	          } while (newDict[key])
	        }
	        if (newDict[key]) {
	          console.warn(("Duplicate key in children: " + key));
	          while(newDict[key]) {
	            key += '|dupe';
	          }
	        }

	        // If a transition/animation is present, upgrade the class to a Animatable class on demand.
	        // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
	        // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
	        // definition if the object is expected to ever need transitions, even if it's temporarily empty.
	        var transition = propsObj.transition;
	        var animation = propsObj.animation;
	        if (transition || animation || propsObj.exitAnimation) {
	          facadeClass = extendAsAnimatable(facadeClass);
	        }

	        // Same for pointer states
	        if (propsObj.pointerStates) {
	          facadeClass = extendAsPointerStatesAware(facadeClass);
	        }

	        // If we have an old instance with the same key and class, update it, otherwise instantiate a new one
	        var oldImpl = oldDict && oldDict[key];
	        var newImpl = (void 0);
	        if (oldImpl && oldImpl.constructor === facadeClass) {
	          newImpl = oldImpl;
	        } else {
	          // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
	          if (oldImpl) { oldImpl.destructor(); }
	          newImpl = new facadeClass(this);
	        }
	        //always set transition/animation before any other props
	        newImpl.transition = transition;
	        newImpl.animation = animation;
	        for (var prop in propsObj) {
	          if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	            newImpl[prop] = propsObj[prop];
	          }
	        }
	        newDict[key] = newImpl;
	        orderedChildKeys.push(key);
	        newImpl.afterUpdate();
	      }
	    }

	    // Destroy all old child instances that were not reused or replaced
	    if (oldDict) {
	      for (var key$1 in oldDict) {
	        if (!newDict || !newDict[key$1]) {
	          oldDict[key$1].destructor();
	        }
	      }
	    }
	  };

	  ParentFacade.prototype.getChildByKey = function getChildByKey (key) {
	    var dict = this._childrenDict;
	    return dict && dict[key] || null
	  };

	  /**
	   * Walk this facade's descendant tree, invoking a function for it and each descendant.
	   * The iteration order will match the order in which the `children` were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  ParentFacade.prototype.traverse = function traverse (fn, thisArg) {
	    fn.call(thisArg, this);
	    var keys = this._orderedChildKeys;
	    var dict = this._childrenDict;
	    for (var i = 0, len = keys.length; i < len; i++) {
	      dict[keys[i]].traverse(fn, thisArg);
	    }
	  };

	  /**
	   * Iterate over this facade's direct child facades, invoking a function for each.
	   * The iteration order will match the order in which the `children` were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  ParentFacade.prototype.forEachChild = function forEachChild (fn, thisArg) {
	    var keys = this._orderedChildKeys;
	    var dict = this._childrenDict;
	    for (var i = 0, len = keys.length; i < len; i++) {
	      fn.call(thisArg, dict[keys[i]], keys[i]);
	    }
	  };

	  ParentFacade.prototype.destructor = function destructor () {
	    this.isDestroying = true;
	    // Destroy all child instances
	    var dict = this._childrenDict;
	    if (dict) {
	      for (var key in dict) {
	        dict[key].destructor();
	      }
	    }
	    Facade.prototype.destructor.call(this);
	  };

	  return ParentFacade;
	}(Facade));

	var pointerMotionEventProps = [
	  'onMouseOver',
	  'onMouseOut',
	  'onMouseMove',
	  'onDragStart',
	  'onDrag',
	  'onDragEnter',
	  'onDragOver',
	  'onDragLeave'
	];

	var pointerActionEventProps = [
	  'onMouseDown',
	  'onMouseUp',
	  'onClick',
	  'onDoubleClick',
	  'onDrop',
	  'onDragEnd',
	  'onWheel'
	];

	var pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);
	var pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);

	var pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);
	var pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);

	function eventPropToType(prop) {
	  return prop === 'onDoubleClick' ? 'dblclick' : prop.replace(/^on/, '').toLowerCase()
	}


	var PointerEventTarget = /*@__PURE__*/(function (ParentFacade) {
	  function PointerEventTarget () {
	    ParentFacade.apply(this, arguments);
	  }

	  if ( ParentFacade ) PointerEventTarget.__proto__ = ParentFacade;
	  PointerEventTarget.prototype = Object.create( ParentFacade && ParentFacade.prototype );
	  PointerEventTarget.prototype.constructor = PointerEventTarget;

	  PointerEventTarget.prototype.interceptsPointerEvents = function interceptsPointerEvents (eventRegistry) {
	    if (this.pointerEvents === false) {
	      return false
	    }
	    if (this.pointerEvents) {
	      return true
	    }
	    for (var i = 0, len = pointerEventTypes.length; i < len; i++) {
	      if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {
	        return true
	      }
	    }
	  };

	  return PointerEventTarget;
	}(ParentFacade));


	Object.defineProperty(PointerEventTarget.prototype, 'isPointerEventTarget', {value: true});


	// Add handlers for pointer event properties
	pointerEventProps.forEach(function (propName) {
	  Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));
	});

	/**
	 * @class EventRegistry
	 * Utility for tracking event listeners by type and target facade
	 */
	function EventRegistry() {
	  var this$1 = this;

	  var byEventType = Object.create(null);

	  this.addListenerForFacade = function (facade, type, handler) {
	    var listenersOfType = byEventType[type] || (byEventType[type] = {
	      count: 0,
	      byFacadeId: Object.create(null)
	    });
	    var facadeId = facade.$facadeId;
	    var oldHandlers = listenersOfType.byFacadeId[facadeId];
	    // No listeners for this facade yet; set handler function as single value to avoid
	    // unnecessary array creation in the common single-listener case.
	    if (!oldHandlers) {
	      listenersOfType.count++;
	      listenersOfType.byFacadeId[facadeId] = handler;
	    }
	    // Already multiple listeners; add to array if not already present
	    else if (Array.isArray(oldHandlers)) {
	      if (oldHandlers.indexOf(handler) === -1) {
	        listenersOfType.count++;
	        oldHandlers.push(handler);
	      }
	    }
	    // Second unique listener; promote to array
	    else if (oldHandlers !== handler) {
	      listenersOfType.count++;
	      listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];
	    }
	  };

	  this.removeListenerForFacade = function (facade, type, handler) {
	    var listenersOfType = byEventType[type];
	    var facadeId = facade.$facadeId;
	    var oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
	    // Single listener; delete from map
	    if (oldHandlers === handler) {
	      listenersOfType.count--;
	      delete listenersOfType.byFacadeId[facadeId];
	    }
	    // Multiple listeners; remove from array
	    else if (Array.isArray(oldHandlers)) {
	      var idx = oldHandlers.indexOf(handler);
	      if (idx > -1) {
	        listenersOfType.count--;
	        // Delete from map if the array will be empty; we don't demote from array to single
	        // item because it can result in unneeded churn in the likely case of a different
	        // listener being added immediately after
	        if (oldHandlers.length === 1) {
	          delete listenersOfType.byFacadeId[facadeId];
	        } else {
	          oldHandlers.splice(idx, 1);
	        }
	      }
	    }
	  };

	  this.removeAllListenersForFacade = function (facade) {
	    var facadeId = facade.$facadeId;
	    for (var type in byEventType) {
	      var facadeListeners = byEventType[type].byFacadeId[facadeId];
	      if (facadeListeners) {
	        byEventType[type].count -= (Array.isArray(facadeListeners) ? facadeListeners.length : 1);
	        delete byEventType[type].byFacadeId[facadeId];
	      }
	    }
	  };

	  this.hasFacadeListenersOfType = function (facade, type) {
	    return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false
	  };

	  this.hasAnyListenersOfType = function (type) {
	    return byEventType[type] ? byEventType[type].count > 0 : false
	  };

	  this.findBubblingEventTarget = function (targetFacade, eventType) {
	    while (targetFacade) {
	      if (this$1.hasFacadeListenersOfType(targetFacade, eventType)) {
	        return targetFacade
	      }
	      targetFacade = targetFacade.parent;
	    }
	    return null
	  };

	  function tryCall(func, scope, arg1, arg2) {
	    try {
	      func.call(scope, arg1, arg2);
	    } catch(err) {
	      console.error(err);
	    }
	  }

	  this.forEachFacadeListenerOfType = function (facade, type, callback, scope) {
	    var listenersOfType = byEventType[type];
	    var facadeId = facade.$facadeId;
	    var handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
	    if (handlers) {
	      if (Array.isArray(handlers)) {
	        for (var i = 0; i < handlers.length; i++) {
	          tryCall(callback, scope, handlers[i], facadeId);
	        }
	      } else {
	        tryCall(callback, scope, handlers, facadeId);
	      }
	    }
	  };

	  this.forEachListenerOfType = function (type, callback, scope) {
	    var listenersOfType = byEventType[type];
	    if (listenersOfType && listenersOfType.count > 0) {
	      for (var facadeId in listenersOfType.byFacadeId) {
	        var facadeListeners = listenersOfType.byFacadeId[facadeId];
	        if (Array.isArray(facadeListeners)) {
	          for (var i = 0; i < facadeListeners.length; i++) {
	            tryCall(callback, scope, facadeListeners[i], facadeId);
	          }
	        } else {
	          tryCall(callback, scope, facadeListeners, facadeId);
	        }
	      }
	    }
	  };

	  this.dispatchEventOnFacade = function (facade, event) {
	    var currentTarget = facade;
	    function callHandler(handler) {
	      handler.call(currentTarget, event);
	    }
	    event.target = facade;
	    while (currentTarget && !event.propagationStopped) { //TODO should defaultPrevented mean anything here?
	      event.currentTarget = currentTarget;
	      this$1.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);
	      if (event.bubbles) {
	        currentTarget = currentTarget.parent;
	      } else {
	        break
	      }
	    }
	  };
	}

	var TAP_DISTANCE_THRESHOLD = 10;
	var TAP_GESTURE_MAX_DUR = 300;
	var TAP_DBLCLICK_MAX_DUR = 300;
	var DEFAULT_EVENT_SOURCE = {};

	var domPointerMotionEventTypes = [
	  'mousemove',
	  'mouseout',
	  'touchmove'
	];
	var domPointerActionEventTypes = [
	  'mousedown',
	  'mouseup',
	  'click',
	  'dblclick',
	  'wheel',
	  'touchstart',
	  'touchend',
	  'touchcancel'
	];
	var dropEventTypes = [
	  'mouseup',
	  'touchend',
	  'touchcancel'
	];
	var pointerActionEventTypeMappings = {
	  'touchstart': 'mousedown',
	  'touchend': 'mouseup',
	  'touchcancel': 'mouseup'
	};

	var touchDragPropsToNormalize = ['clientX', 'clientY', 'screenX', 'screenY', 'pageX', 'pageY'];

	var SyntheticEvent = function SyntheticEvent(nativeEvent, type, target, relatedTarget, extraProps) {
	  var this$1 = this;

	  // Copy native event properties - TODO investigate using a Proxy
	  for (var prop in nativeEvent) {
	    // NOTE: we don't check hasOwnProperty in this loop because properties that will return
	    // false for properties that are defined by getters on inherited prototypes
	    if (typeof nativeEvent[prop] !== 'function') {
	      this[prop] = nativeEvent[prop];
	    }
	  }

	  // Adjust to custom params
	  this.target = target;
	  this.relatedTarget = relatedTarget;
	  this.type = type;
	  this.nativeEvent = nativeEvent;
	  assign(this, extraProps);

	  // normalize position properties on touch events with a single touch, to facilitate
	  // downstream handlers that expect them to look like mouse events
	  // NOTE: can't do this in _normalizePointerEvent() as these props are unwritable on native Event objects
	  if (nativeEvent.touches) {
	    var touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;
	    if (touches.length === 1) {
	      touchDragPropsToNormalize.forEach(function (prop) {
	        this$1[prop] = touches[0][prop];
	      });
	    }
	  }
	};

	SyntheticEvent.prototype.preventDefault = function preventDefault () {
	  this.defaultPrevented = true;
	  this.nativeEvent.preventDefault();
	};

	SyntheticEvent.prototype.stopPropagation = function stopPropagation () {
	  this.propagationStopped = true;
	  this.nativeEvent.stopPropagation();
	};

	function isTouchEndOrCancel(e) {
	  return e.type === 'touchend' || e.type === 'touchcancel'
	}

	function killEvent(e) {
	  e.stopPropagation();
	  e.preventDefault();
	}


	var WorldBaseFacade = /*@__PURE__*/(function (ParentFacade) {
	  function WorldBaseFacade(element) {
	    ParentFacade.call(this, null);

	    this.width = this.height = 1;
	    this._element = element;
	    this._htmlOverlays = Object.create(null);

	    // Bind events
	    this.eventRegistry = new EventRegistry();
	    this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);
	    this._onPointerActionEvent = this._onPointerActionEvent.bind(this);
	    this._onDropEvent = this._onDropEvent.bind(this);
	    this._togglePointerListeners(true);
	  }

	  if ( ParentFacade ) WorldBaseFacade.__proto__ = ParentFacade;
	  WorldBaseFacade.prototype = Object.create( ParentFacade && ParentFacade.prototype );
	  WorldBaseFacade.prototype.constructor = WorldBaseFacade;

	  var prototypeAccessors = { renderingScheduler: { configurable: true } };

	  WorldBaseFacade.prototype.afterUpdate = function afterUpdate () {
	    this._queueRender();
	    ParentFacade.prototype.afterUpdate.call(this);
	  };

	  WorldBaseFacade.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
	    var handler = this._notifyWorldHandlers[message];
	    if (handler) {
	      handler.call(this, source, data);
	    }
	  };

	  WorldBaseFacade.prototype._isContinuousRender = function _isContinuousRender () {
	    return this.continuousRender
	  };

	  /**
	   * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler
	   * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling
	   * functions. Defaults to `window` but can be switched to another implementation, e.g.
	   * to use an XRSession's custom scheduler.
	   */
	  prototypeAccessors.renderingScheduler.set = function (scheduler) {
	    scheduler = scheduler || window;
	    if (scheduler !== this.renderingScheduler) {
	      var activeHandle = this._nextFrameTimer;
	      if (activeHandle) {
	        this.renderingScheduler.cancelAnimationFrame(activeHandle);
	        this._nextFrameTimer = null;
	      }
	      this._renderingScheduler = scheduler;
	    }
	  };
	  prototypeAccessors.renderingScheduler.get = function () {
	    return this._renderingScheduler || window
	  };

	  // Schedule a render pass on the next frame
	  WorldBaseFacade.prototype._queueRender = function _queueRender () {
	    var this$1 = this;

	    if (!this._nextFrameTimer) {
	      var handler = this._nextFrameHandler || (this._nextFrameHandler = function () {
	        var ref$1;

	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];
	        var ref = this$1;
	        var onStatsUpdate = ref.onStatsUpdate;
	        var onBeforeRender = ref.onBeforeRender;
	        var onAfterRender = ref.onAfterRender;
	        var start = onStatsUpdate && Date.now();

	        if (onBeforeRender) { onBeforeRender(this$1); }

	        (ref$1 = this$1).doRender.apply(ref$1, args);

	        if (onStatsUpdate) {
	          var now = Date.now();
	          onStatsUpdate({
	            'Render CPU Time (ms)': now - start,
	            'Time Between Frames (ms)': this$1._lastFrameTime ? now - this$1._lastFrameTime : '?',
	            'FPS': this$1._lastFrameTime ? Math.round(1000 / (now - this$1._lastFrameTime)) : '?'
	          });
	          this$1._lastFrameTime = now;
	        }

	        this$1._doRenderHtmlItems();

	        if (onAfterRender) { onAfterRender(this$1); }

	        this$1._nextFrameTimer = null;

	        if (this$1._isContinuousRender()) {
	          this$1._queueRender();
	        }
	      });
	      this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);
	    }
	  };

	  /**
	   * @abstract
	   */
	  WorldBaseFacade.prototype.doRender = function doRender (/*...frameArgs*/) {
	  };

	  /**
	   * @abstract
	   */
	  WorldBaseFacade.prototype.getFacadeUserSpaceXYZ = function getFacadeUserSpaceXYZ (facade) {
	  };

	  WorldBaseFacade.prototype._doRenderHtmlItems = function _doRenderHtmlItems () {
	    if (this.renderHtmlItems) {
	      var htmlItemsData = [];
	      var overlayFacades = this._htmlOverlays;
	      for (var key in overlayFacades) {
	        var facade = overlayFacades[key];
	        var data = this.getFacadeUserSpaceXYZ(facade);
	        if (data.z >= 0) { //Ignore objects with negative z (behind the camera)
	          data.key = facade.$facadeId;
	          data.html = facade.html;
	          data.exact = facade.exact;
	          htmlItemsData.push(data);
	        }
	      }
	      this.renderHtmlItems(htmlItemsData);
	    }
	  };

	  /**
	   * Hook allowing world implementations to pre-normalize native pointer events, for instance
	   * computing derived worldspace properties that are simpler for downstream code to use.
	   * @param {Event} e
	   * @protected
	   */
	  WorldBaseFacade.prototype._normalizePointerEvent = function _normalizePointerEvent (e) {
	  };

	  /**
	   * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).
	   * This will be called by the code that wraps this World facade to bridge native DOM events
	   * into the Troika world.
	   * @param {Event} e
	   */
	  WorldBaseFacade.prototype._onPointerMotionEvent = function _onPointerMotionEvent (e) {
	    this._normalizePointerEvent(e);
	    var eventState = this._getPointerEventState(e);

	    if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {
	      var hoverInfo = (e.type === 'mouseout' || isTouchEndOrCancel(e)) ? null : this._findHoverTarget(e);
	      var lastHovered = eventState.hoveredFacade;
	      var hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;

	      var dragInfo = eventState.dragInfo;
	      if (dragInfo) {
	        if (!dragInfo.dragStartFired) {
	          this._firePointerEvent('dragstart', dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);
	          dragInfo.dragStartFired = true;
	        }
	        this._firePointerEvent('drag', e, dragInfo.draggedFacade, null, hoverInfo);
	      }

	      if (hovered !== lastHovered) {
	        if (lastHovered) {
	          this._firePointerEvent('mouseout', e, lastHovered, hovered, hoverInfo);
	          if (dragInfo) {
	            this._firePointerEvent('dragleave', e, lastHovered, hovered, hoverInfo);
	          }
	        }
	        if (hovered) {
	          this._firePointerEvent('mouseover', e, hovered, lastHovered, hoverInfo);
	          if (dragInfo) {
	            this._firePointerEvent('dragenter', e, hovered, lastHovered, hoverInfo);
	          }
	        }
	      }
	      if (hovered) {
	        this._firePointerEvent('mousemove', e, hovered, null, hoverInfo);
	        if (dragInfo) {
	          this._firePointerEvent('dragover', e, hovered, null, hoverInfo);
	        }
	      }
	    }

	    // Cancel tap gesture if moving past threshold
	    var tapInfo = eventState.tapInfo;
	    if (tapInfo && e.type === 'touchmove') {
	      var touch = e.changedTouches[0];
	      if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {
	        eventState.tapInfo = null;
	      }
	    }
	  };

	  /**
	   * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).
	   * This will be called by the code that wraps this World facade to bridge native DOM events
	   * into the Troika world.
	   * @param {Event} e
	   */
	  WorldBaseFacade.prototype._onPointerActionEvent = function _onPointerActionEvent (e) {
	    this._normalizePointerEvent(e);

	    // Handle drop events, in the case they weren't captured by the listeners on `document`
	    // e.g. synthetic events dispatched internally
	    if (dropEventTypes.indexOf(e.type) > -1) {
	      this._onDropEvent(e);
	    }

	    // Map touch start to mouseover, and disable touch-hold context menu
	    if (e.type === 'touchstart') {
	      if (e.touches.length === 1) {
	        this._onPointerMotionEvent(e);
	      }
	      this._enableContextMenu(false);
	    }

	    var eventRegistry = this.eventRegistry;
	    if (eventRegistry.hasAnyListenersOfType('dragstart') || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {
	      var hoverInfo = this._findHoverTarget(e);
	      var facade = hoverInfo && hoverInfo.facade;
	      if (facade) {
	        var eventState = this._getPointerEventState(e);
	        this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);

	        // touchstart/touchend could be start/end of a tap - map to click
	        if (eventRegistry.findBubblingEventTarget(facade, 'click') || eventRegistry.findBubblingEventTarget(facade, 'dblclick')) {
	          var tapInfo = eventState.tapInfo;
	          if (e.type === 'touchstart' && e.touches.length === 1) {
	            eventState.tapInfo = {
	              facade: facade,
	              x: e.touches[0].clientX,
	              y: e.touches[0].clientY,
	              startTime: Date.now(),
	              isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR
	            };
	          } else {
	            if (
	              tapInfo && tapInfo.facade === facade && e.type === 'touchend' &&
	              e.touches.length === 0 && e.changedTouches.length === 1 &&
	              Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR
	            ) {
	              this._firePointerEvent('click', e, facade, null, hoverInfo);
	              if (tapInfo.isDblClick) {
	                this._firePointerEvent('dblclick', e, facade, null, hoverInfo);
	              }
	            }
	          }
	        }

	        // mousedown/touchstart could be prepping for drag gesture
	        if (e.type === 'mousedown' || e.type === 'touchstart') {
	          var dragger = eventRegistry.findBubblingEventTarget(facade, 'dragstart');
	          if (dragger) {
	            var dragStartEvent = new SyntheticEvent(e, 'dragstart', dragger, null, {intersection: hoverInfo});
	            eventState.dragInfo = {
	              draggedFacade: dragger,
	              dragStartFired: false,
	              dragStartEvent: dragStartEvent
	            };
	            // handle release outside canvas
	            this._toggleDropListeners(true);
	          }
	        }
	      }
	      e.preventDefault(); //prevent e.g. touch scroll
	    }

	    // Map touch end to mouseout
	    if (isTouchEndOrCancel(e)) {
	      if (e.changedTouches.length === 1) {
	        this._onPointerMotionEvent(e);
	      }
	      this._enableContextMenu(true);
	    }
	  };

	  WorldBaseFacade.prototype._onDropEvent = function _onDropEvent (e) {
	    var eventState = this._getPointerEventState(e);
	    var dragInfo = eventState.dragInfo;
	    if (dragInfo) {
	      this._normalizePointerEvent(e);
	      var hoverInfo = this._findHoverTarget(e);
	      var targetFacade = hoverInfo && hoverInfo.facade;
	      if (targetFacade) {
	        this._firePointerEvent('drop', e, targetFacade, null, hoverInfo);
	      }
	      this._firePointerEvent('dragend', e, dragInfo.draggedFacade, null, hoverInfo);
	      this._toggleDropListeners(false);
	      eventState.dragInfo = null;
	    }
	  };

	  WorldBaseFacade.prototype._firePointerEvent = function _firePointerEvent (eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {
	    var newEvent = (originalEvent instanceof SyntheticEvent) ?
	      originalEvent :
	      new SyntheticEvent(
	        originalEvent,
	        eventType,
	        targetFacade,
	        relatedTargetFacade,
	        {
	          bubbles: true,
	          intersection: intersection
	        }
	      );
	    // Dispatch with bubbling
	    this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);
	  };

	  WorldBaseFacade.prototype._getPointerEventState = function _getPointerEventState (e) {
	    var states = this._pointerEventStates || (this._pointerEventStates = new WeakMap());
	    var eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;
	    var eventState = states.get(eventSource);
	    if (!eventState) {
	      states.set(eventSource, eventState = {});
	    }
	    return eventState
	  };

	  WorldBaseFacade.prototype._toggleDropListeners = function _toggleDropListeners (on) {
	    var this$1 = this;

	    dropEventTypes.forEach(function (type) {
	      document[(on ? 'add' : 'remove') + 'EventListener'](type, this$1._onDropEvent, true);
	    });
	  };

	  WorldBaseFacade.prototype._togglePointerListeners = function _togglePointerListeners (on) {
	    var this$1 = this;

	    var canvas = this._element;
	    if (canvas && on !== this._pointerListenersAttached) {
	      var method = (on ? 'add' : 'remove') + 'EventListener';
	      domPointerMotionEventTypes.forEach(function (type) {
	        canvas[method](type, this$1._onPointerMotionEvent, false);
	      });
	      domPointerActionEventTypes.forEach(function (type) {
	        canvas[method](type, this$1._onPointerActionEvent, false);
	      });
	      this._pointerListenersAttached = on;
	    }
	  };

	  WorldBaseFacade.prototype._enableContextMenu = function _enableContextMenu (enable) {
	    var canvas = this._element;
	    if (canvas) {
	      canvas[(enable ? 'remove' : 'add') + 'EventListener']('contextmenu', killEvent, true);
	    }
	  };

	  /**
	   * @abstract
	   * Given a pointer-related Event, find and return all facade objects that are intersected
	   * by that event. If any hits are found, this should return an array of objects that contain
	   * at least `facade` and `distance` properties. Any additional properties will be exposed to
	   * event listeners on the synthetic event object as an `intersection` property.
	   * @param {Event} e
	   * @param {Function} [filterFn]
	   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
	   */
	  WorldBaseFacade.prototype.getFacadesAtEvent = function getFacadesAtEvent (e, filterFn) {
	    throw new Error('getFacadesAtEvent: no impl')
	  };

	  WorldBaseFacade.prototype._findHoverTarget = function _findHoverTarget (e) {
	    var this$1 = this;

	    //only handle single touches for now
	    if (e.touches && e.touches.length > 1) {
	      return null
	    }

	    var allHits = this.getFacadesAtEvent(e, function (facade) { return facade.isPointerEventTarget && facade.interceptsPointerEvents(this$1.eventRegistry); }
	    );
	    if (allHits) {
	      // Find the closest by comparing distance, or distanceBias if distance is the same
	      var closestHit = allHits[0];
	      for (var i = 1; i < allHits.length; i++) {
	        if (allHits[i].distance < closestHit.distance ||
	          (allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0))
	        ) {
	          closestHit = allHits[i];
	        }
	      }
	      return closestHit
	    }

	    return null
	  };

	  WorldBaseFacade.prototype.destructor = function destructor () {
	    if (this._nextFrameTimer) {
	      this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);
	    }
	    this._togglePointerListeners(false);
	    this._toggleDropListeners(false);
	    ParentFacade.prototype.destructor.call(this);
	  };

	  Object.defineProperties( WorldBaseFacade.prototype, prototypeAccessors );

	  return WorldBaseFacade;
	}(ParentFacade));

	Object.defineProperty(WorldBaseFacade.prototype, 'isWorld', {value: true});

	WorldBaseFacade.prototype._notifyWorldHandlers = {
	  needsRender: function needsRender() {
	    this._queueRender();
	  },
	  addEventListener: function addEventListener(source, data) {
	    this.eventRegistry.addListenerForFacade(source, data.type, data.handler);
	  },
	  removeEventListener: function removeEventListener(source, data) {
	    this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);
	  },
	  removeAllEventListeners: function removeAllEventListeners(source) {
	    this.eventRegistry.removeAllListenersForFacade(source);
	  },
	  dispatchEvent: function dispatchEvent(source, event) {
	    if (!(event instanceof SyntheticEvent)) {
	      event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);
	    }
	    this.eventRegistry.dispatchEventOnFacade(source, event);
	  },
	  addHtmlOverlay: function addHtmlOverlay(source) {
	    this._htmlOverlays[source.$facadeId] = source;
	  },
	  removeHtmlOverlay: function removeHtmlOverlay(source) {
	    delete this._htmlOverlays[source.$facadeId];
	  },
	  statsUpdate: function statsUpdate(source, data) {
	    var onStatsUpdate = this.onStatsUpdate;
	    if (onStatsUpdate) { onStatsUpdate(data); }
	  }
	};

	var CT_STYLES = {
	  position: 'absolute',
	  top: 0,
	  right: 0,
	  bottom: 0,
	  left: 0,
	  pointerEvents: 'none',
	  transformStyle: 'preserve-3d'
	};

	var HtmlOverlayContent = /*@__PURE__*/(function (superclass) {
	  function HtmlOverlayContent () {
	    superclass.apply(this, arguments);
	  }

	  if ( superclass ) HtmlOverlayContent.__proto__ = superclass;
	  HtmlOverlayContent.prototype = Object.create( superclass && superclass.prototype );
	  HtmlOverlayContent.prototype.constructor = HtmlOverlayContent;

	  HtmlOverlayContent.prototype.shouldComponentUpdate = function shouldComponentUpdate (newProps) {
	    return (
	      newProps.html !== this.props.html ||
	      (newProps.html.props && newProps.html.props.shouldUpdateOnMove) === true
	    )
	  };

	  HtmlOverlayContent.prototype.render = function render () {
	    var html = this.props.html;
	    return typeof html === 'string'
	      ? react.createElement('span', null, html)
	      : react.cloneElement(html)
	  };

	  return HtmlOverlayContent;
	}(react.Component));

	HtmlOverlayContent.displayName = 'Canvas3D.HtmlOverlayContent';
	HtmlOverlayContent.propTypes = {
	  html: propTypes.node
	};

	var HtmlOverlay = /*@__PURE__*/(function (superclass) {
	  function HtmlOverlay (props) {
	    superclass.call(this, props);
	    this.setItems = this.setItems.bind(this);
	    this.state = {
	      items: null
	    };
	  }

	  if ( superclass ) HtmlOverlay.__proto__ = superclass;
	  HtmlOverlay.prototype = Object.create( superclass && superclass.prototype );
	  HtmlOverlay.prototype.constructor = HtmlOverlay;

	  HtmlOverlay.prototype.shouldComponentUpdate = function shouldComponentUpdate (newProps, newState) {
	    var oldState = this.state;
	    return (
	      (newState.items && newState.items.length) ||
	      (oldState.items && oldState.items.length)
	    )
	  };

	  HtmlOverlay.prototype.setItems = function setItems (items) {
	    var lastItems = this.state.items;
	    if ((items && items.length) || (lastItems && lastItems.length)) {
	      this.setState({ items: items || null });
	    }
	  };

	  HtmlOverlay.prototype.render = function render () {
	    var items = this.state.items;
	    var round = Math.round;
	    return items && items.length
	      ? react.createElement(
	        'div',
	        {
	          className: 'troika_html_overlay',
	          style: CT_STYLES
	        },
	        items.map(function (ref) {
	          var key = ref.key;
	          var html = ref.html;
	          var x = ref.x;
	          var y = ref.y;
	          var z = ref.z;
	          var exact = ref.exact;

	          if (!exact) {
	            x = round(x);
	            y = round(y);
	          }
	          return react.createElement(
	            'div',
	            {
	              key: key,
	              style: {
	                position: 'absolute',
	                transform: ("translate3d(" + x + "px, " + y + "px, " + (-z) + "px)")
	              }
	            },
	            react.createElement(HtmlOverlayContent, {html: html})
	          )
	        })
	      )
	      : null
	  };

	  return HtmlOverlay;
	}(react.Component));

	HtmlOverlay.displayName = 'Canvas3D.HtmlOverlay';

	var style = {
	  position: 'absolute',
	  top: 0,
	  right: 0,
	  background: 'rgba(0,0,0,.5)',
	  font: '11px sans-serif',
	  padding: 10
	};

	var Stats = /*@__PURE__*/(function (superclass) {
	  function Stats(props) {
	    superclass.call(this, props);
	    this.state = {stats: {}};
	  }

	  if ( superclass ) Stats.__proto__ = superclass;
	  Stats.prototype = Object.create( superclass && superclass.prototype );
	  Stats.prototype.constructor = Stats;

	  Stats.prototype.setStats = function setStats (stats) {
	    this.setState({stats: stats});
	  };

	  Stats.prototype.render = function render () {
	    var stats = this.state.stats;
	    return (
	      react.createElement(
	        'div',
	        {style: style},
	        Object.keys(stats).sort().map(function (key) { return react.createElement('div', {key: key}, (key + ": " + (stats[key]))); }
	        )
	      )
	    )
	  };

	  return Stats;
	}(react.Component));

	var defaultCanvasStyle = {width: '100%', height: '100%'};


	var CanvasBase = /*@__PURE__*/(function (superclass) {
	  function CanvasBase(props) {
	    superclass.call(this, props);
	    this._stats = {};
	    this.updateStats = this.updateStats.bind(this);
	    this.renderHtmlItems = this.renderHtmlItems.bind(this);
	    this._bindHtmlOverlayRef = this._bindHtmlOverlayRef.bind(this);
	    this._bindCanvasRef = this._bindCanvasRef.bind(this);
	    this._bindStatsRef = this._bindStatsRef.bind(this);
	  }

	  if ( superclass ) CanvasBase.__proto__ = superclass;
	  CanvasBase.prototype = Object.create( superclass && superclass.prototype );
	  CanvasBase.prototype.constructor = CanvasBase;

	  CanvasBase.prototype.componentDidUpdate = function componentDidUpdate () {
	    this.updateWorld();
	  };

	  CanvasBase.prototype.initWorld = function initWorld (canvas) {
	    var world = new this.props.worldFacade(canvas);
	    world.renderHtmlItems = this.renderHtmlItems;
	    return world
	  };

	  CanvasBase.prototype.updateWorld = function updateWorld () {
	    var world = this._world;
	    if (world) {
	      var ref = this;
	      var props = ref.props;
	      var useStats = props.stats;
	      var start = useStats && Date.now();

	      world.width = props.width;
	      world.height = props.height;
	      world.pixelRatio = props.pixelRatio;
	      world.continuousRender = props.continuousRender;
	      world.onStatsUpdate = useStats ? this.updateStats : null;
	      assign(world, props.worldProps);
	      world.afterUpdate();

	      if (useStats) {
	        this.updateStats({'Last World Update (ms)': Date.now() - start});
	      }
	    }
	  };

	  CanvasBase.prototype.destroyWorld = function destroyWorld () {
	    //just to see it burn
	    if (this._world) {
	      this._world.destructor();
	      delete this._world;
	    }
	    clearTimeout(this._statsDelay);
	  };

	  CanvasBase.prototype.renderHtmlItems = function renderHtmlItems (items) {
	    if (this._htmlOverlayRef) {
	      this._htmlOverlayRef.setItems(items);
	    }
	  };

	  CanvasBase.prototype.updateStats = function updateStats (stats) {
	    var this$1 = this;

	    this._stats = assign({}, this._stats, stats);

	    if (!this._statsDelay) {
	      this._statsDelay = setTimeout(function () {
	        this$1._statsDelay = null;
	        var ref = this$1._statsRef;
	        if (ref) {
	          ref.setStats(this$1._stats);
	        }
	      }, 250);
	    }
	  };

	  CanvasBase.prototype._bindHtmlOverlayRef = function _bindHtmlOverlayRef (cmp) {
	    this._htmlOverlayRef = cmp;
	  };

	  CanvasBase.prototype._bindCanvasRef = function _bindCanvasRef (canvas) {
	    if (canvas) {
	      try {
	        this._world = this.initWorld(canvas);
	        this.updateWorld();
	      } catch (e) {
	        console.warn(("Troika." + (this.constructor.displayName) + ": world init failed, using fallback content."), e);
	        this._failedWorldInit = true;
	        this._world = null;
	        this.forceUpdate();
	      }
	    } else {
	      this.destroyWorld();
	    }

	    // Call external ref callback
	    var cb = this.props.onCanvasRef;
	    if (cb) { cb(canvas); }
	  };

	  CanvasBase.prototype._bindStatsRef = function _bindStatsRef (ref) {
	    this._statsRef = ref;
	  };

	  CanvasBase.prototype.render = function render () {
	    var ref = this;
	    var props = ref.props;
	    return (
	      react.createElement(
	        'div',
	        {
	          className: ("troika " + (props.className || '')),
	          style: {
	            position: 'relative',
	            overflow: 'hidden',
	            width: props.width,
	            height: props.height,
	            cursor: props.cursor,
	            userSelect: 'none'
	          }
	        },
	        this._failedWorldInit ? this.props.children : react.createElement(
	          'canvas',
	          {
	            className: "troika_canvas",
	            ref: this._bindCanvasRef,
	            style: props.canvasStyle || defaultCanvasStyle
	          }
	        ),
	        react.createElement(HtmlOverlay, {ref: this._bindHtmlOverlayRef}),
	        props.stats ? react.createElement(Stats, {ref: this._bindStatsRef}) : null
	      )
	    )
	  };

	  return CanvasBase;
	}(react.Component));

	CanvasBase.commonPropTypes = {
	  width: propTypes.number.isRequired,
	  height: propTypes.number.isRequired,
	  pixelRatio: propTypes.number,
	  worldFacade: propTypes.func,
	  worldProps: propTypes.object,
	  canvasStyle: propTypes.object,
	  className: propTypes.string,
	  continuousRender: propTypes.bool,
	  onCanvasRef: propTypes.func,
	  stats: propTypes.bool,
	  cursor: propTypes.string
	};

	/**
	 * @license
	 * Copyright 2010-2021 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */
	var REVISION = '127';
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var VSMShadowMap = 3;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var CineonToneMapping = 3;
	var ACESFilmicToneMapping = 4;
	var CustomToneMapping = 5;

	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipmapNearestFilter = 1004;
	var NearestMipmapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipmapNearestFilter = 1007;
	var LinearMipmapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RedIntegerFormat = 1029;
	var RGFormat = 1030;
	var RGIntegerFormat = 1031;
	var RGBIntegerFormat = 1032;
	var RGBAIntegerFormat = 1033;

	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGB_ETC2_Format = 37492;
	var RGBA_ETC2_EAC_Format = 37496;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var RGBA_BPTC_Format = 36492;
	var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var NormalAnimationBlendMode = 2500;
	var AdditiveAnimationBlendMode = 2501;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
	var KeepStencilOp = 7680;
	var AlwaysStencilFunc = 519;

	var StaticDrawUsage = 35044;
	var DynamicDrawUsage = 35048;
	var GLSL3 = '300 es';

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) { this._listeners = {}; }

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) { return false; }

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) { return; }

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) { return; }

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	} );

	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var _seed = 1234567;

	var MathUtils = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var d0 = Math.random() * 0xffffffff | 0;
			var d1 = Math.random() * 0xffffffff | 0;
			var d2 = Math.random() * 0xffffffff | 0;
			var d3 = Math.random() * 0xffffffff | 0;
			var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

			// .toUpperCase() here flattens concatenated strings to save heap memory space.
			return uuid.toUpperCase();

		},

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

		inverseLerp: function ( x, y, value ) {

			if ( x !== y ) {

				return ( value - x ) / ( y - x );

			 } else {

				return 0;

			 }

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

		damp: function ( x, y, lambda, dt ) {

			return MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );

		},

		// https://www.desmos.com/calculator/vcsjnyz7x4

		pingpong: function ( x, length ) {
			if ( length === void 0 ) length = 1;


			return length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) { return 0; }
			if ( x >= max ) { return 1; }

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) { return 0; }
			if ( x >= max ) { return 1; }

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		// Deterministic pseudo-random float in the interval [ 0, 1 ]

		seededRandom: function ( s ) {

			if ( s !== undefined ) { _seed = s % 2147483647; }

			// Park-Miller algorithm

			_seed = _seed * 16807 % 2147483647;

			return ( _seed - 1 ) / 2147483646;

		},

		degToRad: function ( degrees ) {

			return degrees * MathUtils.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * MathUtils.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			switch ( order ) {

				case 'XYX':
					q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
					break;

				case 'YZY':
					q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
					break;

				case 'ZXZ':
					q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
					break;

				case 'XZX':
					q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
					break;

				case 'YXY':
					q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
					break;

				case 'ZYZ':
					q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
					break;

				default:
					console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

			}

		}

	};

	var Vector2 = function Vector2( x, y ) {
		if ( x === void 0 ) x = 0;
		if ( y === void 0 ) y = 0;


		this.x = x;
		this.y = y;

	};

	var prototypeAccessors = { width: { configurable: true },height: { configurable: true } };

	prototypeAccessors.width.get = function () {

		return this.x;

	};

	prototypeAccessors.width.set = function ( value ) {

		this.x = value;

	};

	prototypeAccessors.height.get = function () {

		return this.y;

	};

	prototypeAccessors.height.set = function ( value ) {

		this.y = value;

	};

	Vector2.prototype.set = function set ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	};

	Vector2.prototype.setScalar = function setScalar ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	};

	Vector2.prototype.setX = function setX ( x ) {

		this.x = x;

		return this;

	};

	Vector2.prototype.setY = function setY ( y ) {

		this.y = y;

		return this;

	};

	Vector2.prototype.setComponent = function setComponent ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	};

	Vector2.prototype.getComponent = function getComponent ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	};

	Vector2.prototype.clone = function clone () {

		return new this.constructor( this.x, this.y );

	};

	Vector2.prototype.copy = function copy ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	};

	Vector2.prototype.add = function add ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	};

	Vector2.prototype.addScalar = function addScalar ( s ) {

		this.x += s;
		this.y += s;

		return this;

	};

	Vector2.prototype.addVectors = function addVectors ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	};

	Vector2.prototype.addScaledVector = function addScaledVector ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	};

	Vector2.prototype.sub = function sub ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	};

	Vector2.prototype.subScalar = function subScalar ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	};

	Vector2.prototype.subVectors = function subVectors ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	};

	Vector2.prototype.multiply = function multiply ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	};

	Vector2.prototype.multiplyScalar = function multiplyScalar ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	};

	Vector2.prototype.divide = function divide ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	};

	Vector2.prototype.divideScalar = function divideScalar ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	};

	Vector2.prototype.applyMatrix3 = function applyMatrix3 ( m ) {

		var x = this.x, y = this.y;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	};

	Vector2.prototype.min = function min ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	};

	Vector2.prototype.max = function max ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	};

	Vector2.prototype.clamp = function clamp ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	};

	Vector2.prototype.clampScalar = function clampScalar ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	};

	Vector2.prototype.clampLength = function clampLength ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	};

	Vector2.prototype.floor = function floor () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	};

	Vector2.prototype.ceil = function ceil () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	};

	Vector2.prototype.round = function round () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	};

	Vector2.prototype.roundToZero = function roundToZero () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	};

	Vector2.prototype.negate = function negate () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	};

	Vector2.prototype.dot = function dot ( v ) {

		return this.x * v.x + this.y * v.y;

	};

	Vector2.prototype.cross = function cross ( v ) {

		return this.x * v.y - this.y * v.x;

	};

	Vector2.prototype.lengthSq = function lengthSq () {

		return this.x * this.x + this.y * this.y;

	};

	Vector2.prototype.length = function length () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	};

	Vector2.prototype.manhattanLength = function manhattanLength () {

		return Math.abs( this.x ) + Math.abs( this.y );

	};

	Vector2.prototype.normalize = function normalize () {

		return this.divideScalar( this.length() || 1 );

	};

	Vector2.prototype.angle = function angle () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	};

	Vector2.prototype.distanceTo = function distanceTo ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	};

	Vector2.prototype.distanceToSquared = function distanceToSquared ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	};

	Vector2.prototype.manhattanDistanceTo = function manhattanDistanceTo ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	};

	Vector2.prototype.setLength = function setLength ( length ) {

		return this.normalize().multiplyScalar( length );

	};

	Vector2.prototype.lerp = function lerp ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	};

	Vector2.prototype.lerpVectors = function lerpVectors ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	};

	Vector2.prototype.equals = function equals ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	};

	Vector2.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	};

	Vector2.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	};

	Vector2.prototype.fromBufferAttribute = function fromBufferAttribute ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	};

	Vector2.prototype.rotateAround = function rotateAround ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	};

	Vector2.prototype.random = function random () {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	};

	Object.defineProperties( Vector2.prototype, prototypeAccessors );

	Vector2.prototype.isVector2 = true;

	var Matrix3 = function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	Matrix3.prototype.set = function set ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	};

	Matrix3.prototype.identity = function identity () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	};

	Matrix3.prototype.copy = function copy ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	};

	Matrix3.prototype.extractBasis = function extractBasis ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	};

	Matrix3.prototype.setFromMatrix4 = function setFromMatrix4 ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	};

	Matrix3.prototype.multiply = function multiply ( m ) {

		return this.multiplyMatrices( this, m );

	};

	Matrix3.prototype.premultiply = function premultiply ( m ) {

		return this.multiplyMatrices( m, this );

	};

	Matrix3.prototype.multiplyMatrices = function multiplyMatrices ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	};

	Matrix3.prototype.multiplyScalar = function multiplyScalar ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	};

	Matrix3.prototype.determinant = function determinant () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	};

	Matrix3.prototype.invert = function invert () {

		var te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) { return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); }

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	};

	Matrix3.prototype.transpose = function transpose () {

		var tmp;
		var m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	};

	Matrix3.prototype.getNormalMatrix = function getNormalMatrix ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	};

	Matrix3.prototype.transposeIntoArray = function transposeIntoArray ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	};

	Matrix3.prototype.setUvTransform = function setUvTransform ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	};

	Matrix3.prototype.scale = function scale ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	};

	Matrix3.prototype.rotate = function rotate ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	};

	Matrix3.prototype.translate = function translate ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	};

	Matrix3.prototype.equals = function equals ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) { return false; }

		}

		return true;

	};

	Matrix3.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	};

	Matrix3.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	};

	Matrix3.prototype.clone = function clone () {

		return new this.constructor().fromArray( this.elements );

	};

	Matrix3.prototype.isMatrix3 = true;

	var _canvas;

	var ImageUtils = {

		getDataURL: function ( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			}

			var canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }

				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	var textureId = 0;

	var Texture = /*@__PURE__*/(function (EventDispatcher) {
		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
			if ( image === void 0 ) image = Texture.DEFAULT_IMAGE;
			if ( mapping === void 0 ) mapping = Texture.DEFAULT_MAPPING;
			if ( wrapS === void 0 ) wrapS = ClampToEdgeWrapping;
			if ( wrapT === void 0 ) wrapT = ClampToEdgeWrapping;
			if ( magFilter === void 0 ) magFilter = LinearFilter;
			if ( minFilter === void 0 ) minFilter = LinearMipmapLinearFilter;
			if ( format === void 0 ) format = RGBAFormat;
			if ( type === void 0 ) type = UnsignedByteType;
			if ( anisotropy === void 0 ) anisotropy = 1;
			if ( encoding === void 0 ) encoding = LinearEncoding;


			EventDispatcher.call(this);

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';

			this.image = image;
			this.mipmaps = [];

			this.mapping = mapping;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding;

			this.version = 0;
			this.onUpdate = null;

		}

		if ( EventDispatcher ) Texture.__proto__ = EventDispatcher;
		Texture.prototype = Object.create( EventDispatcher && EventDispatcher.prototype );
		Texture.prototype.constructor = Texture;

		var prototypeAccessors$1 = { needsUpdate: { configurable: true } };

		Texture.prototype.updateMatrix = function updateMatrix () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		};

		Texture.prototype.clone = function clone () {

			return new this.constructor().copy( this );

		};

		Texture.prototype.copy = function copy ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		};

		Texture.prototype.toJSON = function toJSON ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = MathUtils.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							// check cube texture with data textures

							if ( image[ i ].isDataTexture ) {

								url.push( serializeImage( image[ i ].image ) );

							} else {

								url.push( serializeImage( image[ i ] ) );

							}

						}

					} else {

						// process single image

						url = serializeImage( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		};

		Texture.prototype.dispose = function dispose () {

			this.dispatchEvent( { type: 'dispose' } );

		};

		Texture.prototype.transformUv = function transformUv ( uv ) {

			if ( this.mapping !== UVMapping ) { return uv; }

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		};

		prototypeAccessors$1.needsUpdate.set = function ( value ) {

			if ( value === true ) { this.version ++; }

		};

		Object.defineProperties( Texture.prototype, prototypeAccessors$1 );

		return Texture;
	}(EventDispatcher));

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype.isTexture = true;

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.prototype.slice.call( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	var Vector4 = function Vector4( x, y, z, w ) {
		if ( x === void 0 ) x = 0;
		if ( y === void 0 ) y = 0;
		if ( z === void 0 ) z = 0;
		if ( w === void 0 ) w = 1;


		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	};

	var prototypeAccessors$2 = { width: { configurable: true },height: { configurable: true } };

	prototypeAccessors$2.width.get = function () {

		return this.z;

	};

	prototypeAccessors$2.width.set = function ( value ) {

		this.z = value;

	};

	prototypeAccessors$2.height.get = function () {

		return this.w;

	};

	prototypeAccessors$2.height.set = function ( value ) {

		this.w = value;

	};

	Vector4.prototype.set = function set ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	};

	Vector4.prototype.setScalar = function setScalar ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	};

	Vector4.prototype.setX = function setX ( x ) {

		this.x = x;

		return this;

	};

	Vector4.prototype.setY = function setY ( y ) {

		this.y = y;

		return this;

	};

	Vector4.prototype.setZ = function setZ ( z ) {

		this.z = z;

		return this;

	};

	Vector4.prototype.setW = function setW ( w ) {

		this.w = w;

		return this;

	};

	Vector4.prototype.setComponent = function setComponent ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	};

	Vector4.prototype.getComponent = function getComponent ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	};

	Vector4.prototype.clone = function clone () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	};

	Vector4.prototype.copy = function copy ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	};

	Vector4.prototype.add = function add ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	};

	Vector4.prototype.addScalar = function addScalar ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	};

	Vector4.prototype.addVectors = function addVectors ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	};

	Vector4.prototype.addScaledVector = function addScaledVector ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	};

	Vector4.prototype.sub = function sub ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	};

	Vector4.prototype.subScalar = function subScalar ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	};

	Vector4.prototype.subVectors = function subVectors ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	};

	Vector4.prototype.multiply = function multiply ( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	};

	Vector4.prototype.multiplyScalar = function multiplyScalar ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	};

	Vector4.prototype.applyMatrix4 = function applyMatrix4 ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	};

	Vector4.prototype.divideScalar = function divideScalar ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	};

	Vector4.prototype.setAxisAngleFromQuaternion = function setAxisAngleFromQuaternion ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	};

	Vector4.prototype.setAxisAngleFromRotationMatrix = function setAxisAngleFromRotationMatrix ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z; // variables for result
		var epsilon = 0.01,	// margin to allow for rounding errors
			epsilon2 = 0.1,	// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) { s = 1; }

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	};

	Vector4.prototype.min = function min ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	};

	Vector4.prototype.max = function max ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	};

	Vector4.prototype.clamp = function clamp ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	};

	Vector4.prototype.clampScalar = function clampScalar ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	};

	Vector4.prototype.clampLength = function clampLength ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	};

	Vector4.prototype.floor = function floor () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	};

	Vector4.prototype.ceil = function ceil () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	};

	Vector4.prototype.round = function round () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	};

	Vector4.prototype.roundToZero = function roundToZero () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	};

	Vector4.prototype.negate = function negate () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	};

	Vector4.prototype.dot = function dot ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	};

	Vector4.prototype.lengthSq = function lengthSq () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	};

	Vector4.prototype.length = function length () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	};

	Vector4.prototype.manhattanLength = function manhattanLength () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	};

	Vector4.prototype.normalize = function normalize () {

		return this.divideScalar( this.length() || 1 );

	};

	Vector4.prototype.setLength = function setLength ( length ) {

		return this.normalize().multiplyScalar( length );

	};

	Vector4.prototype.lerp = function lerp ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	};

	Vector4.prototype.lerpVectors = function lerpVectors ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	};

	Vector4.prototype.equals = function equals ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	};

	Vector4.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	};

	Vector4.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	};

	Vector4.prototype.fromBufferAttribute = function fromBufferAttribute ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	};

	Vector4.prototype.random = function random () {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	};

	Object.defineProperties( Vector4.prototype, prototypeAccessors$2 );

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	var WebGLRenderTarget = /*@__PURE__*/(function (EventDispatcher) {
		function WebGLRenderTarget( width, height, options ) {

			EventDispatcher.call(this);

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.texture.image = {};
			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = 1;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		}

		if ( EventDispatcher ) WebGLRenderTarget.__proto__ = EventDispatcher;
		WebGLRenderTarget.prototype = Object.create( EventDispatcher && EventDispatcher.prototype );
		WebGLRenderTarget.prototype.constructor = WebGLRenderTarget;

		WebGLRenderTarget.prototype.setTexture = function setTexture ( texture ) {

			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};

			this.texture = texture;

		};

		WebGLRenderTarget.prototype.setSize = function setSize ( width, height, depth ) {
			if ( depth === void 0 ) depth = 1;


			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		};

		WebGLRenderTarget.prototype.clone = function clone () {

			return new this.constructor().copy( this );

		};

		WebGLRenderTarget.prototype.copy = function copy ( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		};

		WebGLRenderTarget.prototype.dispose = function dispose () {

			this.dispatchEvent( { type: 'dispose' } );

		};

		return WebGLRenderTarget;
	}(EventDispatcher));

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	var Quaternion = function Quaternion( x, y, z, w ) {
		if ( x === void 0 ) x = 0;
		if ( y === void 0 ) y = 0;
		if ( z === void 0 ) z = 0;
		if ( w === void 0 ) w = 1;


		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	};

	var prototypeAccessors$3 = { x: { configurable: true },y: { configurable: true },z: { configurable: true },w: { configurable: true } };

	Quaternion.slerp = function slerp ( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	};

	Quaternion.slerpFlat = function slerpFlat ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		var x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t;
			var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	};

	Quaternion.multiplyQuaternionsFlat = function multiplyQuaternionsFlat ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		var x0 = src0[ srcOffset0 ];
		var y0 = src0[ srcOffset0 + 1 ];
		var z0 = src0[ srcOffset0 + 2 ];
		var w0 = src0[ srcOffset0 + 3 ];

		var x1 = src1[ srcOffset1 ];
		var y1 = src1[ srcOffset1 + 1 ];
		var z1 = src1[ srcOffset1 + 2 ];
		var w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	};

	prototypeAccessors$3.x.get = function () {

		return this._x;

	};

	prototypeAccessors$3.x.set = function ( value ) {

		this._x = value;
		this._onChangeCallback();

	};

	prototypeAccessors$3.y.get = function () {

		return this._y;

	};

	prototypeAccessors$3.y.set = function ( value ) {

		this._y = value;
		this._onChangeCallback();

	};

	prototypeAccessors$3.z.get = function () {

		return this._z;

	};

	prototypeAccessors$3.z.set = function ( value ) {

		this._z = value;
		this._onChangeCallback();

	};

	prototypeAccessors$3.w.get = function () {

		return this._w;

	};

	prototypeAccessors$3.w.set = function ( value ) {

		this._w = value;
		this._onChangeCallback();

	};

	Quaternion.prototype.set = function set ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.clone = function clone () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	};

	Quaternion.prototype.copy = function copy ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.setFromEuler = function setFromEuler ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) { this._onChangeCallback(); }

		return this;

	};

	Quaternion.prototype.setFromAxisAngle = function setFromAxisAngle ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.setFromRotationMatrix = function setFromRotationMatrix ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			var s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			var s$1 = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s$1;
			this._x = 0.25 * s$1;
			this._y = ( m12 + m21 ) / s$1;
			this._z = ( m13 + m31 ) / s$1;

		} else if ( m22 > m33 ) {

			var s$2 = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s$2;
			this._x = ( m12 + m21 ) / s$2;
			this._y = 0.25 * s$2;
			this._z = ( m23 + m32 ) / s$2;

		} else {

			var s$3 = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s$3;
			this._x = ( m13 + m31 ) / s$3;
			this._y = ( m23 + m32 ) / s$3;
			this._z = 0.25 * s$3;

		}

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.setFromUnitVectors = function setFromUnitVectors ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	};

	Quaternion.prototype.angleTo = function angleTo ( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	};

	Quaternion.prototype.rotateTowards = function rotateTowards ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) { return this; }

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	};

	Quaternion.prototype.identity = function identity () {

		return this.set( 0, 0, 0, 1 );

	};

	Quaternion.prototype.invert = function invert () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	};

	Quaternion.prototype.conjugate = function conjugate () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.dot = function dot ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	};

	Quaternion.prototype.lengthSq = function lengthSq () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	};

	Quaternion.prototype.length = function length () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	};

	Quaternion.prototype.normalize = function normalize () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.multiply = function multiply ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	};

	Quaternion.prototype.premultiply = function premultiply ( q ) {

		return this.multiplyQuaternions( q, this );

	};

	Quaternion.prototype.multiplyQuaternions = function multiplyQuaternions ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.slerp = function slerp ( qb, t ) {

		if ( t === 0 ) { return this; }
		if ( t === 1 ) { return this.copy( qb ); }

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.slerpQuaternions = function slerpQuaternions ( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	};

	Quaternion.prototype.equals = function equals ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	};

	Quaternion.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	};

	Quaternion.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	};

	Quaternion.prototype.fromBufferAttribute = function fromBufferAttribute ( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	};

	Quaternion.prototype._onChange = function _onChange ( callback ) {

		this._onChangeCallback = callback;

		return this;

	};

	Quaternion.prototype._onChangeCallback = function _onChangeCallback () {};

	Object.defineProperties( Quaternion.prototype, prototypeAccessors$3 );

	Quaternion.prototype.isQuaternion = true;

	var Vector3 = function Vector3( x, y, z ) {
		if ( x === void 0 ) x = 0;
		if ( y === void 0 ) y = 0;
		if ( z === void 0 ) z = 0;


		this.x = x;
		this.y = y;
		this.z = z;

	};

	Vector3.prototype.set = function set ( x, y, z ) {

		if ( z === undefined ) { z = this.z; } // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	};

	Vector3.prototype.setScalar = function setScalar ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	};

	Vector3.prototype.setX = function setX ( x ) {

		this.x = x;

		return this;

	};

	Vector3.prototype.setY = function setY ( y ) {

		this.y = y;

		return this;

	};

	Vector3.prototype.setZ = function setZ ( z ) {

		this.z = z;

		return this;

	};

	Vector3.prototype.setComponent = function setComponent ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	};

	Vector3.prototype.getComponent = function getComponent ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	};

	Vector3.prototype.clone = function clone () {

		return new this.constructor( this.x, this.y, this.z );

	};

	Vector3.prototype.copy = function copy ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	};

	Vector3.prototype.add = function add ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	};

	Vector3.prototype.addScalar = function addScalar ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	};

	Vector3.prototype.addVectors = function addVectors ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	};

	Vector3.prototype.addScaledVector = function addScaledVector ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	};

	Vector3.prototype.sub = function sub ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	};

	Vector3.prototype.subScalar = function subScalar ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	};

	Vector3.prototype.subVectors = function subVectors ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	};

	Vector3.prototype.multiply = function multiply ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	};

	Vector3.prototype.multiplyScalar = function multiplyScalar ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	};

	Vector3.prototype.multiplyVectors = function multiplyVectors ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	};

	Vector3.prototype.applyEuler = function applyEuler ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	};

	Vector3.prototype.applyAxisAngle = function applyAxisAngle ( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	};

	Vector3.prototype.applyMatrix3 = function applyMatrix3 ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	};

	Vector3.prototype.applyNormalMatrix = function applyNormalMatrix ( m ) {

		return this.applyMatrix3( m ).normalize();

	};

	Vector3.prototype.applyMatrix4 = function applyMatrix4 ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	};

	Vector3.prototype.applyQuaternion = function applyQuaternion ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	};

	Vector3.prototype.project = function project ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	};

	Vector3.prototype.unproject = function unproject ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	};

	Vector3.prototype.transformDirection = function transformDirection ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	};

	Vector3.prototype.divide = function divide ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	};

	Vector3.prototype.divideScalar = function divideScalar ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	};

	Vector3.prototype.min = function min ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	};

	Vector3.prototype.max = function max ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	};

	Vector3.prototype.clamp = function clamp ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	};

	Vector3.prototype.clampScalar = function clampScalar ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	};

	Vector3.prototype.clampLength = function clampLength ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	};

	Vector3.prototype.floor = function floor () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	};

	Vector3.prototype.ceil = function ceil () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	};

	Vector3.prototype.round = function round () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	};

	Vector3.prototype.roundToZero = function roundToZero () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	};

	Vector3.prototype.negate = function negate () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	};

	Vector3.prototype.dot = function dot ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	};

	// TODO lengthSquared?

	Vector3.prototype.lengthSq = function lengthSq () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	};

	Vector3.prototype.length = function length () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	};

	Vector3.prototype.manhattanLength = function manhattanLength () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	};

	Vector3.prototype.normalize = function normalize () {

		return this.divideScalar( this.length() || 1 );

	};

	Vector3.prototype.setLength = function setLength ( length ) {

		return this.normalize().multiplyScalar( length );

	};

	Vector3.prototype.lerp = function lerp ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	};

	Vector3.prototype.lerpVectors = function lerpVectors ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	};

	Vector3.prototype.cross = function cross ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	};

	Vector3.prototype.crossVectors = function crossVectors ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	};

	Vector3.prototype.projectOnVector = function projectOnVector ( v ) {

		var denominator = v.lengthSq();

		if ( denominator === 0 ) { return this.set( 0, 0, 0 ); }

		var scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	};

	Vector3.prototype.projectOnPlane = function projectOnPlane ( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	};

	Vector3.prototype.reflect = function reflect ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	};

	Vector3.prototype.angleTo = function angleTo ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) { return Math.PI / 2; }

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	};

	Vector3.prototype.distanceTo = function distanceTo ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	};

	Vector3.prototype.distanceToSquared = function distanceToSquared ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	};

	Vector3.prototype.manhattanDistanceTo = function manhattanDistanceTo ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	};

	Vector3.prototype.setFromSpherical = function setFromSpherical ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	};

	Vector3.prototype.setFromSphericalCoords = function setFromSphericalCoords ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	};

	Vector3.prototype.setFromCylindrical = function setFromCylindrical ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	};

	Vector3.prototype.setFromCylindricalCoords = function setFromCylindricalCoords ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	};

	Vector3.prototype.setFromMatrixPosition = function setFromMatrixPosition ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	};

	Vector3.prototype.setFromMatrixScale = function setFromMatrixScale ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	};

	Vector3.prototype.setFromMatrixColumn = function setFromMatrixColumn ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	};

	Vector3.prototype.setFromMatrix3Column = function setFromMatrix3Column ( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	};

	Vector3.prototype.equals = function equals ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	};

	Vector3.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	};

	Vector3.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	};

	Vector3.prototype.fromBufferAttribute = function fromBufferAttribute ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	};

	Vector3.prototype.random = function random () {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	};

	Vector3.prototype.isVector3 = true;

	var _vector$c = /*@__PURE__*/ new Vector3();
	var _quaternion$4 = /*@__PURE__*/ new Quaternion();

	var Box3 = function Box3( min, max ) {
		if ( min === void 0 ) min = new Vector3( + Infinity, + Infinity, + Infinity );
		if ( max === void 0 ) max = new Vector3( - Infinity, - Infinity, - Infinity );


		this.min = min;
		this.max = max;

	};

	Box3.prototype.set = function set ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	};

	Box3.prototype.setFromArray = function setFromArray ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) { minX = x; }
			if ( y < minY ) { minY = y; }
			if ( z < minZ ) { minZ = z; }

			if ( x > maxX ) { maxX = x; }
			if ( y > maxY ) { maxY = y; }
			if ( z > maxZ ) { maxZ = z; }

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	};

	Box3.prototype.setFromBufferAttribute = function setFromBufferAttribute ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) { minX = x; }
			if ( y < minY ) { minY = y; }
			if ( z < minZ ) { minZ = z; }

			if ( x > maxX ) { maxX = x; }
			if ( y > maxY ) { maxY = y; }
			if ( z > maxZ ) { maxZ = z; }

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	};

	Box3.prototype.setFromPoints = function setFromPoints ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	};

	Box3.prototype.setFromCenterAndSize = function setFromCenterAndSize ( center, size ) {

		var halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	};

	Box3.prototype.setFromObject = function setFromObject ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	};

	Box3.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	Box3.prototype.copy = function copy ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	};

	Box3.prototype.makeEmpty = function makeEmpty () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	};

	Box3.prototype.isEmpty = function isEmpty () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	};

	Box3.prototype.getCenter = function getCenter ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	};

	Box3.prototype.getSize = function getSize ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	};

	Box3.prototype.expandByPoint = function expandByPoint ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	};

	Box3.prototype.expandByVector = function expandByVector ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	};

	Box3.prototype.expandByScalar = function expandByScalar ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	};

	Box3.prototype.expandByObject = function expandByObject ( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		var geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box$3.copy( geometry.boundingBox );
			_box$3.applyMatrix4( object.matrixWorld );

			this.union( _box$3 );

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	};

	Box3.prototype.containsPoint = function containsPoint ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	};

	Box3.prototype.containsBox = function containsBox ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	};

	Box3.prototype.getParameter = function getParameter ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	};

	Box3.prototype.intersectsBox = function intersectsBox ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	};

	Box3.prototype.intersectsSphere = function intersectsSphere ( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	};

	Box3.prototype.intersectsPlane = function intersectsPlane ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	};

	Box3.prototype.intersectsTriangle = function intersectsTriangle ( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		var axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	};

	Box3.prototype.clampPoint = function clampPoint ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	};

	Box3.prototype.distanceToPoint = function distanceToPoint ( point ) {

		var clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	};

	Box3.prototype.getBoundingSphere = function getBoundingSphere ( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	};

	Box3.prototype.intersect = function intersect ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) { this.makeEmpty(); }

		return this;

	};

	Box3.prototype.union = function union ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	};

	Box3.prototype.applyMatrix4 = function applyMatrix4 ( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) { return this; }

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	};

	Box3.prototype.translate = function translate ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	};

	Box3.prototype.equals = function equals ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	};

	Box3.prototype.isBox3 = true;

	var _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	var _vector$b = /*@__PURE__*/ new Vector3();

	var _box$3 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	var _v0$2 = /*@__PURE__*/ new Vector3();
	var _v1$7 = /*@__PURE__*/ new Vector3();
	var _v2$3 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	var _f0 = /*@__PURE__*/ new Vector3();
	var _f1 = /*@__PURE__*/ new Vector3();
	var _f2 = /*@__PURE__*/ new Vector3();

	var _center = /*@__PURE__*/ new Vector3();
	var _extents = /*@__PURE__*/ new Vector3();
	var _triangleNormal = /*@__PURE__*/ new Vector3();
	var _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( var i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the seperating axis
			var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the seperating axis
			var p0 = v0.dot( _testAxis );
			var p1 = v1.dot( _testAxis );
			var p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;

			}

		}

		return true;

	}

	var _box$2 = /*@__PURE__*/ new Box3();
	var _v1$6 = /*@__PURE__*/ new Vector3();
	var _toFarthestPoint = /*@__PURE__*/ new Vector3();
	var _toPoint = /*@__PURE__*/ new Vector3();

	var Sphere = function Sphere( center, radius ) {
		if ( center === void 0 ) center = new Vector3();
		if ( radius === void 0 ) radius = - 1;


		this.center = center;
		this.radius = radius;

	};

	Sphere.prototype.set = function set ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	};

	Sphere.prototype.setFromPoints = function setFromPoints ( points, optionalCenter ) {

		var center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		var maxRadiusSq = 0;

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	};

	Sphere.prototype.copy = function copy ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	};

	Sphere.prototype.isEmpty = function isEmpty () {

		return ( this.radius < 0 );

	};

	Sphere.prototype.makeEmpty = function makeEmpty () {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	};

	Sphere.prototype.containsPoint = function containsPoint ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	};

	Sphere.prototype.distanceToPoint = function distanceToPoint ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	};

	Sphere.prototype.intersectsSphere = function intersectsSphere ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	};

	Sphere.prototype.intersectsBox = function intersectsBox ( box ) {

		return box.intersectsSphere( this );

	};

	Sphere.prototype.intersectsPlane = function intersectsPlane ( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	};

	Sphere.prototype.clampPoint = function clampPoint ( point, target ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	};

	Sphere.prototype.getBoundingBox = function getBoundingBox ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	};

	Sphere.prototype.applyMatrix4 = function applyMatrix4 ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	};

	Sphere.prototype.translate = function translate ( offset ) {

		this.center.add( offset );

		return this;

	};

	Sphere.prototype.expandByPoint = function expandByPoint ( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		var lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			var length = Math.sqrt( lengthSq );
			var missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	};

	Sphere.prototype.union = function union ( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	};

	Sphere.prototype.equals = function equals ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	};

	Sphere.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	var _vector$a = /*@__PURE__*/ new Vector3();
	var _segCenter = /*@__PURE__*/ new Vector3();
	var _segDir = /*@__PURE__*/ new Vector3();
	var _diff = /*@__PURE__*/ new Vector3();

	var _edge1 = /*@__PURE__*/ new Vector3();
	var _edge2 = /*@__PURE__*/ new Vector3();
	var _normal$1 = /*@__PURE__*/ new Vector3();

	var Ray = function Ray( origin, direction ) {
		if ( origin === void 0 ) origin = new Vector3();
		if ( direction === void 0 ) direction = new Vector3( 0, 0, - 1 );


		this.origin = origin;
		this.direction = direction;

	};

	Ray.prototype.set = function set ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	};

	Ray.prototype.copy = function copy ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	};

	Ray.prototype.at = function at ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	};

	Ray.prototype.lookAt = function lookAt ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	};

	Ray.prototype.recast = function recast ( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	};

	Ray.prototype.closestPointToPoint = function closestPointToPoint ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		var directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	};

	Ray.prototype.distanceToPoint = function distanceToPoint ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	};

	Ray.prototype.distanceSqToPoint = function distanceSqToPoint ( point ) {

		var directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	};

	Ray.prototype.distanceSqToSegment = function distanceSqToSegment ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var a01 = - this.direction.dot( _segDir );
		var b0 = _diff.dot( this.direction );
		var b1 = - _diff.dot( _segDir );
		var c = _diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	};

	Ray.prototype.intersectSphere = function intersectSphere ( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		var tca = _vector$a.dot( this.direction );
		var d2 = _vector$a.dot( _vector$a ) - tca * tca;
		var radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) { return null; }

		var thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		var t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		var t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) { return null; }

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) { return this.at( t1, target ); }

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	};

	Ray.prototype.intersectsSphere = function intersectsSphere ( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	};

	Ray.prototype.distanceToPlane = function distanceToPlane ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	};

	Ray.prototype.intersectPlane = function intersectPlane ( plane, target ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	};

	Ray.prototype.intersectsPlane = function intersectsPlane ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	};

	Ray.prototype.intersectBox = function intersectBox ( box, target ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

		if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

		if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

		if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) { return null; }

		return this.at( tmin >= 0 ? tmin : tmax, target );

	};

	Ray.prototype.intersectsBox = function intersectsBox ( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	};

	Ray.prototype.intersectTriangle = function intersectTriangle ( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		var DdN = this.direction.dot( _normal$1 );
		var sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) { return null; }
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		var QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	};

	Ray.prototype.applyMatrix4 = function applyMatrix4 ( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	};

	Ray.prototype.equals = function equals ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	};

	Ray.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	var Matrix4 = function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	Matrix4.prototype.set = function set ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	};

	Matrix4.prototype.identity = function identity () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.clone = function clone () {

		return new Matrix4().fromArray( this.elements );

	};

	Matrix4.prototype.copy = function copy ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	};

	Matrix4.prototype.copyPosition = function copyPosition ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	};

	Matrix4.prototype.setFromMatrix3 = function setFromMatrix3 ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.extractBasis = function extractBasis ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	};

	Matrix4.prototype.makeBasis = function makeBasis ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	};

	Matrix4.prototype.extractRotation = function extractRotation ( m ) {

		// this method does not support reflection matrices

		var te = this.elements;
		var me = m.elements;

		var scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		var scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		var scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	};

	Matrix4.prototype.makeRotationFromEuler = function makeRotationFromEuler ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce$1 = c * e, cf$1 = c * f, de$1 = d * e, df$1 = d * f;

			te[ 0 ] = ce$1 - df$1 * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de$1 + cf$1 * b;

			te[ 1 ] = cf$1 + de$1 * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df$1 - ce$1 * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae$1 = a * e, af$1 = a * f, be$1 = b * e, bf$1 = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be$1 * d - af$1;
			te[ 8 ] = ae$1 * d + bf$1;

			te[ 1 ] = c * f;
			te[ 5 ] = bf$1 * d + ae$1;
			te[ 9 ] = af$1 * d - be$1;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac$1 = a * c, ad$1 = a * d, bc$1 = b * c, bd$1 = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac$1 * f + bd$1;
			te[ 5 ] = a * e;
			te[ 9 ] = ad$1 * f - bc$1;

			te[ 2 ] = bc$1 * f - ad$1;
			te[ 6 ] = b * e;
			te[ 10 ] = bd$1 * f + ac$1;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	};

	Matrix4.prototype.makeRotationFromQuaternion = function makeRotationFromQuaternion ( q ) {

		return this.compose( _zero, q, _one );

	};

	Matrix4.prototype.lookAt = function lookAt ( eye, target, up ) {

		var te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	};

	Matrix4.prototype.multiply = function multiply ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	};

	Matrix4.prototype.premultiply = function premultiply ( m ) {

		return this.multiplyMatrices( m, this );

	};

	Matrix4.prototype.multiplyMatrices = function multiplyMatrices ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	};

	Matrix4.prototype.multiplyScalar = function multiplyScalar ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	};

	Matrix4.prototype.determinant = function determinant () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
			)

		);

	};

	Matrix4.prototype.transpose = function transpose () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	};

	Matrix4.prototype.setPosition = function setPosition ( x, y, z ) {

		var te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	};

	Matrix4.prototype.invert = function invert () {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) { return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ); }

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	};

	Matrix4.prototype.scale = function scale ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	};

	Matrix4.prototype.getMaxScaleOnAxis = function getMaxScaleOnAxis () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	};

	Matrix4.prototype.makeTranslation = function makeTranslation ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeRotationX = function makeRotationX ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeRotationY = function makeRotationY ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
			- s, 0, c, 0,
				 0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeRotationZ = function makeRotationZ ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeRotationAxis = function makeRotationAxis ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeScale = function makeScale ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.makeShear = function makeShear ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	};

	Matrix4.prototype.compose = function compose ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	};

	Matrix4.prototype.decompose = function decompose ( position, quaternion, scale ) {

		var te = this.elements;

		var sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		var sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		var sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) { sx = - sx; }

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	};

	Matrix4.prototype.makePerspective = function makePerspective ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;te[ 4 ] = 0;te[ 8 ] = a;te[ 12 ] = 0;
		te[ 1 ] = 0;te[ 5 ] = y;te[ 9 ] = b;te[ 13 ] = 0;
		te[ 2 ] = 0;te[ 6 ] = 0;te[ 10 ] = c;te[ 14 ] = d;
		te[ 3 ] = 0;te[ 7 ] = 0;te[ 11 ] = - 1;te[ 15 ] = 0;

		return this;

	};

	Matrix4.prototype.makeOrthographic = function makeOrthographic ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;te[ 4 ] = 0;te[ 8 ] = 0;te[ 12 ] = - x;
		te[ 1 ] = 0;te[ 5 ] = 2 * h;te[ 9 ] = 0;te[ 13 ] = - y;
		te[ 2 ] = 0;te[ 6 ] = 0;te[ 10 ] = - 2 * p;te[ 14 ] = - z;
		te[ 3 ] = 0;te[ 7 ] = 0;te[ 11 ] = 0;te[ 15 ] = 1;

		return this;

	};

	Matrix4.prototype.equals = function equals ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) { return false; }

		}

		return true;

	};

	Matrix4.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	};

	Matrix4.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	};

	Matrix4.prototype.isMatrix4 = true;

	var _v1$5 = /*@__PURE__*/ new Vector3();
	var _m1$2 = /*@__PURE__*/ new Matrix4();
	var _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	var _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	var _x = /*@__PURE__*/ new Vector3();
	var _y = /*@__PURE__*/ new Vector3();
	var _z = /*@__PURE__*/ new Vector3();

	var _matrix$1 = /*@__PURE__*/ new Matrix4();
	var _quaternion$3 = /*@__PURE__*/ new Quaternion();

	var Euler = function Euler( x, y, z, order ) {
		if ( x === void 0 ) x = 0;
		if ( y === void 0 ) y = 0;
		if ( z === void 0 ) z = 0;
		if ( order === void 0 ) order = Euler.DefaultOrder;


		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	};

	var prototypeAccessors$4 = { x: { configurable: true },y: { configurable: true },z: { configurable: true },order: { configurable: true } };

	prototypeAccessors$4.x.get = function () {

		return this._x;

	};

	prototypeAccessors$4.x.set = function ( value ) {

		this._x = value;
		this._onChangeCallback();

	};

	prototypeAccessors$4.y.get = function () {

		return this._y;

	};

	prototypeAccessors$4.y.set = function ( value ) {

		this._y = value;
		this._onChangeCallback();

	};

	prototypeAccessors$4.z.get = function () {

		return this._z;

	};

	prototypeAccessors$4.z.set = function ( value ) {

		this._z = value;
		this._onChangeCallback();

	};

	prototypeAccessors$4.order.get = function () {

		return this._order;

	};

	prototypeAccessors$4.order.set = function ( value ) {

		this._order = value;
		this._onChangeCallback();

	};

	Euler.prototype.set = function set ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	};

	Euler.prototype.clone = function clone () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	};

	Euler.prototype.copy = function copy ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	};

	Euler.prototype.setFromRotationMatrix = function setFromRotationMatrix ( m, order, update ) {

		var clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) { this._onChangeCallback(); }

		return this;

	};

	Euler.prototype.setFromQuaternion = function setFromQuaternion ( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	};

	Euler.prototype.setFromVector3 = function setFromVector3 ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	};

	Euler.prototype.reorder = function reorder ( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	};

	Euler.prototype.equals = function equals ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	};

	Euler.prototype.fromArray = function fromArray ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

		this._onChangeCallback();

		return this;

	};

	Euler.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	};

	Euler.prototype.toVector3 = function toVector3 ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	};

	Euler.prototype._onChange = function _onChange ( callback ) {

		this._onChangeCallback = callback;

		return this;

	};

	Euler.prototype._onChangeCallback = function _onChangeCallback () {};

	Object.defineProperties( Euler.prototype, prototypeAccessors$4 );

	Euler.prototype.isEuler = true;

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	var Layers = function Layers() {

		this.mask = 1 | 0;

	};

	Layers.prototype.set = function set ( channel ) {

		this.mask = 1 << channel | 0;

	};

	Layers.prototype.enable = function enable ( channel ) {

		this.mask |= 1 << channel | 0;

	};

	Layers.prototype.enableAll = function enableAll () {

		this.mask = 0xffffffff | 0;

	};

	Layers.prototype.toggle = function toggle ( channel ) {

		this.mask ^= 1 << channel | 0;

	};

	Layers.prototype.disable = function disable ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	};

	Layers.prototype.disableAll = function disableAll () {

		this.mask = 0;

	};

	Layers.prototype.test = function test ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	};

	var _object3DId = 0;

	var _v1$4 = new Vector3();
	var _q1 = new Quaternion();
	var _m1$1 = new Matrix4();
	var _target = new Vector3();

	var _position$3 = new Vector3();
	var _scale$2 = new Vector3();
	var _quaternion$2 = new Quaternion();

	var _xAxis = new Vector3( 1, 0, 0 );
	var _yAxis = new Vector3( 0, 1, 0 );
	var _zAxis = new Vector3( 0, 0, 1 );

	var _addedEvent = { type: 'added' };
	var _removedEvent = { type: 'removed' };

	function Object3D() {

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix4: function ( matrix ) {

			if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function ( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		},

		rotateOnWorldAxis: function ( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		},

		rotateX: function ( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		},

		rotateY: function ( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		},

		rotateZ: function ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		},

		translateOnAxis: function ( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$4.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$4.multiplyScalar( distance ) );

			return this;

		},

		translateX: function ( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		},

		translateY: function ( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		},

		translateZ: function ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		},

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function ( vector ) {

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		},

		lookAt: function ( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			var parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position$3.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position$3, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position$3, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		},

		add: function ( object ) {
			var arguments$1 = arguments;


			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments$1[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		},

		remove: function ( object ) {
			var arguments$1 = arguments;


			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments$1[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		},

		clear: function () {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		},

		attach: function ( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) { return this; }

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
				target = new Quaternion();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, target, _scale$2 );

			return target;

		},

		getWorldScale: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, _quaternion$2, target );

			return target;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			var e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) { return; }

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			var parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) { object.name = this.name; }
			if ( this.castShadow === true ) { object.castShadow = true; }
			if ( this.receiveShadow === true ) { object.receiveShadow = true; }
			if ( this.visible === false ) { object.visible = false; }
			if ( this.frustumCulled === false ) { object.frustumCulled = false; }
			if ( this.renderOrder !== 0 ) { object.renderOrder = this.renderOrder; }
			if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) { object.matrixAutoUpdate = false; }

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) { object.instanceColor = this.instanceColor.toJSON(); }

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i$1 = 0, l$1 = this.material.length; i$1 < l$1; i$1 ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i$1 ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i$2 = 0; i$2 < this.children.length; i$2 ++ ) {

					object.children.push( this.children[ i$2 ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( var i$3 = 0; i$3 < this.animations.length; i$3 ++ ) {

					var animation = this.animations[ i$3 ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes$1 = extractFromCache( meta.shapes );
				var skeletons = extractFromCache( meta.skeletons );
				var animations = extractFromCache( meta.animations );

				if ( geometries.length > 0 ) { output.geometries = geometries; }
				if ( materials.length > 0 ) { output.materials = materials; }
				if ( textures.length > 0 ) { output.textures = textures; }
				if ( images.length > 0 ) { output.images = images; }
				if ( shapes$1.length > 0 ) { output.shapes = shapes$1; }
				if ( skeletons.length > 0 ) { output.skeletons = skeletons; }
				if ( animations.length > 0 ) { output.animations = animations; }

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {
			if ( recursive === void 0 ) recursive = true;


			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	var _vector1 = /*@__PURE__*/ new Vector3();
	var _vector2$1 = /*@__PURE__*/ new Vector3();
	var _normalMatrix = /*@__PURE__*/ new Matrix3();

	var Plane = function Plane( normal, constant ) {
		if ( normal === void 0 ) normal = new Vector3( 1, 0, 0 );
		if ( constant === void 0 ) constant = 0;


		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	};

	Plane.prototype.set = function set ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	};

	Plane.prototype.setComponents = function setComponents ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	};

	Plane.prototype.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	};

	Plane.prototype.setFromCoplanarPoints = function setFromCoplanarPoints ( a, b, c ) {

		var normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	};

	Plane.prototype.copy = function copy ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	};

	Plane.prototype.normalize = function normalize () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	};

	Plane.prototype.negate = function negate () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	};

	Plane.prototype.distanceToPoint = function distanceToPoint ( point ) {

		return this.normal.dot( point ) + this.constant;

	};

	Plane.prototype.distanceToSphere = function distanceToSphere ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	};

	Plane.prototype.projectPoint = function projectPoint ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	};

	Plane.prototype.intersectLine = function intersectLine ( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3();

		}

		var direction = line.delta( _vector1 );

		var denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	};

	Plane.prototype.intersectsLine = function intersectsLine ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	};

	Plane.prototype.intersectsBox = function intersectsBox ( box ) {

		return box.intersectsPlane( this );

	};

	Plane.prototype.intersectsSphere = function intersectsSphere ( sphere ) {

		return sphere.intersectsPlane( this );

	};

	Plane.prototype.coplanarPoint = function coplanarPoint ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	};

	Plane.prototype.applyMatrix4 = function applyMatrix4 ( matrix, optionalNormalMatrix ) {

		var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	};

	Plane.prototype.translate = function translate ( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	};

	Plane.prototype.equals = function equals ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	};

	Plane.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	Plane.prototype.isPlane = true;

	var _v0$1 = /*@__PURE__*/ new Vector3();
	var _v1$3 = /*@__PURE__*/ new Vector3();
	var _v2$2 = /*@__PURE__*/ new Vector3();
	var _v3$1 = /*@__PURE__*/ new Vector3();

	var _vab = /*@__PURE__*/ new Vector3();
	var _vac = /*@__PURE__*/ new Vector3();
	var _vbc = /*@__PURE__*/ new Vector3();
	var _vap = /*@__PURE__*/ new Vector3();
	var _vbp = /*@__PURE__*/ new Vector3();
	var _vcp = /*@__PURE__*/ new Vector3();

	var Triangle = function Triangle( a, b, c ) {
		if ( a === void 0 ) a = new Vector3();
		if ( b === void 0 ) b = new Vector3();
		if ( c === void 0 ) c = new Vector3();


		this.a = a;
		this.b = b;
		this.c = c;

	};

	Triangle.getNormal = function getNormal ( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		var targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	};

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	Triangle.getBarycoord = function getBarycoord ( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		var dot00 = _v0$1.dot( _v0$1 );
		var dot01 = _v0$1.dot( _v1$3 );
		var dot02 = _v0$1.dot( _v2$2 );
		var dot11 = _v1$3.dot( _v1$3 );
		var dot12 = _v1$3.dot( _v2$2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	};

	Triangle.containsPoint = function containsPoint ( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	};

	Triangle.getUV = function getUV ( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	};

	Triangle.isFrontFacing = function isFrontFacing ( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	};

	Triangle.prototype.set = function set ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	};

	Triangle.prototype.setFromPointsAndIndices = function setFromPointsAndIndices ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	};

	Triangle.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	Triangle.prototype.copy = function copy ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	};

	Triangle.prototype.getArea = function getArea () {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	};

	Triangle.prototype.getMidpoint = function getMidpoint ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	};

	Triangle.prototype.getNormal = function getNormal ( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	};

	Triangle.prototype.getPlane = function getPlane ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	};

	Triangle.prototype.getBarycoord = function getBarycoord ( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	};

	Triangle.prototype.getUV = function getUV ( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	};

	Triangle.prototype.containsPoint = function containsPoint ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	};

	Triangle.prototype.isFrontFacing = function isFrontFacing ( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	};

	Triangle.prototype.intersectsBox = function intersectsBox ( box ) {

		return box.intersectsTriangle( this );

	};

	Triangle.prototype.closestPointToPoint = function closestPointToPoint ( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		var a = this.a, b = this.b, c = this.c;
		var v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		var d1 = _vab.dot( _vap );
		var d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		var d3 = _vab.dot( _vbp );
		var d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		var vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		var d5 = _vab.dot( _vcp );
		var d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		var vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		var va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		var denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	};

	Triangle.prototype.equals = function equals ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	};

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

		customProgramCacheKey: function () {

			return this.onBeforeCompile.toString();

		},

		setValues: function ( values ) {

			if ( values === undefined ) { return; }

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) { data.name = this.name; }

			if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

			if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
			if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

			if ( this.sheen && this.sheen.isColor ) { data.sheen = this.sheen.getHex(); }
			if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) { data.emissiveIntensity = this.emissiveIntensity; }

			if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
			if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
			if ( this.clearcoat !== undefined ) { data.clearcoat = this.clearcoat; }
			if ( this.clearcoatRoughness !== undefined ) { data.clearcoatRoughness = this.clearcoatRoughness; }

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
			if ( this.matcap && this.matcap.isTexture ) { data.matcap = this.matcap.toJSON( meta ).uuid; }
			if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
			if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

			if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
			if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
				data.refractionRatio = this.refractionRatio;

				if ( this.combine !== undefined ) { data.combine = this.combine; }
				if ( this.envMapIntensity !== undefined ) { data.envMapIntensity = this.envMapIntensity; }

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) { data.size = this.size; }
			if ( this.shadowSide !== null ) { data.shadowSide = this.shadowSide; }
			if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

			if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
			if ( this.side !== FrontSide ) { data.side = this.side; }
			if ( this.vertexColors ) { data.vertexColors = true; }

			if ( this.opacity < 1 ) { data.opacity = this.opacity; }
			if ( this.transparent === true ) { data.transparent = this.transparent; }

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation && this.rotation !== 0 ) { data.rotation = this.rotation; }

			if ( this.polygonOffset === true ) { data.polygonOffset = true; }
			if ( this.polygonOffsetFactor !== 0 ) { data.polygonOffsetFactor = this.polygonOffsetFactor; }
			if ( this.polygonOffsetUnits !== 0 ) { data.polygonOffsetUnits = this.polygonOffsetUnits; }

			if ( this.linewidth && this.linewidth !== 1 ) { data.linewidth = this.linewidth; }
			if ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }
			if ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }
			if ( this.scale !== undefined ) { data.scale = this.scale; }

			if ( this.dithering === true ) { data.dithering = true; }

			if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
			if ( this.alphaToCoverage === true ) { data.alphaToCoverage = this.alphaToCoverage; }
			if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

			if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
			if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
			if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
			if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

			if ( this.morphTargets === true ) { data.morphTargets = true; }
			if ( this.morphNormals === true ) { data.morphNormals = true; }
			if ( this.skinning === true ) { data.skinning = true; }

			if ( this.flatShading === true ) { data.flatShading = this.flatShading; }

			if ( this.visible === false ) { data.visible = false; }

			if ( this.toneMapped === false ) { data.toneMapped = false; }

			if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) { data.textures = textures; }
				if ( images.length > 0 ) { data.images = images; }

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			var srcPlanes = source.clippingPlanes;
			var dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	Object.defineProperty( Material.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) { this.version ++; }

		}

	} );

	var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	var _hslA = { h: 0, s: 0, l: 0 };
	var _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) { t += 1; }
		if ( t > 1 ) { t -= 1; }
		if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
		if ( t < 1 / 2 ) { return q; }
		if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
		return p;

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	var Color = function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	};

	Color.prototype.set = function set ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	};

	Color.prototype.setScalar = function setScalar ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	};

	Color.prototype.setHex = function setHex ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	};

	Color.prototype.setRGB = function setRGB ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	};

	Color.prototype.setHSL = function setHSL ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	};

	Color.prototype.setStyle = function setStyle ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) { return; }

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	};

	Color.prototype.setColorName = function setColorName ( style ) {

		// color keywords
		var hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	};

	Color.prototype.clone = function clone () {

		return new this.constructor( this.r, this.g, this.b );

	};

	Color.prototype.copy = function copy ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	};

	Color.prototype.copyGammaToLinear = function copyGammaToLinear ( color, gammaFactor ) {
			if ( gammaFactor === void 0 ) gammaFactor = 2.0;


		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	};

	Color.prototype.copyLinearToGamma = function copyLinearToGamma ( color, gammaFactor ) {
			if ( gammaFactor === void 0 ) gammaFactor = 2.0;


		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	};

	Color.prototype.convertGammaToLinear = function convertGammaToLinear ( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	};

	Color.prototype.convertLinearToGamma = function convertLinearToGamma ( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	};

	Color.prototype.copySRGBToLinear = function copySRGBToLinear ( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	};

	Color.prototype.copyLinearToSRGB = function copyLinearToSRGB ( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	};

	Color.prototype.convertSRGBToLinear = function convertSRGBToLinear () {

		this.copySRGBToLinear( this );

		return this;

	};

	Color.prototype.convertLinearToSRGB = function convertLinearToSRGB () {

		this.copyLinearToSRGB( this );

		return this;

	};

	Color.prototype.getHex = function getHex () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	};

	Color.prototype.getHexString = function getHexString () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	};

	Color.prototype.getHSL = function getHSL ( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	};

	Color.prototype.getStyle = function getStyle () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	};

	Color.prototype.offsetHSL = function offsetHSL ( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	};

	Color.prototype.add = function add ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	};

	Color.prototype.addColors = function addColors ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	};

	Color.prototype.addScalar = function addScalar ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	};

	Color.prototype.sub = function sub ( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	};

	Color.prototype.multiply = function multiply ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	};

	Color.prototype.multiplyScalar = function multiplyScalar ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	};

	Color.prototype.lerp = function lerp ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	};

	Color.prototype.lerpColors = function lerpColors ( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	};

	Color.prototype.lerpHSL = function lerpHSL ( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	};

	Color.prototype.equals = function equals ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	};

	Color.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	};

	Color.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	};

	Color.prototype.fromBufferAttribute = function fromBufferAttribute ( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	};

	Color.prototype.toJSON = function toJSON () {

		return this.getHex();

	};

	Color.NAMES = _colorKeywords;

	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	var MeshBasicMaterial = /*@__PURE__*/(function (Material) {
		function MeshBasicMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshBasicMaterial.__proto__ = Material;
		MeshBasicMaterial.prototype = Object.create( Material && Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

		MeshBasicMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		};

		return MeshBasicMaterial;
	}(Material));

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	var _vector$9 = new Vector3();
	var _vector2 = new Vector2();

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) { this.version ++; }

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array;
			var offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array;
			var offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array;
			var offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array;
			var offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		applyMatrix3: function ( m ) {

			if ( this.itemSize === 2 ) {

				for ( var i = 0, l = this.count; i < l; i ++ ) {

					_vector2.fromBufferAttribute( this, i );
					_vector2.applyMatrix3( m );

					this.setXY( i, _vector2.x, _vector2.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( var i$1 = 0, l$1 = this.count; i$1 < l$1; i$1 ++ ) {

					_vector$9.fromBufferAttribute( this, i$1 );
					_vector$9.applyMatrix3( m );

					this.setXYZ( i$1, _vector$9.x, _vector$9.y, _vector$9.z );

				}

			}

			return this;

		},

		applyMatrix4: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.x = this.getX( i );
				_vector$9.y = this.getY( i );
				_vector$9.z = this.getZ( i );

				_vector$9.applyMatrix4( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		},

		applyNormalMatrix: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.x = this.getX( i );
				_vector$9.y = this.getY( i );
				_vector$9.z = this.getZ( i );

				_vector$9.applyNormalMatrix( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		},

		transformDirection: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.x = this.getX( i );
				_vector$9.y = this.getY( i );
				_vector$9.z = this.getZ( i );

				_vector$9.transformDirection( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		},

		set: function ( value, offset ) {
			if ( offset === void 0 ) offset = 0;


			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		},

		toJSON: function () {

			var data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) { data.name = this.name; }
			if ( this.usage !== StaticDrawUsage ) { data.usage = this.usage; }
			if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) { data.updateRange = this.updateRange; }

			return data;

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

	function Float16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	function arrayMax( array ) {

		if ( array.length === 0 ) { return - Infinity; }

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) { max = array[ i ]; }

		}

		return max;

	}

	var _id = 0;

	var _m1 = new Matrix4();
	var _obj = new Object3D();
	var _offset = new Vector3();
	var _box$1 = new Box3();
	var _boxMorphTargets = new Box3();
	var _vector$8 = new Vector3();

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: _id ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		setAttribute: function ( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		},

		deleteAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		hasAttribute: function ( name ) {

			return this.attributes[ name ] !== undefined;

		},

		addGroup: function ( start, count, materialIndex ) {
			if ( materialIndex === void 0 ) materialIndex = 0;


			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix4: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			var tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function ( angle ) {

			// rotate geometry around world x-axis

			_m1.makeRotationX( angle );

			this.applyMatrix4( _m1 );

			return this;

		},

		rotateY: function ( angle ) {

			// rotate geometry around world y-axis

			_m1.makeRotationY( angle );

			this.applyMatrix4( _m1 );

			return this;

		},

		rotateZ: function ( angle ) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ( angle );

			this.applyMatrix4( _m1 );

			return this;

		},

		translate: function ( x, y, z ) {

			// translate geometry

			_m1.makeTranslation( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		},

		scale: function ( x, y, z ) {

			// scale geometry

			_m1.makeScale( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		},

		lookAt: function ( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						var morphAttribute = morphAttributesPosition[ i ];
						_box$1.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$8.addVectors( this.boundingBox.min, _box$1.min );
							this.boundingBox.expandByPoint( _vector$8 );

							_vector$8.addVectors( this.boundingBox.max, _box$1.max );
							this.boundingBox.expandByPoint( _vector$8 );

						} else {

							this.boundingBox.expandByPoint( _box$1.min );
							this.boundingBox.expandByPoint( _box$1.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				var center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						var morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
							_box$1.expandByPoint( _vector$8 );

							_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
							_box$1.expandByPoint( _vector$8 );

						} else {

							_box$1.expandByPoint( _boxMorphTargets.min );
							_box$1.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$1.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i$1 = 0, il$1 = position.count; i$1 < il$1; i$1 ++ ) {

					_vector$8.fromBufferAttribute( position, i$1 );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i$2 = 0, il$2 = morphAttributesPosition.length; i$2 < il$2; i$2 ++ ) {

						var morphAttribute$1 = morphAttributesPosition[ i$2 ];
						var morphTargetsRelative = this.morphTargetsRelative;

						for ( var j = 0, jl = morphAttribute$1.count; j < jl; j ++ ) {

							_vector$8.fromBufferAttribute( morphAttribute$1, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$8.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		},

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeTangents: function () {

			var index = this.index;
			var attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			var indices = index.array;
			var positions = attributes.position.array;
			var normals = attributes.normal.array;
			var uvs = attributes.uv.array;

			var nVertices = positions.length / 3;

			if ( attributes.tangent === undefined ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			var tangents = attributes.tangent.array;

			var tan1 = [], tan2 = [];

			for ( var i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			var vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				var r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) { return; }

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			var groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( var i$1 = 0, il = groups.length; i$1 < il; ++ i$1 ) {

				var group = groups[ i$1 ];

				var start = group.start;
				var count = group.count;

				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			var tmp = new Vector3(), tmp2 = new Vector3();
			var n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				var t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				var test = tmp2.dot( tan2[ v ] );
				var w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( var i$2 = 0, il$1 = groups.length; i$2 < il$1; ++ i$2 ) {

				var group$1 = groups[ i$2 ];

				var start$1 = group$1.start;
				var count$1 = group$1.count;

				for ( var j$1 = start$1, jl$1 = start$1 + count$1; j$1 < jl$1; j$1 += 3 ) {

					handleVertex( indices[ j$1 + 0 ] );
					handleVertex( indices[ j$1 + 1 ] );
					handleVertex( indices[ j$1 + 2 ] );

				}

			}

		},

		computeVertexNormals: function () {

			var index = this.index;
			var positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				var normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( var i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( var i$1 = 0, il$1 = index.count; i$1 < il$1; i$1 += 3 ) {

						var vA = index.getX( i$1 + 0 );
						var vB = index.getX( i$1 + 1 );
						var vC = index.getX( i$1 + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i$2 = 0, il$2 = positionAttribute.count; i$2 < il$2; i$2 += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i$2 + 0 );
						pB.fromBufferAttribute( positionAttribute, i$2 + 1 );
						pC.fromBufferAttribute( positionAttribute, i$2 + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i$2 + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i$2 + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i$2 + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) { continue; }

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeOffset = attribute2.itemSize * offset;
				var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal;

			for ( var i = 0, il = normals.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( normals, i );

				_vector$8.normalize();

				normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

			}

		},

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				var array = attribute.array;
				var itemSize = attribute.itemSize;
				var normalized = attribute.normalized;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			// attributes

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			var morphAttributes = this.morphAttributes;

			for ( var name$1 in morphAttributes ) {

				var morphArray = [];
				var morphAttribute = morphAttributes[ name$1 ]; // morphAttribute: array of Float32BufferAttributes

				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

					var attribute$1 = morphAttribute[ i ];

					var newAttribute$1 = convertBufferAttribute( attribute$1, indices );

					morphArray.push( newAttribute$1 );

				}

				geometry2.morphAttributes[ name$1 ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			var groups = this.groups;

			for ( var i$1 = 0, l = groups.length; i$1 < l; i$1 ++ ) {

				var group = groups[ i$1 ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) { data.name = this.name; }
			if ( Object.keys( this.userData ).length > 0 ) { data.userData = this.userData; }

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			var attributes = this.attributes;

			for ( var key$1 in attributes ) {

				var attribute = attributes[ key$1 ];

				data.data.attributes[ key$1 ] = attribute.toJSON( data.data );

			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for ( var key$2 in this.morphAttributes ) {

				var attributeArray = this.morphAttributes[ key$2 ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute$1 = attributeArray[ i ];

					array.push( attribute$1.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key$2 ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 const parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 const values = [];

			 for ( const key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			var data = {};

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( var name$1 in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name$1 ]; // morphAttribute: array of Float32BufferAttributes

				for ( var i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name$1 ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			var groups = source.groups;

			for ( var i$1 = 0, l$1 = groups.length; i$1 < l$1; i$1 ++ ) {

				var group = groups[ i$1 ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	var _inverseMatrix$2 = new Matrix4();
	var _ray$2 = new Ray();
	var _sphere$3 = new Sphere();

	var _vA$1 = new Vector3();
	var _vB$1 = new Vector3();
	var _vC$1 = new Vector3();

	var _tempA = new Vector3();
	var _tempB = new Vector3();
	var _tempC = new Vector3();

	var _morphA = new Vector3();
	var _morphB = new Vector3();
	var _morphC = new Vector3();

	var _uvA$1 = new Vector2();
	var _uvB$1 = new Vector2();
	var _uvC$1 = new Vector2();

	var _intersectionPoint = new Vector3();
	var _intersectionPointWorld = new Vector3();

	function Mesh( geometry, material ) {
		if ( geometry === void 0 ) geometry = new BufferGeometry();
		if ( material === void 0 ) material = new MeshBasicMaterial();


		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( var m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							var name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: function ( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) { return; }

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			_sphere$3.copy( geometry.boundingSphere );
			_sphere$3.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) { return; }

			//

			_inverseMatrix$2.copy( matrixWorld ).invert();
			_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) { return; }

			}

			var intersection;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var position = geometry.attributes.position;
				var morphPosition = geometry.morphAttributes.position;
				var morphTargetsRelative = geometry.morphTargetsRelative;
				var uv = geometry.attributes.uv;
				var uv2 = geometry.attributes.uv2;
				var groups = geometry.groups;
				var drawRange = geometry.drawRange;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( var i = 0, il = groups.length; i < il; i ++ ) {

							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];

							var start = Math.max( group.start, drawRange.start );
							var end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( var j = start, jl = end; j < jl; j += 3 ) {

								var a = index.getX( j );
								var b = index.getX( j + 1 );
								var c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						var start$1 = Math.max( 0, drawRange.start );
						var end$1 = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( var i$1 = start$1, il$1 = end$1; i$1 < il$1; i$1 += 3 ) {

							var a$1 = index.getX( i$1 );
							var b$1 = index.getX( i$1 + 1 );
							var c$1 = index.getX( i$1 + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a$1, b$1, c$1 );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i$1 / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( var i$2 = 0, il$2 = groups.length; i$2 < il$2; i$2 ++ ) {

							var group$1 = groups[ i$2 ];
							var groupMaterial$1 = material[ group$1.materialIndex ];

							var start$2 = Math.max( group$1.start, drawRange.start );
							var end$2 = Math.min( ( group$1.start + group$1.count ), ( drawRange.start + drawRange.count ) );

							for ( var j$1 = start$2, jl$1 = end$2; j$1 < jl$1; j$1 += 3 ) {

								var a$2 = j$1;
								var b$2 = j$1 + 1;
								var c$2 = j$1 + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial$1, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a$2, b$2, c$2 );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j$1 / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group$1.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						var start$3 = Math.max( 0, drawRange.start );
						var end$3 = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( var i$3 = start$3, il$3 = end$3; i$3 < il$3; i$3 += 3 ) {

							var a$3 = i$3;
							var b$3 = i$3 + 1;
							var c$3 = i$3 + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a$3, b$3, c$3 );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i$3 / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	} );

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		var intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) { return null; }

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA$1.fromBufferAttribute( position, a );
		_vB$1.fromBufferAttribute( position, b );
		_vC$1.fromBufferAttribute( position, c );

		var morphInfluences = object.morphTargetInfluences;

		if ( material.morphTargets && morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

				var influence = morphInfluences[ i ];
				var morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) { continue; }

				_tempA.fromBufferAttribute( morphAttribute, a );
				_tempB.fromBufferAttribute( morphAttribute, b );
				_tempC.fromBufferAttribute( morphAttribute, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

				}

			}

			_vA$1.add( _morphA );
			_vB$1.add( _morphB );
			_vC$1.add( _morphC );

		}

		if ( object.isSkinnedMesh && material.skinning ) {

			object.boneTransform( a, _vA$1 );
			object.boneTransform( b, _vB$1 );
			object.boneTransform( c, _vC$1 );

		}

		var intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA$1.fromBufferAttribute( uv, a );
				_uvB$1.fromBufferAttribute( uv, b );
				_uvC$1.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

			}

			if ( uv2 ) {

				_uvA$1.fromBufferAttribute( uv2, a );
				_uvB$1.fromBufferAttribute( uv2, b );
				_uvC$1.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

			}

			var face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	var BoxGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
			if ( width === void 0 ) width = 1;
			if ( height === void 0 ) height = 1;
			if ( depth === void 0 ) depth = 1;
			if ( widthSegments === void 0 ) widthSegments = 1;
			if ( heightSegments === void 0 ) heightSegments = 1;
			if ( depthSegments === void 0 ) depthSegments = 1;


			BufferGeometry.call(this);

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var numberOfVertices = 0;
			var groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;

				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var vertexCounter = 0;
				var groupCount = 0;

				var vector = new Vector3();

				// generate vertices, normals and uvs

				for ( var iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segmentHeight - heightHalf;

					for ( var ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( var iy$1 = 0; iy$1 < gridY; iy$1 ++ ) {

					for ( var ix$1 = 0; ix$1 < gridX; ix$1 ++ ) {

						var a = numberOfVertices + ix$1 + gridX1 * iy$1;
						var b = numberOfVertices + ix$1 + gridX1 * ( iy$1 + 1 );
						var c = numberOfVertices + ( ix$1 + 1 ) + gridX1 * ( iy$1 + 1 );
						var d = numberOfVertices + ( ix$1 + 1 ) + gridX1 * iy$1;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		if ( BufferGeometry ) BoxGeometry.__proto__ = BufferGeometry;
		BoxGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;

		return BoxGeometry;
	}(BufferGeometry));

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		var dst = {};

		for ( var u in src ) {

			dst[ u ] = {};

			for ( var p in src[ u ] ) {

				var property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = cloneUniforms( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( var name in this.uniforms ) {

			var uniform = this.uniforms[ name ];
			var value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) { data.defines = this.defines; }

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		var extensions = {};

		for ( var key in this.extensions ) {

			if ( this.extensions[ key ] === true ) { extensions[ key ] = true; }

		}

		if ( Object.keys( extensions ).length > 0 ) { data.extensions = extensions; }

		return data;

	};

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			var e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	function PerspectiveCamera( fov, aspect, near, far ) {
		if ( fov === void 0 ) fov = 50;
		if ( aspect === void 0 ) aspect = 1;
		if ( near === void 0 ) near = 0.1;
		if ( far === void 0 ) far = 2000;


		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return MathUtils.RAD2DEG * 2 * Math.atan(
				Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near;
			var top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
			var height = 2 * top;
			var width = this.aspect * height;
			var left = - 0.5 * width;
			var view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	var fov = 90, aspect = 1;

	var CubeCamera = /*@__PURE__*/(function (Object3D) {
		function CubeCamera( near, far, renderTarget ) {

			Object3D.call(this);

			this.type = 'CubeCamera';

			if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

				console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
				return;

			}

			this.renderTarget = renderTarget;

			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

		}

		if ( Object3D ) CubeCamera.__proto__ = Object3D;
		CubeCamera.prototype = Object.create( Object3D && Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;

		CubeCamera.prototype.update = function update ( renderer, scene ) {

			if ( this.parent === null ) { this.updateMatrixWorld(); }

			var renderTarget = this.renderTarget;

			var ref = this.children;
			var cameraPX = ref[0];
			var cameraNX = ref[1];
			var cameraPY = ref[2];
			var cameraNY = ref[3];
			var cameraPZ = ref[4];
			var cameraNZ = ref[5];

			var currentXrEnabled = renderer.xr.enabled;
			var currentRenderTarget = renderer.getRenderTarget();

			renderer.xr.enabled = false;

			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.xr.enabled = currentXrEnabled;

		};

		return CubeCamera;
	}(Object3D));

	var CubeTexture = /*@__PURE__*/(function (Texture) {
		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;

			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			// Why CubeTexture._needsFlipEnvMap is necessary:
			//
			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
			// when using WebGLCubeRenderTarget.texture as a cube texture.

			this._needsFlipEnvMap = true;

			this.flipY = false;

		}

		if ( Texture ) CubeTexture.__proto__ = Texture;
		CubeTexture.prototype = Object.create( Texture && Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;

		var prototypeAccessors$5 = { images: { configurable: true } };

		prototypeAccessors$5.images.get = function () {

			return this.image;

		};

		prototypeAccessors$5.images.set = function ( value ) {

			this.image = value;

		};

		Object.defineProperties( CubeTexture.prototype, prototypeAccessors$5 );

		return CubeTexture;
	}(Texture));

	CubeTexture.prototype.isCubeTexture = true;

	var WebGLCubeRenderTarget = /*@__PURE__*/(function (WebGLRenderTarget) {
		function WebGLCubeRenderTarget( size, options, dummy ) {

			if ( Number.isInteger( options ) ) {

				console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

				options = dummy;

			}

			WebGLRenderTarget.call( this, size, size, options );

			options = options || {};

			this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.texture._needsFlipEnvMap = false;

		}

		if ( WebGLRenderTarget ) WebGLCubeRenderTarget.__proto__ = WebGLRenderTarget;
		WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget && WebGLRenderTarget.prototype );
		WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

		WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function fromEquirectangularTexture ( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859
			this.texture.encoding = texture.encoding;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			var shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",

				fragmentShader: /* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
			};

			var geometry = new BoxGeometry( 5, 5, 5 );

			var material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			var mesh = new Mesh( geometry, material );

			var currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) { texture.minFilter = LinearFilter; }

			var camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		};

		WebGLCubeRenderTarget.prototype.clear = function clear ( renderer, color, depth, stencil ) {

			var currentRenderTarget = renderer.getRenderTarget();

			for ( var i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		};

		return WebGLCubeRenderTarget;
	}(WebGLRenderTarget));

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	var DataTexture = /*@__PURE__*/(function (Texture) {
		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data || null, width: width || 1, height: height || 1 };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

			this.needsUpdate = true;

		}

		if ( Texture ) DataTexture.__proto__ = Texture;
		DataTexture.prototype = Object.create( Texture && Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;

		return DataTexture;
	}(Texture));

	DataTexture.prototype.isDataTexture = true;

	var _sphere$2 = /*@__PURE__*/ new Sphere();
	var _vector$7 = /*@__PURE__*/ new Vector3();

	var Frustum = function Frustum( p0, p1, p2, p3, p4, p5 ) {
		if ( p0 === void 0 ) p0 = new Plane();
		if ( p1 === void 0 ) p1 = new Plane();
		if ( p2 === void 0 ) p2 = new Plane();
		if ( p3 === void 0 ) p3 = new Plane();
		if ( p4 === void 0 ) p4 = new Plane();
		if ( p5 === void 0 ) p5 = new Plane();


		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	};

	Frustum.prototype.set = function set ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	};

	Frustum.prototype.copy = function copy ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	};

	Frustum.prototype.setFromProjectionMatrix = function setFromProjectionMatrix ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	};

	Frustum.prototype.intersectsObject = function intersectsObject ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	};

	Frustum.prototype.intersectsSprite = function intersectsSprite ( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	};

	Frustum.prototype.intersectsSphere = function intersectsSphere ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	};

	Frustum.prototype.intersectsBox = function intersectsBox ( box ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			var plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	};

	Frustum.prototype.containsPoint = function containsPoint ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	};

	Frustum.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;
		var requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) { return; }
				if ( animationLoop === null ) { return; }

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.usage;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = 5126;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = 5131;

					} else {

						console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = 5123;

				}

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				var cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	var PlaneGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function PlaneGeometry( width, height, widthSegments, heightSegments ) {
			if ( width === void 0 ) width = 1;
			if ( height === void 0 ) height = 1;
			if ( widthSegments === void 0 ) widthSegments = 1;
			if ( heightSegments === void 0 ) heightSegments = 1;


			BufferGeometry.call(this);
			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			var width_half = width / 2;
			var height_half = height / 2;

			var gridX = Math.floor( widthSegments );
			var gridY = Math.floor( heightSegments );

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var segment_width = width / gridX;
			var segment_height = height / gridY;

			//

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			for ( var iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segment_height - height_half;

				for ( var ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( var iy$1 = 0; iy$1 < gridY; iy$1 ++ ) {

				for ( var ix$1 = 0; ix$1 < gridX; ix$1 ++ ) {

					var a = ix$1 + gridX1 * iy$1;
					var b = ix$1 + gridX1 * ( iy$1 + 1 );
					var c = ( ix$1 + 1 ) + gridX1 * ( iy$1 + 1 );
					var d = ( ix$1 + 1 ) + gridX1 * iy$1;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		if ( BufferGeometry ) PlaneGeometry.__proto__ = BufferGeometry;
		PlaneGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;

		return PlaneGeometry;
	}(BufferGeometry));

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

	var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmissionmap_fragment: transmissionmap_fragment,
		transmissionmap_pars_fragment: transmissionmap_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	var ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				} ] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Color( 0x000000 ) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeMesh;
		var boxMesh;

		var currentBackground = null;
		var currentBackgroundVersion = 0;
		var currentTonemapping = null;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				background = cubemaps.get( background );

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			var xr = renderer.xr;
			var session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {
				if ( alpha === void 0 ) alpha = 1;


				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		var maxVertexAttributes = gl.getParameter( 34921 );

		var extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		var vaoAvailable = capabilities.isWebGL2 || extension !== null;

		var bindingStates = {};

		var defaultState = createBindingState( null );
		var currentState = defaultState;

		function setup( object, material, program, geometry, index ) {

			var updateBuffers = false;

			if ( vaoAvailable ) {

				var state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( geometry, index );

				if ( updateBuffers ) { saveCache( geometry, index ); }

			} else {

				var wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( object.isInstancedMesh === true ) {

				updateBuffers = true;

			}

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( 34963, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) { return gl.createVertexArray(); }

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) { return gl.bindVertexArray( vao ); }

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) { return gl.deleteVertexArray( vao ); }

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			var wireframe = ( material.wireframe === true );

			var programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			var stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			var state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			var newAttributes = [];
			var enabledAttributes = [];
			var attributeDivisors = [];

			for ( var i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( geometry, index ) {

			var cachedAttributes = currentState.attributes;
			var geometryAttributes = geometry.attributes;

			var attributesNum = 0;

			for ( var key in geometryAttributes ) {

				var cachedAttribute = cachedAttributes[ key ];
				var geometryAttribute = geometryAttributes[ key ];

				if ( cachedAttribute === undefined ) { return true; }

				if ( cachedAttribute.attribute !== geometryAttribute ) { return true; }

				if ( cachedAttribute.data !== geometryAttribute.data ) { return true; }

				attributesNum ++;

			}

			if ( currentState.attributesNum !== attributesNum ) { return true; }

			if ( currentState.index !== index ) { return true; }

			return false;

		}

		function saveCache( geometry, index ) {

			var cache = {};
			var attributes = geometry.attributes;
			var attributesNum = 0;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var data = {};
				data.attribute = attribute;

				if ( attribute.data ) {

					data.data = attribute.data;

				}

				cache[ key ] = data;

				attributesNum ++;

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			var newAttributes = currentState.newAttributes;

			for ( var i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;
			var attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;

			for ( var i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

			if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) { return; }

			}

			initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) { continue; }

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( 34962, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( 34962, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( name === 'instanceMatrix' ) {

						var attribute$1 = attributes.get( object.instanceMatrix );

						// TODO Attribute may not be available on context restore

						if ( attribute$1 === undefined ) { continue; }

						var buffer$1 = attribute$1.buffer;
						var type$1 = attribute$1.type;

						enableAttributeAndDivisor( programAttribute + 0, 1 );
						enableAttributeAndDivisor( programAttribute + 1, 1 );
						enableAttributeAndDivisor( programAttribute + 2, 1 );
						enableAttributeAndDivisor( programAttribute + 3, 1 );

						gl.bindBuffer( 34962, buffer$1 );

						gl.vertexAttribPointer( programAttribute + 0, 4, type$1, false, 64, 0 );
						gl.vertexAttribPointer( programAttribute + 1, 4, type$1, false, 64, 16 );
						gl.vertexAttribPointer( programAttribute + 2, 4, type$1, false, 64, 32 );
						gl.vertexAttribPointer( programAttribute + 3, 4, type$1, false, 64, 48 );

					} else if ( name === 'instanceColor' ) {

						var attribute$2 = attributes.get( object.instanceColor );

						// TODO Attribute may not be available on context restore

						if ( attribute$2 === undefined ) { continue; }

						var buffer$2 = attribute$2.buffer;
						var type$2 = attribute$2.type;

						enableAttributeAndDivisor( programAttribute, 1 );

						gl.bindBuffer( 34962, buffer$2 );

						gl.vertexAttribPointer( programAttribute, 3, type$2, false, 12, 0 );

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( var geometryId in bindingStates ) {

				var programMap = bindingStates[ geometryId ];

				for ( var programId in programMap ) {

					var stateMap = programMap[ programId ];

					for ( var wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) { return; }

			var programMap = bindingStates[ geometry.id ];

			for ( var programId in programMap ) {

				var stateMap = programMap[ programId ];

				for ( var wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( var geometryId in bindingStates ) {

				var programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) { continue; }

				var stateMap = programMap[ program.id ];

				for ( var wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();

			if ( currentState === defaultState ) { return; }

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatilibity

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) { return; }

			var extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) { return maxAnisotropy; }

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		/* eslint-disable no-undef */
		var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
		/* eslint-enable no-undef */

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( 34930 );
		var maxVertexTextures = gl.getParameter( 35660 );
		var maxTextureSize = gl.getParameter( 3379 );
		var maxCubemapSize = gl.getParameter( 34076 );

		var maxAttributes = gl.getParameter( 34921 );
		var maxVertexUniforms = gl.getParameter( 36347 );
		var maxVaryings = gl.getParameter( 36348 );
		var maxFragmentUniforms = gl.getParameter( 36349 );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		var scope = this;

		var globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		var plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( material, camera, useCache ) {

			var planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			var materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				var dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0;
			var dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	function WebGLCubeMaps( renderer ) {

		var cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				var mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						var cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						var image = texture.image;

						if ( image && image.height > 0 ) {

							var currentRenderTarget = renderer.getRenderTarget();

							var renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							renderer.setRenderTarget( currentRenderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			var cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		var extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );

			},

			get: function ( name ) {

				var extension = getExtension( name );

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		var geometries = {};
		var wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			var geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( var name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) { return geometry; }

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			var geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name$1 in morphAttributes ) {

				var array = morphAttributes[ name$1 ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryPosition = geometry.attributes.position;
			var version = 0;

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;
				version = geometryIndex.version;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array$1 = geometryPosition.array;
				version = geometryPosition.version;

				for ( var i$1 = 0, l$1 = ( array$1.length / 3 ) - 1; i$1 < l$1; i$1 += 3 ) {

					var a$1 = i$1 + 0;
					var b$1 = i$1 + 1;
					var c$1 = i$1 + 2;

					indices.push( a$1, b$1, b$1, c$1, c$1, a$1 );

				}

			}

			var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			var previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) { attributes.remove( previousAttribute ); }

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			var currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				var geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) { return; }

			var extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		var workInfluences = [];

		for ( var i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			var length = objectInfluences === undefined ? 0 : objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( var i$1 = 0; i$1 < length; i$1 ++ ) {

				var influence = influences[ i$1 ];

				influence[ 0 ] = i$1;
				influence[ 1 ] = objectInfluences[ i$1 ];

			}

			influences.sort( absNumericalSort );

			for ( var i$2 = 0; i$2 < 8; i$2 ++ ) {

				if ( i$2 < length && influences[ i$2 ][ 1 ] ) {

					workInfluences[ i$2 ][ 0 ] = influences[ i$2 ][ 0 ];
					workInfluences[ i$2 ][ 1 ] = influences[ i$2 ][ 1 ];

				} else {

					workInfluences[ i$2 ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i$2 ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			var morphInfluencesSum = 0;

			for ( var i$3 = 0; i$3 < 8; i$3 ++ ) {

				var influence$1 = workInfluences[ i$3 ];
				var index = influence$1[ 0 ];
				var value = influence$1[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i$3 ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i$3, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i$3 ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i$3, morphNormals[ index ] );

					}

					morphInfluences[ i$3 ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i$3 ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i$3 );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i$3 ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i$3 );

					}

					morphInfluences[ i$3 ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		var updateMap = new WeakMap();

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				attributes.update( object.instanceMatrix, 34962 );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, 34962 );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			var instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) { attributes.remove( instancedMesh.instanceColor ); }

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	var DataTexture2DArray = /*@__PURE__*/(function (Texture) {
		function DataTexture2DArray( data, width, height, depth ) {
			if ( data === void 0 ) data = null;
			if ( width === void 0 ) width = 1;
			if ( height === void 0 ) height = 1;
			if ( depth === void 0 ) depth = 1;


			Texture.call( this, null );

			this.image = { data: data, width: width, height: height, depth: depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;

		}

		if ( Texture ) DataTexture2DArray.__proto__ = Texture;
		DataTexture2DArray.prototype = Object.create( Texture && Texture.prototype );
		DataTexture2DArray.prototype.constructor = DataTexture2DArray;

		return DataTexture2DArray;
	}(Texture));

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	var DataTexture3D = /*@__PURE__*/(function (Texture) {
		function DataTexture3D( data, width, height, depth ) {
			if ( data === void 0 ) data = null;
			if ( width === void 0 ) width = 1;
			if ( height === void 0 ) height = 1;
			if ( depth === void 0 ) depth = 1;


			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			Texture.call( this, null );

			this.image = { data: data, width: width, height: height, depth: depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;

		}

		if ( Texture ) DataTexture3D.__proto__ = Texture;
		DataTexture3D.prototype = Object.create( Texture && Texture.prototype );
		DataTexture3D.prototype.constructor = DataTexture3D;

		return DataTexture3D;
	}(Texture));

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) { return array; }
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize;
		var r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) { return false; }

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) { return false; }

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) { return; }

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) { return; }

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) { return; }

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) { return; }

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) { return; }

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array)

	function setValueV2i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) { return; }

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array)

	function setValueV2ui( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3ui( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4ui( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		var data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		var data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		var data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		var data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		var data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		var data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / Cube)

	function setValueT1Array( gl, v, textures ) {

		var n = v.length;

		var units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		var n = v.length;

		var units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			var id = match[ 1 ];
			var idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) { id = id | 0; } // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map;
				var next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		var n = gl.getProgramParameter( program, 35718 );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		var u = this.map[ name ];

		if ( u !== undefined ) { u.setValue( gl, value, textures ); }

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) { this.setValue( gl, name, v ); }

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) { r.push( u ); }

		}

		return r;

	};

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	var programIdCount = 0;

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			case LogLuvEncoding:
				return [ 'LogLuv', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		var status = gl.getShaderParameter( shader, 35713 );
		var log = gl.getShaderInfoLog( shader ).trim();

		if ( status && log === '' ) { return ''; }

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		var source = gl.getShaderSource( shader );

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		var chunks = [
			( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) { continue; }

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, 35721 );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		var string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string
			.replace( unrollLoopPattern, loopReplacer )
			.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

	}

	function deprecatedLoopReplacer( match, start, end, snippet ) {

		console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
		return loopReplacer( match, start, end, snippet );

	}

	function loopReplacer( match, start, end, snippet ) {

		var string = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:
				case CubeUVRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		var gl = renderer.getContext();

		var defines = parameters.defines;

		var vertexShader = parameters.vertexShader;
		var fragmentShader = parameters.fragmentShader;

		var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		var envMapModeDefine = generateEnvMapModeDefine( parameters );
		var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		var customDefines = generateDefines( defines );

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;
		var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		var vertexGlsl = versionString + prefixVertex + vertexShader;
		var fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			var programLog = gl.getProgramInfoLog( program ).trim();
			var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			var runnable = true;
			var haveDiagnostics = true;

			if ( gl.getProgramParameter( program, 35714 ) === false ) {

				runnable = false;

				var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

		var programs = [];

		var isWebGL2 = capabilities.isWebGL2;
		var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		var floatVertexTextures = capabilities.floatVertexTextures;
		var maxVertexUniforms = capabilities.maxVertexUniforms;
		var vertexTextures = capabilities.vertexTextures;

		var precision = capabilities.precision;

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		var parameterNames = [
			'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
			'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
			'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
			'roughnessMap', 'metalnessMap', 'gradientMap',
			'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
			'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
			'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
			'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
			'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
			'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
			'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
			'sheen', 'transmissionMap'
		];

		function getMaxBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map ) {

			var encoding;

			if ( map && map.isTexture ) {

				encoding = map.encoding;

			} else if ( map && map.isWebGLRenderTarget ) {

				console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
				encoding = map.texture.encoding;

			} else {

				encoding = LinearEncoding;

			}

			return encoding;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;

			var envMap = cubemaps.get( material.envMap || environment );

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var vertexShader, fragmentShader;

			if ( shaderID ) {

				var shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap ),
				envMap: !! envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( envMap ),
				envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !! material.clearcoatMap,
				clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
				clearcoatNormalMap: !! material.clearcoatNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				sheen: !! material.sheen,

				transmissionMap: !! material.transmissionMap,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: !! material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.fragmentShader );
				array.push( parameters.vertexShader );

			}

			if ( parameters.defines !== undefined ) {

				for ( var name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				for ( var i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				array.push( renderer.outputEncoding );
				array.push( renderer.gammaFactor );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getUniforms( material ) {

			var shaderID = shaderIDs[ material.type ];
			var uniforms;

			if ( shaderID ) {

				var shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};

	}

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList( properties ) {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		var defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];
			var materialProperties = properties.get( material );

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) { opaque.sort( customOpaqueSort || painterSortStable ); }
			if ( transparent.length > 1 ) { transparent.sort( customTransparentSort || reversePainterSortStable ); }

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				var renderItem = renderItems[ i ];

				if ( renderItem.id === null ) { break; }

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists( properties ) {

		var lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			var list;

			if ( lists.has( scene ) === false ) {

				list = new WebGLRenderList( properties );
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= lists.get( scene ).length ) {

					list = new WebGLRenderList( properties );
					lists.get( scene ).push( list );

				} else {

					list = lists.get( scene )[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	var nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		var cache = new UniformsCache();

		var shadowCache = ShadowUniformsCache();

		var state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( var i = 0; i < 9; i ++ ) { state.probe.push( new Vector3() ); }

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights ) {

			var r = 0, g = 0, b = 0;

			for ( var i = 0; i < 9; i ++ ) { state.probe[ i ].set( 0, 0, 0 ); }

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var numDirectionalShadows = 0;
			var numPointShadows = 0;
			var numSpotShadows = 0;

			lights.sort( shadowCastingLightsFirst );

			for ( var i$1 = 0, l = lights.length; i$1 < l; i$1 ++ ) {

				var light = lights[ i$1 ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isLightProbe ) {

					for ( var j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

					if ( light.castShadow ) {

						var shadow = light.shadow;

						var shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms$1 = cache.get( light );

					uniforms$1.position.setFromMatrixPosition( light.matrixWorld );

					uniforms$1.color.copy( color ).multiplyScalar( intensity );
					uniforms$1.distance = distance;

					uniforms$1.coneCos = Math.cos( light.angle );
					uniforms$1.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms$1.decay = light.decay;

					if ( light.castShadow ) {

						var shadow$1 = light.shadow;

						var shadowUniforms$1 = shadowCache.get( light );

						shadowUniforms$1.shadowBias = shadow$1.bias;
						shadowUniforms$1.shadowNormalBias = shadow$1.normalBias;
						shadowUniforms$1.shadowRadius = shadow$1.radius;
						shadowUniforms$1.shadowMapSize = shadow$1.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms$1;
						state.spotShadowMap[ spotLength ] = shadowMap;
						state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

						numSpotShadows ++;

					}

					state.spot[ spotLength ] = uniforms$1;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms$2 = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms$2.color.copy( color ).multiplyScalar( intensity );

					uniforms$2.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms$2.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms$2;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms$3 = cache.get( light );

					uniforms$3.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms$3.distance = light.distance;
					uniforms$3.decay = light.decay;

					if ( light.castShadow ) {

						var shadow$2 = light.shadow;

						var shadowUniforms$2 = shadowCache.get( light );

						shadowUniforms$2.shadowBias = shadow$2.bias;
						shadowUniforms$2.shadowNormalBias = shadow$2.normalBias;
						shadowUniforms$2.shadowRadius = shadow$2.radius;
						shadowUniforms$2.shadowMapSize = shadow$2.mapSize;
						shadowUniforms$2.shadowCameraNear = shadow$2.camera.near;
						shadowUniforms$2.shadowCameraFar = shadow$2.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms$2;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms$3;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms$4 = cache.get( light );

					uniforms$4.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms$4.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms$4;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			var hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				if ( light.isDirectionalLight ) {

					var uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms$1 = state.spot[ spotLength ];

					uniforms$1.position.setFromMatrixPosition( light.matrixWorld );
					uniforms$1.position.applyMatrix4( viewMatrix );

					uniforms$1.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms$1.direction.sub( vector3 );
					uniforms$1.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms$2 = state.rectArea[ rectAreaLength ];

					uniforms$2.position.setFromMatrixPosition( light.matrixWorld );
					uniforms$2.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms$2.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms$2.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms$2.halfWidth.applyMatrix4( matrix42 );
					uniforms$2.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms$3 = state.point[ pointLength ];

					uniforms$3.position.setFromMatrixPosition( light.matrixWorld );
					uniforms$3.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms$4 = state.hemi[ hemiLength ];

					uniforms$4.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms$4.direction.transformDirection( viewMatrix );
					uniforms$4.direction.normalize();

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		var lights = new WebGLLights( extensions, capabilities );

		var lightsArray = [];
		var shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights() {

			lights.setup( lightsArray );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		var renderStates = new WeakMap();

		function get( scene, renderCallDepth ) {
			if ( renderCallDepth === void 0 ) renderCallDepth = 0;


			var renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStates.get( scene ).length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStates.get( scene ).push( renderState );

				} else {

					renderState = renderStates.get( scene )[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	var MeshDepthMaterial = /*@__PURE__*/(function (Material) {
		function MeshDepthMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshDepthMaterial.__proto__ = Material;
		MeshDepthMaterial.prototype = Object.create( Material && Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

		MeshDepthMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		return MeshDepthMaterial;
	}(Material));

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	var MeshDistanceMaterial = /*@__PURE__*/(function (Material) {
		function MeshDistanceMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshDistanceMaterial';

			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.fog = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshDistanceMaterial.__proto__ = Material;
		MeshDistanceMaterial.prototype = Object.create( Material && Material.prototype );
		MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

		MeshDistanceMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.referencePosition.copy( source.referencePosition );
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		};

		return MeshDistanceMaterial;
	}(Material));

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap( _renderer, _objects, _capabilities ) {

		var _frustum = new Frustum();

		var _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterials = [],
			_distanceMaterials = [],

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize;

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var shadowMaterialVertical = new ShaderMaterial( {

			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},

			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vsm_vert,

			fragmentShader: vsm_frag

		} );

		var shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		var fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) { return; }
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }

			if ( lights.length === 0 ) { return; }

			var currentRenderTarget = _renderer.getRenderTarget();
			var activeCubeFace = _renderer.getActiveCubeFace();
			var activeMipmapLevel = _renderer.getActiveMipmapLevel();

			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) { continue; }

				_shadowMapSize.copy( shadow.mapSize );

				var shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

					shadow.camera.updateProjectionMatrix();

				}

				if ( shadow.map === null ) {

					var pars$1 = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars$1 );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				var viewportCount = shadow.getViewportCount();

				for ( var vp = 0; vp < viewportCount; vp ++ ) {

					var viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			var geometry = _objects.update( fullScreenMesh );

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			var material = _depthMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDepthMaterial( {

					depthPacking: RGBADepthPacking,

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_depthMaterials[ index ] = material;

			}

			return material;

		}

		function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			var material = _distanceMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDistanceMaterial( {

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_distanceMaterials[ index ] = material;

			}

			return material;

		}

		function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

			var result = null;

			var getMaterialVariant = getDepthMaterialVariant;
			var customMaterial = object.customDepthMaterial;

			if ( light.isPointLight === true ) {

				getMaterialVariant = getDistanceMaterialVariant;
				customMaterial = object.customDistanceMaterial;

			}

			if ( customMaterial === undefined ) {

				var useMorphing = false;

				if ( material.morphTargets === true ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				}

				var useSkinning = false;

				if ( object.isSkinnedMesh === true ) {

					if ( material.skinning === true ) {

						useSkinning = true;

					} else {

						console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

					}

				}

				var useInstancing = object.isInstancedMesh === true;

				result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				result.referencePosition.setFromMatrixPosition( light.matrixWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) { return; }

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial$1 = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial$1, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( 2960 );

						} else {

							disable( 2960 );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var enabledCapabilities = {};

		var xrFramebuffer = null;
		var currentBoundFramebuffers = {};

		var currentProgram = null;

		var currentBlendingEnabled = false;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( 35661 );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );
		var currentViewport = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindXRFramebuffer( framebuffer ) {

			if ( framebuffer !== xrFramebuffer ) {

				gl.bindFramebuffer( 36160, framebuffer );

				xrFramebuffer = framebuffer;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( framebuffer === null && xrFramebuffer !== null ) { framebuffer = xrFramebuffer; } // use active XR framebuffer if available

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

			}

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		var equationToGL = {};
		equationToGL[ AddEquation ] = 32774;
		equationToGL[ SubtractEquation ] = 32778;
		equationToGL[ ReverseSubtractEquation ] = 32779;

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = 32775;
			equationToGL[ MaxEquation ] = 32776;

		} else {

			var extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		var factorToGL = {};
		factorToGL[ ZeroFactor ] = 0;
		factorToGL[ OneFactor ] = 1;
		factorToGL[ SrcColorFactor ] = 768;
		factorToGL[ SrcAlphaFactor ] = 770;
		factorToGL[ SrcAlphaSaturateFactor ] = 776;
		factorToGL[ DstColorFactor ] = 774;
		factorToGL[ DstAlphaFactor ] = 772;
		factorToGL[ OneMinusSrcColorFactor ] = 769;
		factorToGL[ OneMinusSrcAlphaFactor ] = 771;
		factorToGL[ OneMinusDstColorFactor ] = 775;
		factorToGL[ OneMinusDstAlphaFactor ] = 773;

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 0, 769, 771 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFunc( 0, 769 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) { flipSided = ! flipSided; }

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			var stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( 32926 )
				: disable( 32926 );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) { gl.lineWidth( width ); }

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) { webglSlot = 33984 + maxTextures - 1; }

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( 3042 );
			gl.disable( 2884 );
			gl.disable( 2929 );
			gl.disable( 32823 );
			gl.disable( 3089 );
			gl.disable( 2960 );
			gl.disable( 32926 );

			gl.blendEquation( 32774 );
			gl.blendFunc( 1, 0 );
			gl.blendFuncSeparate( 1, 0, 1, 0 );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( 513 );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( 519, 0, 0xffffffff );
			gl.stencilOp( 7680, 7680, 7680 );
			gl.clearStencil( 0 );

			gl.cullFace( 1029 );
			gl.frontFace( 2305 );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( 33984 );

			gl.bindFramebuffer( 36160, null );

			if ( isWebGL2 === true ) {

				gl.bindFramebuffer( 36009, null );
				gl.bindFramebuffer( 36008, null );

			}

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			xrFramebuffer = null;
			currentBoundFramebuffers = {};

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var isWebGL2 = capabilities.isWebGL2;
		var maxTextures = capabilities.maxTextures;
		var maxCubemapSize = capabilities.maxCubemapSize;
		var maxTextureSize = capabilities.maxTextureSize;
		var maxSamples = capabilities.maxSamples;

		var _videoTextures = new WeakMap();
		var _canvas;

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		var useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			var scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

					var width = floor( scale * image.width );
					var height = floor( scale * image.height );

					if ( _canvas === undefined ) { _canvas = createCanvas( width, height ); }

					// cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) { return false; }

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

		}

		function getInternalFormat( internalFormatName, glFormat, glType ) {

			if ( isWebGL2 === false ) { return glFormat; }

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) { return _gl[ internalFormatName ]; }

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			var internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) { internalFormat = 33326; }
				if ( glType === 5131 ) { internalFormat = 33325; }
				if ( glType === 5121 ) { internalFormat = 33321; }

			}

			if ( glFormat === 6407 ) {

				if ( glType === 5126 ) { internalFormat = 34837; }
				if ( glType === 5131 ) { internalFormat = 34843; }
				if ( glType === 5121 ) { internalFormat = 32849; }

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) { internalFormat = 34836; }
				if ( glType === 5131 ) { internalFormat = 34842; }
				if ( glType === 5121 ) { internalFormat = 32856; }

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) { return; }

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var texture = renderTarget.texture;

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( texture );

			if ( ! renderTarget ) { return; }

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) { _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer ); }
				if ( renderTargetProperties.__webglColorRenderbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer ); }
				if ( renderTargetProperties.__webglDepthRenderbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer ); }

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		var textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			var textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) { updateVideoTexture( texture ); }

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

		}

		var wrappingToGL = {};
		wrappingToGL[ RepeatWrapping ] = 10497;
		wrappingToGL[ ClampToEdgeWrapping ] = 33071;
		wrappingToGL[ MirroredRepeatWrapping ] = 33648;

		var filterToGL = {};
		filterToGL[ NearestFilter ] = 9728;
		filterToGL[ NearestMipmapNearestFilter ] = 9984;
		filterToGL[ NearestMipmapLinearFilter ] = 9986;
		filterToGL[ LinearFilter ] = 9729;
		filterToGL[ LinearMipmapNearestFilter ] = 9985;
		filterToGL[ LinearMipmapLinearFilter ] = 9987;

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) { return; } // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) { return; } // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			var textureType = 3553;

			if ( texture.isDataTexture2DArray ) { textureType = 35866; }
			if ( texture.isDataTexture3D ) { textureType = 32879; }

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

			var supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format );

			var glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			var mipmap;
			var mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = 35056;

					} else {

						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i$1 = 0, il$1 = mipmaps.length; i$1 < il$1; i$1 ++ ) {

					mipmap = mipmaps[ i$1 ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 3553, i$1, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( 3553, i$1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i$2 = 0, il$2 = mipmaps.length; i$2 < il$2; i$2 ++ ) {

						mipmap = mipmaps[ i$2 ];
						state.texImage2D( 3553, i$2, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) { texture.onUpdate( texture ); }

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) { return; }

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			var isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
			var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			var cubeImage = [];

			for ( var i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

			}

			var image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( 34067, texture, supportsMips );

			var mipmaps;

			if ( isCompressed ) {

				for ( var i$1 = 0; i$1 < 6; i$1 ++ ) {

					mipmaps = cubeImage[ i$1 ].mipmaps;

					for ( var j = 0; j < mipmaps.length; j ++ ) {

						var mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( 34069 + i$1, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							state.texImage2D( 34069 + i$1, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				mipmaps = texture.mipmaps;

				for ( var i$2 = 0; i$2 < 6; i$2 ++ ) {

					if ( isDataTexture ) {

						state.texImage2D( 34069 + i$2, 0, glInternalFormat, cubeImage[ i$2 ].width, cubeImage[ i$2 ].height, 0, glFormat, glType, cubeImage[ i$2 ].data );

						for ( var j$1 = 0; j$1 < mipmaps.length; j$1 ++ ) {

							var mipmap$1 = mipmaps[ j$1 ];
							var mipmapImage = mipmap$1.image[ i$2 ].image;

							state.texImage2D( 34069 + i$2, j$1 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

						}

					} else {

						state.texImage2D( 34069 + i$2, 0, glInternalFormat, glFormat, glType, cubeImage[ i$2 ] );

						for ( var j$2 = 0; j$2 < mipmaps.length; j$2 ++ ) {

							var mipmap$2 = mipmaps[ j$2 ];

							state.texImage2D( 34069 + i$2, j$2 + 1, glInternalFormat, glFormat, glType, mipmap$2.image[ i$2 ] );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length;

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) { texture.onUpdate( texture ); }

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var texture = renderTarget.texture;

			var glFormat = utils.convert( texture.format );
			var glType = utils.convert( texture.type );
			var glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			if ( textureTarget === 32879 || textureTarget === 35866 ) {

				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

			}

			state.bindFramebuffer( 36160, framebuffer );
			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
			state.bindFramebuffer( 36160, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				var glInternalFormat = 33189;

				if ( isMultisample ) {

					var depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						}

					}

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples$1 = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples$1, 35056, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				var texture = renderTarget.texture;

				var glFormat = utils.convert( texture.format );
				var glType = utils.convert( texture.type );
				var glInternalFormat$1 = getInternalFormat( texture.internalFormat, glFormat, glType );

				if ( isMultisample ) {

					var samples$2 = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples$2, glInternalFormat$1, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat$1, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }

			state.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			state.bindFramebuffer( 36160, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var texture = renderTarget.texture;

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();
			textureProperties.__version = texture.version;

			info.memory.textures ++;

			var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			var isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			// Handles WebGL2 RGBFormat fallback - #18858

			if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

				texture.format = RGBAFormat;

				console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

			}

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

						var glFormat = utils.convert( texture.format );
						var glType = utils.convert( texture.type );
						var glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
						var samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( 36161, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						state.bindFramebuffer( 36160, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, texture, supportsMips );

				for ( var i$1 = 0; i$1 < 6; i$1 ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i$1 ], renderTarget, 36064, 34069 + i$1 );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 34067, null );

			} else {

				var glTextureType = 3553;

				if ( isRenderTarget3D ) {

					// Render targets containing layers, i.e: Texture 3D and 2d arrays

					if ( isWebGL2 ) {

						var isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? 32879 : 35866;

					} else {

						console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType );

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( 3553, texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 3553, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;

			var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( isWebGL2 ) {

					var renderTargetProperties = properties.get( renderTarget );

					state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
					state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;

					if ( renderTarget.depthBuffer ) { mask |= 256; }
					if ( renderTarget.stencilBuffer ) { mask |= 1024; }

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( maxSamples, renderTarget.samples ) : 0;

		}

		function updateVideoTexture( texture ) {

			var frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		// backwards compatibility

		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && texture.isWebGLCubeRenderTarget ) {

				if ( warnedTextureCube === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}


			setTextureCube( texture, slot );

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		function convert( p ) {

			var extension;

			if ( p === UnsignedByteType ) { return 5121; }
			if ( p === UnsignedShort4444Type ) { return 32819; }
			if ( p === UnsignedShort5551Type ) { return 32820; }
			if ( p === UnsignedShort565Type ) { return 33635; }

			if ( p === ByteType ) { return 5120; }
			if ( p === ShortType ) { return 5122; }
			if ( p === UnsignedShortType ) { return 5123; }
			if ( p === IntType ) { return 5124; }
			if ( p === UnsignedIntType ) { return 5125; }
			if ( p === FloatType ) { return 5126; }

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) { return 5131; }

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) { return 6406; }
			if ( p === RGBFormat ) { return 6407; }
			if ( p === RGBAFormat ) { return 6408; }
			if ( p === LuminanceFormat ) { return 6409; }
			if ( p === LuminanceAlphaFormat ) { return 6410; }
			if ( p === DepthFormat ) { return 6402; }
			if ( p === DepthStencilFormat ) { return 34041; }
			if ( p === RedFormat ) { return 6403; }

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) { return 36244; }
			if ( p === RGFormat ) { return 33319; }
			if ( p === RGIntegerFormat ) { return 33320; }
			if ( p === RGBIntegerFormat ) { return 36248; }
			if ( p === RGBAIntegerFormat ) { return 36249; }

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }
					if ( p === RGBA_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }
					if ( p === RGBA_S3TC_DXT3_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }
					if ( p === RGBA_S3TC_DXT5_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }

				} else {

					return null;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }
					if ( p === RGB_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }
					if ( p === RGBA_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }
					if ( p === RGBA_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) { return extension.COMPRESSED_RGB8_ETC2; }
					if ( p === RGBA_ETC2_EAC_Format ) { return extension.COMPRESSED_RGBA8_ETC2_EAC; }

				}

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) { return 34042; }

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

		}

		return { convert: convert };

	}

	var ArrayCamera = /*@__PURE__*/(function (PerspectiveCamera) {
		function ArrayCamera( array ) {
			if ( array === void 0 ) array = [];


			PerspectiveCamera.call(this);

			this.cameras = array;

		}

		if ( PerspectiveCamera ) ArrayCamera.__proto__ = PerspectiveCamera;
		ArrayCamera.prototype = Object.create( PerspectiveCamera && PerspectiveCamera.prototype );
		ArrayCamera.prototype.constructor = ArrayCamera;

		return ArrayCamera;
	}(PerspectiveCamera));

	ArrayCamera.prototype.isArrayCamera = true;

	var Group = /*@__PURE__*/(function (Object3D) {
		function Group() {

			Object3D.call(this);

			this.type = 'Group';

		}

		if ( Object3D ) Group.__proto__ = Object3D;
		Group.prototype = Object.create( Object3D && Object3D.prototype );
		Group.prototype.constructor = Group;

		return Group;
	}(Object3D));

	Group.prototype.isGroup = true;

	function WebXRController() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	Object.assign( WebXRController.prototype, {

		constructor: WebXRController,

		getHandSpace: function () {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		},

		getTargetRaySpace: function () {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;

			}

			return this._targetRay;

		},

		getGripSpace: function () {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;

			}

			return this._grip;

		},

		dispatchEvent: function ( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		},

		disconnect: function ( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		},

		update: function ( inputSource, frame, referenceSpace ) {

			var inputPose = null;
			var gripPose = null;
			var handPose = null;

			var targetRay = this._targetRay;
			var grip = this._grip;
			var hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					}

				}

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( var inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						var jointPose = frame.getJointPose( inputjoint, referenceSpace );

						if ( hand.joints[ inputjoint.jointName ] === undefined ) {

							// The transform of this joint will be updated with the joint pose on each frame
							var joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[ inputjoint.jointName ] = joint;
							// ??
							hand.add( joint );

						}

						var joint$1 = hand.joints[ inputjoint.jointName ];

						if ( jointPose !== null ) {

							joint$1.matrix.fromArray( jointPose.transform.matrix );
							joint$1.matrix.decompose( joint$1.position, joint$1.rotation, joint$1.scale );
							joint$1.jointRadius = jointPose.radius;

						}

						joint$1.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					var indexTip = hand.joints[ 'index-finger-tip' ];
					var thumbTip = hand.joints[ 'thumb-tip' ];
					var distance = indexTip.position.distanceTo( thumbTip.position );

					var distanceToPinch = 0.02;
					var threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						}

					}

				}

			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

	} );

	function WebXRManager( renderer, gl ) {

		var scope = this;
		var state = renderer.state;

		var session = null;

		var framebufferScaleFactor = 1.0;

		var referenceSpace = null;
		var referenceSpaceType = 'local-floor';

		var pose = null;

		var controllers = [];
		var inputSourcesMap = new Map();

		//

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		var cameras = [ cameraL, cameraR ];

		var cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		var _currentDepthNear = null;
		var _currentDepthFar = null;

		//

		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			var controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			var controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			var controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			var controller = inputSourcesMap.get( event.inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				controller.disconnect( inputSource );

			} );

			inputSourcesMap.clear();

			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			state.bindXRFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() );

			//

			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return referenceSpace;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				var attributes = gl.getContextAttributes();

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				var layerInit = {
					antialias: attributes.antialias,
					alpha: attributes.alpha,
					depth: attributes.depth,
					stencil: attributes.stencil,
					framebufferScaleFactor: framebufferScaleFactor
				};

				// eslint-disable-next-line no-undef
				var baseLayer = new XRWebGLLayer( session, gl, layerInit );

				session.updateRenderState( { baseLayer: baseLayer } );

				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			var inputSources = session.inputSources;

			// Assign inputSources to available controllers

			for ( var i = 0; i < controllers.length; i ++ ) {

				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			}

			// Notify disconnected

			for ( var i$1 = 0; i$1 < event.removed.length; i$1 ++ ) {

				var inputSource = event.removed[ i$1 ];
				var controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( var i$2 = 0; i$2 < event.added.length; i$2 ++ ) {

				var inputSource$1 = event.added[ i$2 ];
				var controller$1 = inputSourcesMap.get( inputSource$1 );

				if ( controller$1 ) {

					controller$1.dispatchEvent( { type: 'connected', data: inputSource$1 } );

				}

			}

		}

		//

		var cameraLPos = new Vector3();
		var cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			var ipd = cameraLPos.distanceTo( cameraRPos );

			var projL = cameraL.projectionMatrix.elements;
			var projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			var left = near * leftFov;
			var right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			var zOffset = ipd / ( - leftFov + rightFov );
			var xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			var near2 = near + zOffset;
			var far2 = far + zOffset;
			var left2 = left - xOffset;
			var right2 = right + ( ipd - xOffset );
			var top2 = topFov * far / far2 * near2;
			var bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.getCamera = function ( camera ) {

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			var parent = camera.parent;
			var cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( var i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update camera and its children

			camera.matrixWorld.copy( cameraVR.matrixWorld );
			camera.matrix.copy( cameraVR.matrix );
			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

			var children = camera.children;

			for ( var i$1 = 0, l = children.length; i$1 < l; i$1 ++ ) {

				children[ i$1 ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			return cameraVR;

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( referenceSpace );

			if ( pose !== null ) {

				var views = pose.views;
				var baseLayer = session.renderState.baseLayer;

				state.bindXRFramebuffer( baseLayer.framebuffer );

				var cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( var i = 0; i < views.length; i ++ ) {

					var view = views[ i ];
					var viewport = baseLayer.getViewport( view );

					var camera = cameras[ i ];
					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			var inputSources = session.inputSources;

			for ( var i$1 = 0; i$1 < controllers.length; i$1 ++ ) {

				var controller = controllers[ i$1 ];
				var inputSource = inputSources[ i$1 ];

				controller.update( inputSource, frame, referenceSpace );

			}

			if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time, frame ); }

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

	Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

	function WebGLMaterials( properties ) {

		function refreshFogUniforms( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsLambert( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material );

				} else {

					refreshUniformsStandard( uniforms, material );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDepth( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsNormal( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			var envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				var maxMipLevel = properties.get( envMap ).__maxMipLevel;

				if ( maxMipLevel !== undefined ) {

					uniforms.maxMipLevel.value = maxMipLevel;

				}

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			} else if ( material.clearcoatMap ) {

				uvScaleMap = material.clearcoatMap;

			} else if ( material.clearcoatNormalMap ) {

				uvScaleMap = material.clearcoatNormalMap;

			} else if ( material.clearcoatRoughnessMap ) {

				uvScaleMap = material.clearcoatRoughnessMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			var uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			var envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if ( material.sheen ) { uniforms.sheen.value.copy( material.sheen ); }

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

			uniforms.transmission.value = material.transmission;

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function createCanvasElement() {

		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	function WebGLRenderer( parameters ) {

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		var currentRenderList = null;
		var currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		var renderListStack = [];
		var renderStateStack = [];

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// internal properties

		var _this = this;

		var _isContextLost = false;

		// internal state cache

		var _currentActiveCubeFace = 0;
		var _currentActiveMipmapLevel = 0;
		var _currentRenderTarget = null;
		var _currentMaterialId = - 1;

		var _currentCamera = null;

		var _currentViewport = new Vector4();
		var _currentScissor = new Vector4();
		var _currentScissorTest = null;

		//

		var _width = _canvas.width;
		var _height = _canvas.height;

		var _pixelRatio = 1;
		var _opaqueSort = null;
		var _transparentSort = null;

		var _viewport = new Vector4( 0, 0, _width, _height );
		var _scissor = new Vector4( 0, 0, _width, _height );
		var _scissorTest = false;

		// frustum

		var _frustum = new Frustum();

		// clipping

		var _clippingEnabled = false;
		var _localClippingEnabled = false;

		// camera matrices cache

		var _projScreenMatrix = new Matrix4();

		var _vector3 = new Vector3();

		var _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl = _context;

		function getContext( contextNames, contextAttributes ) {

			for ( var i = 0; i < contextNames.length; i ++ ) {

				var contextName = contextNames[ i ];
				var context = _canvas.getContext( contextName, contextAttributes );
				if ( context !== null ) { return context; }

			}

			return null;

		}

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			if ( _gl === null ) {

				var contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

				if ( _this.isWebGL1Renderer === true ) {

					contextNames.shift();

				}

				_gl = getContext( contextNames, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextNames ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		var extensions, capabilities, state, info;
		var properties, textures, cubemaps, attributes, geometries, objects;
		var programCache, materials, renderLists, renderStates, clipping, shadowMap;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

		var utils, bindingStates;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			extensions.init( capabilities );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			attributes = new WebGLAttributes( _gl, capabilities );
			bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( properties );
			renderLists = new WebGLRenderLists( properties );
			renderStates = new WebGLRenderStates( extensions, capabilities );
			background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		var xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) { extension.loseContext(); }

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) { extension.restoreContext(); }

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) { return; }

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

				target = new Color();

			}

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) { bits |= 16384; }
			if ( depth === undefined || depth ) { bits |= 256; }
			if ( stencil === undefined || stencil ) { bits |= 1024; }

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			objects.dispose();
			bindingStates.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			var infoAutoReset = info.autoReset;
			var shadowMapEnabled = shadowMap.enabled;
			var shadowMapAutoUpdate = shadowMap.autoUpdate;
			var shadowMapNeedsUpdate = shadowMap.needsUpdate;
			var shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			var programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			bindingStates.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }
			if ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }
			if ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }
			if ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( 34962, buffers.position );
				_gl.bufferData( 34962, object.positionArray, 35048 );

				bindingStates.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( 34962, buffers.normal );
				_gl.bufferData( 34962, object.normalArray, 35048 );

				bindingStates.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( 34962, buffers.uv );
				_gl.bufferData( 34962, object.uvArray, 35048 );

				bindingStates.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( 34962, buffers.color );
				_gl.bufferData( 34962, object.colorArray, 35048 );

				bindingStates.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays( 4, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) { scene = _emptyScene; } // renderBufferDirect second parameter used to be fog (could be null)

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			var program = setProgram( camera, scene, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) { return; }

			} else if ( index.count === 0 ) {

				return;

			}

			//

			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			if ( material.morphTargets || material.morphNormals ) {

				morphtargets.update( object, geometry, material, program );

			}

			bindingStates.setup( object, material, program, geometry, index );

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			var dataCount = ( index !== null ) ? index.count : position.count;

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) { return; }

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					renderer.setMode( 4 );

				}

			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( 1 );

				} else if ( object.isLineLoop ) {

					renderer.setMode( 2 );

				} else {

					renderer.setMode( 3 );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( 0 );

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				var instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene );
			currentRenderState.init();

			scene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights();

			scene.traverse( function ( object ) {

				var material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( var i = 0; i < material.length; i ++ ) {

							var material2 = material[ i ];

							getProgram( material2, scene, object );

						}

					} else {

						getProgram( material, scene, object );

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) { animation.setContext( window ); }

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		this.render = function ( scene, camera ) {

			var renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) { return; }

			// update scene graph

			if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

			// update camera matrices and frustum

			if ( camera.parent === null ) { camera.updateMatrixWorld(); }

			if ( xr.enabled === true && xr.isPresenting === true ) {

				camera = xr.getCamera( camera );

			}

			//
			if ( scene.isScene === true ) { scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget ); }

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled === true ) { clipping.beginShadows(); }

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights();
			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) { clipping.endShadows(); }

			//

			if ( this.info.autoReset === true ) { this.info.reset(); }

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( opaqueObjects.length > 0 ) { renderObjects( opaqueObjects, scene, camera ); }
			if ( transparentObjects.length > 0 ) { renderObjects( transparentObjects, scene, camera ); }

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) { scene.onAfterRender( _this, scene, camera ); }

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) { return; }

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) { object.update( camera ); }

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						// update skeleton only once in a frame

						if ( object.skeleton.frame !== info.render.frame ) {

							object.skeleton.update();
							object.skeleton.frame = info.render.frame;

						}

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry$1 = objects.update( object );
						var material$1 = object.material;

						if ( Array.isArray( material$1 ) ) {

							var groups = geometry$1.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material$1[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry$1, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material$1.visible ) {

							currentRenderList.push( object, geometry$1, material$1, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i$1 = 0, l$1 = children.length; i$1 < l$1; i$1 ++ ) {

				projectObject( children[ i$1 ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera ) {

			var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							state.viewport( _currentViewport.copy( camera2.viewport ) );

							currentRenderState.setupLightsView( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				var program = setProgram( camera, scene, material, object );

				state.setMaterial( material );

				bindingStates.reset();

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) { scene = _emptyScene; } // scene could be a Mesh, Line, Points, ...

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var lightsStateVersion = lights.state.version;

			var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			var programCacheKey = programCache.getProgramCacheKey( parameters );

			var programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			var program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			var uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = program.getUniforms();
			var uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;

			return program;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			var materialProperties = properties.get( material );

			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;

		}

		function setProgram( camera, scene, material, object ) {

			if ( scene.isScene !== true ) { scene = _emptyScene; } // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;
			var encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			var envMap = cubemaps.get( material.envMap || environment );
			var vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			var needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputEncoding !== encoding ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			var program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === null ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = MathUtils.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {
			if ( activeCubeFace === void 0 ) activeCubeFace = 0;
			if ( activeMipmapLevel === void 0 ) activeMipmapLevel = 0;


			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = null;
			var isCube = false;
			var isRenderTarget3D = false;

			if ( renderTarget ) {

				var texture = renderTarget.texture;

				if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

					isRenderTarget3D = true;

				}

				var _webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					framebuffer = _webglFramebuffer[ activeCubeFace ];
					isCube = true;

				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = _webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			state.bindFramebuffer( 36160, framebuffer );

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				var textureProperties$1 = properties.get( renderTarget.texture );
				var layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( 36160, 36064, textureProperties$1.__webglTexture, activeMipmapLevel || 0, layer );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( 36160, framebuffer );

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					var halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! halfFloatSupportedByExt ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					var framebuffer$1 = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( 36160, framebuffer$1 );

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {
			if ( level === void 0 ) level = 0;


			var levelScale = Math.pow( 2, - level );
			var width = Math.floor( texture.image.width * levelScale );
			var height = Math.floor( texture.image.height * levelScale );
			var glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {
			if ( level === void 0 ) level = 0;


			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) { _gl.generateMipmap( 3553 ); }

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level ) {
			if ( level === void 0 ) level = 0;


			if ( _this.isWebGL1Renderer ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
				return;

			}

			var ref = srcTexture.image;
			var width = ref.width;
			var height = ref.height;
			var data = ref.data;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );
			var glTarget;

			if ( dstTexture.isDataTexture3D ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = 32879;

			} else if ( dstTexture.isDataTexture2DArray ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = 35866;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			var unpackRowLen = _gl.getParameter( 3314 );
			var unpackImageHeight = _gl.getParameter( 32878 );
			var unpackSkipPixels = _gl.getParameter( 3316 );
			var unpackSkipRows = _gl.getParameter( 3315 );
			var unpackSkipImages = _gl.getParameter( 32877 );

			_gl.pixelStorei( 3314, width );
			_gl.pixelStorei( 32878, height );
			_gl.pixelStorei( 3316, sourceBox.min.x );
			_gl.pixelStorei( 3315, sourceBox.min.y );
			_gl.pixelStorei( 32877, sourceBox.min.z );

			_gl.texSubImage3D(
				glTarget,
				level,
				position.x,
				position.y,
				position.z,
				sourceBox.max.x - sourceBox.min.x + 1,
				sourceBox.max.y - sourceBox.min.y + 1,
				sourceBox.max.z - sourceBox.min.z + 1,
				glFormat,
				glType,
				data
			);

			_gl.pixelStorei( 3314, unpackRowLen );
			_gl.pixelStorei( 32878, unpackImageHeight );
			_gl.pixelStorei( 3316, unpackSkipPixels );
			_gl.pixelStorei( 3315, unpackSkipRows );
			_gl.pixelStorei( 32877, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) { _gl.generateMipmap( glTarget ); }

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			textures.setTexture2D( texture, 0 );

			state.unbindTexture();

		};

		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	var FogExp2 = function FogExp2( color, density ) {
		if ( density === void 0 ) density = 0.00025;


		this.name = '';

		this.color = new Color( color );
		this.density = density;

	};

	FogExp2.prototype.clone = function clone () {

		return new FogExp2( this.color, this.density );

	};

	FogExp2.prototype.toJSON = function toJSON ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	};

	FogExp2.prototype.isFogExp2 = true;

	var Fog = function Fog( color, near, far ) {
		if ( near === void 0 ) near = 1;
		if ( far === void 0 ) far = 1000;


		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	};

	Fog.prototype.clone = function clone () {

		return new Fog( this.color, this.near, this.far );

	};

	Fog.prototype.toJSON = function toJSON ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	};

	Fog.prototype.isFog = true;

	var Scene = /*@__PURE__*/(function (Object3D) {
		function Scene() {

			Object3D.call(this);

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

			}

		}

		if ( Object3D ) Scene.__proto__ = Object3D;
		Scene.prototype = Object.create( Object3D && Object3D.prototype );
		Scene.prototype.constructor = Scene;

		Scene.prototype.copy = function copy ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) { this.background = source.background.clone(); }
			if ( source.environment !== null ) { this.environment = source.environment.clone(); }
			if ( source.fog !== null ) { this.fog = source.fog.clone(); }

			if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		};

		Scene.prototype.toJSON = function toJSON ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
			if ( this.environment !== null ) { data.object.environment = this.environment.toJSON( meta ); }
			if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

			return data;

		};

		return Scene;
	}(Object3D));

	Scene.prototype.isScene = true;

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = MathUtils.generateUUID();

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) { this.version ++; }

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {
			if ( offset === void 0 ) offset = 0;


			this.array.set( value, offset );

			return this;

		},

		clone: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			var array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			var ib = new InterleavedBuffer( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		toJSON: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	} );

	var _vector$6 = new Vector3();

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		},

		needsUpdate: {

			set: function ( value ) {

				this.data.needsUpdate = value;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		applyMatrix4: function ( m ) {

			for ( var i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$6.x = this.getX( i );
				_vector$6.y = this.getY( i );
				_vector$6.z = this.getZ( i );

				_vector$6.applyMatrix4( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		},

		applyNormalMatrix: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.x = this.getX( i );
				_vector$6.y = this.getY( i );
				_vector$6.z = this.getZ( i );

				_vector$6.applyNormalMatrix( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		},

		transformDirection: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.x = this.getX( i );
				_vector$6.y = this.getY( i );
				_vector$6.z = this.getZ( i );

				_vector$6.transformDirection( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		},

		clone: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

				var array = [];

				for ( var i = 0; i < this.count; i ++ ) {

					var index = i * this.data.stride + this.offset;

					for ( var j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		},

		toJSON: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

				var array = [];

				for ( var i = 0; i < this.count; i ++ ) {

					var index = i * this.data.stride + this.offset;

					for ( var j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interlaved attribtue

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	} );

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	var SpriteMaterial = /*@__PURE__*/(function (Material) {
		function SpriteMaterial( parameters ) {

			Material.call(this);

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.setValues( parameters );

		}

		if ( Material ) SpriteMaterial.__proto__ = Material;
		SpriteMaterial.prototype = Object.create( Material && Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;

		SpriteMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		};

		return SpriteMaterial;
	}(Material));

	SpriteMaterial.prototype.isSpriteMaterial = true;

	var _basePosition = new Vector3();

	var _skinIndex = new Vector4();
	var _skinWeight = new Vector4();

	var _vector$5 = new Vector3();
	var _matrix = new Matrix4();

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		copy: function ( source ) {

			Mesh.prototype.copy.call( this, source );

			this.bindMode = source.bindMode;
			this.bindMatrix.copy( source.bindMatrix );
			this.bindMatrixInverse.copy( source.bindMatrixInverse );

			this.skeleton = source.skeleton;

			return this;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.copy( bindMatrix ).invert();

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var vector = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.x = skinWeight.getX( i );
				vector.y = skinWeight.getY( i );
				vector.z = skinWeight.getZ( i );
				vector.w = skinWeight.getW( i );

				var scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.copy( this.matrixWorld ).invert();

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.copy( this.bindMatrix ).invert();

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		boneTransform: function ( index, target ) {

			var skeleton = this.skeleton;
			var geometry = this.geometry;

			_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( var i = 0; i < 4; i ++ ) {

				var weight = _skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					var boneIndex = _skinIndex.getComponent( i );

					_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		}

	} );

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	var _offsetMatrix = /*@__PURE__*/ new Matrix4();
	var _identityMatrix = /*@__PURE__*/ new Matrix4();

	var Skeleton = function Skeleton( bones, boneInverses ) {
		if ( bones === void 0 ) bones = [];
		if ( boneInverses === void 0 ) boneInverses = [];


		this.uuid = MathUtils.generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	};

	Skeleton.prototype.init = function init () {

		var bones = this.bones;
		var boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	};

	Skeleton.prototype.calculateInverses = function calculateInverses () {

		this.boneInverses.length = 0;

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	};

	Skeleton.prototype.pose = function pose () {

		// recover the bind-time world matrices

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var i$1 = 0, il$1 = this.bones.length; i$1 < il$1; i$1 ++ ) {

			var bone$1 = this.bones[ i$1 ];

			if ( bone$1 ) {

				if ( bone$1.parent && bone$1.parent.isBone ) {

					bone$1.matrix.copy( bone$1.parent.matrixWorld ).invert();
					bone$1.matrix.multiply( bone$1.matrixWorld );

				} else {

					bone$1.matrix.copy( bone$1.matrixWorld );

				}

				bone$1.matrix.decompose( bone$1.position, bone$1.quaternion, bone$1.scale );

			}

		}

	};

	Skeleton.prototype.update = function update () {

		var bones = this.bones;
		var boneInverses = this.boneInverses;
		var boneMatrices = this.boneMatrices;
		var boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( var i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			var matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	};

	Skeleton.prototype.clone = function clone () {

		return new Skeleton( this.bones, this.boneInverses );

	};

	Skeleton.prototype.getBoneByName = function getBoneByName ( name ) {

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	};

	Skeleton.prototype.dispose = function dispose ( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	};

	Skeleton.prototype.fromJSON = function fromJSON ( json, bones ) {

		this.uuid = json.uuid;

		for ( var i = 0, l = json.bones.length; i < l; i ++ ) {

			var uuid = json.bones[ i ];
			var bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	};

	Skeleton.prototype.toJSON = function toJSON () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		var bones = this.bones;
		var boneInverses = this.boneInverses;

		for ( var i = 0, l = bones.length; i < l; i ++ ) {

			var bone = bones[ i ];
			data.bones.push( bone.uuid );

			var boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	};

	var _instanceLocalMatrix = new Matrix4();
	var _instanceWorldMatrix = new Matrix4();

	var _instanceIntersects = [];

	var _mesh = new Mesh();

	function InstancedMesh( geometry, material, count ) {

		Mesh.call( this, geometry, material );

		this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;

		this.count = count;

		this.frustumCulled = false;

	}

	InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: InstancedMesh,

		isInstancedMesh: true,

		copy: function ( source ) {

			Mesh.prototype.copy.call( this, source );

			this.instanceMatrix.copy( source.instanceMatrix );

			if ( source.instanceColor !== null ) { this.instanceColor = source.instanceColor.clone(); }

			this.count = source.count;

			return this;

		},

		getColorAt: function ( index, color ) {

			color.fromArray( this.instanceColor.array, index * 3 );

		},

		getMatrixAt: function ( index, matrix ) {

			matrix.fromArray( this.instanceMatrix.array, index * 16 );

		},

		raycast: function ( raycaster, intersects ) {

			var matrixWorld = this.matrixWorld;
			var raycastTimes = this.count;

			_mesh.geometry = this.geometry;
			_mesh.material = this.material;

			if ( _mesh.material === undefined ) { return; }

			for ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

				// calculate the world matrix for each instance

				this.getMatrixAt( instanceId, _instanceLocalMatrix );

				_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

				// the mesh represents this single instance

				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast( raycaster, _instanceIntersects );

				// process the result of raycast

				for ( var i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

					var intersect = _instanceIntersects[ i ];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push( intersect );

				}

				_instanceIntersects.length = 0;

			}

		},

		setColorAt: function ( index, color ) {

			if ( this.instanceColor === null ) {

				this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

			}

			color.toArray( this.instanceColor.array, index * 3 );

		},

		setMatrixAt: function ( index, matrix ) {

			matrix.toArray( this.instanceMatrix.array, index * 16 );

		},

		updateMorphTargets: function () {

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	var LineBasicMaterial = /*@__PURE__*/(function (Material) {
		function LineBasicMaterial( parameters ) {

			Material.call(this);

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.morphTargets = false;

			this.setValues( parameters );

		}

		if ( Material ) LineBasicMaterial.__proto__ = Material;
		LineBasicMaterial.prototype = Object.create( Material && Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;


		LineBasicMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			this.morphTargets = source.morphTargets;

			return this;

		};

		return LineBasicMaterial;
	}(Material));

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	var _start$1 = new Vector3();
	var _end$1 = new Vector3();
	var _inverseMatrix$1 = new Matrix4();
	var _ray$1 = new Ray();
	var _sphere$1 = new Sphere();

	function Line( geometry, material ) {
		if ( geometry === void 0 ) geometry = new BufferGeometry();
		if ( material === void 0 ) material = new LineBasicMaterial();


		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		computeLineDistances: function () {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					var positionAttribute = geometry.attributes.position;
					var lineDistances = [ 0 ];

					for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

						_start$1.fromBufferAttribute( positionAttribute, i - 1 );
						_end$1.fromBufferAttribute( positionAttribute, i );

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += _start$1.distanceTo( _end$1 );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Line.threshold;
			var drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );
			_sphere$1.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) { return; }

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;

			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = this.isLineSegments ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if ( index !== null ) {

					var start = Math.max( 0, drawRange.start );
					var end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( var i = start, l = end - 1; i < l; i += step ) {

						var a = index.getX( i );
						var b = index.getX( i + 1 );

						vStart.fromBufferAttribute( positionAttribute, a );
						vEnd.fromBufferAttribute( positionAttribute, b );

						var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) { continue; }

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					var start$1 = Math.max( 0, drawRange.start );
					var end$1 = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

					for ( var i$1 = start$1, l$1 = end$1 - 1; i$1 < l$1; i$1 += step ) {

						vStart.fromBufferAttribute( positionAttribute, i$1 );
						vEnd.fromBufferAttribute( positionAttribute, i$1 + 1 );

						var distSq$1 = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq$1 > localThresholdSq ) { continue; }

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance$1 = raycaster.ray.origin.distanceTo( interRay );

						if ( distance$1 < raycaster.near || distance$1 > raycaster.far ) { continue; }

						intersects.push( {

							distance: distance$1,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i$1,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( var m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							var name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	var _start = new Vector3();
	var _end = new Vector3();

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: function () {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					var positionAttribute = geometry.attributes.position;
					var lineDistances = [];

					for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

						_start.fromBufferAttribute( positionAttribute, i );
						_end.fromBufferAttribute( positionAttribute, i + 1 );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		}

	} );

	var LineLoop = /*@__PURE__*/(function (Line) {
		function LineLoop( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineLoop';

		}

		if ( Line ) LineLoop.__proto__ = Line;
		LineLoop.prototype = Object.create( Line && Line.prototype );
		LineLoop.prototype.constructor = LineLoop;

		return LineLoop;
	}(Line));

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	var PointsMaterial = /*@__PURE__*/(function (Material) {
		function PointsMaterial( parameters ) {

			Material.call(this);

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.morphTargets = false;

			this.setValues( parameters );

		}

		if ( Material ) PointsMaterial.__proto__ = Material;
		PointsMaterial.prototype = Object.create( Material && Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;

		PointsMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.morphTargets = source.morphTargets;

			return this;

		};

		return PointsMaterial;
	}(Material));

	PointsMaterial.prototype.isPointsMaterial = true;

	var _inverseMatrix = new Matrix4();
	var _ray = new Ray();
	var _sphere = new Sphere();
	var _position$2 = new Vector3();

	function Points( geometry, material ) {
		if ( geometry === void 0 ) geometry = new BufferGeometry();
		if ( material === void 0 ) material = new PointsMaterial();


		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;
			var drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );
			_sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) { return; }

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if ( index !== null ) {

					var start = Math.max( 0, drawRange.start );
					var end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( var i = start, il = end; i < il; i ++ ) {

						var a = index.getX( i );

						_position$2.fromBufferAttribute( positionAttribute, a );

						testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				} else {

					var start$1 = Math.max( 0, drawRange.start );
					var end$1 = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

					for ( var i$1 = start$1, l = end$1; i$1 < l; i$1 ++ ) {

						_position$2.fromBufferAttribute( positionAttribute, i$1 );

						testPoint( _position$2, i$1, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				}

			} else {

				console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( var m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							var name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		var rayPointDistanceSq = _ray.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			var intersectPoint = new Vector3();

			_ray.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) { return; }

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	var CompressedTexture = /*@__PURE__*/(function (Texture) {
		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

		if ( Texture ) CompressedTexture.__proto__ = Texture;
		CompressedTexture.prototype = Object.create( Texture && Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;

		return CompressedTexture;
	}(Texture));

	CompressedTexture.prototype.isCompressedTexture = true;

	var CanvasTexture = /*@__PURE__*/(function (Texture) {
		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

		if ( Texture ) CanvasTexture.__proto__ = Texture;
		CanvasTexture.prototype = Object.create( Texture && Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;

		return CanvasTexture;
	}(Texture));

	CanvasTexture.prototype.isCanvasTexture = true;

	var CylinderGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
			if ( radiusTop === void 0 ) radiusTop = 1;
			if ( radiusBottom === void 0 ) radiusBottom = 1;
			if ( height === void 0 ) height = 1;
			if ( radialSegments === void 0 ) radialSegments = 8;
			if ( heightSegments === void 0 ) heightSegments = 1;
			if ( openEnded === void 0 ) openEnded = false;
			if ( thetaStart === void 0 ) thetaStart = 0;
			if ( thetaLength === void 0 ) thetaLength = Math.PI * 2;


			BufferGeometry.call(this);
			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var index = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) { generateCap( true ); }
				if ( radiusBottom > 0 ) { generateCap( false ); }

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				var normal = new Vector3();
				var vertex = new Vector3();

				var groupCount = 0;

				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( var y = 0; y <= heightSegments; y ++ ) {

					var indexRow = [];

					var v = y / heightSegments;

					// calculate the radius of the current row

					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( var x = 0; x <= radialSegments; x ++ ) {

						var u = x / radialSegments;

						var theta = u * thetaLength + thetaStart;

						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( var x$1 = 0; x$1 < radialSegments; x$1 ++ ) {

					for ( var y$1 = 0; y$1 < heightSegments; y$1 ++ ) {

						// we use the index array to access the correct indices

						var a = indexArray[ y$1 ][ x$1 ];
						var b = indexArray[ y$1 + 1 ][ x$1 ];
						var c = indexArray[ y$1 + 1 ][ x$1 + 1 ];
						var d = indexArray[ y$1 ][ x$1 + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				var centerIndexStart = index;

				var uv = new Vector2();
				var vertex = new Vector3();

				var groupCount = 0;

				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( var x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				var centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( var x$1 = 0; x$1 <= radialSegments; x$1 ++ ) {

					var u = x$1 / radialSegments;
					var theta = u * thetaLength + thetaStart;

					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( var x$2 = 0; x$2 < radialSegments; x$2 ++ ) {

					var c = centerIndexStart + x$2;
					var i = centerIndexEnd + x$2;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		if ( BufferGeometry ) CylinderGeometry.__proto__ = BufferGeometry;
		CylinderGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;

		return CylinderGeometry;
	}(BufferGeometry));

	var PolyhedronGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function PolyhedronGeometry( vertices, indices, radius, detail ) {
			if ( radius === void 0 ) radius = 1;
			if ( detail === void 0 ) detail = 0;


			BufferGeometry.call(this);

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			// default buffer data

			var vertexBuffer = [];
			var uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

			if ( detail === 0 ) {

				this.computeVertexNormals(); // flat normals

			} else {

				this.normalizeNormals(); // smooth normals

			}

			// helper functions

			function subdivide( detail ) {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( var i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				var cols = detail + 1;

				// we use this multidimensional array as a data structure for creating the subdivision

				var v = [];

				// construct all of the vertices for this subdivision

				for ( var i = 0; i <= cols; i ++ ) {

					v[ i ] = [];

					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );

					var rows = cols - i;

					for ( var j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( var i$1 = 0; i$1 < cols; i$1 ++ ) {

					for ( var j$1 = 0; j$1 < 2 * ( cols - i$1 ) - 1; j$1 ++ ) {

						var k = Math.floor( j$1 / 2 );

						if ( j$1 % 2 === 0 ) {

							pushVertex( v[ i$1 ][ k + 1 ] );
							pushVertex( v[ i$1 + 1 ][ k ] );
							pushVertex( v[ i$1 ][ k ] );

						} else {

							pushVertex( v[ i$1 ][ k + 1 ] );
							pushVertex( v[ i$1 + 1 ][ k + 1 ] );
							pushVertex( v[ i$1 + 1 ][ k ] );

						}

					}

				}

			}

			function applyRadius( radius ) {

				var vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				var vertex = new Vector3();

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( var i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];

					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }
						if ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }
						if ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				var stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				var centroid = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					var azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] = uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		if ( BufferGeometry ) PolyhedronGeometry.__proto__ = BufferGeometry;
		PolyhedronGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

		return PolyhedronGeometry;
	}(BufferGeometry));

	new Vector3();
	new Vector3();
	new Vector3();
	new Triangle();

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length;
			var outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
			var outerNode = linkedList( data, 0, outerLen, dim, true );
			var triangles = [];

			if ( ! outerNode || outerNode.next === outerNode.prev ) { return triangles; }

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) { outerNode = eliminateHoles( data, holeIndices, outerNode, dim ); }

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) { minX = x; }
					if ( y < minY ) { minY = y; }
					if ( x > maxX ) { maxX = x; }
					if ( y > maxY ) { maxY = y; }

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

		} else {

			for ( i = end - dim; i >= start; i -= dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points
	function filterPoints( start, end ) {

		if ( ! start ) { return start; }
		if ( ! end ) { end = start; }

		var p = start,
			again;
		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) { break; }
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) { return; }

		// interlink polygon nodes in z-order
		if ( ! pass && invSize ) { indexCurve( ear, minX, minY, invSize ); }

		var stop = ear,
			prev, next;

		// iterate through ears, slicing them one by one
		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertex leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears
			if ( ear === stop ) {

				// try filtering points and slicing again
				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) { return false; }
			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed
		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;
		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		var p = ear.prevZ,
			n = ear.nextZ;

		// look for points inside the triangle in both directions
		while ( p && p.z >= minZ && n && n.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) { return false; }
			p = p.prevZ;

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) { return false; }
			n = n.nextZ;

		}

		// look for remaining points in decreasing z-order
		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) { return false; }
			p = p.prevZ;

		}

		// look for remaining points in increasing z-order
		while ( n && n.z <= maxZ ) {

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) { return false; }
			n = n.nextZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;
		do {

			var a = p.prev,
				b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved
				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return filterPoints( p );

	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two
		var a = start;
		do {

			var b = a.next.next;
			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal
					var c = splitPolygon( a, b );

					// filter colinear points around the cuts
					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half
					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [];
		var i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) { list.steiner = true; }
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right
		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );
		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			// filter collinear points around the cuts
			filterPoints( outerNode, outerNode.next );
			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge( hole, outerNode ) {

		var p = outerNode;
		var hx = hole.x;
		var hy = hole.y;
		var qx = - Infinity, m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
				if ( x <= hx && x > qx ) {

					qx = x;
					if ( x === hx ) {

						if ( hy === p.y ) { return p; }
						if ( hy === p.next.y ) { return p.next; }

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) { return null; }

		if ( hx === qx ) { return m; } // hole touches outer segment; pick leftmost endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y;
		var tanMin = Infinity, tan;

		p = m;

		do {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
					pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		} while ( p !== stop );

		return m;

	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector( m, p ) {

		return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

	}

	// interlink polygon nodes in z-order
	function indexCurve( start, minX, minY, invSize ) {

		var p = start;
		do {

			if ( p.z === null ) { p.z = zOrder( p.x, p.y, minX, minY, invSize ); }
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;
				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) { break; }

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) { tail.nextZ = e; }
					else { list = e; }

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring
	function getLeftmost( start ) {

		var p = start,
			leftmost = start;
		do {

			if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) { leftmost = p; }
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle
	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
				( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
				( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
			( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
			( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
			equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

	}

	// signed area of a triangle
	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal
	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect
	function intersects( p1, q1, p2, q2 ) {

		var o1 = sign( area( p1, q1, p2 ) );
		var o2 = sign( area( p1, q1, q2 ) );
		var o3 = sign( area( p2, q2, p1 ) );
		var o4 = sign( area( p2, q2, q1 ) );

		if ( o1 !== o2 && o3 !== o4 ) { return true; } // general case

		if ( o1 === 0 && onSegment( p1, p2, q1 ) ) { return true; } // p1, q1 and p2 are collinear and p2 lies on p1q1
		if ( o2 === 0 && onSegment( p1, q2, q1 ) ) { return true; } // p1, q1 and q2 are collinear and q2 lies on p1q1
		if ( o3 === 0 && onSegment( p2, p1, q2 ) ) { return true; } // p2, q2 and p1 are collinear and p1 lies on p2q2
		if ( o4 === 0 && onSegment( p2, q1, q2 ) ) { return true; } // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;

	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment( p, q, r ) {

		return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

	}

	function sign( num ) {

		return num > 0 ? 1 : num < 0 ? - 1 : 0;

	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon( a, b ) {

		var p = a;
		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
					intersects( p, p.next, a, b ) ) { return true; }
			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside( a, b ) {

		var p = a,
			inside = false;
		var px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
					( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
				{ inside = ! inside; }
			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) { p.prevZ.nextZ = p.nextZ; }
		if ( p.nextZ ) { p.nextZ.prevZ = p.prevZ; }

	}

	function Node( i, x, y ) {

		// vertex index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertex nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;
		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i$1 = 0; i$1 < triangles.length; i$1 += 3 ) {

				faces.push( triangles.slice( i$1, i$1 + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	var ExtrudeGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function ExtrudeGeometry( shapes, options ) {

			BufferGeometry.call(this);

			this.type = 'ExtrudeGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			var scope = this;

			var verticesArray = [];
			var uvArray = [];

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];
				addShape( shape );

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

			this.computeVertexNormals();

			// functions

			function addShape( shape ) {

				var placeholder = [];

				// options

				var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				var steps = options.steps !== undefined ? options.steps : 1;
				var depth = options.depth !== undefined ? options.depth : 100;

				var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				var extrudePath = options.extrudePath;

				var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				// deprecated options

				if ( options.amount !== undefined ) {

					console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
					depth = options.amount;

				}

				//

				var extrudePts, extrudeByPath = false;
				var splineTube, binormal, normal, position2;

				if ( extrudePath ) {

					extrudePts = extrudePath.getSpacedPoints( steps );

					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames( steps, false );

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();

				}

				// Safeguards if bevels are not enabled

				if ( ! bevelEnabled ) {

					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;

				}

				// Variables initialization

				var shapePoints = shape.extractPoints( curveSegments );

				var vertices = shapePoints.shape;
				var holes = shapePoints.holes;

				var reverse = ! ShapeUtils.isClockWise( vertices );

				if ( reverse ) {

					vertices = vertices.reverse();

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

						var ahole = holes[ h ];

						if ( ShapeUtils.isClockWise( ahole ) ) {

							holes[ h ] = ahole.reverse();

						}

					}

				}


				var faces = ShapeUtils.triangulateShape( vertices, holes );

				/* Vertices */

				var contour = vertices; // vertices has all points but contour has only points of circumference

				for ( var h$1 = 0, hl$1 = holes.length; h$1 < hl$1; h$1 ++ ) {

					var ahole$1 = holes[ h$1 ];

					vertices = vertices.concat( ahole$1 );

				}


				function scalePt2( pt, vec, size ) {

					if ( ! vec ) { console.error( 'THREE.ExtrudeGeometry: vec does not exist' ); }

					return vec.clone().multiplyScalar( size ).add( pt );

				}

				var vlen = vertices.length, flen = faces.length;


				// Find directions for point movement


				function getBevelVec( inPt, inPrev, inNext ) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					var v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					var v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;

					var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

					// check for collinear edges
					var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					if ( Math.abs( collinear0 ) > Number.EPSILON ) {

						// not collinear

						// length of vectors for normalizing

						var v_prev_len = Math.sqrt( v_prev_lensq );
						var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

						// shift adjacent points by unit vectors to the left

						var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
						var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

						var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
						var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

						// scaling factor for v_prev to intersection point

						var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
							( v_prev_x * v_next_y - v_prev_y * v_next_x );

						// vector from inPt to intersection point

						v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
						v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
						if ( v_trans_lensq <= 2 ) {

							return new Vector2( v_trans_x, v_trans_y );

						} else {

							shrink_by = Math.sqrt( v_trans_lensq / 2 );

						}

					} else {

						// handle special case of collinear edges

						var direction_eq = false; // assumes: opposite

						if ( v_prev_x > Number.EPSILON ) {

							if ( v_next_x > Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( v_prev_x < - Number.EPSILON ) {

								if ( v_next_x < - Number.EPSILON ) {

									direction_eq = true;

								}

							} else {

								if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

									direction_eq = true;

								}

							}

						}

						if ( direction_eq ) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt( v_prev_lensq );

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt( v_prev_lensq / 2 );

						}

					}

					return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

				}


				var contourMovements = [];

				for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) { j = 0; }
					if ( k === il ) { k = 0; }

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

				}

				var holesMovements = [];
				var oneHoleMovements, verticesMovements = contourMovements.concat();

				for ( var h$2 = 0, hl$2 = holes.length; h$2 < hl$2; h$2 ++ ) {

					var ahole$2 = holes[ h$2 ];

					oneHoleMovements = [];

					for ( var i$1 = 0, il$1 = ahole$2.length, j$1 = il$1 - 1, k$1 = i$1 + 1; i$1 < il$1; i$1 ++, j$1 ++, k$1 ++ ) {

						if ( j$1 === il$1 ) { j$1 = 0; }
						if ( k$1 === il$1 ) { k$1 = 0; }

						//  (j)---(i)---(k)
						oneHoleMovements[ i$1 ] = getBevelVec( ahole$2[ i$1 ], ahole$2[ j$1 ], ahole$2[ k$1 ] );

					}

					holesMovements.push( oneHoleMovements );
					verticesMovements = verticesMovements.concat( oneHoleMovements );

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( var b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					var t = b / bevelSegments;
					var z = bevelThickness * Math.cos( t * Math.PI / 2 );
					var bs$1 = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( var i$2 = 0, il$2 = contour.length; i$2 < il$2; i$2 ++ ) {

						var vert = scalePt2( contour[ i$2 ], contourMovements[ i$2 ], bs$1 );

						v( vert.x, vert.y, - z );

					}

					// expand holes

					for ( var h$3 = 0, hl$3 = holes.length; h$3 < hl$3; h$3 ++ ) {

						var ahole$3 = holes[ h$3 ];
						oneHoleMovements = holesMovements[ h$3 ];

						for ( var i$3 = 0, il$3 = ahole$3.length; i$3 < il$3; i$3 ++ ) {

							var vert$1 = scalePt2( ahole$3[ i$3 ], oneHoleMovements[ i$3 ], bs$1 );

							v( vert$1.x, vert$1.y, - z );

						}

					}

				}

				var bs = bevelSize + bevelOffset;

				// Back facing vertices

				for ( var i$4 = 0; i$4 < vlen; i$4 ++ ) {

					var vert$2 = bevelEnabled ? scalePt2( vertices[ i$4 ], verticesMovements[ i$4 ], bs ) : vertices[ i$4 ];

					if ( ! extrudeByPath ) {

						v( vert$2.x, vert$2.y, 0 );

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert$2.x );
						binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert$2.y );

						position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				for ( var s = 1; s <= steps; s ++ ) {

					for ( var i$5 = 0; i$5 < vlen; i$5 ++ ) {

						var vert$3 = bevelEnabled ? scalePt2( vertices[ i$5 ], verticesMovements[ i$5 ], bs ) : vertices[ i$5 ];

						if ( ! extrudeByPath ) {

							v( vert$3.x, vert$3.y, depth / steps * s );

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert$3.x );
							binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert$3.y );

							position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

							v( position2.x, position2.y, position2.z );

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for ( var b$1 = bevelSegments - 1; b$1 >= 0; b$1 -- ) {

					var t$1 = b$1 / bevelSegments;
					var z$1 = bevelThickness * Math.cos( t$1 * Math.PI / 2 );
					var bs$2 = bevelSize * Math.sin( t$1 * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( var i$6 = 0, il$4 = contour.length; i$6 < il$4; i$6 ++ ) {

						var vert$4 = scalePt2( contour[ i$6 ], contourMovements[ i$6 ], bs$2 );
						v( vert$4.x, vert$4.y, depth + z$1 );

					}

					// expand holes

					for ( var h$4 = 0, hl$4 = holes.length; h$4 < hl$4; h$4 ++ ) {

						var ahole$4 = holes[ h$4 ];
						oneHoleMovements = holesMovements[ h$4 ];

						for ( var i$7 = 0, il$5 = ahole$4.length; i$7 < il$5; i$7 ++ ) {

							var vert$5 = scalePt2( ahole$4[ i$7 ], oneHoleMovements[ i$7 ], bs$2 );

							if ( ! extrudeByPath ) {

								v( vert$5.x, vert$5.y, depth + z$1 );

							} else {

								v( vert$5.x, vert$5.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z$1 );

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces();

				// Sides faces

				buildSideFaces();


				/////  Internal functions

				function buildLidFaces() {

					var start = verticesArray.length / 3;

					if ( bevelEnabled ) {

						var layer = 0; // steps + 1
						var offset = vlen * layer;

						// Bottom faces

						for ( var i = 0; i < flen; i ++ ) {

							var face = faces[ i ];
							f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer;

						// Top faces

						for ( var i$1 = 0; i$1 < flen; i$1 ++ ) {

							var face$1 = faces[ i$1 ];
							f3( face$1[ 0 ] + offset, face$1[ 1 ] + offset, face$1[ 2 ] + offset );

						}

					} else {

						// Bottom faces

						for ( var i$2 = 0; i$2 < flen; i$2 ++ ) {

							var face$2 = faces[ i$2 ];
							f3( face$2[ 2 ], face$2[ 1 ], face$2[ 0 ] );

						}

						// Top faces

						for ( var i$3 = 0; i$3 < flen; i$3 ++ ) {

							var face$3 = faces[ i$3 ];
							f3( face$3[ 0 ] + vlen * steps, face$3[ 1 ] + vlen * steps, face$3[ 2 ] + vlen * steps );

						}

					}

					scope.addGroup( start, verticesArray.length / 3 - start, 0 );

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces() {

					var start = verticesArray.length / 3;
					var layeroffset = 0;
					sidewalls( contour, layeroffset );
					layeroffset += contour.length;

					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

						var ahole = holes[ h ];
						sidewalls( ahole, layeroffset );

						//, true
						layeroffset += ahole.length;

					}


					scope.addGroup( start, verticesArray.length / 3 - start, 1 );


				}

				function sidewalls( contour, layeroffset ) {

					var i = contour.length;

					while ( -- i >= 0 ) {

						var j = i;
						var k = i - 1;
						if ( k < 0 ) { k = contour.length - 1; }

						//console.log('b', i,j, i-1, k,vertices.length);

						for ( var s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

							var slen1 = vlen * s;
							var slen2 = vlen * ( s + 1 );

							var a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;

							f4( a, b, c, d );

						}

					}

				}

				function v( x, y, z ) {

					placeholder.push( x );
					placeholder.push( y );
					placeholder.push( z );

				}


				function f3( a, b, c ) {

					addVertex( a );
					addVertex( b );
					addVertex( c );

					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );

				}

				function f4( a, b, c, d ) {

					addVertex( a );
					addVertex( b );
					addVertex( d );

					addVertex( b );
					addVertex( c );
					addVertex( d );


					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 3 ] );

					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );
					addUV( uvs[ 3 ] );

				}

				function addVertex( index ) {

					verticesArray.push( placeholder[ index * 3 + 0 ] );
					verticesArray.push( placeholder[ index * 3 + 1 ] );
					verticesArray.push( placeholder[ index * 3 + 2 ] );

				}


				function addUV( vector2 ) {

					uvArray.push( vector2.x );
					uvArray.push( vector2.y );

				}

			}

		}

		if ( BufferGeometry ) ExtrudeGeometry.__proto__ = BufferGeometry;
		ExtrudeGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

		ExtrudeGeometry.prototype.toJSON = function toJSON () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			var shapes = this.parameters.shapes;
			var options = this.parameters.options;

			return toJSON$1( shapes, options, data );

		};

		return ExtrudeGeometry;
	}(BufferGeometry));

	var WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}

	};

	function toJSON$1( shapes, options, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		if ( options.extrudePath !== undefined ) { data.options.extrudePath = options.extrudePath.toJSON(); }

		return data;

	}

	var OctahedronGeometry = /*@__PURE__*/(function (PolyhedronGeometry) {
		function OctahedronGeometry( radius, detail ) {
			if ( radius === void 0 ) radius = 1;
			if ( detail === void 0 ) detail = 0;


			var vertices = [
				1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
				0, - 1, 0, 	0, 0, 1,	0, 0, - 1
			];

			var indices = [
				0, 2, 4,	0, 4, 3,	0, 3, 5,
				0, 5, 2,	1, 2, 5,	1, 5, 3,
				1, 3, 4,	1, 4, 2
			];

			PolyhedronGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		if ( PolyhedronGeometry ) OctahedronGeometry.__proto__ = PolyhedronGeometry;
		OctahedronGeometry.prototype = Object.create( PolyhedronGeometry && PolyhedronGeometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;

		return OctahedronGeometry;
	}(PolyhedronGeometry));

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	function ParametricGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( var i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( var j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( var i$1 = 0; i$1 < stacks; i$1 ++ ) {

			for ( var j$1 = 0; j$1 < slices; j$1 ++ ) {

				var a = i$1 * sliceCount + j$1;
				var b = i$1 * sliceCount + j$1 + 1;
				var c = ( i$1 + 1 ) * sliceCount + j$1 + 1;
				var d = ( i$1 + 1 ) * sliceCount + j$1;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	var SphereGeometry = /*@__PURE__*/(function (BufferGeometry) {
		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
			if ( radius === void 0 ) radius = 1;
			if ( widthSegments === void 0 ) widthSegments = 8;
			if ( heightSegments === void 0 ) heightSegments = 6;
			if ( phiStart === void 0 ) phiStart = 0;
			if ( phiLength === void 0 ) phiLength = Math.PI * 2;
			if ( thetaStart === void 0 ) thetaStart = 0;
			if ( thetaLength === void 0 ) thetaLength = Math.PI;


			BufferGeometry.call(this);
			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			var index = 0;
			var grid = [];

			var vertex = new Vector3();
			var normal = new Vector3();

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// generate vertices, normals and uvs

			for ( var iy = 0; iy <= heightSegments; iy ++ ) {

				var verticesRow = [];

				var v = iy / heightSegments;

				// special case for the poles

				var uOffset = 0;

				if ( iy == 0 && thetaStart == 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( var ix = 0; ix <= widthSegments; ix ++ ) {

					var u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( var iy$1 = 0; iy$1 < heightSegments; iy$1 ++ ) {

				for ( var ix$1 = 0; ix$1 < widthSegments; ix$1 ++ ) {

					var a = grid[ iy$1 ][ ix$1 + 1 ];
					var b = grid[ iy$1 ][ ix$1 ];
					var c = grid[ iy$1 + 1 ][ ix$1 ];
					var d = grid[ iy$1 + 1 ][ ix$1 + 1 ];

					if ( iy$1 !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }
					if ( iy$1 !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		if ( BufferGeometry ) SphereGeometry.__proto__ = BufferGeometry;
		SphereGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;

		return SphereGeometry;
	}(BufferGeometry));

	/**
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	var ShadowMaterial = /*@__PURE__*/(function (Material) {
		function ShadowMaterial( parameters ) {

			Material.call(this);

			this.type = 'ShadowMaterial';

			this.color = new Color( 0x000000 );
			this.transparent = true;

			this.setValues( parameters );

		}

		if ( Material ) ShadowMaterial.__proto__ = Material;
		ShadowMaterial.prototype = Object.create( Material && Material.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;

		ShadowMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			return this;

		};

		return ShadowMaterial;
	}(Material));

	ShadowMaterial.prototype.isShadowMaterial = true;

	var RawShaderMaterial = /*@__PURE__*/(function (ShaderMaterial) {
		function RawShaderMaterial( parameters ) {

			ShaderMaterial.call( this, parameters );

			this.type = 'RawShaderMaterial';

		}

		if ( ShaderMaterial ) RawShaderMaterial.__proto__ = ShaderMaterial;
		RawShaderMaterial.prototype = Object.create( ShaderMaterial && ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;

		return RawShaderMaterial;
	}(ShaderMaterial));

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.vertexTangents = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		this.vertexTangents = source.vertexTangents;

		return this;

	};

	/**
	 * parameters = {
	 *  clearcoat: <float>,
	 *  clearcoatMap: new THREE.Texture( <Image> ),
	 *  clearcoatRoughness: <float>,
	 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *  clearcoatNormalScale: <Vector2>,
	 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *  reflectivity: <float>,
	 *  ior: <float>,
	 *
	 *  sheen: <Color>,
	 *
	 *  transmission: <float>,
	 *  transmissionMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoat = 0.0;
		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.reflectivity = 0.5; // maps to F0 = 0.04

		Object.defineProperty( this, 'ior', {
			get: function () {

				return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

			},
			set: function ( ior ) {

				this.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

			}
		} );

		this.sheen = null; // null will disable sheen bsdf

		this.transmission = 0.0;
		this.transmissionMap = null;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.reflectivity = source.reflectivity;

		if ( source.sheen ) {

			this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

		} else {

			this.sheen = null;

		}

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		return this;

	};

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.MultiplyOperation,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	var MeshPhongMaterial = /*@__PURE__*/(function (Material) {
		function MeshPhongMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshPhongMaterial.__proto__ = Material;
		MeshPhongMaterial.prototype = Object.create( Material && Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

		MeshPhongMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		};

		return MeshPhongMaterial;
	}(Material));

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *  gradientMap: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	var MeshToonMaterial = /*@__PURE__*/(function (Material) {
		function MeshToonMaterial( parameters ) {

			Material.call(this);

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshToonMaterial.__proto__ = Material;
		MeshToonMaterial.prototype = Object.create( Material && Material.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;

		MeshToonMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		return MeshToonMaterial;
	}(Material));

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	var MeshNormalMaterial = /*@__PURE__*/(function (Material) {
		function MeshNormalMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshNormalMaterial.__proto__ = Material;
		MeshNormalMaterial.prototype = Object.create( Material && Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

		MeshNormalMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		};

		return MeshNormalMaterial;
	}(Material));

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	var MeshLambertMaterial = /*@__PURE__*/(function (Material) {
		function MeshLambertMaterial( parameters ) {

			Material.call(this);

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshLambertMaterial.__proto__ = Material;
		MeshLambertMaterial.prototype = Object.create( Material && Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

		MeshLambertMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		return MeshLambertMaterial;
	}(Material));

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 *
	 *  flatShading: <bool>
	 * }
	 */

	var MeshMatcapMaterial = /*@__PURE__*/(function (Material) {
		function MeshMatcapMaterial( parameters ) {

			Material.call(this);

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		if ( Material ) MeshMatcapMaterial.__proto__ = Material;
		MeshMatcapMaterial.prototype = Object.create( Material && Material.prototype );
		MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;


		MeshMatcapMaterial.prototype.copy = function copy ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		};

		return MeshMatcapMaterial;
	}(Material));

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	var LineDashedMaterial = /*@__PURE__*/(function (LineBasicMaterial) {
		function LineDashedMaterial( parameters ) {

			LineBasicMaterial.call(this);

			this.type = 'LineDashedMaterial';

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.setValues( parameters );

		}

		if ( LineBasicMaterial ) LineDashedMaterial.__proto__ = LineBasicMaterial;
		LineDashedMaterial.prototype = Object.create( LineBasicMaterial && LineBasicMaterial.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;

		LineDashedMaterial.prototype.copy = function copy ( source ) {

			LineBasicMaterial.prototype.copy.call( this, source );

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		};

		return LineDashedMaterial;
	}(LineBasicMaterial));

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) { return array; }

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) { return; } // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) { return; } // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		},

		subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {
			if ( fps === void 0 ) fps = 30;


			var clip = sourceClip.clone();

			clip.name = name;

			var tracks = [];

			for ( var i = 0; i < clip.tracks.length; ++ i ) {

				var track = clip.tracks[ i ];
				var valueSize = track.getValueSize();

				var times = [];
				var values = [];

				for ( var j = 0; j < track.times.length; ++ j ) {

					var frame = track.times[ j ] * fps;

					if ( frame < startFrame || frame >= endFrame ) { continue; }

					times.push( track.times[ j ] );

					for ( var k = 0; k < valueSize; ++ k ) {

						values.push( track.values[ j * valueSize + k ] );

					}

				}

				if ( times.length === 0 ) { continue; }

				track.times = AnimationUtils.convertArray( times, track.times.constructor );
				track.values = AnimationUtils.convertArray( values, track.values.constructor );

				tracks.push( track );

			}

			clip.tracks = tracks;

			// find minimum .times value across all tracks in the trimmed clip

			var minStartTime = Infinity;

			for ( var i$1 = 0; i$1 < clip.tracks.length; ++ i$1 ) {

				if ( minStartTime > clip.tracks[ i$1 ].times[ 0 ] ) {

					minStartTime = clip.tracks[ i$1 ].times[ 0 ];

				}

			}

			// shift all tracks such that clip begins at t=0

			for ( var i$2 = 0; i$2 < clip.tracks.length; ++ i$2 ) {

				clip.tracks[ i$2 ].shift( - 1 * minStartTime );

			}

			clip.resetDuration();

			return clip;

		},

		makeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {
			if ( referenceFrame === void 0 ) referenceFrame = 0;
			if ( referenceClip === void 0 ) referenceClip = targetClip;
			if ( fps === void 0 ) fps = 30;


			if ( fps <= 0 ) { fps = 30; }

			var numTracks = referenceClip.tracks.length;
			var referenceTime = referenceFrame / fps;

			// Make each track's values relative to the values at the reference frame
			var loop = function ( i ) {

				var referenceTrack = referenceClip.tracks[ i ];
				var referenceTrackType = referenceTrack.ValueTypeName;

				// Skip this track if it's non-numeric
				if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) { return; }

				// Find the track in the target clip whose name and type matches the reference track
				var targetTrack = targetClip.tracks.find( function ( track ) {

					return track.name === referenceTrack.name
						&& track.ValueTypeName === referenceTrackType;

				} );

				if ( targetTrack === undefined ) { return; }

				var referenceOffset = 0;
				var referenceValueSize = referenceTrack.getValueSize();

				if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					referenceOffset = referenceValueSize / 3;

				}

				var targetOffset = 0;
				var targetValueSize = targetTrack.getValueSize();

				if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					targetOffset = targetValueSize / 3;

				}

				var lastIndex = referenceTrack.times.length - 1;
				var referenceValue = (void 0);

				// Find the value to subtract out of the track
				if ( referenceTime <= referenceTrack.times[ 0 ] ) {

					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					var startIndex = referenceOffset;
					var endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

				} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

					// Reference frame is after the last keyframe, so just use the last keyframe
					var startIndex$1 = lastIndex * referenceValueSize + referenceOffset;
					var endIndex$1 = startIndex$1 + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex$1, endIndex$1 );

				} else {

					// Interpolate to the reference value
					var interpolant = referenceTrack.createInterpolant();
					var startIndex$2 = referenceOffset;
					var endIndex$2 = referenceValueSize - referenceOffset;
					interpolant.evaluate( referenceTime );
					referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex$2, endIndex$2 );

				}

				// Conjugate the quaternion
				if ( referenceTrackType === 'quaternion' ) {

					var referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
					referenceQuat.toArray( referenceValue );

				}

				// Subtract the reference value from all of the track values

				var numTimes = targetTrack.times.length;
				for ( var j = 0; j < numTimes; ++ j ) {

					var valueStart = j * targetValueSize + targetOffset;

					if ( referenceTrackType === 'quaternion' ) {

						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(
							targetTrack.values,
							valueStart,
							referenceValue,
							0,
							targetTrack.values,
							valueStart
						);

					} else {

						var valueEnd = targetValueSize - targetOffset * 2;

						// Subtract each value for all other numeric track types
						for ( var k = 0; k < valueEnd; ++ k ) {

							targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

						}

					}

				}

			};

			for ( var i = 0; i < numTracks; ++ i ) loop( i );

			targetClip.blendMode = AdditiveAnimationBlendMode;

			return targetClip;

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions;
			var i1 = this._cachedIndex,
				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) { break forward_scan; }

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) { break; } // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt$1 = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt$1 ) { break; } // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	// DECLARE ALIAS AFTER assign prototype
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions;
			var iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	var KeyframeTrack = function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) { throw new Error( 'THREE.KeyframeTrack: track name is undefined' ); }
		if ( times === undefined || times.length === 0 ) { throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name ); }

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	};

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	KeyframeTrack.toJSON = function toJSON ( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	};

	KeyframeTrack.prototype.InterpolantFactoryMethodDiscrete = function InterpolantFactoryMethodDiscrete ( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	};

	KeyframeTrack.prototype.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear ( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	};

	KeyframeTrack.prototype.InterpolantFactoryMethodSmooth = function InterpolantFactoryMethodSmooth ( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	};

	KeyframeTrack.prototype.setInterpolation = function setInterpolation ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	};

	KeyframeTrack.prototype.getInterpolation = function getInterpolation () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	};

	KeyframeTrack.prototype.getValueSize = function getValueSize () {

		return this.values.length / this.times.length;

	};

	// move all keyframes either forwards or backwards in time
	KeyframeTrack.prototype.shift = function shift ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	};

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	KeyframeTrack.prototype.scale = function scale ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	};

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	KeyframeTrack.prototype.trim = function trim ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length;

		var from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	};

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	KeyframeTrack.prototype.validate = function validate () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i$1 = 0, n = values.length; i$1 !== n; ++ i$1 ) {

					var value = values[ i$1 ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i$1, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	};

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	KeyframeTrack.prototype.optimize = function optimize () {

		// times or values may be shared with other tracks, so overwriting is unsafe
		var times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		var writeIndex = 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j$1 = 0; j$1 !== stride; ++ j$1 ) {

						values[ writeOffset + j$1 ] = values[ readOffset + j$1 ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset$1 = lastIndex * stride, writeOffset$1 = writeIndex * stride, j$2 = 0; j$2 !== stride; ++ j$2 ) {

				values[ writeOffset$1 + j$2 ] = values[ readOffset$1 + j$2 ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	};

	KeyframeTrack.prototype.clone = function clone () {

		var times = AnimationUtils.arraySlice( this.times, 0 );
		var values = AnimationUtils.arraySlice( this.values, 0 );

		var TypedKeyframeTrack = this.constructor;
		var track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	};

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */
	var BooleanKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function BooleanKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}if ( KeyframeTrack ) BooleanKeyframeTrack.__proto__ = KeyframeTrack;
		BooleanKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		BooleanKeyframeTrack.prototype.constructor = BooleanKeyframeTrack;

		

		return BooleanKeyframeTrack;
	}(KeyframeTrack));

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of keyframe values that represent color.
	 */
	var ColorKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function ColorKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}if ( KeyframeTrack ) ColorKeyframeTrack.__proto__ = KeyframeTrack;
		ColorKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		ColorKeyframeTrack.prototype.constructor = ColorKeyframeTrack;

		

		return ColorKeyframeTrack;
	}(KeyframeTrack));

	ColorKeyframeTrack.prototype.ValueTypeName = 'color';

	/**
	 * A Track of numeric keyframe values.
	 */
	var NumberKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function NumberKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}if ( KeyframeTrack ) NumberKeyframeTrack.__proto__ = KeyframeTrack;
		NumberKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		NumberKeyframeTrack.prototype.constructor = NumberKeyframeTrack;

		

		return NumberKeyframeTrack;
	}(KeyframeTrack));

	NumberKeyframeTrack.prototype.ValueTypeName = 'number';

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				alpha = ( t - t0 ) / ( t1 - t0 );

			var offset = i1 * stride;

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 * A Track of quaternion keyframe values.
	 */
	var QuaternionKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function QuaternionKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}

		if ( KeyframeTrack ) QuaternionKeyframeTrack.__proto__ = KeyframeTrack;
		QuaternionKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		QuaternionKeyframeTrack.prototype.constructor = QuaternionKeyframeTrack;

		QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		};

		return QuaternionKeyframeTrack;
	}(KeyframeTrack));

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */
	var StringKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function StringKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}if ( KeyframeTrack ) StringKeyframeTrack.__proto__ = KeyframeTrack;
		StringKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		StringKeyframeTrack.prototype.constructor = StringKeyframeTrack;

		

		return StringKeyframeTrack;
	}(KeyframeTrack));

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */
	var VectorKeyframeTrack = /*@__PURE__*/(function (KeyframeTrack) {
		function VectorKeyframeTrack () {
			KeyframeTrack.apply(this, arguments);
		}if ( KeyframeTrack ) VectorKeyframeTrack.__proto__ = KeyframeTrack;
		VectorKeyframeTrack.prototype = Object.create( KeyframeTrack && KeyframeTrack.prototype );
		VectorKeyframeTrack.prototype.constructor = VectorKeyframeTrack;

		

		return VectorKeyframeTrack;
	}(KeyframeTrack));

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

	var AnimationClip = function AnimationClip( name, duration, tracks, blendMode ) {
		if ( duration === void 0 ) duration = - 1;
		if ( blendMode === void 0 ) blendMode = NormalAnimationBlendMode;


		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = MathUtils.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	};


	AnimationClip.parse = function parse ( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		var clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	};

	AnimationClip.toJSON = function toJSON ( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	};

	AnimationClip.CreateFromMorphTargetSequence = function CreateFromMorphTargetSequence ( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	};

	AnimationClip.findByName = function findByName ( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	};

	AnimationClip.CreateClipsFromMorphTargetSequences = function CreateClipsFromMorphTargetSequences ( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name$1 in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name$1, animationToMorphTargets[ name$1 ], fps, noLoop ) );

		}

		return clips;

	};

	// parse the animation.hierarchy format
	AnimationClip.parseAnimation = function parseAnimation ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		var fps = animation.fps || 30;
		var blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		var duration = animation.length || - 1;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) { continue; }

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};

				var k = (void 0);

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m$1 = 0; m$1 !== animationKeys[ k ].morphTargets.length; ++ m$1 ) {

						var animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	};

	AnimationClip.prototype.resetDuration = function resetDuration () {

		var tracks = this.tracks;
		var duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	};

	AnimationClip.prototype.trim = function trim () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	};

	AnimationClip.prototype.validate = function validate () {

		var valid = true;

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	};

	AnimationClip.prototype.optimize = function optimize () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	};

	AnimationClip.prototype.clone = function clone () {

		var tracks = [];

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	};

	AnimationClip.prototype.toJSON = function toJSON () {

		return this.constructor.toJSON( this );

	};

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		var trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) { return; }

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) { return; }

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
		var handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			var index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.global ) { regex.lastIndex = 0; } // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	function Loader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	Object.assign( Loader.prototype, {

		load: function ( /* url, onLoad, onProgress, onError */ ) {},

		loadAsync: function ( url, onProgress ) {

			var scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		},

		parse: function ( /* data */ ) {},

		setCrossOrigin: function ( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setPath: function ( path ) {

			this.path = path;
			return this;

		},

		setResourcePath: function ( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		},

		setRequestHeader: function ( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	} );

	var loading = {};

	function FileLoader( manager ) {

		Loader.call( this, manager );

	}

	FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: FileLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) { url = ''; }

			if ( this.path !== undefined ) { url = this.path + url; }

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) { onLoad( cached ); }

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );
			var request;

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];

				var data = dataUriRegexResult[ 3 ];
				data = decodeURIComponent( data );

				if ( isBase64 ) { data = atob( data ); }

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) { onLoad( response ); }

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) { onError( error ); }

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) { console.warn( 'THREE.FileLoader: HTTP Status 0 received.' ); }

						// Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.
						Cache.add( url, response );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) { callback.onLoad( response ); }

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i$1 = 0, il$1 = callbacks.length; i$1 < il$1; i$1 ++ ) {

							var callback$1 = callbacks[ i$1 ];
							if ( callback$1.onError ) { callback$1.onError( event ); }

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) { callback.onProgress( event ); }

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) { callback.onError( event ); }

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) { callback.onError( event ); }

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) { request.responseType = this.responseType; }
				if ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }

				if ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		}

	} );

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function CompressedTextureLoader( manager ) {

		Loader.call( this, manager );

	}

	CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( scope.withCredentials );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope.parse( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 ) { texture.minFilter = LinearFilter; }

						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) { onLoad( texture ); }

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope.parse( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

						texture.image = images;

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) { onLoad( texture ); }

				}, onProgress, onError );

			}

			return texture;

		}

	} );

	var ImageLoader = /*@__PURE__*/(function (Loader) {
		function ImageLoader( manager ) {

			Loader.call( this, manager );

		}

		if ( Loader ) ImageLoader.__proto__ = Loader;
		ImageLoader.prototype = Object.create( Loader && Loader.prototype );
		ImageLoader.prototype.constructor = ImageLoader;

		ImageLoader.prototype.load = function load ( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) { url = this.path + url; }

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) { onLoad( cached ); }

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) { onLoad( this ); }

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) { onError( event ); }

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		};

		return ImageLoader;
	}(Loader));

	var CubeTextureLoader = /*@__PURE__*/(function (Loader) {
		function CubeTextureLoader( manager ) {

			Loader.call( this, manager );

		}

		if ( Loader ) CubeTextureLoader.__proto__ = Loader;
		CubeTextureLoader.prototype = Object.create( Loader && Loader.prototype );
		CubeTextureLoader.prototype.constructor = CubeTextureLoader;

		CubeTextureLoader.prototype.load = function load ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) { onLoad( texture ); }

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		};

		return CubeTextureLoader;
	}(Loader));

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function DataTextureLoader( manager ) {

		Loader.call( this, manager );

	}

	DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: DataTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setPath( this.path );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( buffer ) {

				var texData = scope.parse( buffer );

				if ( ! texData ) { return; }

				if ( texData.image !== undefined ) {

					texture.image = texData.image;

				} else if ( texData.data !== undefined ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if ( texData.encoding !== undefined ) {

					texture.encoding = texData.encoding;

				}

				if ( texData.flipY !== undefined ) {

					texture.flipY = texData.flipY;

				}

				if ( texData.format !== undefined ) {

					texture.format = texData.format;

				}

				if ( texData.type !== undefined ) {

					texture.type = texData.type;

				}

				if ( texData.mipmaps !== undefined ) {

					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...

				}

				if ( texData.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				if ( texData.generateMipmaps !== undefined ) {

					texture.generateMipmaps = texData.generateMipmaps;

				}

				texture.needsUpdate = true;

				if ( onLoad ) { onLoad( texture, texData ); }

			}, onProgress, onError );


			return texture;

		}

	} );

	function TextureLoader( manager ) {

		Loader.call( this, manager );

	}

	TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	} );

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {
			if ( divisions === void 0 ) divisions = 5;


			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {
			if ( divisions === void 0 ) divisions = 5;


			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) { divisions = this.arcLengthDivisions; }

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var sum = 0;

			cache.push( 0 );

			for ( var p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0;
			var il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t, optionalTarget ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) { t1 = 0; }
			if ( t2 > 1 ) { t2 = 1; }

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

			tangent.copy( pt2 ).sub( pt1 ).normalize();

			return tangent;

		},

		getTangentAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t, optionalTarget );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			// compute the tangent vectors for each segment on the curve

			for ( var i = 0; i <= segments; i ++ ) {

				var u = i / segments;

				tangents[ i ] = this.getTangentAt( u, new Vector3() );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( var i$1 = 1; i$1 <= segments; i$1 ++ ) {

				normals[ i$1 ] = normals[ i$1 - 1 ].clone();

				binormals[ i$1 ] = binormals[ i$1 - 1 ].clone();

				vec.crossVectors( tangents[ i$1 - 1 ], tangents[ i$1 ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					var theta = Math.acos( MathUtils.clamp( tangents[ i$1 - 1 ].dot( tangents[ i$1 ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i$1 ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i$1 ].crossVectors( tangents[ i$1 ], normals[ i$1 ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				var theta$1 = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta$1 /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta$1 = - theta$1;

				}

				for ( var i$2 = 1; i$2 <= segments; i$2 ++ ) {

					// twist a little...
					normals[ i$2 ].applyMatrix4( mat.makeRotationAxis( tangents[ i$2 ], theta$1 * i$2 ) );
					binormals[ i$2 ].crossVectors( tangents[ i$2 ], normals[ i$2 ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	var EllipseCurve = /*@__PURE__*/(function (Curve) {
		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
			if ( aX === void 0 ) aX = 0;
			if ( aY === void 0 ) aY = 0;
			if ( xRadius === void 0 ) xRadius = 1;
			if ( yRadius === void 0 ) yRadius = 1;
			if ( aStartAngle === void 0 ) aStartAngle = 0;
			if ( aEndAngle === void 0 ) aEndAngle = Math.PI * 2;
			if ( aClockwise === void 0 ) aClockwise = false;
			if ( aRotation === void 0 ) aRotation = 0;


			Curve.call(this);

			this.type = 'EllipseCurve';

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation;

		}

		if ( Curve ) EllipseCurve.__proto__ = Curve;
		EllipseCurve.prototype = Object.create( Curve && Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;

		EllipseCurve.prototype.getPoint = function getPoint ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) { deltaAngle += twoPi; }
			while ( deltaAngle > twoPi ) { deltaAngle -= twoPi; }

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );

				var tx = x - this.aX;
				var ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return point.set( x, y );

		};

		EllipseCurve.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.aX = source.aX;
			this.aY = source.aY;

			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;

			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;

			this.aClockwise = source.aClockwise;

			this.aRotation = source.aRotation;

			return this;

		};

		EllipseCurve.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.aX = this.aX;
			data.aY = this.aY;

			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;

			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;

			data.aClockwise = this.aClockwise;

			data.aRotation = this.aRotation;

			return data;

		};

		EllipseCurve.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.aX = json.aX;
			this.aY = json.aY;

			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;

			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;

			this.aClockwise = json.aClockwise;

			this.aRotation = json.aRotation;

			return this;

		};

		return EllipseCurve;
	}(Curve));

	EllipseCurve.prototype.isEllipseCurve = true;

	var ArcCurve = /*@__PURE__*/(function (EllipseCurve) {
		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			this.type = 'ArcCurve';

		}

		if ( EllipseCurve ) ArcCurve.__proto__ = EllipseCurve;
		ArcCurve.prototype = Object.create( EllipseCurve && EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;

		return ArcCurve;
	}(EllipseCurve));

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	var CatmullRomCurve3 = /*@__PURE__*/(function (Curve) {
		function CatmullRomCurve3( points, closed, curveType, tension ) {
			if ( points === void 0 ) points = [];
			if ( closed === void 0 ) closed = false;
			if ( curveType === void 0 ) curveType = 'centripetal';
			if ( tension === void 0 ) tension = 0.5;


			Curve.call(this);

			this.type = 'CatmullRomCurve3';

			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;

		}

		if ( Curve ) CatmullRomCurve3.__proto__ = Curve;
		CatmullRomCurve3.prototype = Object.create( Curve && Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

		CatmullRomCurve3.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector3();


			var point = optionalTarget;

			var points = this.points;
			var l = points.length;

			var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( p );
			var weight = p - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p3; // 4 points (p1 & p2 defined below)

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			var p1 = points[ intPoint % l ];
			var p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) { dt1 = 1.0; }
				if ( dt0 < 1e-4 ) { dt0 = dt1; }
				if ( dt2 < 1e-4 ) { dt2 = dt1; }

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.curveType === 'catmullrom' ) {

				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

			}

			point.set(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return point;

		};

		CatmullRomCurve3.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.points = [];

			for ( var i = 0, l = source.points.length; i < l; i ++ ) {

				var point = source.points[ i ];

				this.points.push( point.clone() );

			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;

			return this;

		};

		CatmullRomCurve3.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.points = [];

			for ( var i = 0, l = this.points.length; i < l; i ++ ) {

				var point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;

			return data;

		};

		CatmullRomCurve3.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.points = [];

			for ( var i = 0, l = json.points.length; i < l; i ++ ) {

				var point = json.points[ i ];
				this.points.push( new Vector3().fromArray( point ) );

			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;

			return this;

		};

		return CatmullRomCurve3;
	}(Curve));

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	var CubicBezierCurve = /*@__PURE__*/(function (Curve) {
		function CubicBezierCurve( v0, v1, v2, v3 ) {
			if ( v0 === void 0 ) v0 = new Vector2();
			if ( v1 === void 0 ) v1 = new Vector2();
			if ( v2 === void 0 ) v2 = new Vector2();
			if ( v3 === void 0 ) v3 = new Vector2();


			Curve.call(this);

			this.type = 'CubicBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		if ( Curve ) CubicBezierCurve.__proto__ = Curve;
		CubicBezierCurve.prototype = Object.create( Curve && Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;

		CubicBezierCurve.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector2();


			var point = optionalTarget;

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

			return point;

		};

		CubicBezierCurve.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		};

		CubicBezierCurve.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		};

		CubicBezierCurve.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		};

		return CubicBezierCurve;
	}(Curve));

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	var CubicBezierCurve3 = /*@__PURE__*/(function (Curve) {
		function CubicBezierCurve3( v0, v1, v2, v3 ) {
			if ( v0 === void 0 ) v0 = new Vector3();
			if ( v1 === void 0 ) v1 = new Vector3();
			if ( v2 === void 0 ) v2 = new Vector3();
			if ( v3 === void 0 ) v3 = new Vector3();


			Curve.call(this);

			this.type = 'CubicBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		if ( Curve ) CubicBezierCurve3.__proto__ = Curve;
		CubicBezierCurve3.prototype = Object.create( Curve && Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

		CubicBezierCurve3.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector3();


			var point = optionalTarget;

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

			return point;

		};

		CubicBezierCurve3.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		};

		CubicBezierCurve3.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		};

		CubicBezierCurve3.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		};

		return CubicBezierCurve3;
	}(Curve));

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	var LineCurve = /*@__PURE__*/(function (Curve) {
		function LineCurve( v1, v2 ) {
			if ( v1 === void 0 ) v1 = new Vector2();
			if ( v2 === void 0 ) v2 = new Vector2();


			Curve.call(this);

			this.type = 'LineCurve';

			this.v1 = v1;
			this.v2 = v2;

		}

		if ( Curve ) LineCurve.__proto__ = Curve;
		LineCurve.prototype = Object.create( Curve && Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;

		LineCurve.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector2();


			var point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt
		LineCurve.prototype.getPointAt = function getPointAt ( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		};

		LineCurve.prototype.getTangent = function getTangent ( t, optionalTarget ) {

			var tangent = optionalTarget || new Vector2();

			tangent.copy( this.v2 ).sub( this.v1 ).normalize();

			return tangent;

		};

		LineCurve.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		LineCurve.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		LineCurve.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		return LineCurve;
	}(Curve));

	LineCurve.prototype.isLineCurve = true;

	var LineCurve3 = /*@__PURE__*/(function (Curve) {
		function LineCurve3( v1, v2 ) {
			if ( v1 === void 0 ) v1 = new Vector3();
			if ( v2 === void 0 ) v2 = new Vector3();


			Curve.call(this);

			this.type = 'LineCurve3';
			this.isLineCurve3 = true;

			this.v1 = v1;
			this.v2 = v2;

		}

		if ( Curve ) LineCurve3.__proto__ = Curve;
		LineCurve3.prototype = Object.create( Curve && Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;
		LineCurve3.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector3();


			var point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		};
		// Line curve is linear, so we can overwrite default getPointAt
		LineCurve3.prototype.getPointAt = function getPointAt ( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		};
		LineCurve3.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};
		LineCurve3.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};
		LineCurve3.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		return LineCurve3;
	}(Curve));

	var QuadraticBezierCurve = /*@__PURE__*/(function (Curve) {
		function QuadraticBezierCurve( v0, v1, v2 ) {
			if ( v0 === void 0 ) v0 = new Vector2();
			if ( v1 === void 0 ) v1 = new Vector2();
			if ( v2 === void 0 ) v2 = new Vector2();


			Curve.call(this);

			this.type = 'QuadraticBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		if ( Curve ) QuadraticBezierCurve.__proto__ = Curve;
		QuadraticBezierCurve.prototype = Object.create( Curve && Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

		QuadraticBezierCurve.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector2();


			var point = optionalTarget;

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

			return point;

		};

		QuadraticBezierCurve.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		QuadraticBezierCurve.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		QuadraticBezierCurve.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		return QuadraticBezierCurve;
	}(Curve));

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	var QuadraticBezierCurve3 = /*@__PURE__*/(function (Curve) {
		function QuadraticBezierCurve3( v0, v1, v2 ) {
			if ( v0 === void 0 ) v0 = new Vector3();
			if ( v1 === void 0 ) v1 = new Vector3();
			if ( v2 === void 0 ) v2 = new Vector3();


			Curve.call(this);

			this.type = 'QuadraticBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		if ( Curve ) QuadraticBezierCurve3.__proto__ = Curve;
		QuadraticBezierCurve3.prototype = Object.create( Curve && Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

		QuadraticBezierCurve3.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector3();


			var point = optionalTarget;

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

			return point;

		};

		QuadraticBezierCurve3.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		QuadraticBezierCurve3.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		QuadraticBezierCurve3.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		return QuadraticBezierCurve3;
	}(Curve));

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	var SplineCurve = /*@__PURE__*/(function (Curve) {
		function SplineCurve( points ) {
			if ( points === void 0 ) points = [];


			Curve.call(this);

			this.type = 'SplineCurve';

			this.points = points;

		}

		if ( Curve ) SplineCurve.__proto__ = Curve;
		SplineCurve.prototype = Object.create( Curve && Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;

		SplineCurve.prototype.getPoint = function getPoint ( t, optionalTarget ) {
			if ( optionalTarget === void 0 ) optionalTarget = new Vector2();


			var point = optionalTarget;

			var points = this.points;
			var p = ( points.length - 1 ) * t;

			var intPoint = Math.floor( p );
			var weight = p - intPoint;

			var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var p1 = points[ intPoint ];
			var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			point.set(
				CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
				CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
			);

			return point;

		};

		SplineCurve.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.points = [];

			for ( var i = 0, l = source.points.length; i < l; i ++ ) {

				var point = source.points[ i ];

				this.points.push( point.clone() );

			}

			return this;

		};

		SplineCurve.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.points = [];

			for ( var i = 0, l = this.points.length; i < l; i ++ ) {

				var point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			return data;

		};

		SplineCurve.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.points = [];

			for ( var i = 0, l = json.points.length; i < l; i ++ ) {

				var point = json.points[ i ];
				this.points.push( new Vector2().fromArray( point ) );

			}

			return this;

		};

		return SplineCurve;
	}(Curve));

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	var CurvePath = /*@__PURE__*/(function (Curve) {
		function CurvePath() {

			Curve.call(this);

			this.type = 'CurvePath';

			this.curves = [];
			this.autoClose = false; // Automatically closes the path

		}

		if ( Curve ) CurvePath.__proto__ = Curve;
		CurvePath.prototype = Object.create( Curve && Curve.prototype );
		CurvePath.prototype.constructor = CurvePath;

		CurvePath.prototype.add = function add ( curve ) {

			this.curves.push( curve );

		};

		CurvePath.prototype.closePath = function closePath () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		};

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		CurvePath.prototype.getPoint = function getPoint ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		};

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		CurvePath.prototype.getLength = function getLength () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		};

		// cacheLengths must be recalculated.
		CurvePath.prototype.updateArcLengths = function updateArcLengths () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		};

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		CurvePath.prototype.getCurveLengths = function getCurveLengths () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [];
			var sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		};

		CurvePath.prototype.getSpacedPoints = function getSpacedPoints ( divisions ) {
			if ( divisions === void 0 ) divisions = 40;


			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		};

		CurvePath.prototype.getPoints = function getPoints ( divisions ) {
			if ( divisions === void 0 ) divisions = 12;


			var points = [];
			var last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) { continue; } // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		};

		CurvePath.prototype.copy = function copy ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		};

		CurvePath.prototype.toJSON = function toJSON () {

			var data = Curve.prototype.toJSON.call(this);

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		};

		CurvePath.prototype.fromJSON = function fromJSON ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		};

		return CurvePath;
	}(Curve));

	var Path = /*@__PURE__*/(function (CurvePath) {
		function Path( points ) {

			CurvePath.call(this);
			this.type = 'Path';

			this.currentPoint = new Vector2();

			if ( points ) {

				this.setFromPoints( points );

			}

		}

		if ( CurvePath ) Path.__proto__ = CurvePath;
		Path.prototype = Object.create( CurvePath && CurvePath.prototype );
		Path.prototype.constructor = Path;

		Path.prototype.setFromPoints = function setFromPoints ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

			return this;

		};

		Path.prototype.moveTo = function moveTo ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			return this;

		};

		Path.prototype.lineTo = function lineTo ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

			return this;

		};

		Path.prototype.quadraticCurveTo = function quadraticCurveTo ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		};

		Path.prototype.bezierCurveTo = function bezierCurveTo ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		};

		Path.prototype.splineThru = function splineThru ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

			return this;

		};

		Path.prototype.arc = function arc ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

			return this;

		};

		Path.prototype.absarc = function absarc ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			return this;

		};

		Path.prototype.ellipse = function ellipse ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			return this;

		};

		Path.prototype.absellipse = function absellipse ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

			return this;

		};

		Path.prototype.copy = function copy ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		};

		Path.prototype.toJSON = function toJSON () {

			var data = CurvePath.prototype.toJSON.call(this);

			data.currentPoint = this.currentPoint.toArray();

			return data;

		};

		Path.prototype.fromJSON = function fromJSON ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		};

		return Path;
	}(CurvePath));

	var Light = /*@__PURE__*/(function (Object3D) {
		function Light( color, intensity ) {
			if ( intensity === void 0 ) intensity = 1;


			Object3D.call(this);

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		if ( Object3D ) Light.__proto__ = Object3D;
		Light.prototype = Object.create( Object3D && Object3D.prototype );
		Light.prototype.constructor = Light;

		Light.prototype.copy = function copy ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		};

		Light.prototype.toJSON = function toJSON ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }

			if ( this.distance !== undefined ) { data.object.distance = this.distance; }
			if ( this.angle !== undefined ) { data.object.angle = this.angle; }
			if ( this.decay !== undefined ) { data.object.decay = this.decay; }
			if ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }

			if ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }

			return data;

		};

		return Light;
	}(Object3D));

	Light.prototype.isLight = true;

	var HemisphereLight = /*@__PURE__*/(function (Light) {
		function HemisphereLight( skyColor, groundColor, intensity ) {

			Light.call( this, skyColor, intensity );

			this.type = 'HemisphereLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		if ( Light ) HemisphereLight.__proto__ = Light;
		HemisphereLight.prototype = Object.create( Light && Light.prototype );
		HemisphereLight.prototype.constructor = HemisphereLight;

		HemisphereLight.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		};

		return HemisphereLight;
	}(Light));

	HemisphereLight.prototype.isHemisphereLight = true;

	var _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	var _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	var _lookTarget$1 = /*@__PURE__*/ new Vector3();

	var LightShadow = function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	};

	LightShadow.prototype.getViewportCount = function getViewportCount () {

		return this._viewportCount;

	};

	LightShadow.prototype.getFrustum = function getFrustum () {

		return this._frustum;

	};

	LightShadow.prototype.updateMatrices = function updateMatrices ( light ) {

		var shadowCamera = this.camera;
		var shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	};

	LightShadow.prototype.getViewport = function getViewport ( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	};

	LightShadow.prototype.getFrameExtents = function getFrameExtents () {

		return this._frameExtents;

	};

	LightShadow.prototype.copy = function copy ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	};

	LightShadow.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	LightShadow.prototype.toJSON = function toJSON () {

		var object = {};

		if ( this.bias !== 0 ) { object.bias = this.bias; }
		if ( this.normalBias !== 0 ) { object.normalBias = this.normalBias; }
		if ( this.radius !== 1 ) { object.radius = this.radius; }
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	};

	var SpotLightShadow = /*@__PURE__*/(function (LightShadow) {
		function SpotLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

			this.focus = 1;

		}

		if ( LightShadow ) SpotLightShadow.__proto__ = LightShadow;
		SpotLightShadow.prototype = Object.create( LightShadow && LightShadow.prototype );
		SpotLightShadow.prototype.constructor = SpotLightShadow;

		SpotLightShadow.prototype.updateMatrices = function updateMatrices ( light ) {

			var camera = this.camera;

			var fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

			LightShadow.prototype.updateMatrices.call( this, light );

		};

		SpotLightShadow.prototype.copy = function copy ( source ) {

			LightShadow.prototype.copy.call( this, source );

			this.focus = source.focus;

			return this;

		};

		return SpotLightShadow;
	}(LightShadow));

	SpotLightShadow.prototype.isSpotLightShadow = true;

	var SpotLight = /*@__PURE__*/(function (Light) {
		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
			if ( distance === void 0 ) distance = 0;
			if ( angle === void 0 ) angle = Math.PI / 3;
			if ( penumbra === void 0 ) penumbra = 0;
			if ( decay === void 0 ) decay = 1;


			Light.call( this, color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		if ( Light ) SpotLight.__proto__ = Light;
		SpotLight.prototype = Object.create( Light && Light.prototype );
		SpotLight.prototype.constructor = SpotLight;

		var prototypeAccessors$6 = { power: { configurable: true } };

		prototypeAccessors$6.power.get = function () {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;

		};

		prototypeAccessors$6.power.set = function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;

		};

		SpotLight.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		};

		Object.defineProperties( SpotLight.prototype, prototypeAccessors$6 );

		return SpotLight;
	}(Light));

	SpotLight.prototype.isSpotLight = true;

	var _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	var _lightPositionWorld = /*@__PURE__*/ new Vector3();
	var _lookTarget = /*@__PURE__*/ new Vector3();

	var PointLightShadow = /*@__PURE__*/(function (LightShadow) {
		function PointLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		if ( LightShadow ) PointLightShadow.__proto__ = LightShadow;
		PointLightShadow.prototype = Object.create( LightShadow && LightShadow.prototype );
		PointLightShadow.prototype.constructor = PointLightShadow;

		PointLightShadow.prototype.updateMatrices = function updateMatrices ( light, viewportIndex ) {
			if ( viewportIndex === void 0 ) viewportIndex = 0;


			var camera = this.camera;
			var shadowMatrix = this.matrix;

			var far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix );

		};

		return PointLightShadow;
	}(LightShadow));

	PointLightShadow.prototype.isPointLightShadow = true;

	var PointLight = /*@__PURE__*/(function (Light) {
		function PointLight( color, intensity, distance, decay ) {
			if ( distance === void 0 ) distance = 0;
			if ( decay === void 0 ) decay = 1;


			Light.call( this, color, intensity );

			this.type = 'PointLight';

			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();

		}

		if ( Light ) PointLight.__proto__ = Light;
		PointLight.prototype = Object.create( Light && Light.prototype );
		PointLight.prototype.constructor = PointLight;

		var prototypeAccessors$7 = { power: { configurable: true } };

		prototypeAccessors$7.power.get = function () {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;

		};

		prototypeAccessors$7.power.set = function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / ( 4 * Math.PI );

		};

		PointLight.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		};

		Object.defineProperties( PointLight.prototype, prototypeAccessors$7 );

		return PointLight;
	}(Light));

	PointLight.prototype.isPointLight = true;

	var OrthographicCamera = /*@__PURE__*/(function (Camera) {
		function OrthographicCamera( left, right, top, bottom, near, far ) {
			if ( left === void 0 ) left = - 1;
			if ( right === void 0 ) right = 1;
			if ( top === void 0 ) top = 1;
			if ( bottom === void 0 ) bottom = - 1;
			if ( near === void 0 ) near = 0.1;
			if ( far === void 0 ) far = 2000;


			Camera.call(this);

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		if ( Camera ) OrthographicCamera.__proto__ = Camera;
		OrthographicCamera.prototype = Object.create( Camera && Camera.prototype );
		OrthographicCamera.prototype.constructor = OrthographicCamera;

		OrthographicCamera.prototype.copy = function copy ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		};

		OrthographicCamera.prototype.setViewOffset = function setViewOffset ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		};

		OrthographicCamera.prototype.clearViewOffset = function clearViewOffset () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		};

		OrthographicCamera.prototype.updateProjectionMatrix = function updateProjectionMatrix () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		};

		OrthographicCamera.prototype.toJSON = function toJSON ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

			return data;

		};

		return OrthographicCamera;
	}(Camera));

	OrthographicCamera.prototype.isOrthographicCamera = true;

	var DirectionalLightShadow = /*@__PURE__*/(function (LightShadow) {
		function DirectionalLightShadow() {

			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

		if ( LightShadow ) DirectionalLightShadow.__proto__ = LightShadow;
		DirectionalLightShadow.prototype = Object.create( LightShadow && LightShadow.prototype );
		DirectionalLightShadow.prototype.constructor = DirectionalLightShadow;

		return DirectionalLightShadow;
	}(LightShadow));

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	var DirectionalLight = /*@__PURE__*/(function (Light) {
		function DirectionalLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		if ( Light ) DirectionalLight.__proto__ = Light;
		DirectionalLight.prototype = Object.create( Light && Light.prototype );
		DirectionalLight.prototype.constructor = DirectionalLight;

		DirectionalLight.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		};

		return DirectionalLight;
	}(Light));

	DirectionalLight.prototype.isDirectionalLight = true;

	var AmbientLight = /*@__PURE__*/(function (Light) {
		function AmbientLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'AmbientLight';

		}

		if ( Light ) AmbientLight.__proto__ = Light;
		AmbientLight.prototype = Object.create( Light && Light.prototype );
		AmbientLight.prototype.constructor = AmbientLight;

		return AmbientLight;
	}(Light));

	AmbientLight.prototype.isAmbientLight = true;

	var RectAreaLight = /*@__PURE__*/(function (Light) {
		function RectAreaLight( color, intensity, width, height ) {
			if ( width === void 0 ) width = 10;
			if ( height === void 0 ) height = 10;


			Light.call( this, color, intensity );

			this.type = 'RectAreaLight';

			this.width = width;
			this.height = height;

		}

		if ( Light ) RectAreaLight.__proto__ = Light;
		RectAreaLight.prototype = Object.create( Light && Light.prototype );
		RectAreaLight.prototype.constructor = RectAreaLight;

		RectAreaLight.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		};

		RectAreaLight.prototype.toJSON = function toJSON ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		};

		return RectAreaLight;
	}(Light));

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */

	// 3-band SH defined by 9 coefficients

	var SphericalHarmonics3 = function SphericalHarmonics3() {

		this.coefficients = [];

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	};

	SphericalHarmonics3.prototype.set = function set ( coefficients ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	};

	SphericalHarmonics3.prototype.zero = function zero () {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	};

	// get the radiance in the direction of the normal
	// target is a Vector3
	SphericalHarmonics3.prototype.getAt = function getAt ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	};

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	SphericalHarmonics3.prototype.getIrradianceAt = function getIrradianceAt ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	};

	SphericalHarmonics3.prototype.add = function add ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	};

	SphericalHarmonics3.prototype.addScaledSH = function addScaledSH ( sh, s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	};

	SphericalHarmonics3.prototype.scale = function scale ( s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	};

	SphericalHarmonics3.prototype.lerp = function lerp ( sh, alpha ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	};

	SphericalHarmonics3.prototype.equals = function equals ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	};

	SphericalHarmonics3.prototype.copy = function copy ( sh ) {

		return this.set( sh.coefficients );

	};

	SphericalHarmonics3.prototype.clone = function clone () {

		return new this.constructor().copy( this );

	};

	SphericalHarmonics3.prototype.fromArray = function fromArray ( array, offset ) {
			if ( offset === void 0 ) offset = 0;


		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	};

	SphericalHarmonics3.prototype.toArray = function toArray ( array, offset ) {
			if ( array === void 0 ) array = [];
			if ( offset === void 0 ) offset = 0;


		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	};

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	SphericalHarmonics3.getBasisAt = function getBasisAt ( normal, shBasis ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	};

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	var LightProbe = /*@__PURE__*/(function (Light) {
		function LightProbe( sh, intensity ) {
			if ( sh === void 0 ) sh = new SphericalHarmonics3();
			if ( intensity === void 0 ) intensity = 1;


			Light.call( this, undefined, intensity );

			this.sh = sh;

		}

		if ( Light ) LightProbe.__proto__ = Light;
		LightProbe.prototype = Object.create( Light && Light.prototype );
		LightProbe.prototype.constructor = LightProbe;

		LightProbe.prototype.copy = function copy ( source ) {

			Light.prototype.copy.call( this, source );

			this.sh.copy( source.sh );

			return this;

		};

		LightProbe.prototype.fromJSON = function fromJSON ( json ) {

			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray( json.sh );

			return this;

		};

		LightProbe.prototype.toJSON = function toJSON ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.sh = this.sh.toArray();

			return data;

		};

		return LightProbe;
	}(Light));

	LightProbe.prototype.isLightProbe = true;

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent( escape( s ) );

			} catch ( e ) { // see #16358

				return s;

			}

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) { return './'; }

			return url.substr( 0, index + 1 );

		}

	};

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.instanceCount = source.instanceCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	} );

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		toJSON: function ()	{

			var data = BufferAttribute.prototype.toJSON.call( this );

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	} );

	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		Loader.call( this, manager );

		this.options = { premultiplyAlpha: 'none' };

	}

	ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: ImageBitmapLoader,

		isImageBitmapLoader: true,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) { url = ''; }

			if ( this.path !== undefined ) { url = this.path + url; }

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) { onLoad( cached ); }

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var fetchOptions = {};
			fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;

			fetch( url, fetchOptions ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) { onLoad( imageBitmap ); }

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) { onError( e ); }

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		}

	} );

	var _context;

	var AudioContext = {

		getContext: function () {

			if ( _context === undefined ) {

				_context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return _context;

		},

		setContext: function ( value ) {

			_context = value;

		}

	};

	var AudioLoader = /*@__PURE__*/(function (Loader) {
		function AudioLoader( manager ) {

			Loader.call( this, manager );

		}

		if ( Loader ) AudioLoader.__proto__ = Loader;
		AudioLoader.prototype = Object.create( Loader && Loader.prototype );
		AudioLoader.prototype.constructor = AudioLoader;

		AudioLoader.prototype.load = function load ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( buffer ) {

				try {

					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					var bufferCopy = buffer.slice( 0 );

					var context = AudioContext.getContext();
					context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		};

		return AudioLoader;
	}(Loader));

	new Matrix4();
	new Matrix4();

	var Audio = /*@__PURE__*/(function (Object3D) {
		function Audio( listener ) {

			Object3D.call(this);

			this.type = 'Audio';

			this.listener = listener;
			this.context = listener.context;

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';

			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;

			this.filters = [];

		}

		if ( Object3D ) Audio.__proto__ = Object3D;
		Audio.prototype = Object.create( Object3D && Object3D.prototype );
		Audio.prototype.constructor = Audio;

		Audio.prototype.getOutput = function getOutput () {

			return this.gain;

		};

		Audio.prototype.setNodeSource = function setNodeSource ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		};

		Audio.prototype.setMediaElementSource = function setMediaElementSource ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		};

		Audio.prototype.setMediaStreamSource = function setMediaStreamSource ( mediaStream ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource( mediaStream );
			this.connect();

			return this;

		};

		Audio.prototype.setBuffer = function setBuffer ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) { this.play(); }

			return this;

		};

		Audio.prototype.play = function play ( delay ) {
			if ( delay === void 0 ) delay = 0;


			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._startedAt = this.context.currentTime + delay;

			var source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind( this );
			source.start( this._startedAt, this._progress + this.offset, this.duration );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		};

		Audio.prototype.pause = function pause () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				// update current progress

				this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

				if ( this.loop === true ) {

					// ensure _progress does not exceed duration with looped audios

					this._progress = this._progress % ( this.duration || this.buffer.duration );

				}

				this.source.stop();
				this.source.onended = null;

				this.isPlaying = false;

			}

			return this;

		};

		Audio.prototype.stop = function stop () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._progress = 0;

			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;

			return this;

		};

		Audio.prototype.connect = function connect () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			this._connected = true;

			return this;

		};

		Audio.prototype.disconnect = function disconnect () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			this._connected = false;

			return this;

		};

		Audio.prototype.getFilters = function getFilters () {

			return this.filters;

		};

		Audio.prototype.setFilters = function setFilters ( value ) {

			if ( ! value ) { value = []; }

			if ( this._connected === true ) {

				this.disconnect();
				this.filters = value.slice();
				this.connect();

			} else {

				this.filters = value.slice();

			}

			return this;

		};

		Audio.prototype.setDetune = function setDetune ( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) { return; } // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		};

		Audio.prototype.getDetune = function getDetune () {

			return this.detune;

		};

		Audio.prototype.getFilter = function getFilter () {

			return this.getFilters()[ 0 ];

		};

		Audio.prototype.setFilter = function setFilter ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		};

		Audio.prototype.setPlaybackRate = function setPlaybackRate ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		};

		Audio.prototype.getPlaybackRate = function getPlaybackRate () {

			return this.playbackRate;

		};

		Audio.prototype.onEnded = function onEnded () {

			this.isPlaying = false;

		};

		Audio.prototype.getLoop = function getLoop () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		};

		Audio.prototype.setLoop = function setLoop ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		};

		Audio.prototype.setLoopStart = function setLoopStart ( value ) {

			this.loopStart = value;

			return this;

		};

		Audio.prototype.setLoopEnd = function setLoopEnd ( value ) {

			this.loopEnd = value;

			return this;

		};

		Audio.prototype.getVolume = function getVolume () {

			return this.gain.gain.value;

		};

		Audio.prototype.setVolume = function setVolume ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		};

		return Audio;
	}(Object3D));

	// Characters [].:/ are reserved for track binding syntax.
	var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

	var _trackRe = new RegExp( ''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	);

	var _supportedObjectNames = [ 'material', 'materials', 'bones' ];

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) { binding.getValue( array, offset ); }

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: function ( name ) {

			return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

		},

		parseTrackName: function ( trackName ) {

			var matches = _trackRe.exec( trackName );

			if ( ! matches ) {

				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ], // required
				propertyIndex: matches[ 6 ]
			};

			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

			if ( lastDot !== undefined && lastDot !== - 1 ) {

				var objectName = results.nodeName.substring( lastDot + 1 );

				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;

				}

			}

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

			}

			return results;

		},

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) { return result; }

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node;
			var parsedPath = this.parsedPath;

			var objectName = parsedPath.objectName;
			var propertyName = parsedPath.propertyName;
			var propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === 'morphTargetInfluences' ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

							propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

						}


					} else {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
						return;

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	// DECLARE ALIAS AFTER assign prototype
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		clone: function ( data ) {

			var ib = InterleavedBuffer.prototype.clone.call( this, data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		},

		toJSON: function ( data ) {

			var json = InterleavedBuffer.prototype.toJSON.call( this, data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	} );

	function GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) { this.version ++; }

		}

	} );

	Object.assign( GLBufferAttribute.prototype, {

		isGLBufferAttribute: true,

		setBuffer: function ( buffer ) {

			this.buffer = buffer;

			return this;

		},

		setType: function ( type, elementSize ) {

			this.type = type;
			this.elementSize = elementSize;

			return this;

		},

		setItemSize: function ( itemSize ) {

			this.itemSize = itemSize;

			return this;

		},

		setCount: function ( count ) {

			this.count = count;

			return this;

		},

	} );

	function Raycaster( origin, direction, near, far ) {
		if ( near === void 0 ) near = 0;
		if ( far === void 0 ) far = Infinity;


		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera && camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera && camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		},

		intersectObject: function ( object, recursive, intersects ) {
			if ( recursive === void 0 ) recursive = false;
			if ( intersects === void 0 ) intersects = [];


			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, intersects ) {
			if ( recursive === void 0 ) recursive = false;
			if ( intersects === void 0 ) intersects = [];


			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

		this.hasPositions = false;
		this.hasNormals = false;
		this.hasColors = false;
		this.hasUvs = false;

		this.positionArray = null;
		this.normalArray = null;
		this.colorArray = null;
		this.uvArray = null;

		this.count = 0;

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	var _vector$3 = /*@__PURE__*/ new Vector3();

	var SpotLightHelper = /*@__PURE__*/(function (Object3D) {
		function SpotLightHelper( light, color ) {

			Object3D.call(this);
			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			var geometry = new BufferGeometry();

			var positions = [
				0, 0, 0, 	0, 0, 1,
				0, 0, 0, 	1, 0, 1,
				0, 0, 0,	- 1, 0, 1,
				0, 0, 0, 	0, 1, 1,
				0, 0, 0, 	0, - 1, 1
			];

			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		if ( Object3D ) SpotLightHelper.__proto__ = Object3D;
		SpotLightHelper.prototype = Object.create( Object3D && Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;

		SpotLightHelper.prototype.dispose = function dispose () {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		};

		SpotLightHelper.prototype.update = function update () {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( _vector$3 );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

		return SpotLightHelper;
	}(Object3D));

	var PointLightHelper = /*@__PURE__*/(function (Mesh) {
		function PointLightHelper( light, sphereSize, color ) {

			var geometry = new SphereGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

			Mesh.call( this, geometry, material );

			this.light = light;
			this.light.updateMatrixWorld();

			this.color = color;

			this.type = 'PointLightHelper';

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();


			/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		const d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

		}

		if ( Mesh ) PointLightHelper.__proto__ = Mesh;
		PointLightHelper.prototype = Object.create( Mesh && Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;

		PointLightHelper.prototype.dispose = function dispose () {

			this.geometry.dispose();
			this.material.dispose();

		};

		PointLightHelper.prototype.update = function update () {

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				this.material.color.copy( this.light.color );

			}

			/*
			const d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		};

		return PointLightHelper;
	}(Mesh));

	var _vector$1 = /*@__PURE__*/ new Vector3();
	var _color1 = /*@__PURE__*/ new Color();
	var _color2 = /*@__PURE__*/ new Color();

	var HemisphereLightHelper = /*@__PURE__*/(function (Object3D) {
		function HemisphereLightHelper( light, size, color ) {

			Object3D.call(this);
			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			var geometry = new OctahedronGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );

			this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
			if ( this.color === undefined ) { this.material.vertexColors = true; }

			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );

			geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

			this.add( new Mesh( geometry, this.material ) );

			this.update();

		}

		if ( Object3D ) HemisphereLightHelper.__proto__ = Object3D;
		HemisphereLightHelper.prototype = Object.create( Object3D && Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

		HemisphereLightHelper.prototype.dispose = function dispose () {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		};

		HemisphereLightHelper.prototype.update = function update () {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				_color1.copy( this.light.color );
				_color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? _color1 : _color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

		return HemisphereLightHelper;
	}(Object3D));

	var _v1 = /*@__PURE__*/ new Vector3();
	var _v2 = /*@__PURE__*/ new Vector3();
	var _v3 = /*@__PURE__*/ new Vector3();

	var DirectionalLightHelper = /*@__PURE__*/(function (Object3D) {
		function DirectionalLightHelper( light, size, color ) {

			Object3D.call(this);
			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			if ( size === undefined ) { size = 1; }

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [
				- size, size, 0,
				size, size, 0,
				size, - size, 0,
				- size, - size, 0,
				- size, size, 0
			], 3 ) );

			var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.lightPlane = new Line( geometry, material );
			this.add( this.lightPlane );

			geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.targetLine = new Line( geometry, material );
			this.add( this.targetLine );

			this.update();

		}

		if ( Object3D ) DirectionalLightHelper.__proto__ = Object3D;
		DirectionalLightHelper.prototype = Object.create( Object3D && Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

		DirectionalLightHelper.prototype.dispose = function dispose () {

			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();

		};

		DirectionalLightHelper.prototype.update = function update () {

			_v1.setFromMatrixPosition( this.light.matrixWorld );
			_v2.setFromMatrixPosition( this.light.target.matrixWorld );
			_v3.subVectors( _v2, _v1 );

			this.lightPlane.lookAt( _v2 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( _v2 );
			this.targetLine.scale.z = _v3.length();

		};

		return DirectionalLightHelper;
	}(Object3D));

	var backgroundMaterial = new MeshBasicMaterial( {
		side: BackSide,
		depthWrite: false,
		depthTest: false,
	} );
	new Mesh( new BoxGeometry(), backgroundMaterial );

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Path.prototype.fromPoints = function ( points ) {

		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		return this.setFromPoints( points );

	};

	//

	Loader.prototype.extractUrlBase = function ( url ) {

		console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
		return LoaderUtils.extractUrlBase( url );

	};

	Loader.Handlers = {

		add: function ( /* regex, loader */ ) {

			console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

		},

		get: function ( /* file */ ) {

			console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

		}

	};

	//

	Box3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Box3.prototype.empty = function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	};

	Box3.prototype.isIntersectionBox = function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	};

	Box3.prototype.isIntersectionSphere = function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	};

	Box3.prototype.size = function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	};

	//

	Sphere.prototype.empty = function () {

		console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	};

	//

	Frustum.prototype.setFromMatrix = function ( m ) {

		console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
		return this.setFromProjectionMatrix( m );

	};

	//

	MathUtils.random16 = function () {

		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	};

	MathUtils.nearestPowerOfTwo = function ( value ) {

		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
		return MathUtils.floorPowerOfTwo( value );

	};

	MathUtils.nextPowerOfTwo = function ( value ) {

		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
		return MathUtils.ceilPowerOfTwo( value );

	};

	//

	Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

		console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
		return this.toArray( array, offset );

	};

	Matrix3.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	};

	Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

	};

	Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

		console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
		return attribute.applyMatrix3( this );

	};

	Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	};

	Matrix3.prototype.getInverse = function ( matrix ) {

		console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	};

	//

	Matrix4.prototype.extractPosition = function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	};

	Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

		console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
		return this.toArray( array, offset );

	};

	Matrix4.prototype.getPosition = function () {

		console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
		return new Vector3().setFromMatrixColumn( this, 3 );

	};

	Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	};

	Matrix4.prototype.multiplyToArray = function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	};

	Matrix4.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.multiplyVector4 = function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

	};

	Matrix4.prototype.rotateAxis = function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	};

	Matrix4.prototype.crossVector = function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.translate = function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	};

	Matrix4.prototype.rotateX = function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	};

	Matrix4.prototype.rotateY = function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	};

	Matrix4.prototype.rotateZ = function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	};

	Matrix4.prototype.rotateByAxis = function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	};

	Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

		console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
		return attribute.applyMatrix4( this );

	};

	Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	};

	Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	};

	Matrix4.prototype.getInverse = function ( matrix ) {

		console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	};

	//

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	//

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Quaternion.prototype.inverse = function ( ) {

		console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
		return this.invert();

	};

	//

	Ray.prototype.isIntersectionBox = function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	};

	Ray.prototype.isIntersectionPlane = function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	};

	Ray.prototype.isIntersectionSphere = function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	};

	//

	Triangle.prototype.area = function () {

		console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
		return this.getArea();

	};

	Triangle.prototype.barycoordFromPoint = function ( point, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return this.getBarycoord( point, target );

	};

	Triangle.prototype.midpoint = function ( target ) {

		console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
		return this.getMidpoint( target );

	};

	Triangle.prototypenormal = function ( target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return this.getNormal( target );

	};

	Triangle.prototype.plane = function ( target ) {

		console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
		return this.getPlane( target );

	};

	Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return Triangle.getBarycoord( point, a, b, c, target );

	};

	Triangle.normal = function ( a, b, c, target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return Triangle.getNormal( a, b, c, target );

	};

	//

	Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector2.prototype.distanceToManhattan = function ( v ) {

		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	};

	Vector2.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Vector3.prototype.setEulerFromRotationMatrix = function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	};

	Vector3.prototype.setEulerFromQuaternion = function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	};

	Vector3.prototype.getPositionFromMatrix = function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	};

	Vector3.prototype.getScaleFromMatrix = function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	};

	Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	};

	Vector3.prototype.applyProjection = function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	};

	Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector3.prototype.distanceToManhattan = function ( v ) {

		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	};

	Vector3.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector4.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Object3D.prototype.getChildByName = function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	};

	Object3D.prototype.renderDepth = function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	};

	Object3D.prototype.translate = function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	};

	Object3D.prototype.getWorldRotation = function () {

		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

	};

	Object3D.prototype.applyMatrix = function ( matrix ) {

		console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	};

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Mesh.prototype.setDrawMode = function () {

		console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

	};

	Object.defineProperties( Mesh.prototype, {

		drawMode: {
			get: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
				return TrianglesDrawMode;

			},
			set: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

			}
		}

	} );

	SkinnedMesh.prototype.initBones = function () {

		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

	};

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
				'Use .setFocalLength and .filmGauge for a photographic setup.' );

		if ( filmGauge !== undefined ) { this.filmGauge = filmGauge; }
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		dynamic: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				return this.usage === DynamicDrawUsage;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				this.setUsage( DynamicDrawUsage );

			}
		}

	} );

	BufferAttribute.prototype.setDynamic = function ( value ) {

		console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	};

	BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

	},

	BufferAttribute.prototype.setArray = function ( /* array */ ) {

		console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	};

	//

	BufferGeometry.prototype.addIndex = function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	};

	BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		return this.setAttribute( name, attribute );

	};

	BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	};

	BufferGeometry.prototype.clearDrawCalls = function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	};

	BufferGeometry.prototype.computeOffsets = function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	};

	BufferGeometry.prototype.removeAttribute = function ( name ) {

		console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

		return this.deleteAttribute( name );

	};

	BufferGeometry.prototype.applyMatrix = function ( matrix ) {

		console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	};

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	Object.defineProperties( InstancedBufferGeometry.prototype, {

		maxInstancedCount: {
			get: function () {

				console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
				return this.instanceCount;

			},
			set: function ( value ) {

				console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
				this.instanceCount = value;

			}
		}

	} );

	Object.defineProperties( Raycaster.prototype, {

		linePrecision: {
			get: function () {

				console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
				return this.params.Line.threshold;

			},
			set: function ( value ) {

				console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
				this.params.Line.threshold = value;

			}
		}

	} );

	Object.defineProperties( InterleavedBuffer.prototype, {

		dynamic: {
			get: function () {

				console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
				return this.usage === DynamicDrawUsage;

			},
			set: function ( value ) {

				console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
				this.setUsage( value );

			}
		}

	} );

	InterleavedBuffer.prototype.setDynamic = function ( value ) {

		console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	};

	InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

		console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	};

	//

	ExtrudeGeometry.prototype.getArrays = function () {

		console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

	};

	ExtrudeGeometry.prototype.addShapeList = function () {

		console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

	};

	ExtrudeGeometry.prototype.addShape = function () {

		console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

	};

	//

	Scene.prototype.dispose = function () {

		console.error( 'THREE.Scene: .dispose() has been removed.' );

	};

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},

		overdraw: {
			get: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			}
		},

		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		},

		stencilMask: {
			get: function () {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				return this.stencilFuncMask;

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				this.stencilFuncMask = value;

			}
		}

	} );

	Object.defineProperties( MeshPhysicalMaterial.prototype, {

		transparency: {
			get: function () {

				console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
				return this.transmission;

			},
			set: function ( value ) {

				console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
				this.transmission = value;

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

		console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	WebGLRenderer.prototype.animate = function ( callback ) {

		console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
		this.setAnimationLoop( callback );

	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {

		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();

	};

	WebGLRenderer.prototype.getPrecision = function () {

		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;

	};

	WebGLRenderer.prototype.resetGLState = function () {

		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();

	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	};

	WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	};

	WebGLRenderer.prototype.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	WebGLRenderer.prototype.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	WebGLRenderer.prototype.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	WebGLRenderer.prototype.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

	WebGLRenderer.prototype.setFaceCulling = function () {

		console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

	};

	WebGLRenderer.prototype.allocTextureUnit = function () {

		console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

	};

	WebGLRenderer.prototype.setTexture = function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

	};

	WebGLRenderer.prototype.setTexture2D = function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

	};

	WebGLRenderer.prototype.setTextureCube = function () {

		console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {

		console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
		return this.getActiveMipmapLevel();

	};

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		context: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
				return this.getContext();

			}
		},
		vr: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
				return this.xr;

			}
		},
		gammaInput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

			}
		},
		gammaOutput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				return false;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

			}
		},
		toneMappingWhitePoint: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
				return 1.0;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

			}
		},

	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

		console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
		return this.renderTarget.clear( renderer, color, depth, stencil );

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) { texture.mapping = mapping; }

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) { texture.mapping = mapping; }

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
			revision: REVISION,
		} } ) );
		/* eslint-enable no-undef */

	}

	if ( typeof window !== 'undefined' ) {

		if ( window.__THREE__ ) {

			console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

		} else {

			window.__THREE__ = REVISION;

		}

	}

	var assign$1 = assign;
	var forOwn$1 = forOwn;
	var singletonVec3 = new Vector3();
	var singletonVec3b = new Vector3();
	var notifyWorldGetter = (function() {
	  var obj = {
	    callback: function(pos) {
	      obj.value = pos;
	    },
	    value: null
	  };
	  return obj
	})();
	var removedEvent = {type: 'removed'};
	var singletonIntersects = [];

	function ascDistanceSort(a, b) {
	  return a.distance - b.distance
	}

	function canObjectBeOrphaned(obj) {
	  return obj.isRenderable === false && (
	    !obj.children.length || obj.children.every(canObjectBeOrphaned)
	  )
	}

	var _worldMatrixVersion = 0;
	var _geometrySphereVersion = 0;

	var Object3DFacade = /*@__PURE__*/(function (PointerEventTarget) {
	  function Object3DFacade(parent, threeObject) {
	    PointerEventTarget.call(this, parent);

	    if (!threeObject) {
	      threeObject = this.initThreeObject();
	    }

	    // We'll track matrix updates manually
	    threeObject.matrixAutoUpdate = false;

	    // Set bidirectional refs
	    this.threeObject = threeObject;
	    threeObject.$facade = this;

	    // Subclasses may set isRenderable=false on the threeObject, to trigger some scene graph optimizations.
	    // The first is to remove it from all layer masks to short-circuit WebGLRenderer.projectObject.
	    var isRenderable = threeObject.isRenderable !== false;
	    if (!isRenderable) {
	      threeObject.layers.mask = 0;
	    }

	    // Add it as a child of the nearest parent threeObject, if one exists
	    while (parent) {
	      if (parent.isObject3DFacade) {
	        this._parentObject3DFacade = parent; //reference to nearest Object3DFacade ancestor
	        if (isRenderable) {
	          this._addToThreeObjectTree();
	        }
	        break
	      }
	      parent = parent.parent;
	    }

	    this.notifyWorld('object3DAdded');
	  }

	  if ( PointerEventTarget ) Object3DFacade.__proto__ = PointerEventTarget;
	  Object3DFacade.prototype = Object.create( PointerEventTarget && PointerEventTarget.prototype );
	  Object3DFacade.prototype.constructor = Object3DFacade;

	  /**
	   * Lifecycle method, called at constructor time, that creates and returns a Three.js `Object3D`
	   * instance which will become the `threeObject` for this facade. This is a more ergonomic
	   * alternative than overriding the constructor to pass the `threeObject` as a second argument
	   * to the super() call. By default it creates a plain Object3D marked as non-renderable so it
	   * is not added to the Three.js tree.
	   * @return {Object3D}
	   * @protected
	   */
	  Object3DFacade.prototype.initThreeObject = function initThreeObject () {
	    var obj = new Object3D();
	    obj.isRenderable = false; //trigger optimizations
	    return obj
	  };

	  Object3DFacade.prototype.afterUpdate = function afterUpdate () {
	    // Update matrix and worldMatrix before processing children
	    this.updateMatrices();
	    this._checkBoundsChange();

	    // If the world matrix was modified, and we won't be doing an update pass on child facades due
	    // to `shouldUpdateChildren` optimization, we need to manually update their matrices to match.
	    if (this._worldMatrixVersion > this._worldMatrixVersionAfterLastUpdate) {
	      if (!this.shouldUpdateChildren()) {
	        this.traverse(function (facade, rootFacade) {
	          if (facade !== rootFacade && facade.updateMatrices) {
	            facade.updateMatrices();
	            facade._checkBoundsChange();
	          }
	        }, this);
	      }
	      this._worldMatrixVersionAfterLastUpdate = this._worldMatrixVersion;
	    }

	    // Process children
	    PointerEventTarget.prototype.afterUpdate.call(this);

	    // If any children were removed during the update, remove them from the threejs
	    // object in a single batch; this avoids threejs's very expensive single-item remove.
	    this._flushQueuedChildRemovals();
	  };

	  /**
	   * Update the underlying threeObject's `matrix` and `matrixWorld` to the current state if necessary.
	   * This bypasses the `updateMatrix` and `updateMatrixWorld` methods of the threejs objects with a more
	   * efficient approach that doesn't require traversing the entire tree prior to every render. This is possible
	   * since we control the update lifecycle; as long as this is called from the `afterUpdate` lifecycle
	   * method or later, it can be safely assumed that the world matrices of all ancestors have already been
	   * similarly updated so the result should always be accurate.
	   */
	  Object3DFacade.prototype.updateMatrices = function updateMatrices () {
	    var threeObj = this.threeObject;
	    var parent3DFacade = this._parentObject3DFacade;
	    var needsWorldMatrixUpdate;
	    if (this._matrixChanged) {
	      threeObj.matrix.compose(threeObj.position, threeObj.quaternion, threeObj.scale);
	      this._matrixChanged = false;
	      needsWorldMatrixUpdate = true;
	    } else {
	      needsWorldMatrixUpdate = parent3DFacade && parent3DFacade._worldMatrixVersion > this._worldMatrixVersion;
	    }
	    if (needsWorldMatrixUpdate) {
	      if (parent3DFacade) {
	        threeObj.matrixWorld.multiplyMatrices(parent3DFacade.threeObject.matrixWorld, threeObj.matrix);
	      } else {
	        threeObj.matrixWorld.copy(threeObj.matrix);
	      }

	      // If the threeObject has children that were manually added (not managed by facades), we'll need to update them too
	      // TODO can we determine this state without a full loop that will likely return nothing?
	      var threeKids = threeObj.children;
	      for (var i = 0, len = threeKids.length; i < len; i++) {
	        if (!threeKids[i].$facade) {
	          threeKids[i].updateMatrixWorld(true);
	        }
	      }

	      this.markWorldMatrixDirty();
	    }
	  };

	  /**
	   * If the `threeObject.matrixWorld` is modified manually instead of via the individual transformation
	   * properties, you can call this to tell the facade its caches need to be recalculated.
	   */
	  Object3DFacade.prototype.markWorldMatrixDirty = function markWorldMatrixDirty () {
	    this._worldMatrixVersion = ++_worldMatrixVersion;
	    this._boundsChanged = true;
	  };

	  Object3DFacade.prototype._checkBoundsChange = function _checkBoundsChange () {
	    var changed = this._boundsChanged;
	    if (!changed) {
	      var geomSphere = this._getGeometryBoundingSphere();
	      if (geomSphere && geomSphere.version !== this._lastGeometrySphereVersion) {
	        changed = true;
	        this._lastGeometrySphereVersion = geomSphere.version;
	      }
	    }
	    if (changed) {
	      this.notifyWorld('object3DBoundsChanged');
	      this._boundsChanged = false;
	    }
	  };

	  /**
	   * Get this object's current position in world space
	   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
	   *                  if not passed in a new one will be created.
	   * @returns {Vector3}
	   */
	  Object3DFacade.prototype.getWorldPosition = function getWorldPosition (vec3 ) {
	    this.updateMatrices();
	    return (vec3 || new Vector3()).setFromMatrixPosition(this.threeObject.matrixWorld)
	  };

	  /**
	   * Get the current position vector of the world's camera.
	   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
	   *                  if not passed in a new one will be created.
	   * @returns {Vector3}
	   */
	  Object3DFacade.prototype.getCameraPosition = function getCameraPosition (vec3 ) {
	    vec3 = vec3 || new Vector3();
	    this.notifyWorld('getCameraPosition', vec3);
	    return vec3
	  };

	  /**
	   * Get the facade object for the world's camera. Can be used to get to low-level info
	   * about the camera such as its various matrices, but be careful not to make modifications
	   * to the camera as that can lead to things getting out of sync.
	   * @returns {Camera3DFacade}
	   */
	  Object3DFacade.prototype.getCameraFacade = function getCameraFacade () {
	    notifyWorldGetter.value = null;
	    this.notifyWorld('getCameraFacade', notifyWorldGetter);
	    return notifyWorldGetter.value
	  };

	  /**
	   * Calculate the distance in world units between this object's origin and the camera.
	   * @returns {Number}
	   */
	  Object3DFacade.prototype.getCameraDistance = function getCameraDistance () {
	    var cameraPos = this.getCameraPosition(singletonVec3b);
	    var objectPos = this.getWorldPosition(singletonVec3);
	    return cameraPos.distanceTo(objectPos)
	  };

	  /**
	   * Get the current projected user space position for this object, or for a specific position
	   * in its object space.
	   * @returns {Vector3} x and y are in screen pixels, z is worldspace distance from camera. The
	   *                    z may be negative, which means it is out of view behind the camera.
	   */
	  Object3DFacade.prototype.getProjectedPosition = function getProjectedPosition (x, y, z) {
	    this.updateMatrices();
	    notifyWorldGetter.value = null;
	    notifyWorldGetter.worldPosition = singletonVec3.set(x || 0, y || 0, z || 0).applyMatrix4(this.threeObject.matrixWorld);
	    this.notifyWorld('projectWorldPosition', notifyWorldGetter);
	    return notifyWorldGetter.value
	  };

	  /**
	   * Get the facade object for the world's scene.
	   * @returns {Scene3DFacade}
	   */
	  Object3DFacade.prototype.getSceneFacade = function getSceneFacade () {
	    notifyWorldGetter.value = null;
	    this.notifyWorld('getSceneFacade', notifyWorldGetter);
	    return notifyWorldGetter.value
	  };

	  /**
	   * Return a {@link Sphere} encompassing the bounds of this object in worldspace, or `null` if
	   * it has no physical bounds. This is used for optimized raycasting.
	   *
	   * The default implementation attempts to be as efficient as possible, only updating the sphere
	   * when necessary, and assumes the threeObject has a geometry that accurately describes its bounds.
	   * Override this method to provide custom bounds calculation logic, for example when additional meshes
	   * need to be checked or a vertex shader manipulates the geometry; you'll probably also need to override
	   * {@link #raycast} to match.
	   *
	   * TODO: this needs to be easier to override without having to reimplement large chunks of logic
	   */
	  Object3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
	    // Get the geometry's current bounding sphere
	    var geomSphere = this._getGeometryBoundingSphere();
	    if (!geomSphere) { return null }

	    // Ensure world matrix is up to date
	    this.updateMatrices();

	    // Lazily create our Sphere
	    var sphere = this._boundingSphere;
	    if (!sphere) {
	      sphere = this._boundingSphere = new Sphere();
	    }

	    // If the geometry, the geometry's bounding sphere, or this object's world matrix changed,
	    // update our bounding sphere to match them.
	    if (sphere._geometrySphereVersion !== geomSphere.version || sphere._worldMatrixVersion !== this._worldMatrixVersion) {
	      sphere.copy(geomSphere);
	      sphere.applyMatrix4(this.threeObject.matrixWorld);
	      sphere._worldMatrixVersion = this._worldMatrixVersion;
	      sphere._geometrySphereVersion = geomSphere.version;
	    }

	    return sphere
	  };

	  /**
	   * Ensure the object's geometry, if any, has an up-to-date bounding Sphere, and return that Sphere.
	   * The returned Sphere will be assigned a unique `version` property when it is modified, which can
	   * be used elsewhere for tracking changes.
	   * @private
	   */
	  Object3DFacade.prototype._getGeometryBoundingSphere = function _getGeometryBoundingSphere () {
	    var geometry = this.getGeometry();
	    if (geometry) {
	      var geomSphere = geometry.boundingSphere;
	      var geomSphereChanged = false;
	      if (geomSphere) {
	        if (geometry.isBufferGeometry) {
	          // For a BufferGeometry we can look at the `position` attribute's `version` (incremented
	          // when the user sets `geom.needsUpdate = true`) to detect the need for bounds recalc
	          var posAttr = geometry.attributes.position;
	          if (posAttr && geomSphere._posAttrVersion !== posAttr.version) {
	            geometry.computeBoundingSphere();
	            geomSphere._posAttrVersion = posAttr.version;
	            geomSphereChanged = true;
	          }
	        } else {
	          // For a non-buffer Geometry (not recommended!) users will have to manually call
	          // `geom.computeBoundingSphere()` after changing its vertices, and we'll do a brute force
	          // check for changes to the sphere's properties
	          if (!geometry._lastBoundingSphere || !geomSphere.equals(geometry._lastBoundingSphere)) {
	            geometry._lastBoundingSphere = geomSphere.clone();
	            geomSphereChanged = true;
	          }
	        }
	      } else {
	        geometry.computeBoundingSphere();
	        geomSphere = geometry.boundingSphere;
	        geomSphereChanged = true;
	      }
	      if (geomSphereChanged) {
	        geomSphere.version = ++_geometrySphereVersion;
	      }
	      return geomSphere
	    } else {
	      return null
	    }
	  };

	  /**
	   * @protected Extension point for subclasses that don't use their threeObject's geometry, e.g. Instanceable
	   */
	  Object3DFacade.prototype.getGeometry = function getGeometry () {
	    var obj = this.threeObject;
	    return obj && obj.geometry
	  };

	  /**
	   * Determine if this facade's threeObject intersects a Raycaster. Override this method to provide
	   * custom raycasting logic, for example when additional meshes need to be checked or a vertex shader
	   * manipulates the geometry; you'll probably also need to override {@link #getBoundingSphere} to match.
	   *
	   * The return value can be:
	   *   - An array of hit objects for this facade, matching the format returned by `Raycaster.intersectObject`
	   *   - `null`, if this facade has no hits
	   */
	  Object3DFacade.prototype.raycast = function raycast (raycaster) {
	    return this.threeObject ? this._raycastObject(this.threeObject, raycaster) : null
	  };

	  /**
	   * Custom optimized raycast that, unlike Raycaster.intersectObject(), avoids creating a
	   * new array unless there are actually hits. It also supports the custom `raycastSide`
	   * override property, hit on sides other than the material's configured `side`.
	   * @protected
	   */
	  Object3DFacade.prototype._raycastObject = function _raycastObject (obj, raycaster) {
	    if (obj.visible) {
	      singletonIntersects.length = 0;
	      var origSide = null;
	      var raycastSide = this.raycastSide;
	      if (raycastSide != null) {
	        origSide = obj.material.side;
	        obj.material.side = raycastSide;
	      }
	      obj.raycast(raycaster, singletonIntersects);
	      if (origSide !== null) {
	        obj.material.side = origSide;
	      }
	      if (singletonIntersects.length) {
	        singletonIntersects.sort(ascDistanceSort);
	        return singletonIntersects.slice()
	      }
	    }
	    return null
	  };

	  Object3DFacade.prototype._addToThreeObjectTree = function _addToThreeObjectTree () {
	    var parent = this._parentObject3DFacade;
	    if (parent) {
	      if (this.threeObject.parent !== parent.threeObject) {
	        parent.threeObject.add(this.threeObject);
	        parent._addToThreeObjectTree();
	      }
	    }
	  };

	  Object3DFacade.prototype._queueRemoveChildObject3D = function _queueRemoveChildObject3D (threeObjectId) {
	    var removeChildIds = this._removeChildIds || (this._removeChildIds = Object.create(null));
	    removeChildIds[threeObjectId] = true;
	  };

	  Object3DFacade.prototype._flushQueuedChildRemovals = function _flushQueuedChildRemovals () {
	    // If any children were queued for removal, remove them from the threejs
	    // object in a single batch; this avoids threejs's very expensive single-item remove.
	    if (this._removeChildIds) {
	      var threeObject = this.threeObject;
	      var removeChildIds = this._removeChildIds;
	      threeObject.children = threeObject.children.filter(function (child) {
	        if (child.id in removeChildIds) {
	          child.parent = null;
	          child.dispatchEvent(removedEvent);
	          return false
	        }
	        return true
	      });

	      // If that resulted in a non-renderable object having no renderable children,
	      // remove it from the threejs object tree, recursively upward.
	      var parentObj3D = this._parentObject3DFacade;
	      if (canObjectBeOrphaned(threeObject) && parentObj3D && parentObj3D.threeObject === threeObject.parent) {
	        parentObj3D._queueRemoveChildObject3D(threeObject.id);
	        parentObj3D._flushQueuedChildRemovals(); //if we don't force a parent flush, tree can get in a bad state
	      }

	      this._removeChildIds = null;
	    }
	  };

	  Object3DFacade.prototype.destructor = function destructor () {
	    this.notifyWorld('object3DRemoved');
	    var parentObj3D = this._parentObject3DFacade;
	    if (parentObj3D) {
	      parentObj3D._queueRemoveChildObject3D(this.threeObject.id);
	    }
	    delete this.threeObject;
	    PointerEventTarget.prototype.destructor.call(this);
	  };

	  return Object3DFacade;
	}(PointerEventTarget));
	['castShadow', 'receiveShadow', 'renderOrder', 'visible'].forEach(function (prop) {
	  Object.defineProperty(Object3DFacade.prototype, prop, {
	    get: function get() {
	      return this.threeObject[prop]
	    },
	    set: function set(value) {
	      this.threeObject[prop] = value;
	    }
	  });
	});

	/**
	 * @property {null|number} raycastSide
	 * Hook to force a different `side` than that of the material for mesh raycasting.
	 * Should be set to `FrontSide`|`BackSide`|`DoubleSide`, or `null` to use the
	 * material's side.
	 */
	Object3DFacade.prototype.raycastSide = null;


	// Create flat property setters for individual position/scale/rotation properties
	forOwn$1({
	  position: {
	    x: 'x',
	    y: 'y',
	    z: 'z'
	  },
	  scale: {
	    x: 'scaleX',
	    y: 'scaleY',
	    z: 'scaleZ'
	  },
	  rotation: {
	    x: 'rotateX',
	    y: 'rotateY',
	    z: 'rotateZ',
	    order: 'rotateOrder'
	  },
	  quaternion: {
	    x: 'quaternionX',
	    y: 'quaternionY',
	    z: 'quaternionZ',
	    w: 'quaternionW'
	  }
	}, function (attrs, aspect) {
	  forOwn$1(attrs, function (propName, attr) {
	    // Compile functions to avoid runtime cost of aspect/attr evaluation
	    Object.defineProperty(Object3DFacade.prototype, propName, {
	      get: new Function(("return function " + propName + "$get() {\n  return this.threeObject." + aspect + "." + attr + "\n}"))(),
	      set: new Function(("return function " + propName + "$set(value) {\n  //let obj = this.threeObject." + aspect + "\n  if (this.threeObject." + aspect + "." + attr + " !== value) {\n    this.threeObject." + aspect + "." + attr + " = value\n    if (!this._matrixChanged) {\n      this._matrixChanged = true\n    }\n  }\n}"))()
	    });
	  });
	});

	// ...and a special shortcut for uniform scale
	Object.defineProperty(Object3DFacade.prototype, 'scale', {
	  get: function get() {
	    // can't guarantee scale was already uniform, so just use scaleX arbitrarily
	    return this.threeObject.scale.x
	  },
	  set: function set(value) {
	    var scaleObj = this.threeObject.scale;
	    if (value !== scaleObj.x || value !== scaleObj.y || value !== scaleObj.z) {
	      scaleObj.x = scaleObj.y = scaleObj.z = value;
	      if (!this._matrixChanged) {
	        this._matrixChanged = true;
	      }
	    }
	  }
	});


	Object.defineProperty(Object3DFacade.prototype, 'isObject3DFacade', {value: true});

	// Predefine shape to facilitate JS engine optimization
	assign$1(Object3DFacade.prototype, {
	  threeObject: null,
	  _parentObject3DFacade: null,
	  _removeChildIds: null,
	  _matrixChanged: true,
	  _worldMatrixVersion: -1,
	  _worldMatrixVersionAfterLastUpdate: -1,
	  _boundingSphereChanged: false
	});

	// Define onBeforeRender/onAfterRender event handler properties
	Facade.defineEventProperty(Object3DFacade, 'onBeforeRender', 'beforerender');
	Facade.defineEventProperty(Object3DFacade, 'onAfterRender', 'afterrender');

	/**
	 * Regular expression for matching the `void main() {` opener line in GLSL.
	 * @type {RegExp}
	 */
	var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;

	/**
	 * Recursively expands all `#include <xyz>` statements within string of shader code.
	 * Copied from three's WebGLProgram#parseIncludes for external use.
	 *
	 * @param {string} source - The GLSL source code to evaluate
	 * @return {string} The GLSL code with all includes expanded
	 */
	function expandShaderIncludes( source ) {
	  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
	  function replace(match, include) {
	    var chunk = ShaderChunk[include];
	    return chunk ? expandShaderIncludes(chunk) : match
	  }
	  return source.replace( pattern, replace )
	}

	/*
	 * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three
	 * versions before 0.113.0 as it was changed from Math to MathUtils in that version.
	 * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16
	 */

	var _lut$1 = [];

	for (var i$1 = 0; i$1 < 256; i$1++) {
	  _lut$1[i$1] = (i$1 < 16 ? '0' : '') + (i$1).toString(16);
	}

	function generateUUID() {

	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	  var d0 = Math.random() * 0xffffffff | 0;
	  var d1 = Math.random() * 0xffffffff | 0;
	  var d2 = Math.random() * 0xffffffff | 0;
	  var d3 = Math.random() * 0xffffffff | 0;
	  var uuid = _lut$1[d0 & 0xff] + _lut$1[d0 >> 8 & 0xff] + _lut$1[d0 >> 16 & 0xff] + _lut$1[d0 >> 24 & 0xff] + '-' +
	    _lut$1[d1 & 0xff] + _lut$1[d1 >> 8 & 0xff] + '-' + _lut$1[d1 >> 16 & 0x0f | 0x40] + _lut$1[d1 >> 24 & 0xff] + '-' +
	    _lut$1[d2 & 0x3f | 0x80] + _lut$1[d2 >> 8 & 0xff] + '-' + _lut$1[d2 >> 16 & 0xff] + _lut$1[d2 >> 24 & 0xff] +
	    _lut$1[d3 & 0xff] + _lut$1[d3 >> 8 & 0xff] + _lut$1[d3 >> 16 & 0xff] + _lut$1[d3 >> 24 & 0xff];

	  // .toUpperCase() here flattens concatenated strings to save heap memory space.
	  return uuid.toUpperCase()

	}

	// Local assign polyfill to avoid importing troika-core
	var assign$2 = Object.assign || function(/*target, ...sources*/) {
	  var arguments$1 = arguments;

	  var target = arguments[0];
	  for (var i = 1, len = arguments.length; i < len; i++) {
	    var source = arguments$1[i];
	    if (source) {
	      for (var prop in source) {
	        if (source.hasOwnProperty(prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	};


	var epoch = Date.now();
	var CONSTRUCTOR_CACHE = new WeakMap();
	var SHADER_UPGRADE_CACHE = new Map();

	// Material ids must be integers, but we can't access the increment from Three's `Material` module,
	// so let's choose a sufficiently large starting value that should theoretically never collide.
	var materialInstanceId = 1e10;

	/**
	 * A utility for creating a custom shader material derived from another material's
	 * shaders. This allows you to inject custom shader logic and transforms into the
	 * builtin ThreeJS materials without having to recreate them from scratch.
	 *
	 * @param {THREE.Material} baseMaterial - the original material to derive from
	 *
	 * @param {Object} options - How the base material should be modified.
	 * @param {Object} options.defines - Custom `defines` for the material
	 * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`
	 * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can
	 *        be accessed and manipulated via the resulting material's `uniforms` property, just like
	 *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.
	 * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into
	 *        both shaders, and it will automatically be updated on each render frame with a number of
	 *        elapsed milliseconds. The "zero" epoch time is not significant so don't rely on this as a
	 *        true calendar time.
	 * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level
	 *        definitions, above the `void main()` function.
	 * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex
	 *        shader's `void main` function.
	 * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex
	 *        shader's `void main` function.
	 * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,
	 *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with
	 *        those attributes exposed by their normal names as read/write values.
	 * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level
	 *        definitions, above the `void main()` function.
	 * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment
	 *        shader's `void main` function.
	 * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment
	 *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes
	 *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you
	 *        want those to apply to your changes use `fragmentColorTransform` instead.
	 * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`
	 *        output value. Will be injected near the end of the `void main` function, but before any
	 *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the
	 *        `fragmentMainOutro`.
	 * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function
	 *        for performing custom rewrites of the full shader code. Useful if you need to do something
	 *        special that's not covered by the other builtin options. This function will be executed before
	 *        any other transforms are applied.
	 * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base
	 *        material, rather than the default behavior of copying it. This allows the derived material to
	 *        automatically pick up changes made to the base material and its properties. This can be useful
	 *        where the derived material is hidden from the user as an implementation detail, allowing them
	 *        to work with the original material like normal. But it can result in unexpected behavior if not
	 *        handled carefully.
	 *
	 * @return {THREE.Material}
	 *
	 * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,
	 * which can be called to get a variant of the derived material for use in shadow casting. If the
	 * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`
	 * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to
	 * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These
	 * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look
	 * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance
	 * scenarios, e.g. skipping antialiasing or expensive shader logic.
	 */
	function createDerivedMaterial(baseMaterial, options) {
	  // Generate a key that is unique to the content of these `options`. We'll use this
	  // throughout for caching and for generating the upgraded shader code. This increases
	  // the likelihood that the resulting shaders will line up across multiple calls so
	  // their GL programs can be shared and cached.
	  var optionsKey = getKeyForOptions(options);

	  // First check to see if we've already derived from this baseMaterial using this
	  // unique set of options, and if so reuse the constructor to avoid some allocations.
	  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
	  if (!ctorsByDerivation) {
	    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));
	  }
	  if (ctorsByDerivation[optionsKey]) {
	    return new ctorsByDerivation[optionsKey]()
	  }

	  var privateBeforeCompileProp = "_onBeforeCompile" + optionsKey;

	  // Private onBeforeCompile handler that injects the modified shaders and uniforms when
	  // the renderer switches to this material's program
	  var onBeforeCompile = function (shaderInfo) {
	    baseMaterial.onBeforeCompile.call(this, shaderInfo);

	    // Upgrade the shaders, caching the result by incoming source code
	    var cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;
	    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
	    if (!upgradedShaders) {
	      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);
	      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
	    }

	    // Inject upgraded shaders and uniforms into the program
	    shaderInfo.vertexShader = upgradedShaders.vertexShader;
	    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
	    assign$2(shaderInfo.uniforms, this.uniforms);

	    // Inject auto-updating time uniform if requested
	    if (options.timeUniform) {
	      shaderInfo.uniforms[options.timeUniform] = {
	        get value() {return Date.now() - epoch}
	      };
	    }

	    // Users can still add their own handlers on top of ours
	    if (this[privateBeforeCompileProp]) {
	      this[privateBeforeCompileProp](shaderInfo);
	    }
	  };

	  var DerivedMaterial = function DerivedMaterial() {
	    return derive(options.chained ? baseMaterial : baseMaterial.clone())
	  };

	  var derive = function(base) {
	    // Prototype chain to the base material
	    var derived = Object.create(base, descriptor);

	    // Store the baseMaterial for reference; this is always the original even when cloning
	    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });

	    // Needs its own ids
	    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });
	    derived.uuid = generateUUID();

	    // Merge uniforms, defines, and extensions
	    derived.uniforms = assign$2({}, base.uniforms, options.uniforms);
	    derived.defines = assign$2({}, base.defines, options.defines);
	    derived.defines[("TROIKA_DERIVED_MATERIAL_" + optionsKey)] = ''; //force a program change from the base material
	    derived.extensions = assign$2({}, base.extensions, options.extensions);

	    // Don't inherit EventDispatcher listeners
	    derived._listeners = undefined;

	    return derived
	  };

	  var descriptor = {
	    constructor: {value: DerivedMaterial},
	    isDerivedMaterial: {value: true},

	    customProgramCacheKey: {
	      writable: true,
	      configurable: true,
	      value: function () {
	        return optionsKey
	      }
	    },

	    onBeforeCompile: {
	      get: function get() {
	        return onBeforeCompile
	      },
	      set: function set(fn) {
	        this[privateBeforeCompileProp] = fn;
	      }
	    },

	    copy: {
	      writable: true,
	      configurable: true,
	      value: function (source) {
	        baseMaterial.copy.call(this, source);
	        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
	          assign$2(this.extensions, source.extensions);
	          assign$2(this.defines, source.defines);
	          assign$2(this.uniforms, UniformsUtils.clone(source.uniforms));
	        }
	        return this
	      }
	    },

	    clone: {
	      writable: true,
	      configurable: true,
	      value: function () {
	        var newBase = new baseMaterial.constructor();
	        return derive(newBase).copy(this)
	      }
	    },

	    /**
	     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
	     * transformations and discarded fragments.
	     */
	    getDepthMaterial: {
	      writable: true,
	      configurable: true,
	      value: function() {
	        var depthMaterial = this._depthMaterial;
	        if (!depthMaterial) {
	          depthMaterial = this._depthMaterial = createDerivedMaterial(
	            baseMaterial.isDerivedMaterial
	              ? baseMaterial.getDepthMaterial()
	              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
	            options
	          );
	          depthMaterial.defines.IS_DEPTH_MATERIAL = '';
	          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
	        }
	        return depthMaterial
	      }
	    },

	    /**
	     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
	     * transformations and discarded fragments.
	     */
	    getDistanceMaterial: {
	      writable: true,
	      configurable: true,
	      value: function() {
	        var distanceMaterial = this._distanceMaterial;
	        if (!distanceMaterial) {
	          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
	            baseMaterial.isDerivedMaterial
	              ? baseMaterial.getDistanceMaterial()
	              : new MeshDistanceMaterial(),
	            options
	          );
	          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';
	          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
	        }
	        return distanceMaterial
	      }
	    },

	    dispose: {
	      writable: true,
	      configurable: true,
	      value: function value() {
	        var ref = this;
	        var _depthMaterial = ref._depthMaterial;
	        var _distanceMaterial = ref._distanceMaterial;
	        if (_depthMaterial) { _depthMaterial.dispose(); }
	        if (_distanceMaterial) { _distanceMaterial.dispose(); }
	        baseMaterial.dispose.call(this);
	      }
	    }
	  };

	  ctorsByDerivation[optionsKey] = DerivedMaterial;
	  return new DerivedMaterial()
	}


	function upgradeShaders(ref, options, key) {
	  var vertexShader = ref.vertexShader;
	  var fragmentShader = ref.fragmentShader;

	  var vertexDefs = options.vertexDefs;
	  var vertexMainIntro = options.vertexMainIntro;
	  var vertexMainOutro = options.vertexMainOutro;
	  var vertexTransform = options.vertexTransform;
	  var fragmentDefs = options.fragmentDefs;
	  var fragmentMainIntro = options.fragmentMainIntro;
	  var fragmentMainOutro = options.fragmentMainOutro;
	  var fragmentColorTransform = options.fragmentColorTransform;
	  var customRewriter = options.customRewriter;
	  var timeUniform = options.timeUniform;

	  vertexDefs = vertexDefs || '';
	  vertexMainIntro = vertexMainIntro || '';
	  vertexMainOutro = vertexMainOutro || '';
	  fragmentDefs = fragmentDefs || '';
	  fragmentMainIntro = fragmentMainIntro || '';
	  fragmentMainOutro = fragmentMainOutro || '';

	  // Expand includes if needed
	  if (vertexTransform || customRewriter) {
	    vertexShader = expandShaderIncludes(vertexShader);
	  }
	  if (fragmentColorTransform || customRewriter) {
	    // We need to be able to find postprocessing chunks after include expansion in order to
	    // put them after the fragmentColorTransform, so mark them with comments first. Even if
	    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,
	    // so we still mark them.
	    fragmentShader = fragmentShader.replace(
	      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
	      '\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n'
	    );
	    fragmentShader = expandShaderIncludes(fragmentShader);
	  }

	  // Apply custom rewriter function
	  if (customRewriter) {
	    var res = customRewriter({vertexShader: vertexShader, fragmentShader: fragmentShader});
	    vertexShader = res.vertexShader;
	    fragmentShader = res.fragmentShader;
	  }

	  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract
	  // those and re-insert them into the outro in the correct place:
	  if (fragmentColorTransform) {
	    var postChunks = [];
	    fragmentShader = fragmentShader.replace(
	      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines
	      function (match) {
	        postChunks.push(match);
	        return ''
	      }
	    );
	    fragmentMainOutro = fragmentColorTransform + "\n" + (postChunks.join('\n')) + "\n" + fragmentMainOutro;
	  }

	  // Inject auto-updating time uniform if requested
	  if (timeUniform) {
	    var code = "\nuniform float " + timeUniform + ";\n";
	    vertexDefs = code + vertexDefs;
	    fragmentDefs = code + fragmentDefs;
	  }

	  // Inject a function for the vertexTransform and rename all usages of position/normal/uv
	  if (vertexTransform) {
	    // Hoist these defs to the very top so they work in other function defs
	    vertexShader = "vec3 troika_position_" + key + ";\nvec3 troika_normal_" + key + ";\nvec2 troika_uv_" + key + ";\n" + vertexShader + "\n";
	    vertexDefs = vertexDefs + "\nvoid troikaVertexTransform" + key + "(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  " + vertexTransform + "\n}\n";
	    vertexMainIntro = "\ntroika_position_" + key + " = vec3(position);\ntroika_normal_" + key + " = vec3(normal);\ntroika_uv_" + key + " = vec2(uv);\ntroikaVertexTransform" + key + "(troika_position_" + key + ", troika_normal_" + key + ", troika_uv_" + key + ");\n" + vertexMainIntro + "\n";
	    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, function (match, match1, index, fullStr) {
	      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : ("troika_" + match1 + "_" + key)
	    });
	  }

	  // Inject defs and intro/outro snippets
	  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
	  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);

	  return {
	    vertexShader: vertexShader,
	    fragmentShader: fragmentShader
	  }
	}

	function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
	  if (intro || outro || defs) {
	    shaderCode = shaderCode.replace(voidMainRegExp, ("\n" + defs + "\nvoid troikaOrigMain" + id + "() {")
	    );
	    shaderCode += "\nvoid main() {\n  " + intro + "\n  troikaOrigMain" + id + "();\n  " + outro + "\n}";
	  }
	  return shaderCode
	}


	function optionsJsonReplacer(key, value) {
	  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value
	}

	var _idCtr = 0;
	var optionsHashesToIds = new Map();
	function getKeyForOptions(options) {
	  var optionsHash = JSON.stringify(options, optionsJsonReplacer);
	  var id = optionsHashesToIds.get(optionsHash);
	  if (id == null) {
	    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));
	  }
	  return id
	}

	// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders
	// TODO how can we keep this from getting stale?
	var MATERIAL_TYPES_TO_SHADERS = {
	  MeshDepthMaterial: 'depth',
	  MeshDistanceMaterial: 'distanceRGBA',
	  MeshNormalMaterial: 'normal',
	  MeshBasicMaterial: 'basic',
	  MeshLambertMaterial: 'lambert',
	  MeshPhongMaterial: 'phong',
	  MeshToonMaterial: 'toon',
	  MeshStandardMaterial: 'physical',
	  MeshPhysicalMaterial: 'physical',
	  MeshMatcapMaterial: 'matcap',
	  LineBasicMaterial: 'basic',
	  LineDashedMaterial: 'dashed',
	  PointsMaterial: 'points',
	  ShadowMaterial: 'shadow',
	  SpriteMaterial: 'sprite'
	};

	/**
	 * Given a Three.js `Material` instance, find the shaders/uniforms that will be
	 * used to render that material.
	 *
	 * @param material - the Material instance
	 * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`
	 */
	function getShadersForMaterial(material) {
	  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];
	  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?
	}

	/**
	 * Find all uniforms and their types within a shader code string.
	 *
	 * @param {string} shader - The shader code to parse
	 * @return {object} mapping of uniform names to their glsl type
	 */
	function getShaderUniformTypes(shader) {
	  var uniformRE = /\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g;
	  var uniforms = Object.create(null);
	  var match;
	  while ((match = uniformRE.exec(shader)) !== null) {
	    uniforms[match[2]] = match[1];
	  }
	  return uniforms
	}

	/**
	 * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion
	 * that happened in ThreeJS r123.
	 * @param {Matrix4} srcMatrix
	 * @param {Matrix4} [tgtMatrix]
	 */
	function invertMatrix4(srcMatrix, tgtMatrix) {
	  if ( tgtMatrix === void 0 ) tgtMatrix = new Matrix4();

	  if (typeof tgtMatrix.invert === 'function') {
	    tgtMatrix.copy(srcMatrix).invert();
	  } else {
	    tgtMatrix.getInverse(srcMatrix);
	  }
	  return tgtMatrix
	}

	var noop$1 = function() {};
	var tempRaycaster = new Raycaster();
	var tempVec2 = new Vector2();
	var tempVec3 = new Vector3();
	var tempMat4 = new Matrix4();
	var tempQuat = new Quaternion();
	var lookAtUp = new Vector3(0, 1, 0);

	var _projectionMatrixVersion = 0;

	function createCameraFacade(threeJsCameraClass, projectionProps, otherProps) {
	  var Camera3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	    function Camera3DFacade(parent) {
	      Object3DFacade.call(this, parent);
	      this.lookAt = this.up = null;
	      this._projectionChanged = false;
	      this._frustum = new Frustum();
	    }

	    if ( Object3DFacade ) Camera3DFacade.__proto__ = Object3DFacade;
	    Camera3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	    Camera3DFacade.prototype.constructor = Camera3DFacade;

	    Camera3DFacade.prototype.initThreeObject = function initThreeObject () {
	      var camera = new threeJsCameraClass();
	      // Forcibly prevent updateMatrixWorld from doing anything when called; the renderer
	      // likes to call this even though matrixAutoUpdate=false which can sometimes clobber
	      // our optimized `updateMatrices` handling and any custom adjustments it may make.
	      // TODO consider doing this at the Object3DFacade level?
	      camera.updateMatrixWorld = noop$1;
	      return camera
	    };

	    Camera3DFacade.prototype.afterUpdate = function afterUpdate () {
	      // Apply lookAt+up as a final transform - applied as individual quaternion
	      // properties so they can selectively trigger updates, be transitioned, etc.
	      if (this.lookAt) {
	        tempVec3.copy(this.lookAt);
	        lookAtUp.copy(this.up || Object3D.DefaultUp);
	        tempMat4.lookAt(this.threeObject.position, tempVec3, lookAtUp);
	        tempQuat.setFromRotationMatrix(tempMat4);
	        this.quaternionX = tempQuat.x;
	        this.quaternionY = tempQuat.y;
	        this.quaternionZ = tempQuat.z;
	        this.quaternionW = tempQuat.w;
	      }
	      Object3DFacade.prototype.afterUpdate.call(this);
	    };

	    Camera3DFacade.prototype.updateMatrices = function updateMatrices () {
	      var camObj = this.threeObject;

	      // Projection changes require a projection matrix rebuild - see setters below
	      if (this._projectionChanged) {
	        camObj.updateProjectionMatrix();
	        this._projectionChanged = false;
	        this._projectionMatrixVersion = _projectionMatrixVersion++;
	      }

	      // If changing the world matrix, also update its inverse
	      var matrixVersionBeforeUpdate = this._worldMatrixVersion;
	      Object3DFacade.prototype.updateMatrices.call(this);
	      if (matrixVersionBeforeUpdate !== this._worldMatrixVersion) {
	        invertMatrix4(camObj.matrixWorld, camObj.matrixWorldInverse);
	      }
	    };

	    /**
	     * Utility method that returns a Frustum object which is initialized to match this camera's
	     * current state. This can be used for example to optimize updates to the Facade tree by
	     * avoiding work for objects that fall outside the camera's view.
	     *
	     * You can access this by calling `this.getCameraFacade().getFrustum()` from any Object3DFacade's
	     * `afterUpdate` lifecycle method or later.
	     *
	     * Be careful that this Frustum does not get modified after it is requested, as it is cached for
	     * the lifetime of the camera's current world matrix and modifiying it would result in bad state
	     * for other code requesting it within that lifetime.
	     *
	     * @return {Frustum}
	     */
	    Camera3DFacade.prototype.getFrustum = function getFrustum () {
	      this.updateMatrices();
	      var frustum = this._frustum;
	      var ref = this;
	      var _worldMatrixVersion = ref._worldMatrixVersion;
	      var _projectionMatrixVersion = ref._projectionMatrixVersion;
	      if (frustum._lastWorldMatrixVersion !== _worldMatrixVersion || frustum._lastProjMatrixVersion !== _projectionMatrixVersion) {
	        var camObj = this.threeObject;
	        var matrix = new Matrix4().multiplyMatrices(camObj.projectionMatrix, camObj.matrixWorldInverse);
	        frustum.setFromMatrix(matrix);
	        frustum._lastWorldMatrixVersion = _worldMatrixVersion;
	        frustum._lastProjMatrixVersion = _projectionMatrixVersion;
	      }
	      return frustum
	    };

	    /**
	     * Given a set of camera projection coordinates (u,v in the range [-1, 1]), return a `Ray`
	     * representing that line of sight in worldspace.
	     * @param {number} u
	     * @param {number} v
	     * @return Ray
	     */
	    Camera3DFacade.prototype.getRayAtProjectedCoords = function getRayAtProjectedCoords (u, v) {
	      // By default we use the builtin Raycaster functionality, but this can be overridden
	      var ray = tempRaycaster.ray = new Ray();
	      tempRaycaster.setFromCamera(tempVec2.set(u, v), this.threeObject);
	      return ray
	    };

	    return Camera3DFacade;
	  }(Object3DFacade));

	  // Setters for properties which require a matrix update
	  function defineProp(prop, affectsProjection) {
	    Object.defineProperty(Camera3DFacade.prototype, prop, {
	      set: function set(val) {
	        if (val !== this.threeObject[prop]) {
	          this.threeObject[prop] = val;
	          if (affectsProjection) { this._projectionChanged = true; }
	        }
	      },
	      get: function get() {
	        return this.threeObject[prop]
	      }
	    });
	  }

	  projectionProps.forEach(function (prop) {
	    defineProp(prop, true);
	  });

	  if (otherProps) {
	    otherProps.forEach(function (prop) {
	      defineProp(prop, false);
	    });
	  }

	  return Camera3DFacade
	}


	var PerspectiveCamera3DFacade = createCameraFacade(PerspectiveCamera, ['fov', 'aspect', 'near', 'far'], ['focus', 'filmGauge', 'filmOffset']);
	createCameraFacade(OrthographicCamera, ['left', 'right', 'top', 'bottom', 'near', 'far']);

	var Group3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function Group3DFacade () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Group3DFacade.__proto__ = Object3DFacade;
	  Group3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Group3DFacade.prototype.constructor = Group3DFacade;

	  Group3DFacade.prototype.initThreeObject = function initThreeObject () {
	    var group = new Group();
	    group.isRenderable = false; //trigger optimizations
	    return group
	  };

	  return Group3DFacade;
	}(Object3DFacade));

	/**
	 * Defines a snippet of HTML content that will be positioned to line up with the object's
	 * xyz as projected by the scene's camera. This is a convenient way to display tooltips,
	 * labels, and pieces of UI that follow a given object around.
	 */
	var HtmlOverlay3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function HtmlOverlay3DFacade(parent) {
	    var obj = new Object3D();
	    obj.isRenderable = false; //trigger optimizations
	    Object3DFacade.call(this, parent, obj);

	    /**
	     * Defines the HTML content to be rendered. The type/format of this value is dependent
	     * on the wrapping implementation; for example the Canvas3D.js React-based wrapper will
	     * expect a React element descriptor, while other wrappers might expect a HTML string.
	     *
	     * When using the React-based wrapper, the rendered React component will not be updated
	     * when the overlay is repositioned, unless (a) the `html` element descriptor changes, or
	     * (b) that element descriptor has a `shouldUpdateOnMove` prop.
	     */
	    this.html = null;

	    /**
	     * If set to true, the overlay's x/y position on screen will not be rounded to whole-pixel
	     * values. This can give more accurate alignment at the expense of fuzzy lines and text.
	     */
	    this.exact = false;

	    this.notifyWorld('addHtmlOverlay', this);
	  }

	  if ( Object3DFacade ) HtmlOverlay3DFacade.__proto__ = Object3DFacade;
	  HtmlOverlay3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  HtmlOverlay3DFacade.prototype.constructor = HtmlOverlay3DFacade;

	  HtmlOverlay3DFacade.prototype.destructor = function destructor () {
	    this.notifyWorld('removeHtmlOverlay', this);
	    Object3DFacade.prototype.destructor.call(this);
	  };

	  return HtmlOverlay3DFacade;
	}(Object3DFacade));

	//import {ShadowMapViewer} from 'three/examples/jsm/utils/ShadowMapViewer.js'


	// Common superclass with setters for all possible light properties
	var Light3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function Light3DFacade () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Light3DFacade.__proto__ = Object3DFacade;
	  Light3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Light3DFacade.prototype.constructor = Light3DFacade;

	  var prototypeAccessors = { color: { configurable: true },shadow: { configurable: true } };

	  prototypeAccessors.color.set = function (c) {
	    this.threeObject.color.set(c);
	  };
	  prototypeAccessors.color.get = function () {
	    return this.threeObject.color.getHex()
	  };

	  // Shadow map configurable by deep object copy:
	  prototypeAccessors.shadow.get = function () {
	    return this.threeObject.shadow
	  };
	  prototypeAccessors.shadow.set = function (val) {
	    assignDeep(this.threeObject.shadow, val);
	  };

	  Object.defineProperties( Light3DFacade.prototype, prototypeAccessors );

	  return Light3DFacade;
	}(Object3DFacade));
	// Setters for simple properties to be copied
	['intensity', 'distance', 'angle', 'penumbra', 'decay', 'castShadow', 'width', 'height'].forEach(function (propName) {
	  Object.defineProperty(Light3DFacade.prototype, propName, {
	    get: function get() {
	      return this.threeObject[propName]
	    },
	    set: function set(value) {
	      this.threeObject[propName] = value;
	    }
	  });
	});


	function createLightFacade(ThreeJsLightClass, HelperClass, customProtoDefs) {
	  var Cls = /*@__PURE__*/(function (Light3DFacade) {
	    function Cls () {
	      Light3DFacade.apply(this, arguments);
	    }

	    if ( Light3DFacade ) Cls.__proto__ = Light3DFacade;
	    Cls.prototype = Object.create( Light3DFacade && Light3DFacade.prototype );
	    Cls.prototype.constructor = Cls;

	    var prototypeAccessors = { showHelper: { configurable: true } };

	    Cls.prototype.initThreeObject = function initThreeObject () {
	      return new ThreeJsLightClass()
	    };
	    prototypeAccessors.showHelper.set = function (showHelper) {
	      var helper = this._helper;
	      if (!!showHelper !== !!helper) {
	        if (showHelper) {
	          this.threeObject.add(this._helper = new HelperClass(this.threeObject));
	        } else if (helper) {
	          helper.dispose();
	          this.threeObject.remove(helper);
	          this._helper = null;
	        }
	      }
	    };
	    Cls.prototype.afterUpdate = function afterUpdate () {
	      Light3DFacade.prototype.afterUpdate.call(this);
	      if (this._helper) {
	        this._helper.update();
	      }
	    };

	    Object.defineProperties( Cls.prototype, prototypeAccessors );

	    return Cls;
	  }(Light3DFacade));
	  if (customProtoDefs) {
	    Object.defineProperties(Cls.prototype, customProtoDefs);
	  }
	  return Cls
	}

	var AmbientLight3DFacade = createLightFacade(AmbientLight);
	var DirectionalLight3DFacade = createLightFacade(DirectionalLight, DirectionalLightHelper);
	var SpotLight3DFacade = createLightFacade(SpotLight, SpotLightHelper);
	var PointLight3DFacade = createLightFacade(PointLight, PointLightHelper);
	var HemisphereLight3DFacade = createLightFacade(HemisphereLight, HemisphereLightHelper, {
	  groundColor: {
	    set: function set(c) {
	      this.threeObject.groundColor.set(c);
	    },
	    get: function get() {
	      return this.threeObject.groundColor.getHex()
	    }
	  }
	});
	createLightFacade(RectAreaLight);

	var inverseFunction = "\n#if __VERSION__ < 300\n// matrix inversion utility for pre-ES3 - credit https://github.com/stackgl/glsl-inverse\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(\n    b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)\n  ) / det;\n}\n#endif\n";

	var vertexCommonDefs = "\nattribute vec4 troika_modelMatrixRow0;\nattribute vec4 troika_modelMatrixRow1;\nattribute vec4 troika_modelMatrixRow2;\nmat4 troika_modelMatrix;\nmat4 troika_modelViewMatrix;\nmat3 troika_normalMatrix;\n";

	var modelMatrixVarAssignment = "\ntroika_modelMatrix = mat4(\n  %0.x, %1.x, %2.x, 0.0,\n  %0.y, %1.y, %2.y, 0.0,\n  %0.z, %1.z, %2.z, 0.0,\n  %0.w, %1.w, %2.w, 1.0\n);\n".replace(/%/g, 'troika_modelMatrixRow');

	var modelViewMatrixVarAssignment = "\ntroika_modelViewMatrix = viewMatrix * troika_modelMatrix;\n";

	var normalMatrixVarAssignment = "\ntroika_normalMatrix = transposeMat3(inverse(mat3(troika_modelViewMatrix)));\n";


	var modelMatrixRefRE = /\bmodelMatrix\b/g;
	var modelViewMatrixRefRE = /\bmodelViewMatrix\b/g;
	var normalMatrixRefRE = /\bnormalMatrix\b/g;
	var precededByUniformRE = /\buniform\s+(int|float|vec[234])\s+$/;
	var attrRefReplacer = function (name, index, str) { return precededByUniformRE.test(str.substr(0, index)) ? name : ("troika_" + name); };
	var varyingRefReplacer = function (name, index, str) { return precededByUniformRE.test(str.substr(0, index)) ? name : ("troika_vary_" + name); };

	var CACHE = new WeakMap();

	/**
	 * Get a derived material with instancing upgrades for the given base material.
	 * The result is cached by baseMaterial+instanceUniforms so we always get the same instance
	 * back rather than getting a clone each time and having to re-upgrade every frame.
	 */
	function getInstancingDerivedMaterial(baseMaterial, instanceUniforms) {
	  var instanceUniformsKey = instanceUniforms ? instanceUniforms.sort().join('|') : '';
	  var derived = CACHE.get(baseMaterial);
	  if (!derived || derived._instanceUniformsKey !== instanceUniformsKey) {
	    derived = createDerivedMaterial(baseMaterial, {
	      defines: {
	        TROIKA_INSTANCED_UNIFORMS: instanceUniformsKey
	      },
	      customRewriter: function customRewriter(ref) {
	        var vertexShader = ref.vertexShader;
	        var fragmentShader = ref.fragmentShader;

	        return upgradeShaders$1(vertexShader, fragmentShader, instanceUniforms)
	      }
	    });
	    derived._instanceUniformsKey = instanceUniformsKey;
	    CACHE.set(baseMaterial, derived);
	  }
	  return derived
	}


	/**
	 * Transform the given vertex and fragment shader pair so they accept instancing
	 * attributes for the builtin matrix uniforms as well as any other uniforms that
	 * have been declared as instanceable.
	 */
	function upgradeShaders$1(vertexShader, fragmentShader, instanceUniforms) {
	  // See what gets used
	  var usesModelMatrix = modelMatrixRefRE.test(vertexShader);
	  var usesModelViewMatrix = modelViewMatrixRefRE.test(vertexShader);
	  var usesNormalMatrix = normalMatrixRefRE.test(vertexShader);

	  // Find what uniforms are declared in which shader and their types
	  var vertexUniforms = getShaderUniformTypes(vertexShader);
	  var fragmentUniforms = getShaderUniformTypes(fragmentShader);

	  var vertexDeclarations = [vertexCommonDefs];
	  var vertexAssignments = [];
	  var fragmentDeclarations = [];

	  // Add variable assignments for, and rewrite references to, builtin matrices
	  if (usesModelMatrix || usesModelViewMatrix || usesNormalMatrix) {
	    vertexShader = vertexShader.replace(modelMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(modelMatrixVarAssignment);
	  }
	  if (usesModelViewMatrix || usesNormalMatrix) {
	    vertexShader = vertexShader.replace(modelViewMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(modelViewMatrixVarAssignment);
	  }
	  if (usesNormalMatrix) {
	    vertexShader = vertexShader.replace(normalMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(normalMatrixVarAssignment);
	    // Add the inverse() glsl polyfill if there isn't already one defined
	    if (!/\binverse\s*\(/.test(vertexShader)) {
	      vertexDeclarations.push(inverseFunction);
	    }
	  }

	  // Add attributes and varyings for, and rewrite references to, instanceUniforms
	  if (instanceUniforms) {
	    instanceUniforms.forEach(function (name) {
	      var vertType = vertexUniforms[name];
	      var fragType = fragmentUniforms[name];
	      if (vertType || fragType) {
	        var finder = new RegExp(("\\b" + name + "\\b"), 'g');
	        vertexDeclarations.push(("attribute " + (vertType || fragType) + " troika_" + name + ";"));
	        if (vertType) {
	          vertexShader = vertexShader.replace(finder, attrRefReplacer);
	        }
	        if (fragType) {
	          fragmentShader = fragmentShader.replace(finder, varyingRefReplacer);
	          var varyingDecl = "varying " + fragType + " troika_vary_" + name + ";";
	          vertexDeclarations.push(varyingDecl);
	          fragmentDeclarations.push(varyingDecl);
	          vertexAssignments.push(("troika_vary_" + name + " = troika_" + name + ";"));
	        }
	      }
	    });
	  }

	  // Inject vertex shader declarations and assignments
	  vertexShader = "\n" + (vertexDeclarations.join('\n')) + "\n" + (vertexShader.replace(voidMainRegExp, ("\n  $&\n  " + (vertexAssignments.join('\n')) + "\n")));

	  // Inject fragment shader declarations
	  if (fragmentDeclarations.length) {
	    fragmentShader = "\n" + (fragmentDeclarations.join('\n')) + "\n" + fragmentShader;
	  }

	  return {vertexShader: vertexShader, fragmentShader: fragmentShader}
	}

	var assign$3 = assign;

	var INSTANCE_BATCH_SIZE = 128; //TODO make this an option?
	var DYNAMIC_DRAW = 0x88E8; //can't import DynamicDrawUsage from three without breaking older versions

	/**
	 * An InstancingManager handles aggregating all Instanceable3DFacade descendants into
	 * instancing batches. For each batch it creates a clone of the instancedThreeObject,
	 * populates a pooled InstancedBufferGeometry with buffer attributes holding the world
	 * matrices of all the batch's instances, and temporarily inserts that into the
	 * scene to be rendered.
	 *
	 * As an additional "turbo" optimization, the instancing batch objects/geometries will be
	 * reused untouched between rendering frames if none of the managed Instanceable3DFacade
	 * objects have changed in a way that would affect the batches or world matrix attributes.
	 *
	 * There is a global InstancingManager automatically added to the main scene, and it does
	 * nothing if there are no Instanceable3DFacades in the scene, so in most cases you should
	 * not need to touch this yourself. But it is also possible to insert additional
	 * InstancingManager facades further down in the scene if you wish to control the scope
	 * of instancing, e.g. to increase the likelihood of the aforementioned "turbo" optimization
	 * kicking in.
	 *
	 * Also see InstancingShaderUpgrades, which modifies material shaders so they accept the matrix
	 * and custom uniform values coming in as attributes. This allows built-in materials as well
	 * as custom shaders to work with instancing without manual modification.
	 */
	var InstancingManager = /*@__PURE__*/(function (Group3DFacade) {
	  function InstancingManager(parent) {
	    Group3DFacade.call(this, parent);
	    this._instanceables = Object.create(null);
	    this._batchGeometryPool = new BatchGeometryPool();
	    this._needsRebatch = true;
	    this.addEventListener('beforerender', this._setupBatchObjects.bind(this));
	    this.addEventListener('afterrender', this._teardownBatchObjects.bind(this));
	  }

	  if ( Group3DFacade ) InstancingManager.__proto__ = Group3DFacade;
	  InstancingManager.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  InstancingManager.prototype.constructor = InstancingManager;

	  InstancingManager.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
	    var handler = this._notifyWorldHandlers[message];
	    if (handler) {
	      handler.call(this, source, data);
	    } else if (this.parent) {
	      this.parent.onNotifyWorld(source, message, data);
	    }
	  };

	  InstancingManager.prototype._setupBatchObjects = function _setupBatchObjects (renderer, scene, camera) {
	    var instanceables = this._instanceables;
	    var batchObjectsByKey = this._batchObjectsByKey;
	    var needsRebatch = this._needsRebatch;

	    if (!needsRebatch) {
	      // We'll already know about most types of changes (instanceable addition/removal, instancedThreeObject
	      // changes, matrix changes) but if any of the instancedThreeObjects changed their geometry or material
	      // internally we'll need to detect that here and deoptimize.
	      for (var key in batchObjectsByKey) {
	        var batchObj = batchObjectsByKey[key][0];
	        if (this._getBatchKey(batchObj.$troikaBatchBaseObj) !== key) {
	          needsRebatch = true;
	          break
	        }
	      }
	    }

	    if (needsRebatch) {
	      batchObjectsByKey = this._batchObjectsByKey = Object.create(null);
	      var geometryPool = this._batchGeometryPool;
	      for (var facadeId in instanceables) {
	        var facade = instanceables[facadeId];
	        var instanceObject = facade.threeObject;
	        var protoObject = facade.instancedThreeObject;

	        if (protoObject && instanceObject.visible) {
	          // Find or create the batch object for this facade's instancedThreeObject
	          var batchKey = this._getBatchKey(protoObject);
	          var instanceUniforms = this._getInstanceUniformNames(protoObject);
	          var batchObjects = batchObjectsByKey[batchKey] || (batchObjectsByKey[batchKey] = []);
	          var batchObject = batchObjects[batchObjects.length - 1];
	          var batchGeometry = batchObject && batchObject.geometry;
	          if (!batchGeometry || getInstanceCount(batchGeometry) === INSTANCE_BATCH_SIZE) {
	            batchObject = this._getBatchObject(protoObject);
	            batchGeometry = batchObject.geometry;
	            var attrs = batchGeometry._instanceAttrs.matrix;
	            for (var row = 0; row < 3; row++) {
	              attrs[row].version++;
	            }
	            if (instanceUniforms) {
	              attrs = batchGeometry._instanceAttrs.uniforms;
	              for (var i = instanceUniforms.length; i--;) {
	                attrs[instanceUniforms[i]].version++;
	              }
	            }
	            batchObjects.push(batchObject);
	          }

	          // Put the instance's world matrix into the batch geometry's instancing attributes
	          var attrOffset = getInstanceCount(batchGeometry);
	          setInstanceCount(batchGeometry, attrOffset + 1);
	          var attrs$1 = batchGeometry._instanceAttrs.matrix;
	          var elements = instanceObject.matrixWorld.elements; //column order
	          attrs$1[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]);
	          attrs$1[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]);
	          attrs$1[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]);

	          // Put the instance's values for instanceUniforms into the corresponding attributes
	          if (instanceUniforms) {
	            attrs$1 = batchGeometry._instanceAttrs.uniforms;
	            for (var i$1 = instanceUniforms.length; i$1--;) {
	              var uniform = instanceUniforms[i$1];
	              var attr = attrs$1[uniform];
	              var facadeUniforms = facade._instanceUniforms;
	              var value = facadeUniforms && (uniform in facadeUniforms) ?
	                facadeUniforms[uniform] : getDefaultUniformValue(protoObject.material, uniform);
	              setAttributeValue(attr, attrOffset, value);
	            }
	          }

	          // Save pointers for possible reuse next frame
	          facade._instancingBatchObject = batchObject;
	          facade._instancingBatchAttrOffset = attrOffset;
	        } else {
	          facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        }
	      }

	      // Dispose any old batch geometries that were unused during this render pass
	      // TODO should this be delayed any to prevent thrashing?
	      geometryPool.disposeUnused();
	    }

	    // Add the batch objects to the scene
	    var batchCount = 0;
	    var batchGrpCount = 0;
	    var instanceCount = 0;
	    for (var id in batchObjectsByKey) {
	      var batchObjects$1 = batchObjectsByKey[id];
	      scene.children.push.apply(scene.children, batchObjects$1);

	      // increment stats
	      batchGrpCount++;
	      for (var i$2 = batchObjects$1.length; i$2--;) {
	        batchCount++;
	        instanceCount += getInstanceCount(batchObjects$1[i$2].geometry);
	      }
	    }

	    this.notifyWorld('statsUpdate', {
	      'Instancing Batch Groups': batchGrpCount,
	      'Instancing Batches': batchCount,
	      'Instanced Objects': instanceCount
	    });

	    this._needsRebatch = false;
	  };

	  InstancingManager.prototype._onInstanceAdded = function _onInstanceAdded (facade) {
	    this._instanceables[facade.$facadeId] = facade;
	    this._needsRebatch = true;
	  };

	  InstancingManager.prototype._onInstanceRemoved = function _onInstanceRemoved (facade) {
	    delete this._instanceables[facade.$facadeId];
	    this._needsRebatch = true;
	  };

	  InstancingManager.prototype._onInstanceChanged = function _onInstanceChanged (facade) {
	    this._needsRebatch = true;
	  };

	  InstancingManager.prototype._onInstanceMatrixChanged = function _onInstanceMatrixChanged (facade) {
	    // If a single instance's matrix changed and the batches are still otherwise valid, avoid a
	    // full rebatch by updating just this instance's values in the matrix attributes directly.
	    if (!this._needsRebatch) {
	      var protoObject = facade.instancedThreeObject;
	      var batchObject = facade._instancingBatchObject;
	      var attrOffset = facade._instancingBatchAttrOffset;
	      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)) {
	        var attrs = batchObject.geometry._instanceAttrs.matrix;
	        var elements = facade.threeObject.matrixWorld.elements;
	        attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]).version++;
	        attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]).version++;
	        attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]).version++;
	      } else {
	        // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
	        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        this._needsRebatch = true;
	      }
	    }
	  };

	  InstancingManager.prototype._onInstanceUniformChanged = function _onInstanceUniformChanged (facade, uniformName) {
	    if (!this._needsRebatch) {
	      var protoObject = facade.instancedThreeObject;
	      var batchObject = facade._instancingBatchObject;
	      var attr;
	      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)
	        && (attr = batchObject.geometry._instanceAttrs.uniforms[uniformName])) {
	        setAttributeValue(attr, facade._instancingBatchAttrOffset, facade._instanceUniforms[uniformName]);
	        attr.version++; //skip setter
	      } else {
	        // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
	        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        this._needsRebatch = true;
	      }
	    }
	  };

	  InstancingManager.prototype._getBatchKey = function _getBatchKey (object) {
	    var cache = this._batchKeysCache || (this._batchKeysCache = Object.create(null)); //cache results for duration of this frame
	    var key = cache && cache[object.id];
	    if (!key) {
	      var uniforms = this._getInstanceUniformNames(object);
	      key = (object.geometry.id) + "|" + (object.material.id) + "|" + (uniforms ? uniforms.sort().join(',') : '');
	      cache[object.id] = key;
	    }
	    return key
	  };

	  InstancingManager.prototype._getInstanceUniformNames = function _getInstanceUniformNames (object) {
	    var namesSet = object._instanceUniformNames;
	    if (!namesSet) { return null }
	    var cache = this._uniformNamesCache || (this._uniformNamesCache = new Map());
	    var namesArray = cache.get(namesSet);
	    if (!namesArray) {
	      namesArray = Array.from(namesSet);
	      cache.set(namesSet, namesArray);
	    }
	    return namesArray
	  };

	  InstancingManager.prototype._getInstanceUniformSizes = function _getInstanceUniformSizes (material, uniformNames) {
	    // Cache results per material for duration of this frame
	    var cache = this._uniformSizesCache || (this._uniformSizesCache = new Map());
	    var result = cache.get(material);
	    if (!result) {
	      result = Object.create(null);
	      if (uniformNames) {
	        uniformNames.forEach(function (name) {
	          var size = getUniformItemSize(material, name);
	          if (size > 0) {
	            result[name] = size;
	          } else {
	            console.warn(("Could not determine item size for uniform " + name));
	          }
	        });
	      }
	      cache.set(material, result);
	    }
	    return result
	  };

	  InstancingManager.prototype._getBatchObject = function _getBatchObject (instancedObject) {
	    var geometry = instancedObject.geometry;
	    var material = instancedObject.material;

	    // Upgrade the geometry to an instanced one
	    if (!geometry.isBufferGeometry) {
	      throw new Error('Instanceable proto object must use a BufferGeometry')
	    }
	    var batchKey = this._getBatchKey(instancedObject);
	    var uniformNames = this._getInstanceUniformNames(instancedObject);
	    var uniformSizes = this._getInstanceUniformSizes(material, uniformNames);
	    var batchGeometry = this._batchGeometryPool.borrow(batchKey, geometry, uniformSizes);
	    setInstanceCount(batchGeometry, 0);

	    // Upgrade the material to one with the shader modifications for instancing
	    var batchMaterial = getInstancingDerivedMaterial(material, uniformNames);
	    var depthMaterial, distanceMaterial;

	    // Create a new mesh object to hold it all
	    var batchObject = Object.create(instancedObject, {
	      // Redefine properties rather than setting them so we don't inadvertently trigger setters on
	      // the base object:
	      geometry: { value: batchGeometry },
	      material: { value: batchMaterial },
	      visible: { value: true },
	      frustumCulled: { value: false },

	      // Lazy getters for shadow materials:
	      customDepthMaterial: {
	        get: function get() {
	          if (!depthMaterial) {
	            depthMaterial = batchMaterial.getDepthMaterial();
	            // We need to trick WebGLRenderer into setting the `viewMatrix` uniform, which it doesn't
	            // normally do for MeshDepthMaterial but it's needed by the instancing shader code. It does
	            // for ShaderMaterials so we pretend to be one.
	            depthMaterial.isShaderMaterial = true;
	          }
	          return depthMaterial
	        }
	      },
	      customDistanceMaterial: {
	        get: function get() {
	          if (!distanceMaterial) {
	            distanceMaterial = batchMaterial.getDistanceMaterial();
	            // We need to trick WebGLRenderer into setting the `viewMatrix` uniform, which it doesn't
	            // normally do for MeshDistanceMaterial but it's needed by the instancing shader code. It does
	            // for ShaderMaterials so we pretend to be one.
	            distanceMaterial.isShaderMaterial = true;

	            // Additionally, WebGLShadowMap.render() rotates a single camera 6 times per object, which fails
	            // to trigger the code in WebGLRenderer.setProgram() that updates the viewMatrix uniform for
	            // directions 2 through 6. Since we need a correct viewMatrix in the instancing shader code,
	            // we hack it by defining our own viewMatrix uniform on the distance material and manually
	            // updating it before each view of the distance cube is rendered. Unfortunately intercepting the
	            // view changes in a way that has access to the shadow camera's viewMatrix has proven quite
	            // difficult; the least-awful way I've found is to monkeypatch the `modelViewMatrix.multiplyMatrices()`
	            // function which is always called - see (*!) below.
	            distanceMaterial.uniforms = assign$3({
	              viewMatrix: { value: new Matrix4() }
	            }, distanceMaterial.uniforms);
	          }
	          return distanceMaterial
	        }
	      },
	      // (*!) Hack for updating viewMatrix uniform on the distance material - see explanation above.
	      modelViewMatrix: {
	        value: function() {
	          var modelViewMatrix = new Matrix4();
	          modelViewMatrix.multiplyMatrices = function(viewMatrix, matrixWorld) {
	            if (distanceMaterial) {
	              distanceMaterial.uniforms.viewMatrix.value.copy(viewMatrix);
	              distanceMaterial.uniformsNeedUpdate = true; //undocumented flag for ShaderMaterial
	            }
	            return Matrix4.prototype.multiplyMatrices.call(this, viewMatrix, matrixWorld)
	          };
	          return modelViewMatrix
	        }()
	      }
	    });
	    batchObject.$troikaBatchBaseObj = instancedObject;
	    batchObject.$troikaInstancingManager = this;
	    // NOTE other props are inherited so don't need to copy them
	    return batchObject
	  };

	  InstancingManager.prototype._teardownBatchObjects = function _teardownBatchObjects (renderer, scene, camera) {
	    var this$1 = this;

	    // Release geometries to the pool for next time
	    this._batchGeometryPool.releaseAll();

	    // Clear caches from this render frame
	    this._batchKeysCache = null;
	    this._uniformNamesCache = null;
	    this._uniformSizesCache = null;

	    // Remove batch objects from scene
	    scene.children = scene.children.filter(function (obj) { return obj.$troikaInstancingManager !== this$1; });
	  };

	  InstancingManager.prototype.destructor = function destructor () {
	    var pool = this._batchGeometryPool;
	    pool.releaseAll();
	    pool.disposeUnused();
	    Group3DFacade.prototype.destructor.call(this);
	  };

	  return InstancingManager;
	}(Group3DFacade));


	/**
	 * Pool for the instancing batch geometries
	 */
	var BatchGeometryPool = function BatchGeometryPool() {
	  this._poolsByKey = Object.create(null);
	};

	BatchGeometryPool.prototype.borrow = function borrow (key, baseGeometry, instanceUniformSizes) {
	  var poolsByKey = this._poolsByKey;
	  var pool = poolsByKey[key] || (poolsByKey[key] = {geometries: [], firstFree: 0});
	  var batchGeometry = pool.geometries[pool.firstFree++];

	  if (!batchGeometry) {
	    batchGeometry = new InstancedBufferGeometry();
	    assign$3(batchGeometry, baseGeometry);
	    batchGeometry.attributes = assign$3({}, baseGeometry.attributes);
	    var instanceAttrs = batchGeometry._instanceAttrs = {matrix: [], uniforms: Object.create(null)}; //separate collections for quicker lookup

	    // Create instancing attributes for the modelMatrix's rows
	    for (var row = 0; row < 3; row++) {
	      var attr = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * 4), 4);
	      if (attr.setUsage) {
	        attr.setUsage(DYNAMIC_DRAW);
	      } else {
	        attr.dynamic = true;
	      }
	      batchGeometry.attributes[("troika_modelMatrixRow" + row)] = attr;
	      instanceAttrs.matrix[row] = attr;
	    }

	    // Create instancing attributes for the instanceUniforms
	    for (var name in instanceUniformSizes) {
	      var itemSize = instanceUniformSizes[name];
	      var attr$1 = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * itemSize), itemSize);
	      if (attr$1.setUsage) {
	        attr$1.setUsage(DYNAMIC_DRAW);
	      } else {
	        attr$1.dynamic = true;
	      }
	      batchGeometry.attributes[("troika_" + name)] = attr$1;
	      instanceAttrs.uniforms[name] = attr$1;
	    }

	    pool.geometries.push(batchGeometry);
	  }

	  return batchGeometry
	};

	BatchGeometryPool.prototype.releaseAll = function releaseAll () {
	  var pools = this._poolsByKey;
	  if (pools) {
	    for (var key in pools) {
	      pools[key].firstFree = 0;
	    }
	  }
	};

	BatchGeometryPool.prototype.disposeUnused = function disposeUnused () {
	  var pools = this._poolsByKey;
	  if (pools) {
	    for (var key in pools) {
	      var ref = pools[key];
	        var firstFree = ref.firstFree;
	        var geometries = ref.geometries;
	      for (var i = firstFree, len = geometries.length; i < len; i++) {
	        // Only allow the instancing attributes to be disposed; those copied from the
	        // original geometry will be up to the author to dispose of properly
	        var attrs = geometries[i].attributes;
	        for (var attrName in attrs) {
	          if (attrs.hasOwnProperty(attrName) && attrName.indexOf('troika_') !== 0) {
	            delete attrs[attrName];
	          }
	        }
	        try {
	          // can throw if it's already been disposed or hasn't yet been rendered
	          geometries[i].dispose();
	        } catch(e) {}
	        geometries[i]._instanceAttrs = null;
	      }
	      geometries.length = firstFree;
	    }
	  }
	};


	var proto = InstancingManager.prototype;
	proto._notifyWorldHandlers = {
	  instanceableAdded: proto._onInstanceAdded,
	  instanceableRemoved: proto._onInstanceRemoved,
	  instanceableChanged: proto._onInstanceChanged,
	  instanceableMatrixChanged: proto._onInstanceMatrixChanged,
	  instanceableUniformChanged: proto._onInstanceUniformChanged
	};


	function setAttributeValue(attr, offset, value) {
	  var size = attr.itemSize;
	  if (size === 1) {
	    attr.setX(offset, value);
	  }
	  else if (size === 2) {
	    attr.setXY(offset, value.x, value.y);
	  }
	  else if (size === 3) {
	    if (value.isColor) {
	      attr.setXYZ(offset, value.r, value.g, value.b);
	    } else {
	      attr.setXYZ(offset, value.x, value.y, value.z);
	    }
	  } else if (size === 4) {
	    attr.setXYZW(offset, value.x, value.y, value.z, value.w);
	  }
	}

	function getDefaultUniformValue(material, name) {
	  // Try uniforms on the material itself, then try the builtin material shaders
	  var uniforms = material.uniforms;
	  if (uniforms && uniforms[name]) {
	    return uniforms[name].value
	  }
	  uniforms = getShadersForMaterial(material).uniforms;
	  if (uniforms && uniforms[name]) {
	    return uniforms[name].value
	  }
	  return null
	}

	function getUniformItemSize(material, name) {
	  return getItemSizeForValue(getDefaultUniformValue(material, name))
	}

	function getItemSizeForValue(value) {
	  return value == null ? 0
	    : typeof value === 'number' ? 1
	    : value.isVector2 ? 2
	    : (value.isVector3 || value.isColor) ? 3
	    : value.isVector4 ? 4
	    : Array.isArray(value) ? value.length
	    : 0
	}

	// Handle maxInstancedCount -> instanceCount rename that happened in three r117
	function getInstanceCount(geom) {
	  return geom[geom.hasOwnProperty('instanceCount') ? 'instanceCount' : 'maxInstancedCount']
	}
	function setInstanceCount(geom, count) {
	  geom[geom.hasOwnProperty('instanceCount') ? 'instanceCount' : 'maxInstancedCount'] = count;
	}

	var LIGHT_TYPES = {
	  ambient: AmbientLight3DFacade,
	  directional: DirectionalLight3DFacade,
	  spot: SpotLight3DFacade,
	  point: PointLight3DFacade,
	  hemisphere: HemisphereLight3DFacade
	};

	var RAY_INTERSECTION = [{distance: Infinity}];
	var INFINITE_SPHERE = new Sphere(undefined, Infinity);
	var tempArr = [null];

	var Scene3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function Scene3DFacade () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Scene3DFacade.__proto__ = Object3DFacade;
	  Scene3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Scene3DFacade.prototype.constructor = Scene3DFacade;

	  var prototypeAccessors = { fog: { configurable: true } };

	  Scene3DFacade.prototype.initThreeObject = function initThreeObject () {
	    var scene = new Scene();
	    // We always manually update world matrices when needed - see Object3DFacade.updateMatrices() -
	    // so the additional autoUpdate pass done by threejs before render is not needed:
	    scene.autoUpdate = false;
	    return scene
	  };

	  Scene3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var scene = this.threeObject;
	    scene.background = this.background || null;
	    scene.environment = this.environment || null;
	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  Scene3DFacade.prototype.describeChildren = function describeChildren () {
	    // Add root instancing manager
	    var children = {
	      key: 'instancingMgr',
	      facade: InstancingManager,
	      children: this.objects
	    };

	    // Map light definitions to their appropriate classes
	    var ref = this;
	    var lights = ref.lights;
	    if (lights) {
	      children = [children];
	      if (!Array.isArray(lights)) {
	        tempArr[0] = lights;
	        lights = tempArr;
	      }
	      lights.forEach(function (def, i) {
	        var facade = def.facade || LIGHT_TYPES[def.type];
	        if (typeof facade === 'function') {
	          var realDef = assign({}, def);
	          delete realDef.type;
	          realDef.key = def.key || ("light" + i);
	          realDef.facade = facade;
	          children.push(realDef);
	        }
	      });
	    }

	    return children
	  };

	  prototypeAccessors.fog.set = function (def) {
	    var fogObj = this._fogObj;
	    if (def) {
	      var isExp2 = 'density' in def;
	      var fogClass = isExp2 ? FogExp2 : Fog;
	      if (!fogObj || !(fogObj instanceof fogClass)) {
	        fogObj = this._fogObj = new fogClass();
	      }
	      fogObj.color.set(def.color);
	      if (isExp2) {
	        fogObj.density = def.density;
	      } else {
	        fogObj.near = def.near;
	        fogObj.far = def.far;
	      }
	    } else {
	      fogObj = this._fogObj = null;
	    }
	    this.threeObject.fog = fogObj;
	  };

	  Scene3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
	    return INFINITE_SPHERE
	  };

	  Scene3DFacade.prototype.raycast = function raycast (raycaster) {
	    // Scene3DFacade will always intersect, but as the furthest from the camera
	    return RAY_INTERSECTION
	  };

	  Object.defineProperties( Scene3DFacade.prototype, prototypeAccessors );

	  return Scene3DFacade;
	}(Object3DFacade));

	var assign$4 = assign;
	var forOwn$2 = forOwn;
	var tempSphere = new Sphere();
	var SQRT3 = Math.sqrt(3);
	var PRECISION = 1e-8;


	var BoundingSphereOctree = function BoundingSphereOctree() {
	  this.root = null;
	  this.keysToLeaves = Object.create(null);
	};

	BoundingSphereOctree.prototype.putSpheres = function putSpheres (spheres) {
	    var this$1 = this;

	  forOwn$2(spheres, function (sphere, key) {
	    this$1.putSphere(key, sphere);
	  });
	};

	BoundingSphereOctree.prototype.putSphere = function putSphere (key, sphere) {
	  var center = sphere.center;
	    var radius = sphere.radius;

	  // Sanity check
	  if (!sphere || isNaN(radius) || isNaN(center.x)) {
	    console.warn('Invalid sphere', sphere);
	    return
	  }

	  // To prevent excessively deep trees when spheres are very close together, apply a rounding
	  // precision below which spheres will be treated as coincident and stored in the same leaf.
	  center._roundedX = Math.round(center.x / PRECISION) * PRECISION;
	  center._roundedY = Math.round(center.y / PRECISION) * PRECISION;
	  center._roundedZ = Math.round(center.z / PRECISION) * PRECISION;

	  this._putSphere(key, sphere);
	};

	BoundingSphereOctree.prototype._putSphere = function _putSphere (key, sphere) {
	    var this$1 = this;

	  var center = sphere.center;
	  var ref = this;
	    var root = ref.root;
	  var _roundedX = center._roundedX;
	    var _roundedY = center._roundedY;
	    var _roundedZ = center._roundedZ;

	  // If we already have a sphere for this key, perform an update
	  if (key in this.keysToLeaves) {
	    return this._updateSphere(key, sphere)
	  }

	  // First sphere being added: create a leaf octant and set it as the root. This will be replaced as
	  // soon as a second item is added, so we can start with an initial root bounding cube that matches
	  // our actual dataset rather than an arbitrary one.
	  if (!root) {
	    var newRoot = new Octant();
	    newRoot.isLeaf = true;
	    newRoot.addSphereData(key, sphere);
	    this.root = newRoot;
	    this.keysToLeaves[key] = newRoot;
	  }

	  // Second sphere being added:
	  else if (root.isLeaf) {
	    var oldRoot = this.root;
	    var dataX = root.dataX;
	      var dataY = root.dataY;
	      var dataZ = root.dataZ;

	    // Handle special case where the second sphere has the same center point as the first, we still
	    // can't determine good starting bounds so just append to the existing leaf
	    if (dataX === _roundedX && dataY === _roundedY && dataZ === _roundedZ) {
	      this._insertIntoOctant(key, sphere, root);
	    }
	    // Non-coincident: we can now choose an appropriate size for the root node's box. Overwrite the
	    // root with a new branch octant, and set its position/size to the smallest whole-integer cube
	    // that contains both sphere centerpoints. (Cube rounded to whole ints to avoid floating point issues)
	    else {
	      var newRoot$1 = new Octant();
	      var cx = newRoot$1.cx = Math.round((dataX + _roundedX) / 2);
	      var cy = newRoot$1.cy = Math.round((dataY + _roundedY) / 2);
	      var cz = newRoot$1.cz = Math.round((dataZ + _roundedZ) / 2);
	      newRoot$1.cr = Math.ceil(Math.max(Math.abs(cx - dataX), Math.abs(cy - dataY), Math.abs(cz - dataZ)) + 1e-5);
	      this.root = newRoot$1;

	      // Re-add the original leaf's sphere(s) and the new sphere under the new branch root, and exit
	      oldRoot.forEachLeafSphere(function (_sphere, _key) { return this$1._insertIntoOctant(_key, _sphere, newRoot$1); });
	      this._insertIntoOctant(key, sphere, newRoot$1);
	    }
	  }

	  // Expand the root to cover the new centerpoint if necessary, and insert the sphere within it
	  else {
	    this._expandToCoverPoint(_roundedX, _roundedY, _roundedZ);
	    this._insertIntoOctant(key, sphere, this.root);
	  }
	};

	BoundingSphereOctree.prototype._expandToCoverPoint = function _expandToCoverPoint (x, y, z) {
	  // Loop until the root cube contains the new point...
	  while (!this.root.containsPoint(x, y, z)) {
	    // Create a larger branch, expanded by 2x in the corner direction closest to the new point
	    var oldRoot = this.root;
	    var cx = oldRoot.cx;
	      var cy = oldRoot.cy;
	      var cz = oldRoot.cz;
	      var cr = oldRoot.cr;
	    var newRoot = new Octant();
	    newRoot.maxRadius = oldRoot.maxRadius;
	    newRoot.sphereCount = oldRoot.sphereCount;
	    newRoot.leafCount = oldRoot.leafCount;

	    newRoot.cx = cx + cr * (x < cx ? -1 : 1);
	    newRoot.cy = cy + cr * (y < cy ? -1 : 1);
	    newRoot.cz = cz + cr * (z < cz ? -1 : 1);
	    newRoot.cr = cr * 2;

	    // Move the old root to be a child of the new outer box, and make the outer box the new root
	    var octantIdx = newRoot.getSubOctantIndexForPoint(cx, cy, cz);
	    oldRoot.parent = newRoot;
	    oldRoot.index = octantIdx;
	    newRoot[octantIdx] = oldRoot;
	    this.root = newRoot;
	  }
	};

	BoundingSphereOctree.prototype._insertIntoOctant = function _insertIntoOctant (key, sphere, octant) {
	  var center = sphere.center;
	    var radius = sphere.radius;
	  var _roundedX = center._roundedX;
	    var _roundedY = center._roundedY;
	    var _roundedZ = center._roundedZ;

	  // If the parent octant is a leaf:
	  if (octant.isLeaf) {
	    var dataX = octant.dataX;
	      var dataY = octant.dataY;
	      var dataZ = octant.dataZ;

	    // If the new sphere's center matches that of the leaf, add it to the leaf's members
	    if (_roundedX === dataX && _roundedY === dataY && _roundedZ === dataZ) {
	      octant.addSphereData(key, sphere);

	      // Increase maxRadius up the parent tree as needed
	      for (var oct = octant.parent; oct; oct = oct.parent) {
	        if (radius > oct.maxRadius) { oct.maxRadius = radius; }
	      }

	      // Add to index
	      this.keysToLeaves[key] =octant;
	    }

	    // Otherwise split the leaf into a branch, push the old leaf down, and try again
	    else {
	      var newBranch = _createBranchFromLeaf(octant);
	      octant.parent[octant.index] = newBranch;
	      newBranch.addOctantForPoint(octant, dataX, dataY, dataZ);
	      this._insertIntoOctant(key, sphere, newBranch); //recurse
	    }
	  }

	  // The parent octant is a branch:
	  else {
	    // Always increment branch's total count
	    octant.sphereCount++;

	    // Find the suboctant index in which the new center point falls
	    var subOctantIndex = octant.getSubOctantIndexForPoint(_roundedX, _roundedY, _roundedZ);

	    // If there is nothing at that index yet, insert a new leaf octant
	    var subOctant = octant[subOctantIndex];
	    if (!subOctant) {
	      var newLeaf = new Octant();
	      newLeaf.isLeaf = true;
	      octant.addOctantForPoint(newLeaf, _roundedX, _roundedY, _roundedZ);
	      newLeaf.addSphereData(key, sphere);

	      // Increment leafCount and maxRadius up the parent tree
	      for (var oct$1 = newLeaf.parent; oct$1; oct$1 = oct$1.parent) {
	        if (radius > oct$1.maxRadius) { oct$1.maxRadius = radius; }
	        oct$1.leafCount++;
	      }

	      // Add to index
	      this.keysToLeaves[key] = newLeaf;
	    }

	    // If there was already a sub-octant at that index, recurse
	    else {
	      return this._insertIntoOctant(key, sphere, subOctant)
	    }
	  }
	};

	BoundingSphereOctree.prototype.removeSphere = function removeSphere (key) {
	  // Find the existing leaf that holds the sphere
	  var leafOctant = this.keysToLeaves[key];
	  if (!leafOctant) { return }

	  // Preemptively decrement sphereCount up the parent tree
	  var oct = leafOctant.parent;
	  while (oct) {
	    oct.sphereCount--;
	    oct = oct.parent;
	  }

	  // If there are other members in the leaf, remove it from the leaf's members and keep the leaf in place
	  if (leafOctant.sphereCount > 1) {
	    // Remove sphere from the leaf data
	    leafOctant.removeSphereData(key);

	    // Update maxRadius up the tree
	    leafOctant.updateMaxRadii();
	  }

	  // It was the only member of the leaf; remove the leaf and any ancestor branches that are now empty
	  else {
	    // Walk up the tree and remove all empty branches
	    oct = leafOctant;
	    var lowestRemainingOctant;
	    do {
	      var parent = oct.parent;
	      lowestRemainingOctant = parent;
	      if (parent) {
	        parent[oct.index] = null;
	      }
	      oct = oct.parent;
	    } while (oct && oct.sphereCount === 0)

	    // If we got to the top of the tree, it's totally empty so set the root to null and exit
	    if (!lowestRemainingOctant) {
	      this.root = null;
	      return
	    }

	    // Continue up the tree, decrementing the leafCount and looking for the highest branch point with only
	    // a single remaining leaf underneath it, if any
	    var highestSingleLeafBranch = null;
	    oct = lowestRemainingOctant;
	    while (oct) {
	      oct.leafCount--;
	      if (oct.leafCount === 1) {
	        highestSingleLeafBranch = oct;
	      }
	      oct = oct.parent;
	    }

	    // If we were left with a branch with only one leaf descendant, move that leaf up to the branch point
	    if (highestSingleLeafBranch) {
	      var leaf = this._findSingleLeaf(highestSingleLeafBranch);
	      var parent$1 = highestSingleLeafBranch.parent;
	      if (parent$1) {
	        parent$1.addOctantForPoint(leaf, leaf.cx, leaf.cy, leaf.cz);
	        parent$1.updateMaxRadii();
	      } else {
	        this.root = leaf;
	      }
	    } else {
	      // Update the max radii up the tree from the lowest remaining node
	      lowestRemainingOctant.updateMaxRadii();
	    }
	  }

	  // Delete it from the index
	  delete this.keysToLeaves[key];
	};

	BoundingSphereOctree.prototype._updateSphere = function _updateSphere (key, sphere) {
	  // Find the existing leaf octant that holds the sphere
	  var leaf = this.keysToLeaves[key];

	  var center = sphere.center;
	  var _roundedX = center._roundedX;
	    var _roundedY = center._roundedY;
	    var _roundedZ = center._roundedZ;

	  // If its center point still falls within the leaf's cube, we can fast-path the changes:
	  if (leaf.containsPoint(_roundedX, _roundedY, _roundedZ)) {
	    var isMulti = leaf.sphereCount > 1;

	    var hasMoved = _roundedX !== leaf.dataX ||
	      _roundedY !== leaf.dataY ||
	      _roundedZ !== leaf.dataZ;

	    // If it was not the only member and has changed position, split that leaf; we can do this
	    // slightly faster than a full remove+add because we know this will be the branch point and can
	    // avoid some unnecessary upward tree walking
	    if (isMulti && hasMoved) {
	      leaf.removeSphereData(key);
	      leaf.updateMaxRadii();
	      this._insertIntoOctant(key, sphere, leaf);
	    }

	    // Otherwise we can just update this leaf
	    else {
	      if (hasMoved) {
	        leaf.dataX = _roundedX;
	        leaf.dataY = _roundedY;
	        leaf.dataZ = _roundedZ;
	      }
	      if (sphere.radius !== leaf.maxRadius) {
	        leaf.updateMaxRadii();
	      }
	    }
	  }

	  // If its center point is no longer within the leaf, delegate to full remove+add
	  // TODO possible faster path: remove only up to lowest common ancestor branch point,
	  // collapse remaining up to that point, and insert sphere under that point
	  else {
	    this.removeSphere(key);
	    this._putSphere(key, sphere);
	  }
	};

	// Optimized utility for finding single descendant leaf without creating a function
	BoundingSphereOctree.prototype._findSingleLeaf = function _findSingleLeaf (octant) {
	  var leaf;
	  function visit(oct) {
	    if (oct.isLeaf) { leaf = oct; }
	  }
	  function find(oct) {
	    leaf = null;
	    this.walkBranch(oct, visit);
	    return leaf
	  }
	  this._findSingleLeaf = find; //reuse closure after first call
	  return find.call(this, octant)
	};


	/**
	 * Perform a depth-first walk of the tree structure, invoking a `callback` function for
	 * each node. The `callback` will be passed the current tree node object, and will be invoked
	 * for parent branch nodes first before their child nodes.
	 *
	 * If the function returns `false` for a branch node, none of that branch's children will be
	 * visited; this is how you can efficiently query the tree by filtering out the majority of branches.
	 *
	 * @param {Function} callback
	 */
	BoundingSphereOctree.prototype.walkTree = function walkTree (callback) {
	  if (this.root) {
	    this.walkBranch(this.root, callback);
	  }
	};
	BoundingSphereOctree.prototype.walkBranch = function walkBranch (root, callback) {
	  if (callback(root) !== false && !root.isLeaf) {
	    for (var i = 0; i < 8; i++) {
	      if (root[i] !== null) {
	        this.walkBranch(root[i], callback);
	      }
	    }
	  }
	};


	/**
	 * Given a {@link Ray}, search the octree for any spheres that intersect that ray and invoke
	 * the given `callback` function, passing it the sphere and its key as arguments.
	 * TODO need to handle near/far
	 *
	 * @param {Ray} ray
	 * @param {Function} callback
	 * @param {Object} scope
	 */
	BoundingSphereOctree.prototype.forEachSphereOnRay = function forEachSphereOnRay (ray, callback, scope) {
	  return this._forEachMatchingSphere(ray.intersectsSphere.bind(ray), callback, scope)
	};

	BoundingSphereOctree.prototype.forEachIntersectingSphere = function forEachIntersectingSphere (sphere, callback, scope) {
	  return this._forEachMatchingSphere(sphere.intersectsSphere.bind(sphere), callback, scope)
	};

	BoundingSphereOctree.prototype._forEachMatchingSphere = function _forEachMatchingSphere (testFn, callback, scope) {
	  // const startTime = performance.now()
	  // let branchTests = 0
	  // let sphereTests = 0
	  // let sphereHits = 0

	  function visitSphere(sphere, key) {
	    // sphereTests++
	    if (testFn(sphere)) {
	      // sphereHits++
	      callback.call(scope, sphere, key);
	    }
	  }

	  this.walkTree(function (octant) {
	    if (octant.isLeaf) { //leaf
	      octant.forEachLeafSphere(visitSphere);
	    } else { //branch
	      // branchTests++
	      // Test using a sphere large enough to cover the maximum constituent bounding sphere with
	      // its center anywhere within the octant's box. This will obviously catch some false positives
	      // but those will be filtered at the leaf level.
	      // TODO investigate using a Box3 test, which could have fewer false positives, but only if that
	      // outweighs its slower speed (see https://jsperf.com/ray-intersectsphere-vs-intersectbox)
	      tempSphere.center.set(octant.cx, octant.cy, octant.cz);
	      tempSphere.radius = octant.cr * SQRT3 + octant.maxRadius;
	      if (!testFn(tempSphere)) {
	        return false //ignore this branch
	      }
	    }
	    return true
	  });

	  //console.log(`Raycast search: ${branchTests} branch tests, ${sphereTests} sphere tests, and ${sphereHits} hits, in ${performance.now() - startTime}ms`)
	};




	var Octant = function Octant () {};

	Octant.prototype.containsPoint = function containsPoint (x, y, z) {
	  var ref = this;
	    var cx = ref.cx;
	    var cy = ref.cy;
	    var cz = ref.cz;
	    var cr = ref.cr;
	  return x >= cx - cr && x < cx + cr &&
	    y >= cy - cr && y < cy + cr &&
	    z >= cz - cr && z < cz + cr
	};

	Octant.prototype.getSubOctantIndexForPoint = function getSubOctantIndexForPoint (x, y, z) {
	  return (z < this.cz ? 0 : 4) + (y < this.cy ? 0 : 2) + (x < this.cx ? 0 : 1)
	};

	Octant.prototype.addOctantForPoint = function addOctantForPoint (subOctant, x, y, z) {
	  var index = this.getSubOctantIndexForPoint(x, y, z);
	  var subCR = this.cr / 2;

	  subOctant.parent = this;
	  subOctant.index = index;
	  subOctant.cx = this.cx + subCR * (x < this.cx ? -1 : 1);
	  subOctant.cy = this.cy + subCR * (y < this.cy ? -1 : 1);
	  subOctant.cz = this.cz + subCR * (z < this.cz ? -1 : 1);
	  subOctant.cr = subCR;

	  this[index] = subOctant;
	  return subOctant
	};

	Octant.prototype.findMaxSphereRadius = function findMaxSphereRadius () {
	  var maxRadius = 0;
	  if (this.isLeaf) {
	    var data = this.data;
	    if (this.sphereCount > 1) {
	      for (var key in data) {
	        var r = data[key].radius;
	        if (r > maxRadius) { maxRadius = r; }
	      }
	    } else {
	      maxRadius = data.radius;
	    }
	  } else {
	    for (var i = 0; i < 8; i++) {
	      if (this[i] !== null && this[i].maxRadius > maxRadius) {
	        maxRadius = this[i].maxRadius;
	      }
	    }
	  }
	  return maxRadius
	};

	Octant.prototype.updateMaxRadii = function updateMaxRadii () {
	  // Find the max maxRadius of the leaf octant's members
	  var maxRadius = this.findMaxSphereRadius();

	  // If the max radius has grown, just do a simple increase of the ancestor maxRadius values
	  if (maxRadius > this.maxRadius) {
	    var octant = this;
	    while (octant) {
	      if (maxRadius > octant.maxRadius) {
	        octant.maxRadius = maxRadius;
	      }
	      octant = octant.parent;
	    }
	  }
	  // If the max radius has shrunk, set it and repeat the process up the parent tree
	  else if (maxRadius < this.maxRadius) {
	    this.maxRadius = maxRadius;
	    if (this.parent) {
	      this.parent.updateMaxRadii();
	    }
	  }
	};

	Octant.prototype.addSphereData = function addSphereData (key, sphere) {
	  var count = this.sphereCount++;
	  if (count === 0) {
	    this.leafCount = 1;
	    this.data = sphere;
	    this.dataKey = key;
	    // copy center coords from the first added sphere
	    var ref = sphere.center;
	      var _roundedX = ref._roundedX;
	      var _roundedY = ref._roundedY;
	      var _roundedZ = ref._roundedZ;
	    this.dataX = _roundedX;
	    this.dataY = _roundedY;
	    this.dataZ = _roundedZ;
	  }
	  else if (count === 1) {
	    var oldSphere = this.data;
	    var newData = this.data = Object.create(null);
	    newData[this.dataKey] = oldSphere;
	    newData[key] = sphere;
	    this.dataKey = null;
	  }
	  else if (count > 1) {
	    this.data[key] = sphere;
	  }

	  if (sphere.radius > this.maxRadius) {
	    this.maxRadius = sphere.radius;
	  }
	};

	Octant.prototype.removeSphereData = function removeSphereData (key) {
	  var data = this.data;
	  if (data) {
	    var count = this.sphereCount--;
	    if (count > 2) {
	      delete data[key];
	    }
	    else if (count === 2) {
	      for (var _key in data) {
	        if (_key !== key) {
	          this.dataKey = _key;
	          this.data = data[_key];
	          break
	        }
	      }
	    }
	    else {
	      this.data = null;
	    }
	  }
	};

	Octant.prototype.forEachLeafSphere = function forEachLeafSphere (fn, scope) {
	  var data = this.data;
	  if (data) {
	    if (this.sphereCount > 1) {
	      for (var key in data) {
	        fn.call(scope, data[key], key);
	      }
	    } else {
	      fn.call(scope, data, this.dataKey);
	    }
	  }
	};
	assign$4(Octant.prototype, {
	  // Relationships
	  parent: null,
	  index: -1,

	  // Cube bounds
	  cx: 0, //center x
	  cy: 0, //center y
	  cz: 0, //center z
	  cr: 0, //cubic radius (dist from center to edge)

	  // Sub-octants
	  0: null,
	  1: null,
	  2: null,
	  3: null,
	  4: null,
	  5: null,
	  6: null,
	  7: null,

	  // Leaf data
	  // For a single-item leaf (probably the vast majority) `data` will be the Sphere object and `dataKey`
	  // will be its key. For a multi-item leaf, `data` will be an object of key->Sphere mappings and
	  // `dataKey` will be null. I'm not a huge fan of the asymmetry but this lets us avoid an extra
	  // sub-object for the majority of leaves while keeping the Octant's shape predictable for the JS engine.
	  isLeaf: false,
	  data: null,
	  dataKey: null,
	  // The first sphere added to the leaf will have its center position copied for easier access and
	  // to avoid issues with the Sphere objects being mutated elsewhere.
	  dataX: 0,
	  dataY: 0,
	  dataZ: 0,

	  // Stats
	  sphereCount: 0,
	  leafCount: 0,
	  maxRadius: 0
	});



	var _createBranchFromLeaf = (function() {
	  var copyProps = ['parent', 'index', 'cx', 'cy', 'cz', 'cr', 'sphereCount', 'leafCount', 'maxRadius'];
	  return function(leaf) {
	    var branch = new Octant();
	    for (var i = copyProps.length; i--;) {
	      branch[copyProps[i]] = leaf[copyProps[i]];
	    }
	    return branch
	  }
	})();

	var assign$5 = assign;
	var tmpVec2 = new Vector2();
	var tmpVec3 = new Vector3();
	var raycaster = new Raycaster();


	var World3DFacade = /*@__PURE__*/(function (WorldBaseFacade) {
	  function World3DFacade(canvas) {
	    WorldBaseFacade.call(this, canvas);
	    this._object3DFacadesById = Object.create(null);
	    this._onBgClick = this._onBgClick.bind(this);
	  }

	  if ( WorldBaseFacade ) World3DFacade.__proto__ = WorldBaseFacade;
	  World3DFacade.prototype = Object.create( WorldBaseFacade && WorldBaseFacade.prototype );
	  World3DFacade.prototype.constructor = World3DFacade;

	  World3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var width = ref.width;
	    var height = ref.height;
	    var antialias = ref.antialias;
	    var backgroundColor = ref.backgroundColor;
	    var contextAttributes = ref.contextAttributes;
	    var canvas = ref._element;

	    // Set up renderer
	    var renderer = this._threeRenderer;
	    var RendererClass = this.rendererClass || WebGLRenderer;
	    if (!renderer || !(renderer instanceof RendererClass)) {
	      if (renderer) {
	        renderer.dispose();
	      }
	      // Init the context manually so we can prefer webgl2
	      contextAttributes = assign$5({
	        alpha: true,
	        antialias: antialias
	      }, contextAttributes);
	      var context = canvas.getContext('webgl2', contextAttributes) || undefined;
	      if (!context) {
	        console.info('webgl2 init failed, trying webgl');
	      }
	      renderer = this._threeRenderer = new RendererClass(assign$5({
	        canvas: canvas,
	        context: context
	      }, contextAttributes));
	    }

	    var shadows = this.shadows;
	    renderer.shadowMap.enabled = !!shadows;
	    if (shadows && typeof shadows === 'object') {
	      assign$5(renderer.shadowMap, shadows);
	    }

	    if (backgroundColor !== this._bgColor) {
	      renderer.setClearColor(new Color(backgroundColor || 0), backgroundColor != null ? 1 : 0);
	      this._bgColor = backgroundColor;
	    }

	    renderer.outputEncoding = this.outputEncoding || LinearEncoding;
	    renderer.toneMapping = this.toneMapping || NoToneMapping;

	    // Update render canvas size
	    this._updateDrawingBufferSize(width, height, this.pixelRatio || window.devicePixelRatio || 1);

	    WorldBaseFacade.prototype.afterUpdate.call(this);
	  };

	  World3DFacade.prototype.describeChildren = function describeChildren () {
	    return [
	      this._getCameraDef(),
	      this._getSceneDef()
	    ]
	  };

	  /**
	   * Build a normalized definition for the camera facade
	   * @protected
	   */
	  World3DFacade.prototype._getCameraDef = function _getCameraDef () {
	    var ref = this;
	    var camera = ref.camera;
	    return assign$5({
	      key: 'camera',
	      facade: PerspectiveCamera3DFacade,
	      aspect: this.width / this.height
	    }, camera)
	  };

	  /**
	   * Build a normalized definition for the scene facade
	   * @protected
	   */
	  World3DFacade.prototype._getSceneDef = function _getSceneDef () {
	    return {
	      key: 'scene',
	      facade: Scene3DFacade,
	      lights: this.lights,
	      objects: this.objects,
	      fog: this.fog,
	      background: this.background,
	      environment: this.environment,
	      onClick: this.onBackgroundClick ? this._onBgClick : null
	    }
	  };

	  /**
	   * Update the renderer's drawing buffer size
	   * @protected
	   */
	  World3DFacade.prototype._updateDrawingBufferSize = function _updateDrawingBufferSize (width, height, pixelRatio) {
	    var renderer = this._threeRenderer;
	    renderer.getSize(tmpVec2);
	    if (tmpVec2.width !== width || tmpVec2.height !== height || renderer.getPixelRatio() !== pixelRatio) {
	      renderer.setDrawingBufferSize(width, height, pixelRatio);
	    }
	  };

	  World3DFacade.prototype.doRender = function doRender (/*...frameArgs*/) {
	    var sceneFacade = this.getChildByKey('scene');
	    var scene = sceneFacade.threeObject;
	    var camera = this.getChildByKey('camera').threeObject;
	    var renderer = this._threeRenderer;

	    // Invoke any onBeforeRender listeners
	    var registry = this.eventRegistry;
	    function invokeHandler(handler, facadeId) {
	      handler.call(this._object3DFacadesById[facadeId], renderer, scene, camera);
	    }
	    registry.forEachListenerOfType('beforerender', invokeHandler, this);

	    // Render scene
	    renderer.render(scene, camera);

	    // Invoke any onAfterRender listeners
	    registry.forEachListenerOfType('afterrender', invokeHandler, this);

	    var onStatsUpdate = this.onStatsUpdate;
	    if (onStatsUpdate) {
	      var ref = renderer.info;
	      var memory = ref.memory;
	      var render = ref.render;
	      var stats = {
	        'WebGL Draw Calls': render.calls,
	        'WebGL Geometries': memory.geometries,
	        'WebGL Textures': memory.textures,
	        'WebGL Triangles': render.triangles
	      };
	      if (render.points) {
	        stats['WebGL Points'] = render.points;
	      }
	      if (render.lines) {
	        stats['WebGL Lines'] = render.lines;
	      }
	      onStatsUpdate(stats);
	    }
	  };

	  /**
	   * Implementation of abstract
	   */
	  World3DFacade.prototype.getFacadeUserSpaceXYZ = function getFacadeUserSpaceXYZ (facade) {
	    var matrixEls = facade.threeObject.matrixWorld.elements;
	    return this.projectWorldPosition(matrixEls[12], matrixEls[13], matrixEls[14])
	  };

	  World3DFacade.prototype.projectWorldPosition = function projectWorldPosition (x, y, z) {
	    tmpVec3.set(x, y, z);
	    var camera = this.getChildByKey('camera');
	    camera.updateMatrices();
	    camera = camera.threeObject;

	    // Make position relative to camera
	    tmpVec3.applyMatrix4(camera.matrixWorldInverse);

	    // Get relative distance to the point, negative if it's behind the camera
	    var signedDistance = tmpVec3.length() * (tmpVec3.z > 0 ? -1 : 1);

	    // Project x/y to screen coords
	    tmpVec3.applyMatrix4(camera.projectionMatrix);
	    var screenX = (tmpVec3.x + 1) * this.width / 2;
	    var screenY = (1 - tmpVec3.y) * this.height / 2;

	    return new Vector3(screenX, screenY, signedDistance)
	  };

	  /**
	   * @override
	   * In 3D worlds, we will normalize all pointer events so they always carry a `ray` property;
	   * handlers for these events should then only rely on that, which is guaranteed to be present,
	   * unlike `clientX/Y` etc. which are only present for pointer events originating from a screen.
	   */
	  World3DFacade.prototype._normalizePointerEvent = function _normalizePointerEvent (e) {
	    // All pointer events in a 3D world will be given a `ray` property.
	    if (!e.ray) {
	      // normalize touch events
	      var posInfo = e;
	      if (e.touches) {
	        var touches = /^touch(end|cancel)$/.test(e.type) ? e.changedTouches : e.touches;
	        if (touches.length === 1) {
	          posInfo = touches[0];
	        }
	      }

	      // convert mouse position to normalized device coords (-1 to 1)
	      var canvasRect = e.target.getBoundingClientRect(); //e.target is the canvas
	      var width = canvasRect.width || this.width; //use logical size if no visible rect, e.g. offscreen canvas
	      var height = canvasRect.height || this.height;
	      var u = ((posInfo.clientX || 0) - (canvasRect.left || 0)) / width * 2 - 1;
	      var v = ((posInfo.clientY || 0) - (canvasRect.top || 0)) / height * -2 + 1;

	      // ensure camera's matrix is up to date
	      var camera = this.getChildByKey('camera');
	      camera.updateMatrices();

	      // calculate the ray and put it on the event
	      e.ray = camera.getRayAtProjectedCoords(u, v);
	    }

	    WorldBaseFacade.prototype._normalizePointerEvent.call(this, e);
	  };

	  /**
	   * @override Implementation of abstract
	   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
	   */
	  World3DFacade.prototype.getFacadesAtEvent = function getFacadesAtEvent (e, filterFn) {
	    return e.ray ? this.getFacadesOnRay(e.ray, filterFn) : null
	  };

	  World3DFacade.prototype.getFacadesOnRay = function getFacadesOnRay (ray, filterFn) {
	    var this$1 = this;

	    // update bounding sphere octree
	    var octree = this._updateOctree();

	    // search bounding sphere octree to quickly filter down to a small set of likely hits,
	    // then do a true raycast on those facades
	    var allHits = null;
	    if (octree) {
	      raycaster.ray = ray;
	      octree.forEachSphereOnRay(ray, function (sphere, facadeId) {
	        var facadesById = this$1._object3DFacadesById;
	        var facade = facadesById && facadesById[facadeId];
	        // let the filterFn eliminate things before trying to raycast them
	        var hits = facade && (!filterFn || filterFn(facade)) && facade.raycast && facade.raycast(raycaster);
	        if (hits && hits[0]) {
	          // Ignore all but closest
	          hits[0].facade = facade
	          ;(allHits || (allHits = [])).push(hits[0]);
	        }
	      });
	    }
	    return allHits
	  };

	  World3DFacade.prototype._updateOctree = function _updateOctree () {
	    // update octree with any new bounding spheres
	    var octree = this._boundingSphereOctree;
	    var changes = this._octreeChangeset;
	    if (changes) {
	      if (!octree) {
	        octree = this._boundingSphereOctree = new BoundingSphereOctree();
	      }
	      var remove = changes.remove;
	      var put = changes.put;
	      if (remove) {
	        for (var facadeId in remove) {
	          octree.removeSphere(facadeId);
	        }
	      }
	      if (put) {
	        for (var facadeId$1 in put) {
	          // Check for put requests for objects that are now obsolete
	          var facade = this._object3DFacadesById[facadeId$1];
	          if (facade && !facade.isDestroying && !(remove && remove[facadeId$1])) {
	            var sphere = facade.getBoundingSphere && facade.getBoundingSphere();
	            if (sphere) {
	              octree.putSphere(facadeId$1, sphere);
	            } else {
	              octree.removeSphere(facadeId$1);
	            }
	          }
	        }
	      }
	      this._octreeChangeset = null;
	    }
	    return octree
	  };

	  World3DFacade.prototype._queueForOctreeChange = function _queueForOctreeChange (changeType, facade) {
	    var changes = this._octreeChangeset || (this._octreeChangeset = {});
	    var map = changes[changeType] || (changes[changeType] = Object.create(null));
	    map[facade.$facadeId] = facade;
	  };

	  World3DFacade.prototype._onBgClick = function _onBgClick (e) {
	    // Ignore clicks that bubbled up
	    if (e.target === e.currentTarget) {
	      this.onBackgroundClick(e);
	    }
	  };

	  World3DFacade.prototype.destructor = function destructor () {
	    WorldBaseFacade.prototype.destructor.call(this);
	    this._threeRenderer.dispose();
	  };

	  return World3DFacade;
	}(WorldBaseFacade));



	World3DFacade.prototype._notifyWorldHandlers = assign$5(
	  Object.create(WorldBaseFacade.prototype._notifyWorldHandlers),
	  {
	    getCameraPosition: function getCameraPosition(source, outputVec3) {
	      // We decompose from the world matrix here to handle pose transforms on top of the configured position
	      outputVec3.setFromMatrixPosition(this.getChildByKey('camera').threeObject.matrixWorld);
	    },
	    getCameraFacade: function getCameraFacade(source, data) {
	      data.callback(this.getChildByKey('camera'));
	    },
	    getSceneFacade: function getSceneFacade(source, data) {
	      data.callback(this.getChildByKey('scene'));
	    },
	    projectWorldPosition: function projectWorldPosition(source, data) {
	      var pos = data.worldPosition;
	      data.callback(this.projectWorldPosition(pos.x, pos.y, pos.z));
	    },
	    object3DAdded: function object3DAdded(source) {
	      this._object3DFacadesById[source.$facadeId] = source;
	      this._queueForOctreeChange('put', source);
	    },
	    object3DBoundsChanged: function object3DBoundsChanged(source) {
	      this._queueForOctreeChange('put', source);
	    },
	    object3DRemoved: function object3DRemoved(source) {
	      delete this._object3DFacadesById[source.$facadeId];
	      this._queueForOctreeChange('remove', source);
	    },
	    rayPointerMotion: function rayPointerMotion(source, ray) {
	      // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
	      // override to search for a hovered facade
	      var e = new MouseEvent('mousemove');
	      e.isRayEvent = true;
	      e.ray = ray;
	      e.eventSource = source; //for tracking gesture states per ray source
	      this._onPointerMotionEvent(e);
	    },
	    rayPointerAction: function rayPointerAction(source, eventParams) {
	      // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
	      // override to search for a hovered facade
	      var e = new (eventParams.type === 'wheel' ? WheelEvent : MouseEvent)(eventParams.type, eventParams);
	      e.isRayEvent = true;
	      e.ray = eventParams.ray;
	      e.eventSource = source; //for tracking gesture states per ray source
	      this._onPointerActionEvent(e);
	    }
	  }
	);

	/**
	 * Instanceable3DFacade is a specialized Object3DFacade that renders using GPU
	 * instancing. This can give a significant performance boost for objects that
	 * are rendered many thousands of times in a scene.
	 *
	 * Usage is nearly identical to an Object3DFacade, but instead of creating a
	 * `threeObject` in the constructor, you set its `instancedThreeObject` property
	 * to a common shared Mesh object. Any other Instanceable3DFacades in the scene
	 * that reference the same `instancedThreeObject` will be batched together and
	 * rendered using a single GPU draw call. The `instancedThreeObject` can be
	 * changed at any time, allowing dynamic appearance changes by swapping out the
	 * referenced mesh or its geometry or material.
	 *
	 * == Per-instance values: ==
	 *
	 * By default, the instances will each be rendered using their own world matrix
	 * transform, so they can be positioned/scaled/rotated independently as usual.
	 *
	 * It is also possible, with a little extra effort, to allow specific shader
	 * uniforms such as colors to be varied per instance. This works with both custom
	 * shader materials as well as the built-in materials.
	 *
	 * To enable per-instance uniforms, use the `setInstanceUniform(name, value)`
	 * method to set an instance's values for the enabled uniforms:
	 *
	 *     `this.setInstanceUniform('diffuse', new Color(color))`
	 *
	 * If an instance does not have a uniform value set this way, it will fall back to using
	 * the default value in the material's `uniforms` object.
	 *
	 * The uniform types that allow instancing are: `int`, `float`, `vec2`, `vec3`, and `vec4`.
	 * Mapping from application value types such as `Vector2` or `Color` behaves similarly to
	 * how three.js does it internally. More complex uniform types such as textures are not
	 * instanceable.
	 *
	 * == Caveats: ==
	 *
	 * It is generally not recommended to use this technique on meshes that are semi-
	 * transparent, as there is no guarantee that they will be drawn in back-to-front
	 * order relative to the camera position.
	 */
	var Instanceable3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function Instanceable3DFacade(parent) {
	    var obj = new Object3D();

	    // Trigger scene graph size optimizations
	    obj.isRenderable = false;

	    // Visibility change affects batching so listen for changes
	    obj.$troikaVisible = obj.visible;
	    Object.defineProperty(obj, 'visible', visibilityPropDef);

	    Object3DFacade.call(this, parent, obj);

	    this.notifyWorld('instanceableAdded');
	  }

	  if ( Object3DFacade ) Instanceable3DFacade.__proto__ = Object3DFacade;
	  Instanceable3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Instanceable3DFacade.prototype.constructor = Instanceable3DFacade;

	  /**
	   * @property {Object3D} instancedThreeObject
	   * Sets the Mesh instance to use for batching this instance with others that
	   * reference the same Mesh.
	   */

	  /**
	   * Sets this instance's value for a shader uniform.
	   * @param {String} name
	   * @param {Number|Vector2|Vector3|Vector4|Color} value
	   */
	  Instanceable3DFacade.prototype.setInstanceUniform = function setInstanceUniform (name, value) {
	    var values = this._instanceUniforms || (this._instanceUniforms = Object.create(null));
	    if (values[name] !== value) {
	      // If this is a new uniform value, add it to the Set of instance uniform names
	      var obj = this.instancedThreeObject;
	      if (obj && !(name in values)) {
	        var names = obj._instanceUniformNames || (obj._instanceUniformNames = new Set());
	        names.add(name);
	      }
	      values[name] = value;
	      this.notifyWorld('instanceableUniformChanged', name);
	    }
	  };

	  Instanceable3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var newObj = this.instancedThreeObject;
	    var oldObj = this._instancedObj;
	    if (newObj !== oldObj) {
	      if (newObj && this._instanceUniforms) { //make sure new object tracks our instance uniforms
	        var names = newObj._instanceUniformNames || (newObj._instanceUniformNames = new Set());
	        for (var name in this._instanceUniforms) {
	          names.add(name);
	        }
	      }
	      this._instancedObj = newObj;
	      this.notifyWorld('instanceableChanged');
	      this._boundsChanged = true;
	    }
	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  Instanceable3DFacade.prototype.updateMatrices = function updateMatrices () {
	    var prevMatrixVersion = this._worldMatrixVersion;

	    Object3DFacade.prototype.updateMatrices.call(this);

	    // If the world matrix changed, we must notify the instancing manager
	    if (this._worldMatrixVersion !== prevMatrixVersion && this.threeObject.$troikaVisible) {
	      this.notifyWorld('instanceableMatrixChanged');
	    }
	  };

	  Instanceable3DFacade.prototype.destructor = function destructor () {
	    this.notifyWorld('instanceableRemoved');
	    Object3DFacade.prototype.destructor.call(this);
	  };

	  // Custom bounding sphere calc
	  Instanceable3DFacade.prototype.getGeometry = function getGeometry () {
	    var instancedObj = this.instancedThreeObject;
	    return instancedObj && instancedObj.geometry
	  };

	  // Custom raycasting based on current geometry and transform
	  Instanceable3DFacade.prototype.raycast = function raycast (raycaster) {
	    var ref = this;
	    var instancedThreeObject = ref.instancedThreeObject;
	    var threeObject = ref.threeObject;
	    if (instancedThreeObject && threeObject) {
	      var origMatrix = instancedThreeObject.matrixWorld;
	      instancedThreeObject.matrixWorld = threeObject.matrixWorld;
	      var result = this._raycastObject(instancedThreeObject, raycaster); //use optimized method
	      instancedThreeObject.matrixWorld = origMatrix;
	      return result
	    }
	    return null
	  };

	  return Instanceable3DFacade;
	}(Object3DFacade));

	var visibilityPropDef = {
	  set: function set(visible) {
	    if (visible !== this.$troikaVisible) {
	      this.$troikaVisible = visible;
	      this.$facade.notifyWorld('instanceableChanged');
	    }
	  },
	  get: function get() {
	    return this.$troikaVisible
	  }
	};

	// Predefine shape to facilitate JS engine optimization
	assign(Instanceable3DFacade.prototype, {
	  _lastInstancedMatrixVersion: -1,
	  _instancedThreeObject: null
	});

	var Canvas3D = /*@__PURE__*/(function (ReactCanvasBase) {
	  function Canvas3D(props) {
	    var this$1 = this;

	    ReactCanvasBase.call(this, props);
	    this._onCanvasRef = function (canvas) {
	      var fn = this$1.context.onCanvasRef;
	      if (fn) { fn(canvas); }
	      fn = this$1.props.onCanvasRef;
	      if (fn) { fn(canvas); }
	    };
	  }

	  if ( ReactCanvasBase ) Canvas3D.__proto__ = ReactCanvasBase;
	  Canvas3D.prototype = Object.create( ReactCanvasBase && ReactCanvasBase.prototype );
	  Canvas3D.prototype.constructor = Canvas3D;

	  Canvas3D.prototype.render = function render () {
	    var ref = this;
	    var props = ref.props;
	    var context = ref.context;
	    return react.createElement(
	      ReactCanvasBase,
	      assign({}, props, {
	        onCanvasRef: this._onCanvasRef,
	        canvasStyle: props.canvasStyle || context.canvasStyle,
	        worldFacade: props.worldFacade || context.worldFacade || World3DFacade,
	        worldProps: assign(
	          {
	            antialias: props.antialias,
	            rendererClass: props.rendererClass,
	            backgroundColor: props.backgroundColor,
	            background: props.background,
	            environment: props.environment,
	            outputEncoding: props.outputEncoding,
	            toneMapping: props.toneMapping,
	            shadows: props.shadows,
	            camera: props.camera,
	            lights: props.lights,
	            objects: props.objects,
	            fog: props.fog,
	            onBackgroundClick: props.onBackgroundClick
	          },
	          context.worldProps,
	          props.worldProps
	        )
	      }),
	      props.children
	    )
	  };

	  return Canvas3D;
	}(CanvasBase));

	Canvas3D.displayName = 'Canvas3D';

	Canvas3D.propTypes = assignIf(
	  {
	    backgroundColor: propTypes.any,
	    background: propTypes.any,
	    environment: propTypes.any,
	    outputEncoding: propTypes.number,
	    toneMapping: propTypes.number,
	    lights: propTypes.array,
	    camera: propTypes.object,
	    fog: propTypes.object,
	    objects: propTypes.oneOfType([propTypes.array, propTypes.object]).isRequired,
	    antialias: propTypes.bool,
	    onBackgroundClick: propTypes.func,
	    rendererClass: propTypes.func
	  },
	  CanvasBase.commonPropTypes
	);

	/**
	 * Ancestors React components may provide these context values to override
	 * how the world is created, e.g. switching to a WebXR-aware world impl
	 */
	Canvas3D.contextType = react.createContext({
	  worldFacade: World3DFacade,
	  worldProps: {},
	  onCanvasRef: null,
	  canvasStyle: null
	});

	var XRLauncher = /*@__PURE__*/(function (superclass) {
	  function XRLauncher(props) {
	    superclass.call(this, props);

	    this._onClick = this._onClick.bind(this);
	  }

	  if ( superclass ) XRLauncher.__proto__ = superclass;
	  XRLauncher.prototype = Object.create( superclass && superclass.prototype );
	  XRLauncher.prototype.constructor = XRLauncher;

	  XRLauncher.prototype._onClick = function _onClick () {
	    this.props.onSelectSession(this.props.xrSession ? null : 'immersive-vr'); //TODO handle other modes
	  };

	  XRLauncher.prototype.render = function render () {
	    var props = this.props;
	    return react.createElement(
	      'button',
	      {
	        onClick: this._onClick,
	        disabled: !props.xrSupported
	      },
	      props.xrSupported ? (props.xrSession ? 'Exit XR' : 'Enter XR') : 'XR Not Available'
	    )
	  };

	  return XRLauncher;
	}(react.PureComponent));

	var cursorGeom = new SphereGeometry();
	var cursorMaterial = new MeshBasicMaterial({color: 0xffffff});
	var tempVec3$1 = new Vector3();
	var tempQuat$1 = new Quaternion();
	var degToRadMult = Math.PI / 180;

	var CursorFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function CursorFacade(parent) {
	    Object3DFacade.call(this, parent, new Mesh(
	      cursorGeom,
	      cursorMaterial.clone()
	    ));

	    /**
	     * Visual size at which the cursor should be drawn, regardless of its distance.
	     * This is measured in degrees of the field of view.
	     * @type {number}
	     */
	    this.size = 0.3;

	    /**
	     * If nonzero, defines the default distance at which the cursor should be displayed when
	     * the targetRay does not intersect any pointable objects in the scene. Defaults to `0`,
	     * which means it is hidden by default.
	     * @type {number}
	     */
	    this.defaultDistance = 0;
	  }

	  if ( Object3DFacade ) CursorFacade.__proto__ = Object3DFacade;
	  CursorFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  CursorFacade.prototype.constructor = CursorFacade;

	  CursorFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var rayIntersection = ref.rayIntersection;
	    var defaultDistance = ref.defaultDistance;
	    var targetRayPose = ref.targetRayPose;

	    // Only display if there is a valid ray intersection, or we're configured with a default distance
	    var point = rayIntersection && rayIntersection.point;
	    if (!point && defaultDistance && targetRayPose) {
	      point = tempVec3$1.set(0, 0, -1)
	        .multiplyScalar(defaultDistance) //length
	        .applyQuaternion(tempQuat$1.copy(targetRayPose.transform.orientation)) //rotation
	        .add(targetRayPose.transform.position); //origin
	    }
	    if (point) {
	      point.copy.call(this, point);
	      this.scale = point.distanceTo(this.getCameraPosition()) * Math.sin(this.size * degToRadMult);
	      this.visible = true;
	    } else {
	      this.visible = false;
	    }

	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  return CursorFacade;
	}(Object3DFacade));

	/**
	 * A `renderOrder` for the target ray that ensures proper transparency
	 */
	var TARGET_RAY_RENDERORDER = 1e8;

	/**
	 * Given a XRPose, copy its transform's position and orientation to the corresponding
	 * properties on a Object3DFacade.
	 * @param {XRPose} pose
	 * @param {Object3DFacade} facade
	 */
	function copyXRPoseToFacadeProps(pose, facade) {
	  if (pose && facade) {
	    var ref = pose.transform;
	    var position = ref.position;
	    var orientation = ref.orientation;
	    facade.x = position.x;
	    facade.y = position.y;
	    facade.z = position.z;
	    facade.quaternionX = orientation.x;
	    facade.quaternionY = orientation.y;
	    facade.quaternionZ = orientation.z;
	    facade.quaternionW = orientation.w;
	  }
	}

	var getGeometry = function () {
	  var geometry = new CylinderGeometry(1, 1, 1, 4, 1, false)
	    .translate(0, 0.5, 0)
	    .rotateY(Math.PI / 4)
	    .rotateX(Math.PI / -2);
	  getGeometry = function () { return geometry; };
	  return geometry
	};

	var getMaterial = function () {
	  var material = createDerivedMaterial(
	    new MeshBasicMaterial({
	      transparent: true,
	      opacity: 0.5,
	      color: 0xffffff,
	      depthTest: false
	    }), {
	      vertexDefs: "varying float dist;",
	      vertexMainIntro: "dist = -position.z;",
	      fragmentDefs: "varying float dist;",
	      fragmentColorTransform: "gl_FragColor.a *= smoothstep(1.0, 0.6, dist);"
	    }
	  );
	  getMaterial = function () { return material; };
	  return material
	};



	var TargetRayFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function TargetRayFacade(parent) {
	    Object3DFacade.call(this, parent, new Group());

	    this.threeObject.add(this.laserMesh = new Mesh(getGeometry(), getMaterial()));

	    this.radius = 0.003;
	    this.startDistance = 0.05;
	    this.maxLength = 0.4;
	    this.renderOrder = TARGET_RAY_RENDERORDER;
	  }

	  if ( Object3DFacade ) TargetRayFacade.__proto__ = Object3DFacade;
	  TargetRayFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  TargetRayFacade.prototype.constructor = TargetRayFacade;

	  TargetRayFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var laserMesh = ref.laserMesh;
	    var targetRayPose = ref.targetRayPose;
	    var radius = ref.radius;
	    var rayIntersection = ref.rayIntersection;
	    var startDistance = ref.startDistance;
	    var maxLength = ref.maxLength;
	    if (targetRayPose) {
	      // Sync group to the targetRay pose
	      copyXRPoseToFacadeProps(targetRayPose, this);

	      // Update laser size from radius/rayIntersection props
	      laserMesh.scale.set(
	        radius,
	        radius,
	        (rayIntersection ? Math.min(rayIntersection.distance, maxLength) : maxLength) - startDistance
	      );
	      laserMesh.position.z = -startDistance;
	      laserMesh.visible = true;
	    } else {
	      laserMesh.visible = false;
	    }

	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  return TargetRayFacade;
	}(Object3DFacade));

	var getGeometry$1 = function () {
	  var geometry = new CylinderGeometry(0.03, 0.05, 0.1, 8)
	    .rotateX(Math.PI / -2)
	    .translate(0, 0, 0.05);
	  getGeometry$1 = function () { return geometry; };
	  return geometry
	};

	var getMaterial$1 = function () {
	  var material = new MeshStandardMaterial({
	    color: 0x666666,
	    emissive: 0x666666,
	    roughness: 0.5,
	    metalness: 0.5
	  });
	  getMaterial$1 = function () { return material; };
	  return material
	};


	/**
	 * Very basic tracked controller model
	 */
	var Basic = /*@__PURE__*/(function (Object3DFacade) {
	  function Basic(parent) {
	    var mesh = new Mesh(getGeometry$1(), getMaterial$1());
	    Object3DFacade.call(this, parent, mesh);
	  }

	  if ( Object3DFacade ) Basic.__proto__ = Object3DFacade;
	  Basic.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Basic.prototype.constructor = Basic;

	  return Basic;
	}(Object3DFacade));

	var GLTFLoader = ( function () {

		function GLTFLoader( manager ) {

			Loader.call( this, manager );

			this.dracoLoader = null;
			this.ktx2Loader = null;
			this.meshoptDecoder = null;

			this.pluginCallbacks = [];

			this.register( function ( parser ) {

				return new GLTFMaterialsClearcoatExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFTextureBasisUExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFTextureWebPExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsTransmissionExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFLightsExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMeshoptCompression( parser );

			} );

		}

		GLTFLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: GLTFLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var resourcePath;

				if ( this.resourcePath !== '' ) {

					resourcePath = this.resourcePath;

				} else if ( this.path !== '' ) {

					resourcePath = this.path;

				} else {

					resourcePath = LoaderUtils.extractUrlBase( url );

				}

				// Tells the LoadingManager to track an extra item, which resolves after
				// the model is fully loaded. This means the count of items loaded will
				// be incorrect, but ensures manager.onLoad() does not fire early.
				this.manager.itemStart( url );

				var _onError = function ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				};

				var loader = new FileLoader( this.manager );

				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );
				loader.setRequestHeader( this.requestHeader );
				loader.setWithCredentials( this.withCredentials );

				loader.load( url, function ( data ) {

					try {

						scope.parse( data, resourcePath, function ( gltf ) {

							onLoad( gltf );

							scope.manager.itemEnd( url );

						}, _onError );

					} catch ( e ) {

						_onError( e );

					}

				}, onProgress, _onError );

			},

			setDRACOLoader: function ( dracoLoader ) {

				this.dracoLoader = dracoLoader;
				return this;

			},

			setDDSLoader: function () {

				throw new Error(

					'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

				);

			},

			setKTX2Loader: function ( ktx2Loader ) {

				this.ktx2Loader = ktx2Loader;
				return this;

			},

			setMeshoptDecoder: function ( meshoptDecoder ) {

				this.meshoptDecoder = meshoptDecoder;
				return this;

			},

			register: function ( callback ) {

				if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

					this.pluginCallbacks.push( callback );

				}

				return this;

			},

			unregister: function ( callback ) {

				if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

					this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

				}

				return this;

			},

			parse: function ( data, path, onLoad, onError ) {

				var content;
				var extensions = {};
				var plugins = {};

				if ( typeof data === 'string' ) {

					content = data;

				} else {

					var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

					if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

						try {

							extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

						} catch ( error ) {

							if ( onError ) { onError( error ); }
							return;

						}

						content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

					} else {

						content = LoaderUtils.decodeText( new Uint8Array( data ) );

					}

				}

				var json = JSON.parse( content );

				if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

					if ( onError ) { onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) ); }
					return;

				}

				var parser = new GLTFParser( json, {

					path: path || this.resourcePath || '',
					crossOrigin: this.crossOrigin,
					requestHeader: this.requestHeader,
					manager: this.manager,
					ktx2Loader: this.ktx2Loader,
					meshoptDecoder: this.meshoptDecoder

				} );

				parser.fileLoader.setRequestHeader( this.requestHeader );

				for ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {

					var plugin = this.pluginCallbacks[ i ]( parser );
					plugins[ plugin.name ] = plugin;

					// Workaround to avoid determining as unknown extension
					// in addUnknownExtensionsToUserData().
					// Remove this workaround if we move all the existing
					// extension handlers to plugin system
					extensions[ plugin.name ] = true;

				}

				if ( json.extensionsUsed ) {

					for ( var i = 0; i < json.extensionsUsed.length; ++ i ) {

						var extensionName = json.extensionsUsed[ i ];
						var extensionsRequired = json.extensionsRequired || [];

						switch ( extensionName ) {

							case EXTENSIONS.KHR_MATERIALS_UNLIT:
								extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
								break;

							case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
								extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
								break;

							case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
								extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
								break;

							case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
								extensions[ extensionName ] = new GLTFTextureTransformExtension();
								break;

							case EXTENSIONS.KHR_MESH_QUANTIZATION:
								extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
								break;

							default:

								if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

									console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

								}

						}

					}

				}

				parser.setExtensions( extensions );
				parser.setPlugins( plugins );
				parser.parse( onLoad, onError );

			}

		} );

		/* GLTFREGISTRY */

		function GLTFRegistry() {

			var objects = {};

			return	{

				get: function ( key ) {

					return objects[ key ];

				},

				add: function ( key, object ) {

					objects[ key ] = object;

				},

				remove: function ( key ) {

					delete objects[ key ];

				},

				removeAll: function () {

					objects = {};

				}

			};

		}

		/*********************************/
		/********** EXTENSIONS ***********/
		/*********************************/

		var EXTENSIONS = {
			KHR_BINARY_GLTF: 'KHR_binary_glTF',
			KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
			KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
			KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
			KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
			KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
			KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
			KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
			KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
			KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
			EXT_TEXTURE_WEBP: 'EXT_texture_webp',
			EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
		};

		/**
		 * Punctual Lights Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
		 */
		function GLTFLightsExtension( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

			// Object3D instance caches
			this.cache = { refs: {}, uses: {} };

		}

		GLTFLightsExtension.prototype._markDefs = function () {

			var parser = this.parser;
			var nodeDefs = this.parser.json.nodes || [];

			for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				var nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

					parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

				}

			}

		};

		GLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {

			var parser = this.parser;
			var cacheKey = 'light:' + lightIndex;
			var dependency = parser.cache.get( cacheKey );

			if ( dependency ) { return dependency; }

			var json = parser.json;
			var extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
			var lightDefs = extensions.lights || [];
			var lightDef = lightDefs[ lightIndex ];
			var lightNode;

			var color = new Color( 0xffffff );

			if ( lightDef.color !== undefined ) { color.fromArray( lightDef.color ); }

			var range = lightDef.range !== undefined ? lightDef.range : 0;

			switch ( lightDef.type ) {

				case 'directional':
					lightNode = new DirectionalLight( color );
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				case 'point':
					lightNode = new PointLight( color );
					lightNode.distance = range;
					break;

				case 'spot':
					lightNode = new SpotLight( color );
					lightNode.distance = range;
					// Handle spotlight properties.
					lightDef.spot = lightDef.spot || {};
					lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
					lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
					lightNode.angle = lightDef.spot.outerConeAngle;
					lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				default:
					throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

			}

			// Some lights (e.g. spot) default to a position other than the origin. Reset the position
			// here, because node-level parsing will only override position if explicitly specified.
			lightNode.position.set( 0, 0, 0 );

			lightNode.decay = 2;

			if ( lightDef.intensity !== undefined ) { lightNode.intensity = lightDef.intensity; }

			lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

			dependency = Promise.resolve( lightNode );

			parser.cache.add( cacheKey, dependency );

			return dependency;

		};

		GLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {

			var self = this;
			var parser = this.parser;
			var json = parser.json;
			var nodeDef = json.nodes[ nodeIndex ];
			var lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
			var lightIndex = lightDef.light;

			if ( lightIndex === undefined ) { return null; }

			return this._loadLight( lightIndex ).then( function ( light ) {

				return parser._getNodeRef( self.cache, lightIndex, light );

			} );

		};

		/**
		 * Unlit Materials Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
		 */
		function GLTFMaterialsUnlitExtension() {

			this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

		}

		GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

			return MeshBasicMaterial;

		};

		GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {

			var pending = [];

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			var metallicRoughness = materialDef.pbrMetallicRoughness;

			if ( metallicRoughness ) {

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					var array = metallicRoughness.baseColorFactor;

					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

			}

			return Promise.all( pending );

		};

		/**
		 * Clearcoat Materials Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
		 */
		function GLTFMaterialsClearcoatExtension( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

		}

		GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {

			var parser = this.parser;
			var materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return null; }

			return MeshPhysicalMaterial;

		};

		GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {

			var parser = this.parser;
			var materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			var pending = [];

			var extension = materialDef.extensions[ this.name ];

			if ( extension.clearcoatFactor !== undefined ) {

				materialParams.clearcoat = extension.clearcoatFactor;

			}

			if ( extension.clearcoatTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

			}

			if ( extension.clearcoatRoughnessFactor !== undefined ) {

				materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

			}

			if ( extension.clearcoatRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

			}

			if ( extension.clearcoatNormalTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

				if ( extension.clearcoatNormalTexture.scale !== undefined ) {

					var scale = extension.clearcoatNormalTexture.scale;

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					materialParams.clearcoatNormalScale = new Vector2( scale, - scale );

				}

			}

			return Promise.all( pending );

		};

		/**
		 * Transmission Materials Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
		 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
		 */
		function GLTFMaterialsTransmissionExtension( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

		}

		GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {

			var parser = this.parser;
			var materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return null; }

			return MeshPhysicalMaterial;

		};

		GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {

			var parser = this.parser;
			var materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			var pending = [];

			var extension = materialDef.extensions[ this.name ];

			if ( extension.transmissionFactor !== undefined ) {

				materialParams.transmission = extension.transmissionFactor;

			}

			if ( extension.transmissionTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

			}

			return Promise.all( pending );

		};

		/**
		 * BasisU Texture Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
		 */
		function GLTFTextureBasisUExtension( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

		}

		GLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {

			var parser = this.parser;
			var json = parser.json;

			var textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

				return null;

			}

			var extension = textureDef.extensions[ this.name ];
			var source = json.images[ extension.source ];
			var loader = parser.options.ktx2Loader;

			if ( ! loader ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

				} else {

					// Assumes that the extension is optional and that a fallback texture is present
					return null;

				}

			}

			return parser.loadTextureImage( textureIndex, source, loader );

		};

		/**
		 * WebP Texture Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
		 */
		function GLTFTextureWebPExtension( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
			this.isSupported = null;

		}

		GLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {

			var name = this.name;
			var parser = this.parser;
			var json = parser.json;

			var textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

				return null;

			}

			var extension = textureDef.extensions[ name ];
			var source = json.images[ extension.source ];

			var loader = parser.textureLoader;
			if ( source.uri ) {

				var handler = parser.options.manager.getHandler( source.uri );
				if ( handler !== null ) { loader = handler; }

			}

			return this.detectSupport().then( function ( isSupported ) {

				if ( isSupported ) { return parser.loadTextureImage( textureIndex, source, loader ); }

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

				}

				// Fall back to PNG or JPEG.
				return parser.loadTexture( textureIndex );

			} );

		};

		GLTFTextureWebPExtension.prototype.detectSupport = function () {

			if ( ! this.isSupported ) {

				this.isSupported = new Promise( function ( resolve ) {

					var image = new Image();

					// Lossy test image. Support for lossy images doesn't guarantee support for all
					// WebP images, unfortunately.
					image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

					image.onload = image.onerror = function () {

						resolve( image.height === 1 );

					};

				} );

			}

			return this.isSupported;

		};

		/**
		* meshopt BufferView Compression Extension
		*
		* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
		*/
		function GLTFMeshoptCompression( parser ) {

			this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
			this.parser = parser;

		}

		GLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {

			var json = this.parser.json;
			var bufferView = json.bufferViews[ index ];

			if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

				var extensionDef = bufferView.extensions[ this.name ];

				var buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
				var decoder = this.parser.options.meshoptDecoder;

				if ( ! decoder || ! decoder.supported ) {

					if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

						throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

					} else {

						// Assumes that the extension is optional and that fallback buffer data is present
						return null;

					}

				}

				return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

					var byteOffset = extensionDef.byteOffset || 0;
					var byteLength = extensionDef.byteLength || 0;

					var count = extensionDef.count;
					var stride = extensionDef.byteStride;

					var result = new ArrayBuffer( count * stride );
					var source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

					decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
					return result;

				} );

			} else {

				return null;

			}

		};

		/* BINARY EXTENSION */
		var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
		var BINARY_EXTENSION_HEADER_LENGTH = 12;
		var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

		function GLTFBinaryExtension( data ) {

			this.name = EXTENSIONS.KHR_BINARY_GLTF;
			this.content = null;
			this.body = null;

			var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

			this.header = {
				magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
				version: headerView.getUint32( 4, true ),
				length: headerView.getUint32( 8, true )
			};

			if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

				throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

			} else if ( this.header.version < 2.0 ) {

				throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

			}

			var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
			var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
			var chunkIndex = 0;

			while ( chunkIndex < chunkContentsLength ) {

				var chunkLength = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				var chunkType = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

					var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
					this.content = LoaderUtils.decodeText( contentArray );

				} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

					var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
					this.body = data.slice( byteOffset, byteOffset + chunkLength );

				}

				// Clients must ignore chunks with unknown types.

				chunkIndex += chunkLength;

			}

			if ( this.content === null ) {

				throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

			}

		}

		/**
		 * DRACO Mesh Compression Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
		 */
		function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {

			if ( ! dracoLoader ) {

				throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

			}

			this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
			this.json = json;
			this.dracoLoader = dracoLoader;
			this.dracoLoader.preload();

		}

		GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {

			var json = this.json;
			var dracoLoader = this.dracoLoader;
			var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
			var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
			var threeAttributeMap = {};
			var attributeNormalizedMap = {};
			var attributeTypeMap = {};

			for ( var attributeName in gltfAttributeMap ) {

				var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

			}

			for ( attributeName in primitive.attributes ) {

				var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				if ( gltfAttributeMap[ attributeName ] !== undefined ) {

					var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
					var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

					attributeTypeMap[ threeAttributeName ] = componentType;
					attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

				}

			}

			return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

				return new Promise( function ( resolve ) {

					dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

						for ( var attributeName in geometry.attributes ) {

							var attribute = geometry.attributes[ attributeName ];
							var normalized = attributeNormalizedMap[ attributeName ];

							if ( normalized !== undefined ) { attribute.normalized = normalized; }

						}

						resolve( geometry );

					}, threeAttributeMap, attributeTypeMap );

				} );

			} );

		};

		/**
		 * Texture Transform Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
		 */
		function GLTFTextureTransformExtension() {

			this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

		}

		GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {

			texture = texture.clone();

			if ( transform.offset !== undefined ) {

				texture.offset.fromArray( transform.offset );

			}

			if ( transform.rotation !== undefined ) {

				texture.rotation = transform.rotation;

			}

			if ( transform.scale !== undefined ) {

				texture.repeat.fromArray( transform.scale );

			}

			if ( transform.texCoord !== undefined ) {

				console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

			}

			texture.needsUpdate = true;

			return texture;

		};

		/**
		 * Specular-Glossiness Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
		 */

		/**
		 * A sub class of StandardMaterial with some of the functionality
		 * changed via the `onBeforeCompile` callback
		 * @pailhead
		 */

		function GLTFMeshStandardSGMaterial( params ) {

			MeshStandardMaterial.call( this );

			this.isGLTFSpecularGlossinessMaterial = true;

			//various chunks that need replacing
			var specularMapParsFragmentChunk = [
				'#ifdef USE_SPECULARMAP',
				'	uniform sampler2D specularMap;',
				'#endif'
			].join( '\n' );

			var glossinessMapParsFragmentChunk = [
				'#ifdef USE_GLOSSINESSMAP',
				'	uniform sampler2D glossinessMap;',
				'#endif'
			].join( '\n' );

			var specularMapFragmentChunk = [
				'vec3 specularFactor = specular;',
				'#ifdef USE_SPECULARMAP',
				'	vec4 texelSpecular = texture2D( specularMap, vUv );',
				'	texelSpecular = sRGBToLinear( texelSpecular );',
				'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	specularFactor *= texelSpecular.rgb;',
				'#endif'
			].join( '\n' );

			var glossinessMapFragmentChunk = [
				'float glossinessFactor = glossiness;',
				'#ifdef USE_GLOSSINESSMAP',
				'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
				'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	glossinessFactor *= texelGlossiness.a;',
				'#endif'
			].join( '\n' );

			var lightPhysicalFragmentChunk = [
				'PhysicalMaterial material;',
				'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
				'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
				'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
				'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
				'material.specularRoughness += geometryRoughness;',
				'material.specularRoughness = min( material.specularRoughness, 1.0 );',
				'material.specularColor = specularFactor;' ].join( '\n' );

			var uniforms = {
				specular: { value: new Color().setHex( 0xffffff ) },
				glossiness: { value: 1 },
				specularMap: { value: null },
				glossinessMap: { value: null }
			};

			this._extraUniforms = uniforms;

			this.onBeforeCompile = function ( shader ) {

				for ( var uniformName in uniforms ) {

					shader.uniforms[ uniformName ] = uniforms[ uniformName ];

				}

				shader.fragmentShader = shader.fragmentShader
					.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
					.replace( 'uniform float metalness;', 'uniform float glossiness;' )
					.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
					.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
					.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
					.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
					.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

			};

			Object.defineProperties( this, {

				specular: {
					get: function () {

						return uniforms.specular.value;

					},
					set: function ( v ) {

						uniforms.specular.value = v;

					}
				},

				specularMap: {
					get: function () {

						return uniforms.specularMap.value;

					},
					set: function ( v ) {

						uniforms.specularMap.value = v;

						if ( v ) {

							this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

						} else {

							delete this.defines.USE_SPECULARMAP;

						}

					}
				},

				glossiness: {
					get: function () {

						return uniforms.glossiness.value;

					},
					set: function ( v ) {

						uniforms.glossiness.value = v;

					}
				},

				glossinessMap: {
					get: function () {

						return uniforms.glossinessMap.value;

					},
					set: function ( v ) {

						uniforms.glossinessMap.value = v;

						if ( v ) {

							this.defines.USE_GLOSSINESSMAP = '';
							this.defines.USE_UV = '';

						} else {

							delete this.defines.USE_GLOSSINESSMAP;
							delete this.defines.USE_UV;

						}

					}
				}

			} );

			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;

			this.setValues( params );

		}

		GLTFMeshStandardSGMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

		GLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {

			MeshStandardMaterial.prototype.copy.call( this, source );
			this.specularMap = source.specularMap;
			this.specular.copy( source.specular );
			this.glossinessMap = source.glossinessMap;
			this.glossiness = source.glossiness;
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			return this;

		};

		function GLTFMaterialsPbrSpecularGlossinessExtension() {

			return {

				name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

				specularGlossinessParams: [
					'color',
					'map',
					'lightMap',
					'lightMapIntensity',
					'aoMap',
					'aoMapIntensity',
					'emissive',
					'emissiveIntensity',
					'emissiveMap',
					'bumpMap',
					'bumpScale',
					'normalMap',
					'normalMapType',
					'displacementMap',
					'displacementScale',
					'displacementBias',
					'specularMap',
					'specular',
					'glossinessMap',
					'glossiness',
					'alphaMap',
					'envMap',
					'envMapIntensity',
					'refractionRatio' ],

				getMaterialType: function () {

					return GLTFMeshStandardSGMaterial;

				},

				extendParams: function ( materialParams, materialDef, parser ) {

					var pbrSpecularGlossiness = materialDef.extensions[ this.name ];

					materialParams.color = new Color( 1.0, 1.0, 1.0 );
					materialParams.opacity = 1.0;

					var pending = [];

					if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

						var array = pbrSpecularGlossiness.diffuseFactor;

						materialParams.color.fromArray( array );
						materialParams.opacity = array[ 3 ];

					}

					if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

						pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

					}

					materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
					materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
					materialParams.specular = new Color( 1.0, 1.0, 1.0 );

					if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

						materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

					}

					if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

						var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
						pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
						pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

					}

					return Promise.all( pending );

				},

				createMaterial: function ( materialParams ) {

					var material = new GLTFMeshStandardSGMaterial( materialParams );
					material.fog = true;

					material.color = materialParams.color;

					material.map = materialParams.map === undefined ? null : materialParams.map;

					material.lightMap = null;
					material.lightMapIntensity = 1.0;

					material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
					material.aoMapIntensity = 1.0;

					material.emissive = materialParams.emissive;
					material.emissiveIntensity = 1.0;
					material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

					material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
					material.bumpScale = 1;

					material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
					material.normalMapType = TangentSpaceNormalMap;

					if ( materialParams.normalScale ) { material.normalScale = materialParams.normalScale; }

					material.displacementMap = null;
					material.displacementScale = 1;
					material.displacementBias = 0;

					material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
					material.specular = materialParams.specular;

					material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
					material.glossiness = materialParams.glossiness;

					material.alphaMap = null;

					material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
					material.envMapIntensity = 1.0;

					material.refractionRatio = 0.98;

					return material;

				},

			};

		}

		/**
		 * Mesh Quantization Extension
		 *
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
		 */
		function GLTFMeshQuantizationExtension() {

			this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

		}

		/*********************************/
		/********** INTERPOLATION ********/
		/*********************************/

		// Spline Interpolation
		// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
		function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		GLTFCubicSplineInterpolant.prototype = Object.create( Interpolant.prototype );
		GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

		GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {

			// Copies a sample value to the result buffer. See description of glTF
			// CUBICSPLINE values layout in interpolate_() function below.

			var result = this.resultBuffer,
				values = this.sampleValues,
				valueSize = this.valueSize,
				offset = index * valueSize * 3 + valueSize;

			for ( var i = 0; i !== valueSize; i ++ ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		};

		GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

		GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

		GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer;
			var values = this.sampleValues;
			var stride = this.valueSize;

			var stride2 = stride * 2;
			var stride3 = stride * 3;

			var td = t1 - t0;

			var p = ( t - t0 ) / td;
			var pp = p * p;
			var ppp = pp * p;

			var offset1 = i1 * stride3;
			var offset0 = offset1 - stride3;

			var s2 = - 2 * ppp + 3 * pp;
			var s3 = ppp - pp;
			var s0 = 1 - s2;
			var s1 = s3 - pp + p;

			// Layout of keyframe output values for CUBICSPLINE animations:
			//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
			for ( var i = 0; i !== stride; i ++ ) {

				var p0 = values[ offset0 + i + stride ]; // splineVertex_k
				var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
				var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
				var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

				result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

			}

			return result;

		};

		/*********************************/
		/********** INTERNALS ************/
		/*********************************/

		/* CONSTANTS */

		var WEBGL_CONSTANTS = {
			FLOAT: 5126,
			//FLOAT_MAT2: 35674,
			FLOAT_MAT3: 35675,
			FLOAT_MAT4: 35676,
			FLOAT_VEC2: 35664,
			FLOAT_VEC3: 35665,
			FLOAT_VEC4: 35666,
			LINEAR: 9729,
			REPEAT: 10497,
			SAMPLER_2D: 35678,
			POINTS: 0,
			LINES: 1,
			LINE_LOOP: 2,
			LINE_STRIP: 3,
			TRIANGLES: 4,
			TRIANGLE_STRIP: 5,
			TRIANGLE_FAN: 6,
			UNSIGNED_BYTE: 5121,
			UNSIGNED_SHORT: 5123
		};

		var WEBGL_COMPONENT_TYPES = {
			5120: Int8Array,
			5121: Uint8Array,
			5122: Int16Array,
			5123: Uint16Array,
			5125: Uint32Array,
			5126: Float32Array
		};

		var WEBGL_FILTERS = {
			9728: NearestFilter,
			9729: LinearFilter,
			9984: NearestMipmapNearestFilter,
			9985: LinearMipmapNearestFilter,
			9986: NearestMipmapLinearFilter,
			9987: LinearMipmapLinearFilter
		};

		var WEBGL_WRAPPINGS = {
			33071: ClampToEdgeWrapping,
			33648: MirroredRepeatWrapping,
			10497: RepeatWrapping
		};

		var WEBGL_TYPE_SIZES = {
			'SCALAR': 1,
			'VEC2': 2,
			'VEC3': 3,
			'VEC4': 4,
			'MAT2': 4,
			'MAT3': 9,
			'MAT4': 16
		};

		var ATTRIBUTES = {
			POSITION: 'position',
			NORMAL: 'normal',
			TANGENT: 'tangent',
			TEXCOORD_0: 'uv',
			TEXCOORD_1: 'uv2',
			COLOR_0: 'color',
			WEIGHTS_0: 'skinWeight',
			JOINTS_0: 'skinIndex',
		};

		var PATH_PROPERTIES = {
			scale: 'scale',
			translation: 'position',
			rotation: 'quaternion',
			weights: 'morphTargetInfluences'
		};

		var INTERPOLATION = {
			CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
			                        // keyframe track will be initialized with a default interpolation type, then modified.
			LINEAR: InterpolateLinear,
			STEP: InterpolateDiscrete
		};

		var ALPHA_MODES = {
			OPAQUE: 'OPAQUE',
			MASK: 'MASK',
			BLEND: 'BLEND'
		};

		/* UTILITY FUNCTIONS */

		function resolveURL( url, path ) {

			// Invalid URL
			if ( typeof url !== 'string' || url === '' ) { return ''; }

			// Host Relative URL
			if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

				path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

			}

			// Absolute URL http://,https://,//
			if ( /^(https?:)?\/\//i.test( url ) ) { return url; }

			// Data URI
			if ( /^data:.*,.*$/i.test( url ) ) { return url; }

			// Blob URL
			if ( /^blob:.*$/i.test( url ) ) { return url; }

			// Relative URL
			return path + url;

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
		 */
		function createDefaultMaterial( cache ) {

			if ( cache[ 'DefaultMaterial' ] === undefined ) {

				cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
					color: 0xFFFFFF,
					emissive: 0x000000,
					metalness: 1,
					roughness: 1,
					transparent: false,
					depthTest: true,
					side: FrontSide
				} );

			}

			return cache[ 'DefaultMaterial' ];

		}

		function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

			// Add unknown glTF extensions to an object's userData.

			for ( var name in objectDef.extensions ) {

				if ( knownExtensions[ name ] === undefined ) {

					object.userData.gltfExtensions = object.userData.gltfExtensions || {};
					object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

				}

			}

		}

		/**
		 * @param {Object3D|Material|BufferGeometry} object
		 * @param {GLTF.definition} gltfDef
		 */
		function assignExtrasToUserData( object, gltfDef ) {

			if ( gltfDef.extras !== undefined ) {

				if ( typeof gltfDef.extras === 'object' ) {

					Object.assign( object.userData, gltfDef.extras );

				} else {

					console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

				}

			}

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
		 *
		 * @param {BufferGeometry} geometry
		 * @param {Array<GLTF.Target>} targets
		 * @param {GLTFParser} parser
		 * @return {Promise<BufferGeometry>}
		 */
		function addMorphTargets( geometry, targets, parser ) {

			var hasMorphPosition = false;
			var hasMorphNormal = false;

			for ( var i = 0, il = targets.length; i < il; i ++ ) {

				var target = targets[ i ];

				if ( target.POSITION !== undefined ) { hasMorphPosition = true; }
				if ( target.NORMAL !== undefined ) { hasMorphNormal = true; }

				if ( hasMorphPosition && hasMorphNormal ) { break; }

			}

			if ( ! hasMorphPosition && ! hasMorphNormal ) { return Promise.resolve( geometry ); }

			var pendingPositionAccessors = [];
			var pendingNormalAccessors = [];

			for ( var i = 0, il = targets.length; i < il; i ++ ) {

				var target = targets[ i ];

				if ( hasMorphPosition ) {

					var pendingAccessor = target.POSITION !== undefined
						? parser.getDependency( 'accessor', target.POSITION )
						: geometry.attributes.position;

					pendingPositionAccessors.push( pendingAccessor );

				}

				if ( hasMorphNormal ) {

					var pendingAccessor = target.NORMAL !== undefined
						? parser.getDependency( 'accessor', target.NORMAL )
						: geometry.attributes.normal;

					pendingNormalAccessors.push( pendingAccessor );

				}

			}

			return Promise.all( [
				Promise.all( pendingPositionAccessors ),
				Promise.all( pendingNormalAccessors )
			] ).then( function ( accessors ) {

				var morphPositions = accessors[ 0 ];
				var morphNormals = accessors[ 1 ];

				if ( hasMorphPosition ) { geometry.morphAttributes.position = morphPositions; }
				if ( hasMorphNormal ) { geometry.morphAttributes.normal = morphNormals; }
				geometry.morphTargetsRelative = true;

				return geometry;

			} );

		}

		/**
		 * @param {Mesh} mesh
		 * @param {GLTF.Mesh} meshDef
		 */
		function updateMorphTargets( mesh, meshDef ) {

			mesh.updateMorphTargets();

			if ( meshDef.weights !== undefined ) {

				for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

					mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

				}

			}

			// .extras has user-defined data, so check that .extras.targetNames is an array.
			if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

				var targetNames = meshDef.extras.targetNames;

				if ( mesh.morphTargetInfluences.length === targetNames.length ) {

					mesh.morphTargetDictionary = {};

					for ( var i = 0, il = targetNames.length; i < il; i ++ ) {

						mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

					}

				} else {

					console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

				}

			}

		}

		function createPrimitiveKey( primitiveDef ) {

			var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
			var geometryKey;

			if ( dracoExtension ) {

				geometryKey = 'draco:' + dracoExtension.bufferView
					+ ':' + dracoExtension.indices
					+ ':' + createAttributesKey( dracoExtension.attributes );

			} else {

				geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

			}

			return geometryKey;

		}

		function createAttributesKey( attributes ) {

			var attributesKey = '';

			var keys = Object.keys( attributes ).sort();

			for ( var i = 0, il = keys.length; i < il; i ++ ) {

				attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

			}

			return attributesKey;

		}

		/* GLTF PARSER */

		function GLTFParser( json, options ) {

			this.json = json || {};
			this.extensions = {};
			this.plugins = {};
			this.options = options || {};

			// loader object cache
			this.cache = new GLTFRegistry();

			// associations between Three.js objects and glTF elements
			this.associations = new Map();

			// BufferGeometry caching
			this.primitiveCache = {};

			// Object3D instance caches
			this.meshCache = { refs: {}, uses: {} };
			this.cameraCache = { refs: {}, uses: {} };
			this.lightCache = { refs: {}, uses: {} };

			// Track node names, to ensure no duplicates
			this.nodeNamesUsed = {};

			// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
			// expensive work of uploading a texture to the GPU off the main thread.
			if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

				this.textureLoader = new ImageBitmapLoader( this.options.manager );

			} else {

				this.textureLoader = new TextureLoader( this.options.manager );

			}

			this.textureLoader.setCrossOrigin( this.options.crossOrigin );
			this.textureLoader.setRequestHeader( this.options.requestHeader );

			this.fileLoader = new FileLoader( this.options.manager );
			this.fileLoader.setResponseType( 'arraybuffer' );

			if ( this.options.crossOrigin === 'use-credentials' ) {

				this.fileLoader.setWithCredentials( true );

			}

		}

		GLTFParser.prototype.setExtensions = function ( extensions ) {

			this.extensions = extensions;

		};

		GLTFParser.prototype.setPlugins = function ( plugins ) {

			this.plugins = plugins;

		};

		GLTFParser.prototype.parse = function ( onLoad, onError ) {

			var parser = this;
			var json = this.json;
			var extensions = this.extensions;

			// Clear the loader cache
			this.cache.removeAll();

			// Mark the special nodes/meshes in json for efficient parse
			this._invokeAll( function ( ext ) {

				return ext._markDefs && ext._markDefs();

			} );

			Promise.all( this._invokeAll( function ( ext ) {

				return ext.beforeRoot && ext.beforeRoot();

			} ) ).then( function () {

				return Promise.all( [

					parser.getDependencies( 'scene' ),
					parser.getDependencies( 'animation' ),
					parser.getDependencies( 'camera' ) ] );

			} ).then( function ( dependencies ) {

				var result = {
					scene: dependencies[ 0 ][ json.scene || 0 ],
					scenes: dependencies[ 0 ],
					animations: dependencies[ 1 ],
					cameras: dependencies[ 2 ],
					asset: json.asset,
					parser: parser,
					userData: {}
				};

				addUnknownExtensionsToUserData( extensions, result, json );

				assignExtrasToUserData( result, json );

				Promise.all( parser._invokeAll( function ( ext ) {

					return ext.afterRoot && ext.afterRoot( result );

				} ) ).then( function () {

					onLoad( result );

				} );

			} ).catch( onError );

		};

		/**
		 * Marks the special nodes/meshes in json for efficient parse.
		 */
		GLTFParser.prototype._markDefs = function () {

			var nodeDefs = this.json.nodes || [];
			var skinDefs = this.json.skins || [];
			var meshDefs = this.json.meshes || [];

			// Nothing in the node definition indicates whether it is a Bone or an
			// Object3D. Use the skins' joint references to mark bones.
			for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

				var joints = skinDefs[ skinIndex ].joints;

				for ( var i = 0, il = joints.length; i < il; i ++ ) {

					nodeDefs[ joints[ i ] ].isBone = true;

				}

			}

			// Iterate over all nodes, marking references to shared resources,
			// as well as skeleton joints.
			for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				var nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.mesh !== undefined ) {

					this._addNodeRef( this.meshCache, nodeDef.mesh );

					// Nothing in the mesh definition indicates whether it is
					// a SkinnedMesh or Mesh. Use the node's mesh reference
					// to mark SkinnedMesh if node has skin.
					if ( nodeDef.skin !== undefined ) {

						meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

					}

				}

				if ( nodeDef.camera !== undefined ) {

					this._addNodeRef( this.cameraCache, nodeDef.camera );

				}

			}

		};

		/**
		 * Counts references to shared node / Object3D resources. These resources
		 * can be reused, or "instantiated", at multiple nodes in the scene
		 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
		 * be marked. Non-scenegraph resources (like Materials, Geometries, and
		 * Textures) can be reused directly and are not marked here.
		 *
		 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
		 */
		GLTFParser.prototype._addNodeRef = function ( cache, index ) {

			if ( index === undefined ) { return; }

			if ( cache.refs[ index ] === undefined ) {

				cache.refs[ index ] = cache.uses[ index ] = 0;

			}

			cache.refs[ index ] ++;

		};

		/** Returns a reference to a shared resource, cloning it if necessary. */
		GLTFParser.prototype._getNodeRef = function ( cache, index, object ) {

			if ( cache.refs[ index ] <= 1 ) { return object; }

			var ref = object.clone();

			ref.name += '_instance_' + ( cache.uses[ index ] ++ );

			return ref;

		};

		GLTFParser.prototype._invokeOne = function ( func ) {

			var extensions = Object.values( this.plugins );
			extensions.push( this );

			for ( var i = 0; i < extensions.length; i ++ ) {

				var result = func( extensions[ i ] );

				if ( result ) { return result; }

			}

		};

		GLTFParser.prototype._invokeAll = function ( func ) {

			var extensions = Object.values( this.plugins );
			extensions.unshift( this );

			var pending = [];

			for ( var i = 0; i < extensions.length; i ++ ) {

				var result = func( extensions[ i ] );

				if ( result ) { pending.push( result ); }

			}

			return pending;

		};

		/**
		 * Requests the specified dependency asynchronously, with caching.
		 * @param {string} type
		 * @param {number} index
		 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
		 */
		GLTFParser.prototype.getDependency = function ( type, index ) {

			var cacheKey = type + ':' + index;
			var dependency = this.cache.get( cacheKey );

			if ( ! dependency ) {

				switch ( type ) {

					case 'scene':
						dependency = this.loadScene( index );
						break;

					case 'node':
						dependency = this.loadNode( index );
						break;

					case 'mesh':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMesh && ext.loadMesh( index );

						} );
						break;

					case 'accessor':
						dependency = this.loadAccessor( index );
						break;

					case 'bufferView':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadBufferView && ext.loadBufferView( index );

						} );
						break;

					case 'buffer':
						dependency = this.loadBuffer( index );
						break;

					case 'material':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMaterial && ext.loadMaterial( index );

						} );
						break;

					case 'texture':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadTexture && ext.loadTexture( index );

						} );
						break;

					case 'skin':
						dependency = this.loadSkin( index );
						break;

					case 'animation':
						dependency = this.loadAnimation( index );
						break;

					case 'camera':
						dependency = this.loadCamera( index );
						break;

					default:
						throw new Error( 'Unknown type: ' + type );

				}

				this.cache.add( cacheKey, dependency );

			}

			return dependency;

		};

		/**
		 * Requests all dependencies of the specified type asynchronously, with caching.
		 * @param {string} type
		 * @return {Promise<Array<Object>>}
		 */
		GLTFParser.prototype.getDependencies = function ( type ) {

			var dependencies = this.cache.get( type );

			if ( ! dependencies ) {

				var parser = this;
				var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

				dependencies = Promise.all( defs.map( function ( def, index ) {

					return parser.getDependency( type, index );

				} ) );

				this.cache.add( type, dependencies );

			}

			return dependencies;

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

			var bufferDef = this.json.buffers[ bufferIndex ];
			var loader = this.fileLoader;

			if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

				throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

			}

			// If present, GLB container is required to be the first buffer.
			if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

				return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

			}

			var options = this.options;

			return new Promise( function ( resolve, reject ) {

				loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

					reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

				} );

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferViewIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

			var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

			return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

				var byteLength = bufferViewDef.byteLength || 0;
				var byteOffset = bufferViewDef.byteOffset || 0;
				return buffer.slice( byteOffset, byteOffset + byteLength );

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
		 * @param {number} accessorIndex
		 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
		 */
		GLTFParser.prototype.loadAccessor = function ( accessorIndex ) {

			var parser = this;
			var json = this.json;

			var accessorDef = this.json.accessors[ accessorIndex ];

			if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

				// Ignore empty accessors, which may be used to declare runtime
				// information about attributes coming from another source (e.g. Draco
				// compression extension).
				return Promise.resolve( null );

			}

			var pendingBufferViews = [];

			if ( accessorDef.bufferView !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

			} else {

				pendingBufferViews.push( null );

			}

			if ( accessorDef.sparse !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

			}

			return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

				var bufferView = bufferViews[ 0 ];

				var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
				var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
				var elementBytes = TypedArray.BYTES_PER_ELEMENT;
				var itemBytes = elementBytes * itemSize;
				var byteOffset = accessorDef.byteOffset || 0;
				var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
				var normalized = accessorDef.normalized === true;
				var array, bufferAttribute;

				// The buffer is not interleaved if the stride is the item size in bytes.
				if ( byteStride && byteStride !== itemBytes ) {

					// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
					// This makes sure that IBA.count reflects accessor.count properly
					var ibSlice = Math.floor( byteOffset / byteStride );
					var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
					var ib = parser.cache.get( ibCacheKey );

					if ( ! ib ) {

						array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

						// Integer parameters to IB/IBA are in array elements, not bytes.
						ib = new InterleavedBuffer( array, byteStride / elementBytes );

						parser.cache.add( ibCacheKey, ib );

					}

					bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

				} else {

					if ( bufferView === null ) {

						array = new TypedArray( accessorDef.count * itemSize );

					} else {

						array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

					}

					bufferAttribute = new BufferAttribute( array, itemSize, normalized );

				}

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
				if ( accessorDef.sparse !== undefined ) {

					var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
					var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

					var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
					var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

					var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
					var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

					if ( bufferView !== null ) {

						// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
						bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

					}

					for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {

						var index = sparseIndices[ i ];

						bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
						if ( itemSize >= 2 ) { bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); }
						if ( itemSize >= 3 ) { bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); }
						if ( itemSize >= 4 ) { bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); }
						if ( itemSize >= 5 ) { throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); }

					}

				}

				return bufferAttribute;

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
		 * @param {number} textureIndex
		 * @return {Promise<THREE.Texture>}
		 */
		GLTFParser.prototype.loadTexture = function ( textureIndex ) {

			var json = this.json;
			var options = this.options;
			var textureDef = json.textures[ textureIndex ];
			var source = json.images[ textureDef.source ];

			var loader = this.textureLoader;

			if ( source.uri ) {

				var handler = options.manager.getHandler( source.uri );
				if ( handler !== null ) { loader = handler; }

			}

			return this.loadTextureImage( textureIndex, source, loader );

		};

		GLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {

			var parser = this;
			var json = this.json;
			var options = this.options;

			var textureDef = json.textures[ textureIndex ];

			var URL = self.URL || self.webkitURL;

			var sourceURI = source.uri;
			var isObjectURL = false;
			var hasAlpha = true;

			if ( source.mimeType === 'image/jpeg' ) { hasAlpha = false; }

			if ( source.bufferView !== undefined ) {

				// Load binary image data from bufferView, if provided.

				sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

					if ( source.mimeType === 'image/png' ) {

						// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
						// alpha channel. This check is conservative — the image could have an alpha
						// channel with all values == 1, and the indexed type (colorType == 3) only
						// sometimes contains alpha.
						//
						// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
						var colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );
						hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;

					}

					isObjectURL = true;
					var blob = new Blob( [ bufferView ], { type: source.mimeType } );
					sourceURI = URL.createObjectURL( blob );
					return sourceURI;

				} );

			} else if ( source.uri === undefined ) {

				throw new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );

			}

			return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

				return new Promise( function ( resolve, reject ) {

					var onLoad = resolve;

					if ( loader.isImageBitmapLoader === true ) {

						onLoad = function ( imageBitmap ) {

							resolve( new CanvasTexture( imageBitmap ) );

						};

					}

					loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

				} );

			} ).then( function ( texture ) {

				// Clean up resources and configure Texture.

				if ( isObjectURL === true ) {

					URL.revokeObjectURL( sourceURI );

				}

				texture.flipY = false;

				if ( textureDef.name ) { texture.name = textureDef.name; }

				// When there is definitely no alpha channel in the texture, set RGBFormat to save space.
				if ( ! hasAlpha ) { texture.format = RGBFormat; }

				var samplers = json.samplers || {};
				var sampler = samplers[ textureDef.sampler ] || {};

				texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
				texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
				texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
				texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

				parser.associations.set( texture, {
					type: 'textures',
					index: textureIndex
				} );

				return texture;

			} );

		};

		/**
		 * Asynchronously assigns a texture to the given material parameters.
		 * @param {Object} materialParams
		 * @param {string} mapName
		 * @param {Object} mapDef
		 * @return {Promise}
		 */
		GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {

			var parser = this;

			return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

				// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
				// However, we will copy UV set 0 to UV set 1 on demand for aoMap
				if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

					console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

				}

				if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

					var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

					if ( transform ) {

						var gltfReference = parser.associations.get( texture );
						texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
						parser.associations.set( texture, gltfReference );

					}

				}

				materialParams[ mapName ] = texture;

			} );

		};

		/**
		 * Assigns final material to a Mesh, Line, or Points instance. The instance
		 * already has a material (generated from the glTF material options alone)
		 * but reuse of the same glTF material may require multiple threejs materials
		 * to accommodate different primitive types, defines, etc. New materials will
		 * be created if necessary, and reused from a cache.
		 * @param  {Object3D} mesh Mesh, Line, or Points instance.
		 */
		GLTFParser.prototype.assignFinalMaterial = function ( mesh ) {

			var geometry = mesh.geometry;
			var material = mesh.material;

			var useVertexTangents = geometry.attributes.tangent !== undefined;
			var useVertexColors = geometry.attributes.color !== undefined;
			var useFlatShading = geometry.attributes.normal === undefined;
			var useSkinning = mesh.isSkinnedMesh === true;
			var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
			var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

			if ( mesh.isPoints ) {

				var cacheKey = 'PointsMaterial:' + material.uuid;

				var pointsMaterial = this.cache.get( cacheKey );

				if ( ! pointsMaterial ) {

					pointsMaterial = new PointsMaterial();
					Material.prototype.copy.call( pointsMaterial, material );
					pointsMaterial.color.copy( material.color );
					pointsMaterial.map = material.map;
					pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

					this.cache.add( cacheKey, pointsMaterial );

				}

				material = pointsMaterial;

			} else if ( mesh.isLine ) {

				var cacheKey = 'LineBasicMaterial:' + material.uuid;

				var lineMaterial = this.cache.get( cacheKey );

				if ( ! lineMaterial ) {

					lineMaterial = new LineBasicMaterial();
					Material.prototype.copy.call( lineMaterial, material );
					lineMaterial.color.copy( material.color );

					this.cache.add( cacheKey, lineMaterial );

				}

				material = lineMaterial;

			}

			// Clone the material if it will be modified
			if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

				var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

				if ( material.isGLTFSpecularGlossinessMaterial ) { cacheKey += 'specular-glossiness:'; }
				if ( useSkinning ) { cacheKey += 'skinning:'; }
				if ( useVertexTangents ) { cacheKey += 'vertex-tangents:'; }
				if ( useVertexColors ) { cacheKey += 'vertex-colors:'; }
				if ( useFlatShading ) { cacheKey += 'flat-shading:'; }
				if ( useMorphTargets ) { cacheKey += 'morph-targets:'; }
				if ( useMorphNormals ) { cacheKey += 'morph-normals:'; }

				var cachedMaterial = this.cache.get( cacheKey );

				if ( ! cachedMaterial ) {

					cachedMaterial = material.clone();

					if ( useSkinning ) { cachedMaterial.skinning = true; }
					if ( useVertexColors ) { cachedMaterial.vertexColors = true; }
					if ( useFlatShading ) { cachedMaterial.flatShading = true; }
					if ( useMorphTargets ) { cachedMaterial.morphTargets = true; }
					if ( useMorphNormals ) { cachedMaterial.morphNormals = true; }

					if ( useVertexTangents ) {

						cachedMaterial.vertexTangents = true;

						// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
						if ( cachedMaterial.normalScale ) { cachedMaterial.normalScale.y *= - 1; }
						if ( cachedMaterial.clearcoatNormalScale ) { cachedMaterial.clearcoatNormalScale.y *= - 1; }

					}

					this.cache.add( cacheKey, cachedMaterial );

					this.associations.set( cachedMaterial, this.associations.get( material ) );

				}

				material = cachedMaterial;

			}

			// workarounds for mesh and geometry

			if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

				geometry.setAttribute( 'uv2', geometry.attributes.uv );

			}

			mesh.material = material;

		};

		GLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {

			return MeshStandardMaterial;

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
		 * @param {number} materialIndex
		 * @return {Promise<Material>}
		 */
		GLTFParser.prototype.loadMaterial = function ( materialIndex ) {

			var parser = this;
			var json = this.json;
			var extensions = this.extensions;
			var materialDef = json.materials[ materialIndex ];

			var materialType;
			var materialParams = {};
			var materialExtensions = materialDef.extensions || {};

			var pending = [];

			if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

				var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
				materialType = sgExtension.getMaterialType();
				pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

			} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

				var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
				materialType = kmuExtension.getMaterialType();
				pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

			} else {

				// Specification:
				// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

				var metallicRoughness = materialDef.pbrMetallicRoughness || {};

				materialParams.color = new Color( 1.0, 1.0, 1.0 );
				materialParams.opacity = 1.0;

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					var array = metallicRoughness.baseColorFactor;

					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

				materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
				materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

				if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
					pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

				}

				materialType = this._invokeOne( function ( ext ) {

					return ext.getMaterialType && ext.getMaterialType( materialIndex );

				} );

				pending.push( Promise.all( this._invokeAll( function ( ext ) {

					return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

				} ) ) );

			}

			if ( materialDef.doubleSided === true ) {

				materialParams.side = DoubleSide;

			}

			var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

			if ( alphaMode === ALPHA_MODES.BLEND ) {

				materialParams.transparent = true;

				// See: https://github.com/mrdoob/three.js/issues/17706
				materialParams.depthWrite = false;

			} else {

				materialParams.transparent = false;

				if ( alphaMode === ALPHA_MODES.MASK ) {

					materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

				}

			}

			if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

				// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				materialParams.normalScale = new Vector2( 1, - 1 );

				if ( materialDef.normalTexture.scale !== undefined ) {

					materialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );

				}

			}

			if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

				if ( materialDef.occlusionTexture.strength !== undefined ) {

					materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

				}

			}

			if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

				materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

			}

			if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

			}

			return Promise.all( pending ).then( function () {

				var material;

				if ( materialType === GLTFMeshStandardSGMaterial ) {

					material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

				} else {

					material = new materialType( materialParams );

				}

				if ( materialDef.name ) { material.name = materialDef.name; }

				// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
				if ( material.map ) { material.map.encoding = sRGBEncoding; }
				if ( material.emissiveMap ) { material.emissiveMap.encoding = sRGBEncoding; }

				assignExtrasToUserData( material, materialDef );

				parser.associations.set( material, { type: 'materials', index: materialIndex } );

				if ( materialDef.extensions ) { addUnknownExtensionsToUserData( extensions, material, materialDef ); }

				return material;

			} );

		};

		/** When Object3D instances are targeted by animation, they need unique names. */
		GLTFParser.prototype.createUniqueName = function ( originalName ) {

			var sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

			var name = sanitizedName;

			for ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

				name = sanitizedName + '_' + i;

			}

			this.nodeNamesUsed[ name ] = true;

			return name;

		};

		/**
		 * @param {BufferGeometry} geometry
		 * @param {GLTF.Primitive} primitiveDef
		 * @param {GLTFParser} parser
		 */
		function computeBounds( geometry, primitiveDef, parser ) {

			var attributes = primitiveDef.attributes;

			var box = new Box3();

			if ( attributes.POSITION !== undefined ) {

				var accessor = parser.json.accessors[ attributes.POSITION ];

				var min = accessor.min;
				var max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					box.set(
						new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
						new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

					return;

				}

			} else {

				return;

			}

			var targets = primitiveDef.targets;

			if ( targets !== undefined ) {

				var maxDisplacement = new Vector3();
				var vector = new Vector3();

				for ( var i = 0, il = targets.length; i < il; i ++ ) {

					var target = targets[ i ];

					if ( target.POSITION !== undefined ) {

						var accessor = parser.json.accessors[ target.POSITION ];
						var min = accessor.min;
						var max = accessor.max;

						// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

						if ( min !== undefined && max !== undefined ) {

							// we need to get max of absolute components because target weight is [-1,1]
							vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
							vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
							vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

							// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
							// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
							// are used to implement key-frame animations and as such only two are active at a time - this results in very large
							// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
							maxDisplacement.max( vector );

						} else {

							console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

						}

					}

				}

				// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
				box.expandByVector( maxDisplacement );

			}

			geometry.boundingBox = box;

			var sphere = new Sphere();

			box.getCenter( sphere.center );
			sphere.radius = box.min.distanceTo( box.max ) / 2;

			geometry.boundingSphere = sphere;

		}

		/**
		 * @param {BufferGeometry} geometry
		 * @param {GLTF.Primitive} primitiveDef
		 * @param {GLTFParser} parser
		 * @return {Promise<BufferGeometry>}
		 */
		function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

			var attributes = primitiveDef.attributes;

			var pending = [];

			function assignAttributeAccessor( accessorIndex, attributeName ) {

				return parser.getDependency( 'accessor', accessorIndex )
					.then( function ( accessor ) {

						geometry.setAttribute( attributeName, accessor );

					} );

			}

			for ( var gltfAttributeName in attributes ) {

				var threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

				// Skip attributes already provided by e.g. Draco extension.
				if ( threeAttributeName in geometry.attributes ) { continue; }

				pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

			}

			if ( primitiveDef.indices !== undefined && ! geometry.index ) {

				var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

					geometry.setIndex( accessor );

				} );

				pending.push( accessor );

			}

			assignExtrasToUserData( geometry, primitiveDef );

			computeBounds( geometry, primitiveDef, parser );

			return Promise.all( pending ).then( function () {

				return primitiveDef.targets !== undefined
					? addMorphTargets( geometry, primitiveDef.targets, parser )
					: geometry;

			} );

		}

		/**
		 * @param {BufferGeometry} geometry
		 * @param {Number} drawMode
		 * @return {BufferGeometry}
		 */
		function toTrianglesDrawMode( geometry, drawMode ) {

			var index = geometry.getIndex();

			// generate index if not present

			if ( index === null ) {

				var indices = [];

				var position = geometry.getAttribute( 'position' );

				if ( position !== undefined ) {

					for ( var i = 0; i < position.count; i ++ ) {

						indices.push( i );

					}

					geometry.setIndex( indices );
					index = geometry.getIndex();

				} else {

					console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
					return geometry;

				}

			}

			//

			var numberOfTriangles = index.count - 2;
			var newIndices = [];

			if ( drawMode === TriangleFanDrawMode ) {

				// gl.TRIANGLE_FAN

				for ( var i = 1; i <= numberOfTriangles; i ++ ) {

					newIndices.push( index.getX( 0 ) );
					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );

				}

			} else {

				// gl.TRIANGLE_STRIP

				for ( var i = 0; i < numberOfTriangles; i ++ ) {

					if ( i % 2 === 0 ) {

						newIndices.push( index.getX( i ) );
						newIndices.push( index.getX( i + 1 ) );
						newIndices.push( index.getX( i + 2 ) );


					} else {

						newIndices.push( index.getX( i + 2 ) );
						newIndices.push( index.getX( i + 1 ) );
						newIndices.push( index.getX( i ) );

					}

				}

			}

			if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

			}

			// build final geometry

			var newGeometry = geometry.clone();
			newGeometry.setIndex( newIndices );

			return newGeometry;

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
		 *
		 * Creates BufferGeometries from primitives.
		 *
		 * @param {Array<GLTF.Primitive>} primitives
		 * @return {Promise<Array<BufferGeometry>>}
		 */
		GLTFParser.prototype.loadGeometries = function ( primitives ) {

			var parser = this;
			var extensions = this.extensions;
			var cache = this.primitiveCache;

			function createDracoPrimitive( primitive ) {

				return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
					.decodePrimitive( primitive, parser )
					.then( function ( geometry ) {

						return addPrimitiveAttributes( geometry, primitive, parser );

					} );

			}

			var pending = [];

			for ( var i = 0, il = primitives.length; i < il; i ++ ) {

				var primitive = primitives[ i ];
				var cacheKey = createPrimitiveKey( primitive );

				// See if we've already created this geometry
				var cached = cache[ cacheKey ];

				if ( cached ) {

					// Use the cached geometry if it exists
					pending.push( cached.promise );

				} else {

					var geometryPromise;

					if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

						// Use DRACO geometry if available
						geometryPromise = createDracoPrimitive( primitive );

					} else {

						// Otherwise create a new geometry
						geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

					}

					// Cache this geometry
					cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

					pending.push( geometryPromise );

				}

			}

			return Promise.all( pending );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
		 * @param {number} meshIndex
		 * @return {Promise<Group|Mesh|SkinnedMesh>}
		 */
		GLTFParser.prototype.loadMesh = function ( meshIndex ) {

			var parser = this;
			var json = this.json;
			var extensions = this.extensions;

			var meshDef = json.meshes[ meshIndex ];
			var primitives = meshDef.primitives;

			var pending = [];

			for ( var i = 0, il = primitives.length; i < il; i ++ ) {

				var material = primitives[ i ].material === undefined
					? createDefaultMaterial( this.cache )
					: this.getDependency( 'material', primitives[ i ].material );

				pending.push( material );

			}

			pending.push( parser.loadGeometries( primitives ) );

			return Promise.all( pending ).then( function ( results ) {

				var materials = results.slice( 0, results.length - 1 );
				var geometries = results[ results.length - 1 ];

				var meshes = [];

				for ( var i = 0, il = geometries.length; i < il; i ++ ) {

					var geometry = geometries[ i ];
					var primitive = primitives[ i ];

					// 1. create Mesh

					var mesh;

					var material = materials[ i ];

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

						// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
						mesh = meshDef.isSkinnedMesh === true
							? new SkinnedMesh( geometry, material )
							: new Mesh( geometry, material );

						if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

							// we normalize floating point skin weight array to fix malformed assets (see #15319)
							// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
							mesh.normalizeSkinWeights();

						}

						if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

						} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

						}

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

						mesh = new LineSegments( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

						mesh = new Line( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

						mesh = new LineLoop( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

						mesh = new Points( geometry, material );

					} else {

						throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

					}

					if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

						updateMorphTargets( mesh, meshDef );

					}

					mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

					assignExtrasToUserData( mesh, meshDef );

					if ( primitive.extensions ) { addUnknownExtensionsToUserData( extensions, mesh, primitive ); }

					parser.assignFinalMaterial( mesh );

					meshes.push( mesh );

				}

				if ( meshes.length === 1 ) {

					return meshes[ 0 ];

				}

				var group = new Group();

				for ( var i = 0, il = meshes.length; i < il; i ++ ) {

					group.add( meshes[ i ] );

				}

				return group;

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
		 * @param {number} cameraIndex
		 * @return {Promise<THREE.Camera>}
		 */
		GLTFParser.prototype.loadCamera = function ( cameraIndex ) {

			var camera;
			var cameraDef = this.json.cameras[ cameraIndex ];
			var params = cameraDef[ cameraDef.type ];

			if ( ! params ) {

				console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
				return;

			}

			if ( cameraDef.type === 'perspective' ) {

				camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

			} else if ( cameraDef.type === 'orthographic' ) {

				camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

			}

			if ( cameraDef.name ) { camera.name = this.createUniqueName( cameraDef.name ); }

			assignExtrasToUserData( camera, cameraDef );

			return Promise.resolve( camera );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
		 * @param {number} skinIndex
		 * @return {Promise<Object>}
		 */
		GLTFParser.prototype.loadSkin = function ( skinIndex ) {

			var skinDef = this.json.skins[ skinIndex ];

			var skinEntry = { joints: skinDef.joints };

			if ( skinDef.inverseBindMatrices === undefined ) {

				return Promise.resolve( skinEntry );

			}

			return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

				skinEntry.inverseBindMatrices = accessor;

				return skinEntry;

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
		 * @param {number} animationIndex
		 * @return {Promise<AnimationClip>}
		 */
		GLTFParser.prototype.loadAnimation = function ( animationIndex ) {

			var json = this.json;

			var animationDef = json.animations[ animationIndex ];

			var pendingNodes = [];
			var pendingInputAccessors = [];
			var pendingOutputAccessors = [];
			var pendingSamplers = [];
			var pendingTargets = [];

			for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {

				var channel = animationDef.channels[ i ];
				var sampler = animationDef.samplers[ channel.sampler ];
				var target = channel.target;
				var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
				var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
				var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

				pendingNodes.push( this.getDependency( 'node', name ) );
				pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
				pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
				pendingSamplers.push( sampler );
				pendingTargets.push( target );

			}

			return Promise.all( [

				Promise.all( pendingNodes ),
				Promise.all( pendingInputAccessors ),
				Promise.all( pendingOutputAccessors ),
				Promise.all( pendingSamplers ),
				Promise.all( pendingTargets )

			] ).then( function ( dependencies ) {

				var nodes = dependencies[ 0 ];
				var inputAccessors = dependencies[ 1 ];
				var outputAccessors = dependencies[ 2 ];
				var samplers = dependencies[ 3 ];
				var targets = dependencies[ 4 ];

				var tracks = [];

				for ( var i = 0, il = nodes.length; i < il; i ++ ) {

					var node = nodes[ i ];
					var inputAccessor = inputAccessors[ i ];
					var outputAccessor = outputAccessors[ i ];
					var sampler = samplers[ i ];
					var target = targets[ i ];

					if ( node === undefined ) { continue; }

					node.updateMatrix();
					node.matrixAutoUpdate = true;

					var TypedKeyframeTrack;

					switch ( PATH_PROPERTIES[ target.path ] ) {

						case PATH_PROPERTIES.weights:

							TypedKeyframeTrack = NumberKeyframeTrack;
							break;

						case PATH_PROPERTIES.rotation:

							TypedKeyframeTrack = QuaternionKeyframeTrack;
							break;

						case PATH_PROPERTIES.position:
						case PATH_PROPERTIES.scale:
						default:

							TypedKeyframeTrack = VectorKeyframeTrack;
							break;

					}

					var targetName = node.name ? node.name : node.uuid;

					var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

					var targetNames = [];

					if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

						// Node may be a Group (glTF mesh with several primitives) or a Mesh.
						node.traverse( function ( object ) {

							if ( object.isMesh === true && object.morphTargetInfluences ) {

								targetNames.push( object.name ? object.name : object.uuid );

							}

						} );

					} else {

						targetNames.push( targetName );

					}

					var outputArray = outputAccessor.array;

					if ( outputAccessor.normalized ) {

						var scale;

						if ( outputArray.constructor === Int8Array ) {

							scale = 1 / 127;

						} else if ( outputArray.constructor === Uint8Array ) {

							scale = 1 / 255;

						} else if ( outputArray.constructor == Int16Array ) {

							scale = 1 / 32767;

						} else if ( outputArray.constructor === Uint16Array ) {

							scale = 1 / 65535;

						} else {

							throw new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );

						}

						var scaled = new Float32Array( outputArray.length );

						for ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {

							scaled[ j ] = outputArray[ j ] * scale;

						}

						outputArray = scaled;

					}

					for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

						var track = new TypedKeyframeTrack(
							targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
							inputAccessor.array,
							outputArray,
							interpolation
						);

						// Override interpolation with custom factory method.
						if ( sampler.interpolation === 'CUBICSPLINE' ) {

							track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

								// A CUBICSPLINE keyframe in glTF has three output values for each input value,
								// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
								// must be divided by three to get the interpolant's sampleSize argument.

								return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

							};

							// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
							track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

						}

						tracks.push( track );

					}

				}

				var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

				return new AnimationClip( name, undefined, tracks );

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
		 * @param {number} nodeIndex
		 * @return {Promise<Object3D>}
		 */
		GLTFParser.prototype.loadNode = function ( nodeIndex ) {

			var json = this.json;
			var extensions = this.extensions;
			var parser = this;

			var nodeDef = json.nodes[ nodeIndex ];

			// reserve node's name before its dependencies, so the root has the intended name.
			var nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

			return ( function () {

				var pending = [];

				if ( nodeDef.mesh !== undefined ) {

					pending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

						var node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

						// if weights are provided on the node, override weights on the mesh.
						if ( nodeDef.weights !== undefined ) {

							node.traverse( function ( o ) {

								if ( ! o.isMesh ) { return; }

								for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

									o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

								}

							} );

						}

						return node;

					} ) );

				}

				if ( nodeDef.camera !== undefined ) {

					pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

						return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

					} ) );

				}

				parser._invokeAll( function ( ext ) {

					return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

				} ).forEach( function ( promise ) {

					pending.push( promise );

				} );

				return Promise.all( pending );

			}() ).then( function ( objects ) {

				var node;

				// .isBone isn't in glTF spec. See ._markDefs
				if ( nodeDef.isBone === true ) {

					node = new Bone();

				} else if ( objects.length > 1 ) {

					node = new Group();

				} else if ( objects.length === 1 ) {

					node = objects[ 0 ];

				} else {

					node = new Object3D();

				}

				if ( node !== objects[ 0 ] ) {

					for ( var i = 0, il = objects.length; i < il; i ++ ) {

						node.add( objects[ i ] );

					}

				}

				if ( nodeDef.name ) {

					node.userData.name = nodeDef.name;
					node.name = nodeName;

				}

				assignExtrasToUserData( node, nodeDef );

				if ( nodeDef.extensions ) { addUnknownExtensionsToUserData( extensions, node, nodeDef ); }

				if ( nodeDef.matrix !== undefined ) {

					var matrix = new Matrix4();
					matrix.fromArray( nodeDef.matrix );
					node.applyMatrix4( matrix );

				} else {

					if ( nodeDef.translation !== undefined ) {

						node.position.fromArray( nodeDef.translation );

					}

					if ( nodeDef.rotation !== undefined ) {

						node.quaternion.fromArray( nodeDef.rotation );

					}

					if ( nodeDef.scale !== undefined ) {

						node.scale.fromArray( nodeDef.scale );

					}

				}

				parser.associations.set( node, { type: 'nodes', index: nodeIndex } );

				return node;

			} );

		};

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
		 * @param {number} sceneIndex
		 * @return {Promise<Group>}
		 */
		GLTFParser.prototype.loadScene = function () {

			// scene node hierachy builder

			function buildNodeHierachy( nodeId, parentObject, json, parser ) {

				var nodeDef = json.nodes[ nodeId ];

				return parser.getDependency( 'node', nodeId ).then( function ( node ) {

					if ( nodeDef.skin === undefined ) { return node; }

					// build skeleton here as well

					var skinEntry;

					return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

						skinEntry = skin;

						var pendingJoints = [];

						for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

							pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

						}

						return Promise.all( pendingJoints );

					} ).then( function ( jointNodes ) {

						node.traverse( function ( mesh ) {

							if ( ! mesh.isMesh ) { return; }

							var bones = [];
							var boneInverses = [];

							for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {

								var jointNode = jointNodes[ j ];

								if ( jointNode ) {

									bones.push( jointNode );

									var mat = new Matrix4();

									if ( skinEntry.inverseBindMatrices !== undefined ) {

										mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

									}

									boneInverses.push( mat );

								} else {

									console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

								}

							}

							mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

						} );

						return node;

					} );

				} ).then( function ( node ) {

					// build node hierachy

					parentObject.add( node );

					var pending = [];

					if ( nodeDef.children ) {

						var children = nodeDef.children;

						for ( var i = 0, il = children.length; i < il; i ++ ) {

							var child = children[ i ];
							pending.push( buildNodeHierachy( child, node, json, parser ) );

						}

					}

					return Promise.all( pending );

				} );

			}

			return function loadScene( sceneIndex ) {

				var json = this.json;
				var extensions = this.extensions;
				var sceneDef = this.json.scenes[ sceneIndex ];
				var parser = this;

				// Loader returns Group, not Scene.
				// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
				var scene = new Group();
				if ( sceneDef.name ) { scene.name = parser.createUniqueName( sceneDef.name ); }

				assignExtrasToUserData( scene, sceneDef );

				if ( sceneDef.extensions ) { addUnknownExtensionsToUserData( extensions, scene, sceneDef ); }

				var nodeIds = sceneDef.nodes || [];

				var pending = [];

				for ( var i = 0, il = nodeIds.length; i < il; i ++ ) {

					pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

				}

				return Promise.all( pending ).then( function () {

					return scene;

				} );

			};

		}();

		return GLTFLoader;

	} )();

	var GLTFFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function GLTFFacade (parent) {
	    Object3DFacade.call(this, parent, new Group());
	    this.url = null;
	    this.rootTransform = null;
	    this.autoDispose = true;
	  }

	  if ( Object3DFacade ) GLTFFacade.__proto__ = Object3DFacade;
	  GLTFFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  GLTFFacade.prototype.constructor = GLTFFacade;

	  GLTFFacade.prototype.afterUpdate = function afterUpdate () {
	    var this$1 = this;

	    var ref = this;
	    var url = ref.url;
	    if (url !== this._url) {
	      this._url = url;
	      this.removeObjects();
	      if (url) {
	        var loader = new GLTFLoader();
	        loader.setCrossOrigin('anonymous');
	        loader.load(
	          url,
	          function (result) {
	            this$1.onLoad(result);
	          },
	          null,
	          function (err) {
	            console.error('Failed loading controller model', err);
	          }
	        );
	      }
	    }
	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  GLTFFacade.prototype.onLoad = function onLoad (gltf) {
	    if (this.threeObject) {
	      gltf = this.normalize(gltf);
	      var root = gltf.scene;
	      if (this.rootTransform) {
	        root.applyMatrix4(this.rootTransform);
	      }
	      this.threeObject.add(root);
	      root.updateMatrixWorld(true);
	      this.gltf = gltf;
	      this.afterUpdate();
	    }
	  };

	  GLTFFacade.prototype.normalize = function normalize (gltf) {
	    return gltf
	  };

	  GLTFFacade.prototype.removeObjects = function removeObjects () {
	    var ref = this;
	    var gltf = ref.gltf;
	    if (gltf && gltf.scene) {
	      if (this.autoDispose) {
	        gltf.scene.traverse(function (ref) {
	          var geometry = ref.geometry;
	          var material = ref.material;

	          if (geometry) {
	            geometry.dispose();
	          }
	          if (material) {
	            if (material.texture) {
	              material.texture.dispose();
	            }
	            material.dispose();
	          }
	        });
	      }
	      if (this.threeObject) {
	        this.threeObject.remove(gltf.scene);
	      }
	      this.gltf = null;
	    }
	  };

	  GLTFFacade.prototype.destructor = function destructor () {
	    this.removeObjects();
	    Object3DFacade.prototype.destructor.call(this);
	  };

	  return GLTFFacade;
	}(Object3DFacade));

	var MODEL_GEN = 'gen2';

	function getModelUrl (gen, hand) {
	  return ("https://cdn.aframe.io/controllers/oculus/oculus-touch-controller-" + gen + "-" + hand + ".gltf")
	}

	var MODEL_PARAMS = {
	  gen1: {
	    left: {
	      url: getModelUrl('gen1', 'left'),
	      transform: new Matrix4().compose(
	        new Vector3(0, 0, -0.1),
	        new Quaternion(),
	        new Vector3(1, 1, 1)
	      )
	    },
	    right: {
	      url: getModelUrl('gen1', 'right'),
	      transform: new Matrix4().compose(
	        new Vector3(0, 0, -0.1),
	        new Quaternion(),
	        new Vector3(1, 1, 1)
	      )
	    }
	  },
	  gen2: {
	    left: {
	      url: getModelUrl('gen2', 'left'),
	      transform: new Matrix4().compose(
	        new Vector3(0.01, -0.01, -0.05),
	        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),
	        new Vector3(1, 1, 1)
	      )
	    },
	    right: {
	      url: getModelUrl('gen2', 'right'),
	      transform: new Matrix4().compose(
	        new Vector3(-0.01, -0.01, -0.05),
	        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),
	        new Vector3(1, 1, 1)
	      )
	    }
	  }
	};

	var OculusTouchGrip = /*@__PURE__*/(function (GLTFFacade) {
	  function OculusTouchGrip (parent) {
	    GLTFFacade.call(this, parent);

	    this.xrInputSource = null;
	    this.bodyColor = 0x999999;
	    this.buttonColor = 0xffffff;
	    this.buttonActiveColor = 0xccffcc;
	    this.emissiveIntensity = 0.3;
	  }

	  if ( GLTFFacade ) OculusTouchGrip.__proto__ = GLTFFacade;
	  OculusTouchGrip.prototype = Object.create( GLTFFacade && GLTFFacade.prototype );
	  OculusTouchGrip.prototype.constructor = OculusTouchGrip;

	  OculusTouchGrip.prototype.afterUpdate = function afterUpdate () {
	    var hand = this.xrInputSource.handedness;
	    if (hand !== 'left' && hand !== 'right') {
	      hand = 'left';
	    }
	    if (hand !== this._hand) {
	      this._hand = hand;
	      this.url = MODEL_PARAMS[MODEL_GEN][hand].url;
	      this.rootTransform = MODEL_PARAMS[MODEL_GEN][hand].transform;
	    }

	    this.updateMaterials();
	    GLTFFacade.prototype.afterUpdate.call(this);
	  };

	  OculusTouchGrip.prototype.normalize = function normalize (gltf) {
	    var this$1 = this;

	    // Track all the individual meshes
	    this.meshes = Object.create(null);
	    gltf.scene.traverse(function (obj) {
	      if (obj.isMesh) {
	        obj.material = obj.material.clone(); //workaround for some meshes sharing a material instance
	        this$1.meshes[obj.name] = obj;
	      }
	    });
	    return gltf
	  };

	  OculusTouchGrip.prototype.updateMaterials = function updateMaterials () {
	    var ref = this;
	    var meshes = ref.meshes;
	    if (meshes) {
	      for (var name in meshes) {
	        var color = name === 'body' ? this.bodyColor : this.buttonColor;
	        var material = meshes[name].material;
	        if (color !== material._lastColor) {
	          material.color.set(color);
	          material.emissive.set(color);
	          material._lastColor = color;
	        }
	        material.emissiveIntensity = this.emissiveIntensity;
	      }
	    }
	  };

	  return OculusTouchGrip;
	}(GLTFFacade));

	//import { HandsGrip } from './grip-models/HandsGrip.js'


	var PROFILE_MODELS = [
	  /*{
	    match: xrInputSource => {
	      return true //TODO
	    },
	    facade: HandsGrip
	  },*/
	  {
	    match: function (xrInputSource) {
	      return /Oculus/.test(navigator.userAgent) || (
	        xrInputSource.profiles && xrInputSource.profiles.some(function (profile) { return /oculus-touch/.test(profile); })
	      )
	    },
	    facade: OculusTouchGrip
	  },
	  {
	    match: function (xrInputSource) { return true; },
	    facade: Basic,
	    space: 'targetRay'
	  }
	];

	function findModelConfig(xrInputSource) {
	  for (var i = 0; i < PROFILE_MODELS.length; i++) {
	    if (PROFILE_MODELS[i].match(xrInputSource)) {
	      var result = assign({}, PROFILE_MODELS[i]);
	      delete result.match;
	      return result
	    }
	  }
	}


	var GripFacade = /*@__PURE__*/(function (Group3DFacade) {
	  function GripFacade () {
	    Group3DFacade.apply(this, arguments);
	  }

	  if ( Group3DFacade ) GripFacade.__proto__ = Group3DFacade;
	  GripFacade.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  GripFacade.prototype.constructor = GripFacade;

	  GripFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var xrInputSource = ref.xrInputSource;
	    var modelConfig = this.modelConfig;
	    if (xrInputSource && xrInputSource !== this._lastSource) {
	      this._lastSource = xrInputSource;
	      modelConfig = this.modelConfig = findModelConfig(xrInputSource);
	      if (modelConfig) {
	        modelConfig.xrInputSource = xrInputSource;
	      }
	    }

	    // Update to match the appropriate pose
	    if (modelConfig) {
	      var pose = modelConfig.space === 'targetRay' ? this.targetRayPose : this.gripPose;
	      this.visible = !!pose;
	      if (pose) {
	        copyXRPoseToFacadeProps(pose, this);
	      }
	      modelConfig.rayIntersection = this.rayIntersection;
	    }

	    this.children = modelConfig || null;
	    Group3DFacade.prototype.afterUpdate.call(this);
	  };

	  return GripFacade;
	}(Group3DFacade));

	// xr-standard gamepad button/axis index mappings
	// https://immersive-web.github.io/webxr-gamepads-module/

	var BUTTON_TRIGGER = 0;
	var BUTTON_SQUEEZE = 1;
	var BUTTON_DEFAULT_BACK = 5;

	var SCENE_EVENTS = ['mousemove', 'mouseover', 'mouseout', 'mousedown', 'mouseup', 'click'];
	var XRSESSION_EVENTS = ['selectstart', 'selectend', 'squeezestart', 'squeezeend'];
	var CLICK_MAX_DUR = 300;

	var HAPTICS = { //TODO allow control
	  mouseover: {value: 0.3, duration: 10},
	  click: {value: 1, duration: 20}
	};

	var DEFAULT_CURSOR = {
	  facade: CursorFacade
	};
	var DEFAULT_TARGET_RAY = {
	  facade: TargetRayFacade
	};
	var DEFAULT_GRIP = {
	  facade: GripFacade
	};

	function toggleEvents (target, on, eventTypes, handler) {
	  if (target) {
	    eventTypes.forEach(function (type) {
	      target[((on ? 'add' : 'remove') + "EventListener")](type, handler);
	    });
	  }
	}

	new Matrix4();

	/**
	 * Controls the behavior and visual representation of a single XRInputSource.
	 *
	 * |                   | Highlight | Cursor | Pointing Ray | Renderable Model |
	 * | ------------------| --------- | ------ | ------------ | ---------------- |
	 * | 'screen'          | √         | X      | X            | X                |
	 * | 'gaze'            | √         | √      | X            | X                |
	 * | 'tracked-pointer' | √         | √      | √            | √ (if possible)  |
	 */
	var XRInputSourceFacade = /*@__PURE__*/(function (Group3DFacade) {
	  function XRInputSourceFacade (parent) {
	    Group3DFacade.call(this, parent);
	    this.isXRInputSource = true;

	    // Required props
	    this.xrInputSource = null;
	    this.xrSession = null;
	    this.xrReferenceSpace = null;

	    // Current frame state data, passed to all children:
	    this.targetRayPose = null;
	    this.gripPose = null;
	    this.rayIntersection = null;

	    // Child object configs:
	    this.cursor = assign(DEFAULT_CURSOR);
	    this.targetRay = assign(DEFAULT_TARGET_RAY);
	    this.grip = assign(DEFAULT_GRIP);

	    // Pointing - true for all inputs by default
	    this.isPointing = true;

	    this.clickOnPoke = false;

	    this.children = [
	      null, //cursor
	      null, //targetRay
	      null //grip
	    ];

	    this._ray = new Ray();

	    this._onSessionEvent = this._onSessionEvent.bind(this);
	    this._onSceneRayEvent = this._onSceneRayEvent.bind(this);
	    this.addEventListener('xrframe', this._onXrFrame.bind(this));

	    // Listen to ray intersection related events at the scene level, so we can respond to intersection changes
	    toggleEvents(this.getSceneFacade(), true, SCENE_EVENTS, this._onSceneRayEvent);
	  }

	  if ( Group3DFacade ) XRInputSourceFacade.__proto__ = Group3DFacade;
	  XRInputSourceFacade.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  XRInputSourceFacade.prototype.constructor = XRInputSourceFacade;

	  XRInputSourceFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var xrSession = ref.xrSession;
	    var _lastXrSession = ref._lastXrSession;
	    var xrInputSource = ref.xrInputSource;
	    var rayIntersection = ref.rayIntersection;
	    var children = ref.children;
	    var isPointing = ref.isPointing;
	    var cursor = ref.cursor;
	    var targetRay = ref.targetRay;
	    var grip = ref.grip;
	    var targetRayPose = ref.targetRayPose;
	    var gripPose = ref.gripPose;

	    if (xrSession !== _lastXrSession) {
	      this._lastXrSession = xrSession;
	      toggleEvents(_lastXrSession, false, XRSESSION_EVENTS, this._onSessionEvent);
	      // Only listen for XRSession 'select' event if we won't be handling the xr-standard
	      // gamepad button tracking ourselves
	      if (!this._isXrStandardGamepad()) {
	        toggleEvents(xrSession, true, XRSESSION_EVENTS, this._onSessionEvent);
	      }
	    }

	    // Update child objects
	    var cursorCfg = null, targetRayCfg = null, gripCfg = null;
	    if (xrInputSource.targetRayMode !== 'screen') {
	      cursorCfg = isPointing && cursor;
	      if (cursorCfg) {
	        cursorCfg.key = 'cursor';
	        cursorCfg.targetRayPose = targetRayPose;
	        cursorCfg.gripPose = gripPose;
	        cursorCfg.rayIntersection = rayIntersection;
	        cursorCfg.xrInputSource = xrInputSource;
	      }
	    }
	    if (xrInputSource.targetRayMode === 'tracked-pointer') {
	      targetRayCfg = isPointing && targetRay;
	      if (targetRayCfg) {
	        targetRayCfg.key = 'targetRay';
	        targetRayCfg.targetRayPose = targetRayPose;
	        targetRayCfg.gripPose = gripPose;
	        targetRayCfg.rayIntersection = rayIntersection;
	        targetRayCfg.xrInputSource = xrInputSource;
	      }
	      gripCfg = gripPose ? grip : null;
	      if (gripCfg) {
	        gripCfg.key = 'grip';
	        gripCfg.targetRayPose = targetRayPose;
	        gripCfg.gripPose = gripPose;
	        gripCfg.rayIntersection = rayIntersection;
	        gripCfg.xrInputSource = xrInputSource;
	      }
	    }
	    children[0] = cursorCfg;
	    children[1] = targetRayCfg;
	    children[2] = gripCfg;

	    Group3DFacade.prototype.afterUpdate.call(this);
	  };

	  XRInputSourceFacade.prototype._onXrFrame = function _onXrFrame (time, xrFrame) {
	    var ref = this;
	    var xrInputSource = ref.xrInputSource;
	    var isPointing = ref.isPointing;
	    var ray = ref._ray;
	    var offsetReferenceSpace = this.getCameraFacade().offsetReferenceSpace;

	    if (offsetReferenceSpace) {
	      // Update current poses
	      var targetRaySpace = xrInputSource.targetRaySpace;
	      var gripSpace = xrInputSource.gripSpace;
	      var targetRayPose = xrFrame.getPose(targetRaySpace, offsetReferenceSpace);
	      if (targetRayPose && isPointing) {
	        ray.origin.copy(targetRayPose.transform.position);
	        ray.direction.set(0, 0, -1).applyQuaternion(targetRayPose.transform.orientation);
	        this.notifyWorld('rayPointerMotion', ray);
	      }
	      this.targetRayPose = targetRayPose;
	      this.gripPose = gripSpace ? xrFrame.getPose(gripSpace, offsetReferenceSpace) : null;
	    }

	    // If this is a tracked-pointer with a gamepad, track its button/axis states
	    if (this._isXrStandardGamepad()) {
	      this._trackGamepadState(xrInputSource.gamepad);
	    }

	    this.afterUpdate();
	  };

	  XRInputSourceFacade.prototype._isXrStandardGamepad = function _isXrStandardGamepad () {
	    var ref = this.xrInputSource;
	    var gamepad = ref.gamepad;
	    return gamepad && gamepad.mapping === 'xr-standard'
	  };

	  XRInputSourceFacade.prototype._trackGamepadState = function _trackGamepadState (gamepad) {
	    // Handle button presses
	    var buttons = gamepad.buttons;
	    var pressedTimes = this._buttonPresses || (this._buttonPresses = []);
	    var now = Date.now();
	    var ray = this._ray; //assumes already updated to current frame pose
	    for (var i = 0; i < buttons.length; i++) {
	      if (buttons[i].pressed !== !!pressedTimes[i]) {
	        if (this.isPointing) {
	          this.notifyWorld('rayPointerAction', {
	            ray: ray,
	            type: buttons[i].pressed ? 'mousedown' : 'mouseup',
	            button: i
	          });
	          if (pressedTimes[i] && !buttons[i].pressed && now - pressedTimes[i] <= CLICK_MAX_DUR) {
	            this.notifyWorld('rayPointerAction', {
	              ray: ray,
	              type: 'click',
	              button: i
	            });
	          }
	        }
	        pressedTimes[i] = buttons[i].pressed ? now : null;
	      }
	      pressedTimes.length = buttons.length;
	    }

	    // Handle axis inputs
	    var axes = gamepad.axes;
	    for (var i$1 = 0; i$1 < axes.length; i$1 += 2) {
	      // Map each pair of axes to wheel event deltaX/Y
	      // TODO investigate better mapping
	      var deltaX = (axes[i$1] || 0) * 10;
	      var deltaY = (axes[i$1 + 1] || 0) * 10;
	      if (Math.hypot(deltaX, deltaY) > 0.1) {
	        if (this.isPointing) {
	          this.notifyWorld('rayPointerAction', {
	            ray: ray,
	            type: 'wheel',
	            deltaX: deltaX,
	            deltaY: deltaY,
	            deltaMode: 0 //pixel mode
	          });
	        }
	      }
	    }
	  };

	  XRInputSourceFacade.prototype._onSessionEvent = function _onSessionEvent (e) {
	    if (e.inputSource === this.xrInputSource) {
	      // Redispatch select and squeeze events as standard pointer events to the world's event system.
	      // Note this is only used for non xr-standard gamepad inputs, otherwise it's handled in the
	      // gamepad button state tracking.
	      var button = /^squeeze/.test(e.type) ? BUTTON_SQUEEZE : BUTTON_TRIGGER;
	      this.notifyWorld('rayPointerAction', {
	        ray: this._ray,
	        type: /start$/.test(e.type) ? 'mousedown' : 'mouseup',
	        button: button
	      });
	      // If this was an "end" event, then we'll also want to fire a click event after the mouseup.
	      // This is a workaround for the fact that WebXR fires 'select' then 'selectend', which doesn't
	      // match with standard DOM mouse events which go 'mouseup' then 'click', and can lead to
	      // unexpected behaviors in downstram code that assumes the standard order.
	      if (/end$/.test(e.type)) {
	        this.notifyWorld('rayPointerAction', {
	          ray: this._ray,
	          type: 'click',
	          button: button
	        });
	      }
	    }
	  };

	  XRInputSourceFacade.prototype._onSceneRayEvent = function _onSceneRayEvent (e) {
	    var this$1 = this;

	    // Only handle events where this was the ray's source
	    if (e.nativeEvent.eventSource === this) {
	      var ref = this.xrInputSource;
	      var gamepad = ref.gamepad;
	      var targetRayMode = ref.targetRayMode;

	      // Copy intersection info to local state and update subtree
	      this.rayIntersection = e.intersection;
	      this.afterUpdate();

	      // If haptics available, trigger a pulse
	      if (gamepad) {
	        var isScene = e.target === e.currentTarget;
	        var hapticPulse = e.type === 'click' ? HAPTICS.click
	          : (e.type === 'mouseover' && !isScene) ? HAPTICS.mouseover
	          : null;
	        if (hapticPulse) {
	          var hapticActuator = gamepad.hapticActuators && gamepad.hapticActuators[0];
	          if (hapticActuator) {
	            hapticActuator.pulse(hapticPulse.value || 1, hapticPulse.duration || 100);
	          }
	        }
	      }

	      // For gamepad buttons and select/squeeze session events, dispatch custom xr-specific
	      // events to the raycasted target facade:
	      var defaultPrevented = e.defaultPrevented;
	      var fireEvent = function (type) {
	        if (type) {
	          var customEvent = new Event(type, {bubbles: true});
	          customEvent.eventSource = this$1;
	          e.target.dispatchEvent(customEvent);
	          defaultPrevented = defaultPrevented || customEvent.defaultPrevented;
	        }
	      };
	      //TODO: fireEvent(RAY_TARGET_EVENTS.all[e.type]) //all buttons
	      fireEvent(RAY_TARGET_EVENTS[e.button] && RAY_TARGET_EVENTS[e.button][e.type]); //special select/squeeze

	      // Default gamepad button mapping to exit the XR session; authors can override this
	      // to use that button for other things by calling `preventDefault()`
	      if (!defaultPrevented && e.type === 'click' && e.button === BUTTON_DEFAULT_BACK) {
	        this.notifyWorld('endXRSession');
	      }

	      // Check physical proximity to trigger a click when poking an object
	      if (targetRayMode === 'tracked-pointer' && this.clickOnPoke) {
	        this._checkPokeGesture(e);
	      }
	    }
	  };

	  XRInputSourceFacade.prototype._checkPokeGesture = function _checkPokeGesture (e) {
	    var DEBOUNCE = 500;
	    var RAY_DISTANCE = 0.1; //slight buffer
	    var intersection = e.intersection;
	    var target = e.target;
	    var pokeState = this._pokeState || (this._pokeState = {target: null, isPoking: false, time: 0});
	    var isPoking = !!intersection && intersection.distance < RAY_DISTANCE;
	    if (isPoking && (!pokeState.isPoking || target !== pokeState.target) && Date.now() - pokeState.time > DEBOUNCE) {
	      pokeState.time = Date.now();
	      this.notifyWorld('rayPointerAction', {
	        ray: e.ray,
	        type: 'click',
	        button: BUTTON_TRIGGER
	      });
	    }
	    pokeState.isPoking = isPoking;
	    pokeState.target = target;
	  };

	  XRInputSourceFacade.prototype.destructor = function destructor () {
	    toggleEvents(this.xrSession, false, XRSESSION_EVENTS, this._onSessionEvent);
	    toggleEvents(this.getSceneFacade(), false, SCENE_EVENTS, this._onSceneRayEvent);
	    Group3DFacade.prototype.destructor.call(this);
	  };

	  return XRInputSourceFacade;
	}(Group3DFacade));

	// this.onXrFrame = null //timestamp, XRFrame
	// this.onIntersectionEvent = null //???
	// this.onSelectStart = null
	// this.onSelect = null
	// this.onSelectEnd = null
	// this.onSqueezeStart = null
	// this.onSqueeze = null
	// this.onSqueezeEnd = null
	// this.onButtonTouchStart = null
	// this.onButtonPressStart = null
	// this.onButtonPress = null
	// this.onButtonPressEnd = null
	// this.onButtonTouchEnd = null


	// Define some custom xr-specific events that will be dispatched to the target Object3DFacade
	// intersecting the ray at the time of a button action:
	var RAY_TARGET_EVENTS = {};
	RAY_TARGET_EVENTS[BUTTON_TRIGGER] = {
	    mousedown: 'xrselectstart',
	    mouseup: 'xrselectend',
	    click: 'xrselect'
	  };
	RAY_TARGET_EVENTS[BUTTON_SQUEEZE] = {
	    mousedown: 'xrsqueezestart',
	    mouseup: 'xrsqueezeend',
	    click: 'xrsqueeze'
	  };

	// ...and add shortcut event handler properties on Object3DFacade for those events:
	Facade.defineEventProperty(Object3DFacade, 'onXRSelectStart', 'xrselectstart');
	Facade.defineEventProperty(Object3DFacade, 'onXRSelect', 'xrselect');
	Facade.defineEventProperty(Object3DFacade, 'onXRSelectEnd', 'xrselectend');
	Facade.defineEventProperty(Object3DFacade, 'onXRSqueezeStart', 'xrsqueezestart');
	Facade.defineEventProperty(Object3DFacade, 'onXRSqueeze', 'xrsqueeze');
	Facade.defineEventProperty(Object3DFacade, 'onXRSqueezeEnd', 'xrsqueezeend');

	/*

	Additive or replace?


	{
	  key: 'primaryTool',
	  facade: XRInputSourceAnchored,
	  selector: xrInputSource => (
	    xrInputSource.targetRayMode === 'tracked-pointer' &&
	    xrInputSource.handedness === prefs.handedness
	  ),
	  referenceSpace: 'grip'
	},
	{
	  key: 'xrInputDefaultGrips',
	  facade: XRInputVendorGrips
	},
	{
	  facade: TrackedPointerXRInputSource,
	  matches: (xrInputSource, allSources) => (
	    xrInputSource.handedness === 'left'
	  ),

	  onSelectStart: e => {},
	  onSelect: e => {},
	  onSelectEnd: e => {},
	  onSqueezeStart: e => {},
	  onSqueeze: e => {},
	  onSqueezeEnd: e => {},

	  onButtonDown: e => {},
	  onButtonClick: e => {},
	  onButtonUp: e => {},
	  onAxisChange: e => {},

	  targetRay: true,
	  targetRay: {facade: MyCustomLaser},
	  targetRay: {color: 0x33ff33},
	  cursor: true,
	  cursor: {facade: MyCustomCursor},
	  cursor: {color: 0xff0000},
	  grip: true,
	  grip: {facade: PlatformGripModel},
	  grip: {
	    facade: Group3DFacade,
	    children: [{
	      key: 'main',
	      facade: PlatformGripModel
	    }, {
	      key: 'ui',
	      facade: GripTabletFacade,
	      visible: state.
	    }]
	  }
	}



	{
	  facade: XRInputSourceConfig,
	  configs: [
	    {
	      match: src => src.targetRayMode === 'tracked-pointer' && src.handedness === 'left'
	    }
	  ]
	}



	---

	For each XRInputSource:
	  - Resolve a XRInputSourceFacade
	    - based on...?
	  - Find objects in scene matching the XRInputSource
	    - based on: targetRayMode, handedness, profiles, ...?
	    - if none found, supply a default set



	*/



	/**
	 * A container facade, placed at the root of the scene, that manages the tracking of
	 * `XRInputSource`s and the rendering of their related scene objects.
	 *
	 *
	 */
	var XRInputSourceManager = /*@__PURE__*/(function (ParentFacade) {
	  function XRInputSourceManager(parent) {
	    var this$1 = this;

	    ParentFacade.call(this, parent);
	    this._sourcesDirty = true;

	    // Required props:
	    this.xrSession = null;
	    this.xrReferenceSpace = null;

	    // Separate subtree for the XRInputSourceFacade instances:
	    this._xrInputSourceSubtree = new ParentFacade(this);

	    this._onInputSourcesChange = function (e) {
	      this$1._sourcesDirty = true;
	      this$1.afterUpdate();
	    };
	  }

	  if ( ParentFacade ) XRInputSourceManager.__proto__ = ParentFacade;
	  XRInputSourceManager.prototype = Object.create( ParentFacade && ParentFacade.prototype );
	  XRInputSourceManager.prototype.constructor = XRInputSourceManager;

	  XRInputSourceManager.prototype.afterUpdate = function afterUpdate () {
	    var this$1 = this;

	    var ref = this;
	    var xrSession = ref.xrSession;
	    var _lastXrSession = ref._lastXrSession;

	    if (xrSession !== _lastXrSession) {
	      this._lastXrSession = xrSession;
	      if (_lastXrSession) {
	        _lastXrSession.removeEventListener('inputsourceschange', this._onInputSourcesChange);
	      }
	      if (xrSession) {
	        xrSession.addEventListener('inputsourceschange', this._onInputSourcesChange);
	      }
	    }

	    if (this._sourcesDirty) {
	      this._sourcesDirty = false;
	      var inputSources = xrSession && xrSession.inputSources;
	      this._xrInputSourceSubtree.children = inputSources && Array.from(inputSources).map(function (xrInputSource) {
	        // TODO resolve config overrides?
	        return {
	          facade: XRInputSourceFacade,
	          key: getIdForObject(xrInputSource),
	          xrInputSource: xrInputSource,
	          xrSession: this$1.xrSession,
	          xrReferenceSpace: this$1.xrReferenceSpace
	        }
	      });
	      this._xrInputSourceSubtree.afterUpdate();
	    }
	    ParentFacade.prototype.afterUpdate.call(this);
	  };

	  XRInputSourceManager.prototype.destructor = function destructor () {
	    if (this.xrSession) {
	      this.xrSession.removeEventListener('inputsourceschange', this._onInputSourcesChange);
	    }
	    ParentFacade.prototype.destructor.call(this);
	    this._xrInputSourceSubtree.destructor();
	  };

	  return XRInputSourceManager;
	}(ParentFacade));

	var tempVec3$2 = new Vector3();
	var tempVec3b = new Vector3();
	var tempQuat$2 = new Quaternion();
	var dummyObj = {};
	var tempMat4$1 = new Matrix4();

	function extendAsXRCamera (BaseCameraFacadeClass) {
	  return doExtendAsXRCamera(BaseCameraFacadeClass || PerspectiveCamera3DFacade)
	}

	var doExtendAsXRCamera = createClassExtender('xrCamera', function (BaseCameraFacadeClass) {
	  return /*@__PURE__*/(function (BaseCameraFacadeClass) {
	    function XRCameraFacade (parent) {
	      BaseCameraFacadeClass.call(this, parent);

	      // Required props
	      this.xrSession = null;
	      this.xrReferenceSpace = null;

	      // This will behave like an ArrayCamera with a sub-camera for each view.
	      // The individual view cameras will be created as needed based on the xrFrame's pose views.
	      var mainCam = this.threeObject;
	      mainCam.isArrayCamera = true;
	      mainCam.cameras = [];

	      // Expose the camera's configured position/orientation as an offset XRReferenceSpace.
	      this.offsetReferenceSpace = null;

	      // Update cameras on every render frame
	      this.addEventListener('xrframe', this._onXrFrame.bind(this));
	    }

	    if ( BaseCameraFacadeClass ) XRCameraFacade.__proto__ = BaseCameraFacadeClass;
	    XRCameraFacade.prototype = Object.create( BaseCameraFacadeClass && BaseCameraFacadeClass.prototype );
	    XRCameraFacade.prototype.constructor = XRCameraFacade;

	    XRCameraFacade.prototype.afterUpdate = function afterUpdate () {
	      var ref = this;
	      var near = ref.near;
	      var far = ref.far;
	      var xrSession = ref.xrSession;
	      ref.xrReferenceSpace;
	      ref.threeObject;

	      // Update near/far planes
	      var ref$1 = xrSession.renderState;
	      var depthNear = ref$1.depthNear;
	      var depthFar = ref$1.depthFar;
	      if (near !== depthNear || far !== depthFar) {
	        xrSession.updateRenderState({
	          depthNear: near,
	          depthFar: far
	        });
	      }

	      BaseCameraFacadeClass.prototype.afterUpdate.call(this);
	    };

	    XRCameraFacade.prototype.updateMatrices = function updateMatrices () {
	      // Update offsetReferenceSpace to match configured camera position/rotation
	      // TODO test if this reacts to reset events properly
	      var ref = this;
	      var xrReferenceSpace = ref.xrReferenceSpace;
	      var offsetChanging = this._matrixChanged || xrReferenceSpace !== this._lastRefSpace;
	      BaseCameraFacadeClass.prototype.updateMatrices.call(this);
	      if (offsetChanging) {
	        this._lastRefSpace = xrReferenceSpace;
	        invertMatrix4(this.threeObject.matrix, tempMat4$1).decompose(tempVec3$2, tempQuat$2, dummyObj);
	        this.offsetReferenceSpace = xrReferenceSpace
	          ? xrReferenceSpace.getOffsetReferenceSpace(new XRRigidTransform(tempVec3$2, tempQuat$2))
	          : null;
	      }
	    };

	    /**
	     * Handle syncing the cameras to the current XRFrame's pose data
	     */
	    XRCameraFacade.prototype._onXrFrame = function _onXrFrame (timestamp, xrFrame) {
	      var ref = this;
	      var xrSession = ref.xrSession;
	      var offsetReferenceSpace = ref.offsetReferenceSpace;
	      var mainCam = ref.threeObject;
	      var pose = offsetReferenceSpace && xrFrame.getViewerPose(offsetReferenceSpace);

	      if (pose && xrSession && xrSession.renderState.baseLayer) {
	        var views = pose.views;
	        var viewCameras = mainCam.cameras;

	        // Remove extra cameras if the count is decreasing
	        while (viewCameras.length > views.length) {
	          mainCam.layers.disable(viewCameras.length--);
	        }

	        // Update each eye view
	        for (var i = 0; i < views.length; i++) {
	          var view = views[i];
	          var viewCam = viewCameras[i];

	          // Create the view's sub-camera if needed
	          if (!viewCam) {
	            viewCam = viewCameras[i] = new PerspectiveCamera();
	            viewCam.viewport = new Vector4();
	            // Match the ThreeJS convention of layer masks per eye
	            viewCam.layers.enable(i + 1);
	            mainCam.layers.enable(i + 1);
	          }

	          // Update the sub-camera viewport and matrices to match the view
	          var viewport = xrSession.renderState.baseLayer.getViewport(view);
	          viewCam.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
	          viewCam.matrixWorld.fromArray(view.transform.matrix);
	          viewCam.matrixWorldInverse.fromArray(view.transform.inverse.matrix);
	          viewCam.projectionMatrix.fromArray(view.projectionMatrix);
	        }

	        // We also need to make the main camera match an overall pose/projection for use in
	        // frustum culling etc. For now let's just copy the first view's data.
	        // TODO this isn't good enough for the frustum, it results in overaggressive culling from the right eye.
	        //  Should use a combined frustum once available from API (https://github.com/w3c/webvr/issues/203)
	        //  or calculate it ourselves like ThreeJS does with WebVRUtils.setProjectionFromUnion
	        if (views.length === 2) {
	          setProjectionFromUnion(mainCam, viewCameras[0], viewCameras[1]);
	        }
	      }
	    };

	    return XRCameraFacade;
	  }(BaseCameraFacadeClass))
	});

	/**
	 * NOTE: mostly copied from private function in ThreeJS's WebXRManager at
	 * https://github.com/mrdoob/three.js/blob/f43ec7c849d7cecbc4831d152cf6a5d97c45ad3b/src/renderers/webxr/WebXRManager.js#L281
	 *
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion (camera, cameraL, cameraR) {

	  tempVec3$2.setFromMatrixPosition(cameraL.matrixWorld);
	  tempVec3b.setFromMatrixPosition(cameraR.matrixWorld);

	  var ipd = tempVec3$2.distanceTo(tempVec3b);

	  var projL = cameraL.projectionMatrix.elements;
	  var projR = cameraR.projectionMatrix.elements;

	  // VR systems will have identical far and near planes, and
	  // most likely identical top and bottom frustum extents.
	  // Use the left camera for these values.
	  var near = projL[14] / (projL[10] - 1);
	  var far = projL[14] / (projL[10] + 1);
	  var topFov = (projL[9] + 1) / projL[5];
	  var bottomFov = (projL[9] - 1) / projL[5];

	  var leftFov = (projL[8] - 1) / projL[0];
	  var rightFov = (projR[8] + 1) / projR[0];
	  var left = near * leftFov;
	  var right = near * rightFov;

	  // Calculate the new camera's position offset from the
	  // left camera. xOffset should be roughly half `ipd`.
	  var zOffset = ipd / (-leftFov + rightFov);
	  var xOffset = zOffset * -leftFov;

	  // TODO: Better way to apply this offset?
	  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
	  camera.translateX(xOffset);
	  camera.translateZ(zOffset);
	  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
	  invertMatrix4(camera.matrixWorld, camera.matrixWorldInverse);

	  // Find the union of the frustum values of the cameras and scale
	  // the values so that the near plane's position does not change in world space,
	  // although must now be relative to the new union camera.
	  var near2 = near + zOffset;
	  var far2 = far + zOffset;
	  var left2 = left - xOffset;
	  var right2 = right + (ipd - xOffset);
	  var top2 = topFov * far / far2 * near2;
	  var bottom2 = bottomFov * far / far2 * near2;

	  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
	}

	var emptyArray = [];
	var tempVec2$1 = new Vector2();

	var _xrSessions = new WeakMap();


	var WorldXRFacade = /*@__PURE__*/(function (World3DFacade) {
	  function WorldXRFacade () {
	    World3DFacade.apply(this, arguments);
	  }

	  if ( World3DFacade ) WorldXRFacade.__proto__ = World3DFacade;
	  WorldXRFacade.prototype = Object.create( World3DFacade && World3DFacade.prototype );
	  WorldXRFacade.prototype.constructor = WorldXRFacade;

	  WorldXRFacade.prototype.afterUpdate = function afterUpdate () {
	    var this$1 = this;

	    // Disable pointer events on the onscreen canvas when in an immersive XR session
	    this._togglePointerListeners(!this._isImmersive());

	    World3DFacade.prototype.afterUpdate.call(this);

	    var ref = this;
	    var xrSession = ref.xrSession;
	    var renderer = ref._threeRenderer;

	    var prevXrSession = _xrSessions.get(this);
	    if (xrSession !== prevXrSession) {
	      _xrSessions.set(this, xrSession);
	      this.renderingScheduler = xrSession || window;
	      setAnimationScheduler(xrSession || window);
	      if (xrSession) {
	        var baseLayer = xrSession.renderState.baseLayer;
	        var gl = renderer.getContext();

	        // If the session has an existing valid XRWebGLLayer, just grab its framebuffer.
	        // Otherwise, create a new XRWebGLLayer
	        if (baseLayer && baseLayer._glContext === gl) {
	          bindFramebuffer(renderer, baseLayer.framebuffer);
	        } else {
	          var promise = gl.makeXRCompatible ? gl.makeXRCompatible() : Promise.resolve(); //not always implemented?
	          promise.then(function () {
	            if (this$1.xrSession === xrSession) {
	              baseLayer = new XRWebGLLayer(xrSession, gl, {
	                antialias: !!renderer.getContextAttributes().antialias,
	                framebufferScaleFactor: parseFramebufferScaleFactor(this$1.xrFramebufferScaleFactor, xrSession)
	              });
	              baseLayer._glContext = gl;
	              xrSession.updateRenderState({ baseLayer: baseLayer });
	              bindFramebuffer(renderer, baseLayer.framebuffer);
	              this$1._queueRender();
	            }
	          });
	        }
	      } else {
	        bindFramebuffer(renderer, null);
	        renderer.setRenderTarget(renderer.getRenderTarget()); //see https://github.com/mrdoob/three.js/pull/15830
	        // reset canvas/viewport size in case something changed it (cough cough polyfill)
	        renderer.getSize(tempVec2$1);
	        renderer.setDrawingBufferSize(tempVec2$1.x, tempVec2$1.y, renderer.getPixelRatio());
	        this._queueRender();
	      }
	    }
	  };

	  /**
	   * @override
	   */
	  WorldXRFacade.prototype.doRender = function doRender (timestamp, xrFrame) {
	    // Invoke xrframe event handlers
	    if (xrFrame && xrFrame.session) {
	      this.eventRegistry.forEachListenerOfType('xrframe', function (fn) { return fn(timestamp, xrFrame); }, this);
	    }

	    World3DFacade.prototype.doRender.call(this);
	  };

	  WorldXRFacade.prototype._isOpaque = function _isOpaque () { //TODO???
	    return this.xrSession && this.xrSession.environmentBlendMode === 'opaque'
	  };

	  WorldXRFacade.prototype._isImmersive = function _isImmersive () {
	    return this.xrSession && this.xrSessionMode !== 'inline'
	  };

	  /**
	   * @override to use an XR stereo camera when in immersive XR mode
	   */
	  WorldXRFacade.prototype._getCameraDef = function _getCameraDef () {
	    var camera = World3DFacade.prototype._getCameraDef.call(this);
	    if (this._isImmersive()) {
	      camera.facade = extendAsXRCamera(camera.facade);
	      camera.xrSession = this.xrSession;
	      camera.xrReferenceSpace = this.xrReferenceSpace;
	    }
	    return camera
	  };

	  /**
	   * @override to add VR controllers manager object
	   */
	  WorldXRFacade.prototype._getSceneDef = function _getSceneDef () {
	    var scene = World3DFacade.prototype._getSceneDef.call(this);
	    var ref = this;
	    var xrSession = ref.xrSession;
	    var xrReferenceSpace = ref.xrReferenceSpace;
	    if (xrSession && xrReferenceSpace) {
	      scene.objects = emptyArray.concat(
	        scene.objects,
	        {
	          key: 'xrInputMgr',
	          facade: XRInputSourceManager,
	          xrSession: xrSession,
	          xrReferenceSpace: xrReferenceSpace
	        }
	      );
	    }
	    return scene
	  };

	  /**
	   * @override to always continuously render when in XR
	   */
	  WorldXRFacade.prototype._isContinuousRender = function _isContinuousRender () {
	    return this.xrSession || this.continuousRender
	  };

	  /**
	   * @override to skip rendering HTML overlays when in immersive mode
	   */
	  WorldXRFacade.prototype._doRenderHtmlItems = function _doRenderHtmlItems () {
	    if (this._isImmersive()) {
	      if (this.renderHtmlItems) {
	        this.renderHtmlItems(emptyArray);
	      }
	    } else {
	      World3DFacade.prototype._doRenderHtmlItems.call(this);
	    }
	  };

	  return WorldXRFacade;
	}(World3DFacade));

	WorldXRFacade.prototype._notifyWorldHandlers = Object.create(
	  World3DFacade.prototype._notifyWorldHandlers,
	  {
	    // notification to end the XR session
	    endXRSession: {
	      value: function(source, data) {
	        if (this.xrSession) {
	          this.xrSession.end();
	        }
	      }
	    }
	  }
	);

	function parseFramebufferScaleFactor(value, xrSession) {
	  var scale = 1;
	  if (value != null) {
	    if (typeof value === 'string') {
	      if (/native/.test(value)) {
	        var mult = +value.replace(/\s*native\s*/, '') || 1;
	        var nativeScale = XRWebGLLayer.getNativeFramebufferScaleFactor(xrSession);
	        scale = nativeScale * mult;
	      }
	    } else {
	      scale = +value;
	    }
	    if (isNaN(scale)) { scale = 1; }
	  }
	  //console.info(`WebXR: using framebufferScaleFactor ${scale}`)
	  return scale
	}

	// Smooth out r127 framebuffer state refactor
	function bindFramebuffer(renderer, framebuffer) {
	  if (renderer.setFramebuffer) { //pre-r127
	    renderer.setFramebuffer(framebuffer);
	  } else {
	    renderer.state.bindXRFramebuffer(framebuffer);
	  }
	}

	var SESSION_MODES = ['inline', 'immersive-vr']; //TODO add others as they are added to the specs
	var REFERENCE_SPACE_TYPES = ['viewer', 'local', 'local-floor', 'bounded-floor', 'unbounded'];


	/**
	 * The types of the props that are passed down to the wrapped React component
	 */
	({
	  xrSupported: propTypes.bool,
	  xrSupportedSessionModes: propTypes.arrayOf(propTypes.oneOf(SESSION_MODES)),
	  xrSession: propTypes.object,
	  xrSessionMode: propTypes.oneOf(SESSION_MODES),
	  xrReferenceSpace: propTypes.object,
	  xrReferenceSpaceType: propTypes.oneOf(REFERENCE_SPACE_TYPES),
	  xrLauncher: propTypes.element
	});


	/**
	 * Wraps a React component class/function in a higher-order component which enables support
	 * for WebXR. The wrapper handles querying the browser for supported XR session types,
	 * initiating a supported XR session, and upgrading any descendant `Canvas3D` components
	 * with support for rendering XR stereo views and handling XR input controllers.
	 *
	 *
	 *
	 * @param {class|function} ReactClass
	 * @param {object} options
	 * @param {React.Component} options.xrLauncherRenderer - The React component to use for
	 *        rendering the launcher button. Defaults to a basic launcher button implementation.
	 * @param {string[]} options.sessionModes - The XRSessionMode(s) supported by this particular scene.
	 *        Assumes an 'immersive-vr' experience only by default. Authors can add 'inline' as a
	 *        fallback, or force 'inline' only.
	 *        TODO: allow secondary mode to be chosen by the user, rather than just as a fallback?
	 * @param {string[]} options.referenceSpaces - The XRReferenceSpaceType(s) supported by this particular scene.
	 *        By default a floor-relative space is required, preferring 'bounded-floor', falling
	 *        back to 'local-floor', and failing session initialization if neither is available or
	 *        permitted by the user. Authors can change this list to support other reference space
	 *        types as fallbacks. All but the final will be used as `optionalFeatures`, and the final
	 *        will be used for `requiredFeatures`.
	 *        TODO: allow secondary spaces to be chosen by the user, rather than just as a fallback?
	 *        TODO: allow different spaces to be specified for immersive-vr vs. local modes?
	 * @param {number|string} options.framebufferScaleFactor - Scaling factor for the XR framebuffer.
	 *        A number is used directly as the WebGLLayer's `framebufferScaleFactor` parameter. The
	 *        string "native" uses the device's native resolution. A string containing "native" and
	 *        a number, e.g. "0.5 native", uses the device's native resolution multiplied by that
	 *        number. Defaults to `1` per the WebXR spec.
	 *        TODO: allow 'auto' adaptive scaling to maintain frame rate
	 *        TODO: allow changing this value on the fly
	 * @return {class}
	 */
	function ReactXRAware(ReactClass, options) {
	  options = assign({
	    xrLauncherRenderer: XRLauncher,
	    sessionModes: ['immersive-vr'],
	    referenceSpaces: ['bounded-floor', 'local-floor'],
	    framebufferScaleFactor: 1
	  }, options);

	  var XRAware = /*@__PURE__*/(function (superclass) {
	    function XRAware(props) {
	      var this$1 = this;

	      superclass.call(this, props);

	      this.state = {
	        xrSupportedSessionModes: [],
	        xrSession: null,
	        xrSessionMode: null,
	        xrReferenceSpace: null,
	        xrReferenceSpaceType: null
	      }

	      // bind handler methods:
	      ;[
	        '_checkXrSupport',
	        '_onSessionEnded',
	        '_onLauncherSelect'
	      ].forEach(function (method) {
	        this$1[method] = this$1[method].bind(this$1);
	      });

	      var xr = navigator.xr;
	      if (xr) {
	        xr.addEventListener('devicechange', this._checkXrSupport);
	      }
	      this._checkXrSupport();
	    }

	    if ( superclass ) XRAware.__proto__ = superclass;
	    XRAware.prototype = Object.create( superclass && superclass.prototype );
	    XRAware.prototype.constructor = XRAware;

	    XRAware.prototype.componentWillUnmount = function componentWillUnmount () {
	      var xr = navigator.xr;
	      if (xr) {
	        xr.removeEventListener('devicechange', this._checkXrSupport);
	      }
	    };

	    XRAware.prototype._checkXrSupport = function _checkXrSupport () {
	      var this$1 = this;

	      var xr = navigator.xr;
	      if (xr) {
	        var xrSupportedSessionModes = [];
	        Promise.all(options.sessionModes.map(function (mode) {
	          if (typeof xr.isSessionSupported === 'function') {
	            return xr.isSessionSupported(mode)
	              .then(function (supported) {
	                if (supported) {
	                  xrSupportedSessionModes.push(mode);
	                } else {
	                  console.info(("XR session type '" + mode + "' not supported"));
	                }
	              })
	          } else {
	            // TODO remove this fallback for slightly old API impls...
	            return xr.supportsSession(mode)
	              .then(function () {
	                xrSupportedSessionModes.push(mode);
	              }, function (err) {
	                console.info(("XR session type '" + mode + "' not supported"), err);
	              })
	          }
	        })).then(function () {
	          this$1.setState({xrSupportedSessionModes: xrSupportedSessionModes});
	        });
	      } else {
	        this.setState({
	          xrSupportedSessionModes: []
	        });
	      }
	    };

	    XRAware.prototype._startSession = function _startSession (xrSessionMode) {
	      var this$1 = this;

	      var ref = this.state;
	      var xrSupportedSessionModes = ref.xrSupportedSessionModes;
	      var xrSession = ref.xrSession;

	      // Stop current session if running
	      // TODO not sure if this is a potential race condition, but we can't wait for its promise
	      //  to resolve because that fails the "user activation" requirement for starting the new session.
	      //  We may want to make the selection UI require first ending a session before being able to select a new one.
	      if (xrSession) {
	        xrSession.end();
	      }

	      if (xrSupportedSessionModes.includes(xrSessionMode)) {
	        var candidateRefSpaces = options.referenceSpaces;
	        if (!candidateRefSpaces || !candidateRefSpaces.length) {
	          console.error('XRAware `referencesSpaces` cannot be empty');
	          return
	        }

	        navigator.xr.requestSession(xrSessionMode, {
	          optionalFeatures: candidateRefSpaces.slice(0, -1),
	          requiredFeatures: candidateRefSpaces.slice(-1)
	        })
	          .then(function (xrSession) {
	            xrSession.addEventListener('end', this$1._onSessionEnded, false);

	            // Get the first XRReferenceSpace supported by the hardware
	            var getRefSpace = function (index) {
	              if ( index === void 0 ) index=0;

	              var type = candidateRefSpaces[index];
	              return xrSession.requestReferenceSpace(type)
	                .then(function (xrReferenceSpace) { return [xrReferenceSpace, type]; })
	                .catch(function (err) {
	                  console.debug(("Reference space " + type + " not supported or denied by user."), err);
	                  if (index + 1 === candidateRefSpaces.length) {
	                    throw new Error(("All requested referenceSpaces (" + (candidateRefSpaces.join(', ')) + ") are either unsupported or were denied by the user."))
	                  } else {
	                    return getRefSpace(index + 1)
	                  }
	                })
	            };
	            return getRefSpace().then(function (ref) {
	              var xrReferenceSpace = ref[0];
	              var xrReferenceSpaceType = ref[1];

	              this$1.setState({
	                xrSession: xrSession,
	                xrSessionMode: xrSessionMode,
	                xrReferenceSpace: xrReferenceSpace,
	                xrReferenceSpaceType: xrReferenceSpaceType
	              });
	            })
	          })
	          .catch(function (err) {
	            console.error(err);
	            //TODO supply for user feedback... this.setState({xrSessionError: err})
	          });
	      }
	    };

	    XRAware.prototype._onSessionEnded = function _onSessionEnded (e) {
	      e.session.removeEventListener('end', this._onSessionEnded, false);
	      this.setState({
	        xrSession: null,
	        xrSessionMode: null,
	        xrReferenceSpace: null,
	        xrReferenceSpaceType: null
	      });
	    };

	    XRAware.prototype._onLauncherSelect = function _onLauncherSelect (mode) {
	      // TODO this fails due to user activation requirement
	      // if (!mode || mode !== this.state.xrSessionMode) {
	      //   this._stopSession().then(() => {
	      //     if (mode) {
	      //       this._startSession(mode)
	      //     }
	      //   })
	      // } else {
	        this._startSession(mode);
	      //}
	    };

	    XRAware.prototype.render = function render () {
	      var ref = this;
	      var props = ref.props;
	      var state = ref.state;
	      var xrSupportedSessionModes = state.xrSupportedSessionModes;
	      var xrSession = state.xrSession;
	      var xrSessionMode = state.xrSessionMode;
	      var xrReferenceSpace = state.xrReferenceSpace;
	      var xrReferenceSpaceType = state.xrReferenceSpaceType;
	      var xrSupported = xrSupportedSessionModes.length > 0;

	      var xrLauncher = react.createElement(
	        options.xrLauncherRenderer,
	        {
	          xrSupportedSessionModes: xrSupportedSessionModes,
	          xrSupported: xrSupported,
	          xrSession: xrSession,
	          onSelectSession: this._onLauncherSelect
	        }
	      );

	      var contextValue = {
	        worldFacade: WorldXRFacade,
	        worldProps: {
	          xrSession: xrSession,
	          xrSessionMode: xrSessionMode,
	          xrReferenceSpace: xrReferenceSpace,
	          xrReferenceSpaceType: xrReferenceSpaceType,
	          xrFramebufferScaleFactor: options.framebufferScaleFactor
	        }
	      };

	      return react.createElement(Canvas3D.contextType.Provider, {value: contextValue},
	        react.createElement(
	          ReactClass,
	          assign({}, props, {
	            xrSupported: xrSupported,
	            xrSupportedSessionModes: xrSupportedSessionModes,
	            xrSession: xrSession,
	            xrSessionMode: xrSessionMode,
	            xrReferenceSpace: xrReferenceSpace,
	            xrReferenceSpaceType: xrReferenceSpaceType,
	            xrLauncher: xrLauncher
	          }),
	          props.children
	        )
	      )
	    };

	    return XRAware;
	  }(react.Component));

	  XRAware.displayName = "XRAware(" + (ReactClass.displayName || ReactClass.name || '?') + ")";

	  return XRAware
	}

	var BOX_SIZE = 40;

	var geometry = new BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE);
	var material = new MeshPhongMaterial({
	  color: 0x003300,
	  opacity: 0.6,
	  side: DoubleSide,
	  transparent: true
	});

	var Box = /*@__PURE__*/(function (Object3DFacade) {
	  function Box () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Box.__proto__ = Object3DFacade;
	  Box.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Box.prototype.constructor = Box;

	  Box.prototype.initThreeObject = function initThreeObject () {
	    return new Mesh(geometry, material)
	  };

	  return Box;
	}(Object3DFacade));

	var geometry$1 = new SphereGeometry(1);
	var material$1 = new MeshPhongMaterial({
	  color: 0x993333
	});

	var Dot = /*@__PURE__*/(function (Object3DFacade) {
	  function Dot () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Dot.__proto__ = Object3DFacade;
	  Dot.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Dot.prototype.constructor = Dot;

	  Dot.prototype.initThreeObject = function initThreeObject () {
	    return new Mesh(geometry$1, material$1)
	  };

	  return Dot;
	}(Object3DFacade));

	var Glow = /*@__PURE__*/(function (Object3DFacade) {
	  function Glow(parent) {
	    Object3DFacade.call(this, parent, new Mesh(
	      parent.threeObject.geometry,
	      new MeshBasicMaterial({
	        color: 0xffffff,
	        opacity: 0,
	        side: BackSide,
	        transparent: true
	      })
	    ));
	  }

	  if ( Object3DFacade ) Glow.__proto__ = Object3DFacade;
	  Glow.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Glow.prototype.constructor = Glow;

	  var prototypeAccessors = { amount: { configurable: true },opacity: { configurable: true } };

	  prototypeAccessors.amount.set = function (val) {
	    if (val !== this._amount) {
	      this.scaleX = this.scaleY = this.scaleZ = 1 + val;
	      this._amount = val;
	    }
	  };
	  prototypeAccessors.amount.get = function () {
	    return this._amount
	  };

	  prototypeAccessors.opacity.set = function (o) {
	    this.threeObject.material.opacity = o;
	  };
	  prototypeAccessors.opacity.get = function () {
	    return this.threeObject.material.opacity
	  };

	  Object.defineProperties( Glow.prototype, prototypeAccessors );

	  return Glow;
	}(Object3DFacade));

	var HtmlOverlaysExample = /*@__PURE__*/(function (superclass) {
	  function HtmlOverlaysExample(props) {
	    superclass.call(this, props);
	    this.state = {
	      hoveredBox: null
	    };
	    this._onBoxMouseOver = this._onBoxMouseOver.bind(this);
	    this._onBoxMouseOut = this._onBoxMouseOut.bind(this);
	  }

	  if ( superclass ) HtmlOverlaysExample.__proto__ = superclass;
	  HtmlOverlaysExample.prototype = Object.create( superclass && superclass.prototype );
	  HtmlOverlaysExample.prototype.constructor = HtmlOverlaysExample;

	  HtmlOverlaysExample.prototype._onBoxMouseOver = function _onBoxMouseOver (e) {
	    this.setState({hoveredBox: e.target.id});
	  };

	  HtmlOverlaysExample.prototype._onBoxMouseOut = function _onBoxMouseOut () {
	    this.setState({hoveredBox: null});
	  };

	  HtmlOverlaysExample.prototype.render = function render () {
	    var this$1 = this;

	    var state = this.state;
	    var ref = this.props;
	    var width = ref.width;
	    var height = ref.height;
	    var paused = typeof state.hoveredBox === 'number';

	    return (
	      react.createElement( 'div', null, 
	        react.createElement( 'style', { type: "text/css" }, "@import url(\"html-overlays/styles.css\")"), 

	        react.createElement( Canvas3D, {
	          antialias: true, stats: this.props.stats, width: width, height: height, lights: [
	            { type: 'ambient', color: 0x666666 },
	            { type: 'point', color: 0xffffff, x: 1000, z: 1000 },
	            { type: 'point', color: 0xffffff, x: -1000, z: 1000 } ], camera: {
	            z: 400,
	          }, objects: {
	            key: 'main',
	            facade: Group3DFacade,
	            children: {
	              key: 'boxes',
	              facade: Group3DFacade,
	              children: ['One', 'Two', 'Three', 'Four', 'Five', 'Six'].map(function (num, i, arr) {
	                var angle = Math.PI * 2 * i / arr.length;
	                return {
	                  key: i,
	                  facade: Box,
	                  id: i,
	                  x: Math.cos(angle) * 100,
	                  y: Math.sin(angle) * 100,
	                  rotateZ: angle,
	                  animation: {
	                    from: {rotateX: 0},
	                    to: {rotateX: Math.PI},
	                    duration: 3000,
	                    delay: i * 200,
	                    easing: 'easeInOutCubic',
	                    direction: 'alternate',
	                    iterations: Infinity,
	                    paused: i === state.hoveredBox
	                  },
	                  onMouseOver: this$1._onBoxMouseOver,
	                  onMouseOut: this$1._onBoxMouseOut,
	                  children: [
	                    {
	                      key: 'dot',
	                      facade: Dot,
	                      x: 20,
	                      y: 20,
	                      z: 20
	                    },
	                    {
	                      key: 'glow',
	                      facade: Glow,
	                      color: 0xffffff,
	                      opacity: 0,
	                      amount: i === state.hoveredBox ? .05 : 0,
	                      transition: {amount: true, opacity: true},
	                      animation: i === state.hoveredBox ? {
	                        from: {opacity: 0.5},
	                        to: {opacity: 1},
	                        duration: 500,
	                        iterations: Infinity,
	                        direction: 'alternate'
	                      } : 0
	                    },
	                    {
	                      key: 'html',
	                      facade: HtmlOverlay3DFacade,
	                      x: 20,
	                      y: 20,
	                      z: 20,
	                      html: (
	                        react.createElement( 'div', { className: "tip" }, "Object Number ", num
	                        )
	                      )
	                    }
	                  ]
	                }
	              }),
	              animation: {
	                from: {rotateZ: 0},
	                to: {rotateZ: Math.PI * 2},
	                duration: 6000,
	                easing: 'easeInOutCubic',
	                direction: 'alternate',
	                iterations: Infinity,
	                paused: paused
	              }
	            },
	            animation: {
	              from: {rotateY: 0},
	              to: {rotateY: Math.PI * 2},
	              duration: 10000,
	              iterations: Infinity,
	              paused: paused
	            }
	          } }), 

	        react.createElement( 'div', { className: "example_desc" }, 
	          react.createElement( 'p', null, "This example uses the ", react.createElement( 'b', null, "HtmlOverlay" ), " facade to define tooltips that are anchored to a corner of each box. Their HTML contents are rendered into the DOM, fully styleable, and synchronized to the position of their anchor point in the 3D world as projected to the camera. Also demonstrated: nested animations with pausing and a glow effect on hover." )
	        )
	      )
	    )
	  };

	  return HtmlOverlaysExample;
	}(react.Component));

	HtmlOverlaysExample.propTypes = {
	  width: propTypes.number,
	  height: propTypes.number
	};

	/**
	 * Lightweight thenable implementation that is entirely self-contained within a single
	 * function with no external dependencies so it can be easily shipped across to a WorkerModule.
	 *
	 * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate
	 * with other thenable implementations. https://github.com/promises-aplus/promises-spec
	 *
	 * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not
	 * have the same constructor signature and does not expose a `catch` method or the static
	 * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable
	 * instance off to consuming code that may expect a true Promise, you'll want to wrap it
	 * in a native-or-polyfilled Promise first.
	 *
	 * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like
	 * thing that was (a) wrapped in a single function for easy serialization across to a Worker,
	 * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest
	 * implementation I've found. And also, exercises like this are challenging and fun.)
	 */
	function BespokeThenable() {
	  var state = 0; // 0=pending, 1=fulfilled, -1=rejected
	  var queue = [];
	  var value;
	  var scheduled = 0;
	  var completeCalled = 0;

	  function then(onResolve, onReject) {
	    var nextThenable = BespokeThenable();

	    function handleNext() {
	      var cb = state > 0 ? onResolve : onReject;
	      if (isFn(cb)) {
	        try {
	          var result = cb(value);
	          if (result === nextThenable) {
	            recursiveError();
	          }
	          var resultThen = getThenableThen(result);
	          if (resultThen) {
	            resultThen.call(result, nextThenable.resolve, nextThenable.reject);
	          } else {
	            nextThenable.resolve(result);
	          }
	        } catch (err) {
	          nextThenable.reject(err);
	        }
	      } else {
	        nextThenable[state > 0 ? 'resolve' : 'reject'](value);
	      }
	    }

	    queue.push(handleNext);
	    if (state) {
	      scheduleQueueFlush();
	    }
	    return nextThenable
	  }

	  var resolve = oneTime(function (val) {
	    if (!completeCalled) {
	      complete(1, val);
	    }
	  });

	  var reject = oneTime(function (reason) {
	    if (!completeCalled) {
	      complete(-1, reason);
	    }
	  });

	  function complete(st, val) {
	    completeCalled++;
	    var ignoreThrow = 0;
	    try {
	      if (val === thenableObj) {
	        recursiveError();
	      }
	      var valThen = st > 0 && getThenableThen(val);
	      if (valThen) {
	        valThen.call(val, oneTime(function (v) {
	          ignoreThrow++;
	          complete(1, v);
	        }), oneTime(function (v) {
	          ignoreThrow++;
	          complete(-1, v);
	        }));
	      } else {
	        state = st;
	        value = val;
	        scheduleQueueFlush();
	      }
	    } catch(e) {
	      if (!state && !ignoreThrow) {
	        complete(-1, e);
	      }
	    }
	  }

	  function scheduleQueueFlush() {
	    if (!scheduled) {
	      setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?
	      scheduled = 1;
	    }
	  }

	  function flushQueue() {
	    var q = queue;
	    scheduled = 0;
	    queue = [];
	    q.forEach(callIt);
	  }

	  function callIt(fn) {
	    fn();
	  }

	  function getThenableThen(val) {
	    var valThen = val && (isFn(val) || typeof val === 'object') && val.then;
	    return isFn(valThen) && valThen
	  }

	  function oneTime(fn) {
	    var called = 0;
	    return function() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      if (!called++) {
	        fn.apply(this, args);
	      }
	    }
	  }

	  function recursiveError() {
	    throw new TypeError('Chaining cycle detected')
	  }

	  var isFn = function (v) { return typeof v === 'function'; };

	  var thenableObj = {
	    then: then,
	    resolve: resolve,
	    reject: reject
	  };
	  return thenableObj
	}


	/**
	 * Thenable implementation that uses a native Promise under the covers. This implementation
	 * is preferred if Promise is available, for better performance and dev tools integration.
	 * @constructor
	 */
	function NativePromiseThenable() {
	  var resolve, reject;
	  var promise = new Promise(function (res, rej) {
	    resolve = res;
	    reject = rej;
	  });
	  return {
	    then: promise.then.bind(promise),
	    resolve: resolve,
	    reject: reject
	  }
	}

	/**
	 * Promise.all() impl:
	 */
	BespokeThenable.all = NativePromiseThenable.all = function(items) {
	  var resultCount = 0;
	  var results = [];
	  var out = DefaultThenable();
	  if (items.length === 0) {
	    out.resolve([]);
	  } else {
	    items.forEach(function (item, i) {
	      var itemThenable = DefaultThenable();
	      itemThenable.resolve(item);
	      itemThenable.then(function (res) {
	        resultCount++;
	        results[i] = res;
	        if (resultCount === items.length) {
	          out.resolve(results);
	        }
	      }, out.reject);
	    });
	  }
	  return out
	};


	/**
	 * Choose the best Thenable implementation and export it as the default.
	 */
	var DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;

	/**
	 * Main content for the worker that handles the loading and execution of
	 * modules within it.
	 */
	function workerBootstrap() {
	  var modules = Object.create(null);

	  // Handle messages for registering a module
	  function registerModule(ref, callback) {
	    var id = ref.id;
	    var name = ref.name;
	    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];
	    var init = ref.init; if ( init === void 0 ) init = function(){};
	    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;

	    // Only register once
	    if (modules[id]) { return }

	    try {
	      // If any dependencies are modules, ensure they're registered and grab their value
	      dependencies = dependencies.map(function (dep) {
	        if (dep && dep.isWorkerModule) {
	          registerModule(dep, function (depResult) {
	            if (depResult instanceof Error) { throw depResult }
	          });
	          dep = modules[dep.id].value;
	        }
	        return dep
	      });

	      // Rehydrate functions
	      init = rehydrate(("<" + name + ">.init"), init);
	      if (getTransferables) {
	        getTransferables = rehydrate(("<" + name + ">.getTransferables"), getTransferables);
	      }

	      // Initialize the module and store its value
	      var value = null;
	      if (typeof init === 'function') {
	        value = init.apply(void 0, dependencies);
	      } else {
	        console.error('worker module init function failed to rehydrate');
	      }
	      modules[id] = {
	        id: id,
	        value: value,
	        getTransferables: getTransferables
	      };
	      callback(value);
	    } catch(err) {
	      if (!(err && err.noLog)) {
	        console.error(err);
	      }
	      callback(err);
	    }
	  }

	  // Handle messages for calling a registered module's result function
	  function callModule(ref, callback) {
	    var ref$1;

	    var id = ref.id;
	    var args = ref.args;
	    if (!modules[id] || typeof modules[id].value !== 'function') {
	      callback(new Error(("Worker module " + id + ": not found or its 'init' did not return a function")));
	    }
	    try {
	      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
	      if (result && typeof result.then === 'function') {
	        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });
	      } else {
	        handleResult(result);
	      }
	    } catch(err) {
	      callback(err);
	    }
	    function handleResult(result) {
	      try {
	        var tx = modules[id].getTransferables && modules[id].getTransferables(result);
	        if (!tx || !Array.isArray(tx) || !tx.length) {
	          tx = undefined; //postMessage is very picky about not passing null or empty transferables
	        }
	        callback(result, tx);
	      } catch(err) {
	        console.error(err);
	        callback(err);
	      }
	    }
	  }

	  function rehydrate(name, str) {
	    var result = void 0;
	    self.troikaDefine = function (r) { return result = r; };
	    var url = URL.createObjectURL(
	      new Blob(
	        [("/** " + (name.replace(/\*/g, '')) + " **/\n\ntroikaDefine(\n" + str + "\n)")],
	        {type: 'application/javascript'}
	      )
	    );
	    try {
	      importScripts(url);
	    } catch(err) {
	      console.error(err);
	    }
	    URL.revokeObjectURL(url);
	    delete self.troikaDefine;
	    return result
	  }

	  // Handler for all messages within the worker
	  self.addEventListener('message', function (e) {
	    var ref = e.data;
	    var messageId = ref.messageId;
	    var action = ref.action;
	    var data = ref.data;
	    try {
	      // Module registration
	      if (action === 'registerModule') {
	        registerModule(data, function (result) {
	          if (result instanceof Error) {
	            postMessage({
	              messageId: messageId,
	              success: false,
	              error: result.message
	            });
	          } else {
	            postMessage({
	              messageId: messageId,
	              success: true,
	              result: {isCallable: typeof result === 'function'}
	            });
	          }
	        });
	      }
	      // Invocation
	      if (action === 'callModule') {
	        callModule(data, function (result, transferables) {
	          if (result instanceof Error) {
	            postMessage({
	              messageId: messageId,
	              success: false,
	              error: result.message
	            });
	          } else {
	            postMessage({
	              messageId: messageId,
	              success: true,
	              result: result
	            }, transferables || undefined);
	          }
	        });
	      }
	    } catch(err) {
	      postMessage({
	        messageId: messageId,
	        success: false,
	        error: err.stack
	      });
	    }
	  });
	}

	/**
	 * Fallback for `defineWorkerModule` that behaves identically but runs in the main
	 * thread, for when the execution environment doesn't support web workers or they
	 * are disallowed due to e.g. CSP security restrictions.
	 */
	function defineMainThreadModule(options) {
	  var moduleFunc = function() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return moduleFunc._getInitResult().then(function (initResult) {
	      if (typeof initResult === 'function') {
	        return initResult.apply(void 0, args)
	      } else {
	        throw new Error('Worker module function was called but `init` did not return a callable function')
	      }
	    })
	  };
	  moduleFunc._getInitResult = function() {
	    // We can ignore getTransferables in main thread. TODO workerId?
	    var dependencies = options.dependencies;
	    var init = options.init;

	    // Resolve dependencies
	    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }
	    ) : [];

	    // Invoke init with the resolved dependencies
	    var initThenable = DefaultThenable.all(dependencies).then(function (deps) {
	      return init.apply(null, deps)
	    });

	    // Cache the resolved promise for subsequent calls
	    moduleFunc._getInitResult = function () { return initThenable; };

	    return initThenable
	  };
	  return moduleFunc
	}

	var supportsWorkers = function () {
	  var supported = false;

	  // Only attempt worker initialization in browsers; elsewhere it would just be
	  // noise e.g. loading into a Node environment for SSR.
	  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
	    try {
	      // TODO additional checks for things like importScripts within the worker?
	      //  Would need to be an async check.
	      var worker = new Worker(
	        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))
	      );
	      worker.terminate();
	      supported = true;
	    } catch (err) {
	      if (typeof process !== 'undefined' && "production" === 'test') ; else {
	        console.log(
	          ("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + (err.message) + "]")
	        );
	      }
	    }
	  }

	  // Cached result
	  supportsWorkers = function () { return supported; };
	  return supported
	};

	var _workerModuleId = 0;
	var _messageId = 0;
	var _allowInitAsString = false;
	var workers = Object.create(null);
	var openRequests = /*#__PURE__*/(function () {
	  var obj = Object.create(null);
	  obj._count = 0;
	  return obj
	})();


	/**
	 * Define a module of code that will be executed with a web worker. This provides a simple
	 * interface for moving chunks of logic off the main thread, and managing their dependencies
	 * among one another.
	 *
	 * @param {object} options
	 * @param {function} options.init
	 * @param {array} [options.dependencies]
	 * @param {function} [options.getTransferables]
	 * @param {string} [options.name]
	 * @param {string} [options.workerId]
	 * @return {function(...[*]): {then}}
	 */
	function defineWorkerModule(options) {
	  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {
	    throw new Error('requires `options.init` function')
	  }
	  var dependencies = options.dependencies;
	  var init = options.init;
	  var getTransferables = options.getTransferables;
	  var workerId = options.workerId;

	  if (!supportsWorkers()) {
	    return defineMainThreadModule(options)
	  }

	  if (workerId == null) {
	    workerId = '#default';
	  }
	  var id = "workerModule" + (++_workerModuleId);
	  var name = options.name || id;
	  var registrationThenable = null;

	  dependencies = dependencies && dependencies.map(function (dep) {
	    // Wrap raw functions as worker modules with no dependencies
	    if (typeof dep === 'function' && !dep.workerModuleData) {
	      _allowInitAsString = true;
	      dep = defineWorkerModule({
	        workerId: workerId,
	        name: ("<" + name + "> function dependency: " + (dep.name)),
	        init: ("function(){return (\n" + (stringifyFunction(dep)) + "\n)}")
	      });
	      _allowInitAsString = false;
	    }
	    // Grab postable data for worker modules
	    if (dep && dep.workerModuleData) {
	      dep = dep.workerModuleData;
	    }
	    return dep
	  });

	  function moduleFunc() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    // Register this module if needed
	    if (!registrationThenable) {
	      registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);
	    }

	    // Invoke the module, returning a thenable
	    return registrationThenable.then(function (ref) {
	      var isCallable = ref.isCallable;

	      if (isCallable) {
	        return callWorker(workerId,'callModule', {id: id, args: args})
	      } else {
	        throw new Error('Worker module function was called but `init` did not return a callable function')
	      }
	    })
	  }
	  moduleFunc.workerModuleData = {
	    isWorkerModule: true,
	    id: id,
	    name: name,
	    dependencies: dependencies,
	    init: stringifyFunction(init),
	    getTransferables: getTransferables && stringifyFunction(getTransferables)
	  };
	  return moduleFunc
	}

	/**
	 * Stringifies a function into a form that can be deserialized in the worker
	 * @param fn
	 */
	function stringifyFunction(fn) {
	  var str = fn.toString();
	  // If it was defined in object method/property format, it needs to be modified
	  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
	    str = 'function ' + str;
	  }
	  return str
	}


	function getWorker(workerId) {
	  var worker = workers[workerId];
	  if (!worker) {
	    // Bootstrap the worker's content
	    var bootstrap = stringifyFunction(workerBootstrap);

	    // Create the worker from the bootstrap function content
	    worker = workers[workerId] = new Worker(
	      URL.createObjectURL(
	        new Blob(
	          [("/** Worker Module Bootstrap: " + (workerId.replace(/\*/g, '')) + " **/\n\n;(" + bootstrap + ")()")],
	          {type: 'application/javascript'}
	        )
	      )
	    );

	    // Single handler for response messages from the worker
	    worker.onmessage = function (e) {
	      var response = e.data;
	      var msgId = response.messageId;
	      var callback = openRequests[msgId];
	      if (!callback) {
	        throw new Error('WorkerModule response with empty or unknown messageId')
	      }
	      delete openRequests[msgId];
	      openRequests._count--;
	      callback(response);
	    };
	  }
	  return worker
	}

	// Issue a call to the worker with a callback to handle the response
	function callWorker(workerId, action, data) {
	  var thenable = DefaultThenable();
	  var messageId = ++_messageId;
	  openRequests[messageId] = function (response) {
	    if (response.success) {
	      thenable.resolve(response.result);
	    } else {
	      thenable.reject(new Error(("Error in worker " + action + " call: " + (response.error))));
	    }
	  };
	  openRequests._count++;
	  if (openRequests._count > 1000) { //detect leaks
	    console.warn('Large number of open WorkerModule requests, some may not be returning');
	  }
	  getWorker(workerId).postMessage({
	    messageId: messageId,
	    action: action,
	    data: data
	  });
	  return thenable
	}

	/**
	 * Just the {@link Thenable} function wrapped as a worker module. If another worker
	 * module needs Thenable as a dependency, it's better to pass this module rather than
	 * the raw function in its `dependencies` array so it only gets registered once.
	 */
	var ThenableWorkerModule = /*#__PURE__*/defineWorkerModule({
	  name: 'Thenable',
	  dependencies: [DefaultThenable],
	  init: function(Thenable) {
	    return Thenable
	  }
	});

	/**
	 * Initializes and returns a function to generate an SDF texture for a given glyph.
	 * @param {function} createGlyphSegmentsIndex - factory for a GlyphSegmentsIndex implementation.
	 * @param {number} config.sdfExponent
	 * @param {number} config.sdfMargin
	 *
	 * @return {function(Object): {renderingBounds: [minX, minY, maxX, maxY], textureData: Uint8Array}}
	 */
	function createSDFGenerator(createGlyphSegmentsIndex, config) {
	  var sdfExponent = config.sdfExponent;
	  var sdfMargin = config.sdfMargin;

	  /**
	   * How many straight line segments to use when approximating a glyph's quadratic/cubic bezier curves.
	   */
	  var CURVE_POINTS = 16;

	  /**
	   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]
	   */
	  function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t) {
	    var t2 = 1 - t;
	    return {
	      x: t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2,
	      y: t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2
	    }
	  }

	  /**
	   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]
	   */
	  function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t) {
	    var t2 = 1 - t;
	    return {
	      x: t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3,
	      y: t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3
	    }
	  }

	  /**
	   * Generate an SDF texture segment for a single glyph.
	   * @param {object} glyphObj
	   * @param {number} sdfSize - the length of one side of the SDF image.
	   *        Larger images encode more details. Must be a power of 2.
	   * @return {{textureData: Uint8Array, renderingBounds: *[]}}
	   */
	  function generateSDF(glyphObj, sdfSize) {
	    //console.time('glyphSDF')

	    var textureData = new Uint8Array(sdfSize * sdfSize);

	    // Determine mapping between glyph grid coords and sdf grid coords
	    var glyphW = glyphObj.xMax - glyphObj.xMin;
	    var glyphH = glyphObj.yMax - glyphObj.yMin;

	    // Choose a maximum search distance radius in font units, based on the glyph's max dimensions
	    var fontUnitsMaxSearchDist = Math.max(glyphW, glyphH);

	    // Margin - add an extra 0.5 over the configured value because the outer 0.5 doesn't contain
	    // useful interpolated values and will be ignored anyway.
	    var fontUnitsMargin = Math.max(glyphW, glyphH) / sdfSize * (sdfMargin * sdfSize + 0.5);

	    // Metrics of the texture/quad in font units
	    var textureMinFontX = glyphObj.xMin - fontUnitsMargin;
	    var textureMinFontY = glyphObj.yMin - fontUnitsMargin;
	    var textureMaxFontX = glyphObj.xMax + fontUnitsMargin;
	    var textureMaxFontY = glyphObj.yMax + fontUnitsMargin;
	    var fontUnitsTextureWidth = textureMaxFontX - textureMinFontX;
	    var fontUnitsTextureHeight = textureMaxFontY - textureMinFontY;
	    var fontUnitsTextureMaxDim = Math.max(fontUnitsTextureWidth, fontUnitsTextureHeight);

	    function textureXToFontX(x) {
	      return textureMinFontX + fontUnitsTextureWidth * x / sdfSize
	    }

	    function textureYToFontY(y) {
	      return textureMinFontY + fontUnitsTextureHeight * y / sdfSize
	    }

	    if (glyphObj.pathCommandCount) { //whitespace chars will have no commands, so we can skip all this
	      // Decompose all paths into straight line segments and add them to a quadtree
	      var lineSegmentsIndex = createGlyphSegmentsIndex(glyphObj);
	      var firstX, firstY, prevX, prevY;
	      glyphObj.forEachPathCommand(function (type, x0, y0, x1, y1, x2, y2) {
	        switch (type) {
	          case 'M':
	            prevX = firstX = x0;
	            prevY = firstY = y0;
	            break
	          case 'L':
	            if (x0 !== prevX || y0 !== prevY) { //yup, some fonts have zero-length line commands
	              lineSegmentsIndex.addLineSegment(prevX, prevY, (prevX = x0), (prevY = y0));
	            }
	            break
	          case 'Q': {
	            var prevPoint = {x: prevX, y: prevY};
	            for (var i = 1; i < CURVE_POINTS; i++) {
	              var nextPoint = pointOnQuadraticBezier(
	                prevX, prevY,
	                x0, y0,
	                x1, y1,
	                i / (CURVE_POINTS - 1)
	              );
	              lineSegmentsIndex.addLineSegment(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);
	              prevPoint = nextPoint;
	            }
	            prevX = x1;
	            prevY = y1;
	            break
	          }
	          case 'C': {
	            var prevPoint$1 = {x: prevX, y: prevY};
	            for (var i$1 = 1; i$1 < CURVE_POINTS; i$1++) {
	              var nextPoint$1 = pointOnCubicBezier(
	                prevX, prevY,
	                x0, y0,
	                x1, y1,
	                x2, y2,
	                i$1 / (CURVE_POINTS - 1)
	              );
	              lineSegmentsIndex.addLineSegment(prevPoint$1.x, prevPoint$1.y, nextPoint$1.x, nextPoint$1.y);
	              prevPoint$1 = nextPoint$1;
	            }
	            prevX = x2;
	            prevY = y2;
	            break
	          }
	          case 'Z':
	            if (prevX !== firstX || prevY !== firstY) {
	              lineSegmentsIndex.addLineSegment(prevX, prevY, firstX, firstY);
	            }
	            break
	        }
	      });

	      // For each target SDF texel, find the distance from its center to its nearest line segment,
	      // map that distance to an alpha value, and write that alpha to the texel
	      for (var sdfX = 0; sdfX < sdfSize; sdfX++) {
	        for (var sdfY = 0; sdfY < sdfSize; sdfY++) {
	          var signedDist = lineSegmentsIndex.findNearestSignedDistance(
	            textureXToFontX(sdfX + 0.5),
	            textureYToFontY(sdfY + 0.5),
	            fontUnitsMaxSearchDist
	          );

	          // Use an exponential scale to ensure the texels very near the glyph path have adequate
	          // precision, while allowing the distance field to cover the entire texture, given that
	          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam
	          var alpha = Math.pow((1 - Math.abs(signedDist) / fontUnitsTextureMaxDim), sdfExponent) / 2;
	          if (signedDist < 0) {
	            alpha = 1 - alpha;
	          }

	          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp
	          textureData[sdfY * sdfSize + sdfX] = alpha;
	        }
	      }
	    }

	    //console.timeEnd('glyphSDF')

	    return {
	      textureData: textureData,

	      renderingBounds: [
	        textureMinFontX,
	        textureMinFontY,
	        textureMaxFontX,
	        textureMaxFontY
	      ]
	    }
	  }


	  return generateSDF
	}

	/**
	 * Creates a self-contained environment for processing text rendering requests.
	 *
	 * It is important that this function has no closure dependencies, so that it can be easily injected
	 * into the source for a Worker without requiring a build step or complex dependency loading. All its
	 * dependencies must be passed in at initialization.
	 *
	 * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns
	 * a standardized structure giving access to the font and its glyphs:
	 *   {
	 *     unitsPerEm: number,
	 *     ascender: number,
	 *     descender: number,
	 *     forEachGlyph(string, fontSize, letterSpacing, callback) {
	 *       //invokes callback for each glyph to render, passing it an object:
	 *       callback({
	 *         index: number,
	 *         advanceWidth: number,
	 *         xMin: number,
	 *         yMin: number,
	 *         xMax: number,
	 *         yMax: number,
	 *         pathCommandCount: number,
	 *         forEachPathCommand(callback) {
	 *           //invokes callback for each path command, with args:
	 *           callback(
	 *             type: 'M|L|C|Q|Z',
	 *             ...args //0 to 6 args depending on the type
	 *           )
	 *         }
	 *       })
	 *     }
	 *   }
	 * @param {function} sdfGenerator - a function that accepts a glyph object and generates an SDF texture
	 * from it.
	 * @param {Object} config
	 * @return {Object}
	 */
	function createFontProcessor(fontParser, sdfGenerator, bidi, config) {

	  var defaultFontURL = config.defaultFontURL;


	  /**
	   * @private
	   * Holds data about font glyphs and how they relate to SDF atlases
	   *
	   * {
	   *   'fontUrl@sdfSize': {
	   *     fontObj: {}, //result of the fontParser
	   *     glyphs: {
	   *       [glyphIndex]: {
	   *         atlasIndex: 0,
	   *         glyphObj: {}, //glyph object from the fontParser
	   *         renderingBounds: [x0, y0, x1, y1]
	   *       },
	   *       ...
	   *     },
	   *     glyphCount: 123
	   *   }
	   * }
	   */
	  var fontAtlases = Object.create(null);

	  /**
	   * Holds parsed font objects by url
	   */
	  var fonts = Object.create(null);

	  var INF = Infinity;

	  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs
	  var DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;

	  /**
	   * Load a given font url
	   */
	  function doLoadFont(url, callback) {
	    function tryLoad() {
	      var onError = function (err) {
	        console.error(("Failure loading font " + url + (url === defaultFontURL ? '' : '; trying fallback')), err);
	        if (url !== defaultFontURL) {
	          url = defaultFontURL;
	          tryLoad();
	        }
	      };
	      try {
	        var request = new XMLHttpRequest();
	        request.open('get', url, true);
	        request.responseType = 'arraybuffer';
	        request.onload = function () {
	          if (request.status >= 400) {
	            onError(new Error(request.statusText));
	          }
	          else if (request.status > 0) {
	            try {
	              var fontObj = fontParser(request.response);
	              callback(fontObj);
	            } catch (e) {
	              onError(e);
	            }
	          }
	        };
	        request.onerror = onError;
	        request.send();
	      } catch(err) {
	        onError(err);
	      }
	    }
	    tryLoad();
	  }


	  /**
	   * Load a given font url if needed, invoking a callback when it's loaded. If already
	   * loaded, the callback will be called synchronously.
	   */
	  function loadFont(fontUrl, callback) {
	    if (!fontUrl) { fontUrl = defaultFontURL; }
	    var font = fonts[fontUrl];
	    if (font) {
	      // if currently loading font, add to callbacks, otherwise execute immediately
	      if (font.pending) {
	        font.pending.push(callback);
	      } else {
	        callback(font);
	      }
	    } else {
	      fonts[fontUrl] = {pending: [callback]};
	      doLoadFont(fontUrl, function (fontObj) {
	        var callbacks = fonts[fontUrl].pending;
	        fonts[fontUrl] = fontObj;
	        callbacks.forEach(function (cb) { return cb(fontObj); });
	      });
	    }
	  }


	  /**
	   * Get the atlas data for a given font url, loading it from the network and initializing
	   * its atlas data objects if necessary.
	   */
	  function getSdfAtlas(fontUrl, sdfGlyphSize, callback) {
	    if (!fontUrl) { fontUrl = defaultFontURL; }
	    var atlasKey = fontUrl + "@" + sdfGlyphSize;
	    var atlas = fontAtlases[atlasKey];
	    if (atlas) {
	      callback(atlas);
	    } else {
	      loadFont(fontUrl, function (fontObj) {
	        atlas = fontAtlases[atlasKey] || (fontAtlases[atlasKey] = {
	          fontObj: fontObj,
	          glyphs: {},
	          glyphCount: 0
	        });
	        callback(atlas);
	      });
	    }
	  }


	  /**
	   * Main entry point.
	   * Process a text string with given font and formatting parameters, and return all info
	   * necessary to render all its glyphs.
	   */
	  function process(
	    ref,
	    callback,
	    metricsOnly
	  ) {
	    var text = ref.text; if ( text === void 0 ) text = '';
	    var font = ref.font; if ( font === void 0 ) font = defaultFontURL;
	    var sdfGlyphSize = ref.sdfGlyphSize; if ( sdfGlyphSize === void 0 ) sdfGlyphSize = 64;
	    var fontSize = ref.fontSize; if ( fontSize === void 0 ) fontSize = 1;
	    var letterSpacing = ref.letterSpacing; if ( letterSpacing === void 0 ) letterSpacing = 0;
	    var lineHeight = ref.lineHeight; if ( lineHeight === void 0 ) lineHeight = 'normal';
	    var maxWidth = ref.maxWidth; if ( maxWidth === void 0 ) maxWidth = INF;
	    var direction = ref.direction;
	    var textAlign = ref.textAlign; if ( textAlign === void 0 ) textAlign = 'left';
	    var textIndent = ref.textIndent; if ( textIndent === void 0 ) textIndent = 0;
	    var whiteSpace = ref.whiteSpace; if ( whiteSpace === void 0 ) whiteSpace = 'normal';
	    var overflowWrap = ref.overflowWrap; if ( overflowWrap === void 0 ) overflowWrap = 'normal';
	    var anchorX = ref.anchorX; if ( anchorX === void 0 ) anchorX = 0;
	    var anchorY = ref.anchorY; if ( anchorY === void 0 ) anchorY = 0;
	    var includeCaretPositions = ref.includeCaretPositions; if ( includeCaretPositions === void 0 ) includeCaretPositions = false;
	    var chunkedBoundsSize = ref.chunkedBoundsSize; if ( chunkedBoundsSize === void 0 ) chunkedBoundsSize = 8192;
	    var colorRanges = ref.colorRanges; if ( colorRanges === void 0 ) colorRanges = null;
	    if ( metricsOnly === void 0 ) metricsOnly=false;

	    var mainStart = now();
	    var timings = {total: 0, fontLoad: 0, layout: 0, sdf: {}, sdfTotal: 0};

	    // Ensure newlines are normalized
	    if (text.indexOf('\r') > -1) {
	      console.warn('FontProcessor.process: got text with \\r chars; normalizing to \\n');
	      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
	    }

	    // Ensure we've got numbers not strings
	    fontSize = +fontSize;
	    letterSpacing = +letterSpacing;
	    maxWidth = +maxWidth;
	    lineHeight = lineHeight || 'normal';
	    textIndent = +textIndent;

	    getSdfAtlas(font, sdfGlyphSize, function (atlas) {
	      var fontObj = atlas.fontObj;
	      var hasMaxWidth = isFinite(maxWidth);
	      var newGlyphs = null;
	      var glyphBounds = null;
	      var glyphAtlasIndices = null;
	      var glyphColors = null;
	      var caretPositions = null;
	      var visibleBounds = null;
	      var chunkedBounds = null;
	      var maxLineWidth = 0;
	      var renderableGlyphCount = 0;
	      var canWrap = whiteSpace !== 'nowrap';
	      var ascender = fontObj.ascender;
	      var descender = fontObj.descender;
	      var unitsPerEm = fontObj.unitsPerEm;
	      timings.fontLoad = now() - mainStart;
	      var layoutStart = now();

	      // Find conversion between native font units and fontSize units; this will already be done
	      // for the gx/gy values below but everything else we'll need to convert
	      var fontSizeMult = fontSize / unitsPerEm;

	      // Determine appropriate value for 'normal' line height based on the font's actual metrics
	      // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?
	      if (lineHeight === 'normal') {
	        lineHeight = (ascender - descender) / unitsPerEm;
	      }

	      // Determine line height and leading adjustments
	      lineHeight = lineHeight * fontSize;
	      var halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
	      var topBaseline = -(ascender * fontSizeMult + halfLeading);
	      var caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
	      var caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;

	      // Distribute glyphs into lines based on wrapping
	      var lineXOffset = textIndent;
	      var currentLine = new TextLine();
	      var lines = [currentLine];

	      fontObj.forEachGlyph(text, fontSize, letterSpacing, function (glyphObj, glyphX, charIndex) {
	        var char = text.charAt(charIndex);
	        var glyphWidth = glyphObj.advanceWidth * fontSizeMult;
	        var curLineCount = currentLine.count;
	        var nextLine;

	        // Calc isWhitespace and isEmpty once per glyphObj
	        if (!('isEmpty' in glyphObj)) {
	          glyphObj.isWhitespace = !!char && /\s/.test(char);
	          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
	        }
	        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
	          renderableGlyphCount++;
	        }

	        // If a non-whitespace character overflows the max width, we need to soft-wrap
	        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
	          // If it's the first char after a whitespace, start a new line
	          if (currentLine.glyphAt(curLineCount - 1).glyphObj.isWhitespace) {
	            nextLine = new TextLine();
	            lineXOffset = -glyphX;
	          } else {
	            // Back up looking for a whitespace character to wrap at
	            for (var i = curLineCount; i--;) {
	              // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'
	              if (i === 0 && overflowWrap === 'break-word') {
	                nextLine = new TextLine();
	                lineXOffset = -glyphX;
	                break
	              }
	              // Found a soft break point; move all chars since it to a new line
	              else if (currentLine.glyphAt(i).glyphObj.isWhitespace) {
	                nextLine = currentLine.splitAt(i + 1);
	                var adjustX = nextLine.glyphAt(0).x;
	                lineXOffset -= adjustX;
	                for (var j = nextLine.count; j--;) {
	                  nextLine.glyphAt(j).x -= adjustX;
	                }
	                break
	              }
	            }
	          }
	          if (nextLine) {
	            currentLine.isSoftWrapped = true;
	            currentLine = nextLine;
	            lines.push(currentLine);
	            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width
	          }
	        }

	        var fly = currentLine.glyphAt(currentLine.count);
	        fly.glyphObj = glyphObj;
	        fly.x = glyphX + lineXOffset;
	        fly.width = glyphWidth;
	        fly.charIndex = charIndex;

	        // Handle hard line breaks
	        if (char === '\n') {
	          currentLine = new TextLine();
	          lines.push(currentLine);
	          lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;
	        }
	      });

	      // Calculate width of each line (excluding trailing whitespace) and maximum block width
	      lines.forEach(function (line) {
	        for (var i = line.count; i--;) {
	          var ref = line.glyphAt(i);
	          var glyphObj = ref.glyphObj;
	          var x = ref.x;
	          var width = ref.width;
	          if (!glyphObj.isWhitespace) {
	            line.width = x + width;
	            if (line.width > maxLineWidth) {
	              maxLineWidth = line.width;
	            }
	            return
	          }
	        }
	      });

	      // Find overall position adjustments for anchoring
	      var anchorXOffset = 0;
	      var anchorYOffset = 0;
	      if (anchorX) {
	        if (typeof anchorX === 'number') {
	          anchorXOffset = -anchorX;
	        }
	        else if (typeof anchorX === 'string') {
	          anchorXOffset = -maxLineWidth * (
	            anchorX === 'left' ? 0 :
	            anchorX === 'center' ? 0.5 :
	            anchorX === 'right' ? 1 :
	            parsePercent(anchorX)
	          );
	        }
	      }
	      if (anchorY) {
	        if (typeof anchorY === 'number') {
	          anchorYOffset = -anchorY;
	        }
	        else if (typeof anchorY === 'string') {
	          var height = lines.length * lineHeight;
	          anchorYOffset = anchorY === 'top' ? 0 :
	            anchorY === 'top-baseline' ? -topBaseline :
	            anchorY === 'middle' ? height / 2 :
	            anchorY === 'bottom' ? height :
	            anchorY === 'bottom-baseline' ? height - halfLeading + descender * fontSizeMult :
	            parsePercent(anchorY) * height;
	        }
	      }

	      if (!metricsOnly) {
	        // Resolve bidi levels
	        var bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);

	        // Process each line, applying alignment offsets, adding each glyph to the atlas, and
	        // collecting all renderable glyphs into a single collection.
	        glyphBounds = new Float32Array(renderableGlyphCount * 4);
	        glyphAtlasIndices = new Float32Array(renderableGlyphCount);
	        visibleBounds = [INF, INF, -INF, -INF];
	        chunkedBounds = [];
	        var lineYOffset = topBaseline;
	        if (includeCaretPositions) {
	          caretPositions = new Float32Array(text.length * 3);
	        }
	        if (colorRanges) {
	          glyphColors = new Uint8Array(renderableGlyphCount * 3);
	        }
	        var renderableGlyphIndex = 0;
	        var prevCharIndex = -1;
	        var colorCharIndex = -1;
	        var chunk;
	        var currentColor;
	        lines.forEach(function (line, lineIndex) {
	          var lineGlyphCount = line.count;
	          var lineWidth = line.width;

	          // Ignore empty lines
	          if (lineGlyphCount > 0) {
	            // Count trailing whitespaces, we want to ignore these for certain things
	            var trailingWhitespaceCount = 0;
	            for (var i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {
	              trailingWhitespaceCount++;
	            }

	            // Apply horizontal alignment adjustments
	            var lineXOffset = 0;
	            var justifyAdjust = 0;
	            if (textAlign === 'center') {
	              lineXOffset = (maxLineWidth - lineWidth) / 2;
	            } else if (textAlign === 'right') {
	              lineXOffset = maxLineWidth - lineWidth;
	            } else if (textAlign === 'justify' && line.isSoftWrapped) {
	              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop
	              var whitespaceCount = 0;
	              for (var i$1 = lineGlyphCount - trailingWhitespaceCount; i$1--;) {
	                if (line.glyphAt(i$1).glyphObj.isWhitespace) {
	                  whitespaceCount++;
	                }
	              }
	              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
	            }
	            if (justifyAdjust || lineXOffset) {
	              var justifyOffset = 0;
	              for (var i$2 = 0; i$2 < lineGlyphCount; i$2++) {
	                var glyphInfo = line.glyphAt(i$2);
	                var glyphObj = glyphInfo.glyphObj;
	                glyphInfo.x += lineXOffset + justifyOffset;
	                // Expand non-trailing whitespaces for justify alignment
	                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i$2 < lineGlyphCount - trailingWhitespaceCount) {
	                  justifyOffset += justifyAdjust;
	                  glyphInfo.width += justifyAdjust;
	                }
	              }
	            }

	            // Perform bidi range flipping
	            var flips = bidi.getReorderSegments(
	              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex
	            );
	            for (var fi = 0; fi < flips.length; fi++) {
	              var ref = flips[fi];
	              var start = ref[0];
	              var end = ref[1];
	              // Map start/end string indices to indices in the line
	              var left = Infinity, right = -Infinity;
	              for (var i$3 = 0; i$3 < lineGlyphCount; i$3++) {
	                if (line.glyphAt(i$3).charIndex >= start) { // gte to handle removed characters
	                  var startInLine = i$3, endInLine = i$3;
	                  for (; endInLine < lineGlyphCount; endInLine++) {
	                    var info = line.glyphAt(endInLine);
	                    if (info.charIndex > end) {
	                      break
	                    }
	                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width
	                      left = Math.min(left, info.x);
	                      right = Math.max(right, info.x + info.width);
	                    }
	                  }
	                  for (var j = startInLine; j < endInLine; j++) {
	                    var glyphInfo$1 = line.glyphAt(j);
	                    glyphInfo$1.x = right - (glyphInfo$1.x + glyphInfo$1.width - left);
	                  }
	                  break
	                }
	              }
	            }

	            // Assemble final data arrays
	            var glyphObj$1;
	            var setGlyphObj = function (g) { return glyphObj$1 = g; };
	            for (var i$4 = 0; i$4 < lineGlyphCount; i$4++) {
	              var glyphInfo$2 = line.glyphAt(i$4);
	              glyphObj$1 = glyphInfo$2.glyphObj;

	              // Replace mirrored characters in rtl
	              var rtl = bidiLevelsResult.levels[glyphInfo$2.charIndex] & 1; //odd level means rtl
	              if (rtl) {
	                var mirrored = bidi.getMirroredCharacter(text[glyphInfo$2.charIndex]);
	                if (mirrored) {
	                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
	                }
	              }

	              // Add caret positions
	              if (includeCaretPositions) {
	                var ref$1 = glyphInfo$2;
	                var charIndex = ref$1.charIndex;
	                var caretLeft = glyphInfo$2.x + anchorXOffset;
	                var caretRight = glyphInfo$2.x + glyphInfo$2.width + anchorXOffset;
	                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x
	                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x
	                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y

	                // If we skipped any chars from the previous glyph (due to ligature subs), copy the
	                // previous glyph's info to those missing char indices. In the future we may try to
	                // use the font's LigatureCaretList table to get interior caret positions.
	                while (charIndex - prevCharIndex > 1) {
	                  caretPositions[(prevCharIndex + 1) * 3] = caretPositions[prevCharIndex * 3];
	                  caretPositions[(prevCharIndex + 1) * 3 + 1] = caretPositions[prevCharIndex * 3 + 1];
	                  caretPositions[(prevCharIndex + 1) * 3 + 2] = caretPositions[prevCharIndex * 3 + 2];
	                  prevCharIndex++;
	                }
	                prevCharIndex = charIndex;
	              }

	              // Track current color range
	              if (colorRanges) {
	                var ref$2 = glyphInfo$2;
	                var charIndex$1 = ref$2.charIndex;
	                while(charIndex$1 > colorCharIndex) {
	                  colorCharIndex++;
	                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
	                    currentColor = colorRanges[colorCharIndex];
	                  }
	                }
	              }

	              // Get atlas data for renderable glyphs
	              if (!glyphObj$1.isWhitespace && !glyphObj$1.isEmpty) {
	                var idx = renderableGlyphIndex++;

	                // If we haven't seen this glyph yet, generate its SDF
	                var glyphAtlasInfo = atlas.glyphs[glyphObj$1.index];
	                if (!glyphAtlasInfo) {
	                  var sdfStart = now();
	                  var glyphSDFData = sdfGenerator(glyphObj$1, sdfGlyphSize);
	                  timings.sdf[text.charAt(glyphInfo$2.charIndex)] = now() - sdfStart;

	                  // Assign this glyph the next available atlas index
	                  glyphSDFData.atlasIndex = atlas.glyphCount++;

	                  // Queue it up in the response's newGlyphs list
	                  if (!newGlyphs) { newGlyphs = []; }
	                  newGlyphs.push(glyphSDFData);

	                  // Store its metadata (not the texture) in our atlas info
	                  glyphAtlasInfo = atlas.glyphs[glyphObj$1.index] = {
	                    atlasIndex: glyphSDFData.atlasIndex,
	                    glyphObj: glyphObj$1,
	                    renderingBounds: glyphSDFData.renderingBounds
	                  };
	                }

	                // Determine final glyph quad bounds and add them to the glyphBounds array
	                var bounds = glyphAtlasInfo.renderingBounds;
	                var startIdx = idx * 4;
	                var xStart = glyphInfo$2.x + anchorXOffset;
	                var yStart = lineYOffset + anchorYOffset;
	                glyphBounds[startIdx] = xStart + bounds[0] * fontSizeMult;
	                glyphBounds[startIdx + 1] = yStart + bounds[1] * fontSizeMult;
	                glyphBounds[startIdx + 2] = xStart + bounds[2] * fontSizeMult;
	                glyphBounds[startIdx + 3] = yStart + bounds[3] * fontSizeMult;

	                // Track total visible bounds
	                var visX0 = xStart + glyphObj$1.xMin * fontSizeMult;
	                var visY0 = yStart + glyphObj$1.yMin * fontSizeMult;
	                var visX1 = xStart + glyphObj$1.xMax * fontSizeMult;
	                var visY1 = yStart + glyphObj$1.yMax * fontSizeMult;
	                if (visX0 < visibleBounds[0]) { visibleBounds[0] = visX0; }
	                if (visY0 < visibleBounds[1]) { visibleBounds[1] = visY0; }
	                if (visX1 > visibleBounds[2]) { visibleBounds[2] = visX1; }
	                if (visY1 > visibleBounds[3]) { visibleBounds[3] = visY1; }

	                // Track bounding rects for each chunk of N glyphs
	                if (idx % chunkedBoundsSize === 0) {
	                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};
	                  chunkedBounds.push(chunk);
	                }
	                chunk.end++;
	                var chunkRect = chunk.rect;
	                if (visX0 < chunkRect[0]) { chunkRect[0] = visX0; }
	                if (visY0 < chunkRect[1]) { chunkRect[1] = visY0; }
	                if (visX1 > chunkRect[2]) { chunkRect[2] = visX1; }
	                if (visY1 > chunkRect[3]) { chunkRect[3] = visY1; }

	                // Add to atlas indices array
	                glyphAtlasIndices[idx] = glyphAtlasInfo.atlasIndex;

	                // Add colors
	                if (colorRanges) {
	                  var start$1 = idx * 3;
	                  glyphColors[start$1] = currentColor >> 16 & 255;
	                  glyphColors[start$1 + 1] = currentColor >> 8 & 255;
	                  glyphColors[start$1 + 2] = currentColor & 255;
	                }
	              }
	            }
	          }

	          // Increment y offset for next line
	          lineYOffset -= lineHeight;
	        });
	      }

	      // Timing stats
	      for (var ch in timings.sdf) {
	        timings.sdfTotal += timings.sdf[ch];
	      }
	      timings.layout = now() - layoutStart - timings.sdfTotal;
	      timings.total = now() - mainStart;

	      callback({
	        glyphBounds: glyphBounds, //rendering quad bounds for each glyph [x1, y1, x2, y2]
	        glyphAtlasIndices: glyphAtlasIndices, //atlas indices for each glyph
	        caretPositions: caretPositions, //x,y of bottom of cursor position before each char, plus one after last char
	        caretHeight: caretHeight, //height of cursor from bottom to top
	        glyphColors: glyphColors, //color for each glyph, if color ranges supplied
	        chunkedBounds: chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs
	        ascender: ascender * fontSizeMult, //font ascender
	        descender: descender * fontSizeMult, //font descender
	        lineHeight: lineHeight, //computed line height
	        topBaseline: topBaseline, //y coordinate of the top line's baseline
	        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight
	          anchorXOffset,
	          anchorYOffset - lines.length * lineHeight,
	          anchorXOffset + maxLineWidth,
	          anchorYOffset
	        ],
	        visibleBounds: visibleBounds, //total bounds of visible text paths, may be larger or smaller than totalBounds
	        newGlyphSDFs: newGlyphs, //if this request included any new SDFs for the atlas, they'll be included here
	        timings: timings
	      });
	    });
	  }


	  /**
	   * For a given text string and font parameters, determine the resulting block dimensions
	   * after wrapping for the given maxWidth.
	   * @param args
	   * @param callback
	   */
	  function measure(args, callback) {
	    process(args, function (result) {
	      var ref = result.blockBounds;
	      var x0 = ref[0];
	      var y0 = ref[1];
	      var x1 = ref[2];
	      var y1 = ref[3];
	      callback({
	        width: x1 - x0,
	        height: y1 - y0
	      });
	    }, {metricsOnly: true});
	  }

	  function parsePercent(str) {
	    var match = str.match(/^([\d.]+)%$/);
	    var pct = match ? parseFloat(match[1]) : NaN;
	    return isNaN(pct) ? 0 : pct / 100
	  }

	  function now() {
	    return (self.performance || Date).now()
	  }

	  // Array-backed structure for a single line's glyphs data
	  function TextLine() {
	    this.data = [];
	  }
	  var textLineProps = ['glyphObj', 'x', 'width', 'charIndex'];
	  TextLine.prototype = {
	    width: 0,
	    isSoftWrapped: false,
	    get count() {
	      return Math.ceil(this.data.length / textLineProps.length)
	    },
	    glyphAt: function glyphAt(i) {
	      var fly = TextLine.flyweight;
	      fly.data = this.data;
	      fly.index = i;
	      return fly
	    },
	    splitAt: function splitAt(i) {
	      var newLine = new TextLine();
	      newLine.data = this.data.splice(i * textLineProps.length);
	      return newLine
	    }
	  };
	  TextLine.flyweight = textLineProps.reduce(function (obj, prop, i, all) {
	    Object.defineProperty(obj, prop, {
	      get: function get() {
	        return this.data[this.index * textLineProps.length + i]
	      },
	      set: function set(val) {
	        this.data[this.index * textLineProps.length + i] = val;
	      }
	    });
	    return obj
	  }, {data: null, index: 0});


	  return {
	    process: process,
	    measure: measure,
	    loadFont: loadFont
	  }
	}

	/**
	 * Index for performing fast spatial searches of a glyph's line segments.
	 * @return {{addLineSegment:function, findNearestSignedDistance:function}}
	 */
	function createGlyphSegmentsIndex() {
	  var needsSort = false;
	  var segments = [];

	  function sortSegments() {
	    if (needsSort) {
	      // sort by maxX, this will let us short-circuit some loops below
	      segments.sort(function(a, b) {
	        return a.maxX - b.maxX
	      });
	      needsSort = false;
	    }
	  }

	  /**
	   * Add a line segment to the index.
	   * @param x0
	   * @param y0
	   * @param x1
	   * @param y1
	   */
	  function addLineSegment(x0, y0, x1, y1) {
	    var segment = {
	      x0: x0, y0: y0, x1: x1, y1: y1,
	      minX: Math.min(x0, x1),
	      minY: Math.min(y0, y1),
	      maxX: Math.max(x0, x1),
	      maxY: Math.max(y0, y1)
	    };
	    segments.push(segment);
	    needsSort = true;
	  }

	  /**
	   * For a given x/y, search the index for the closest line segment and return
	   * its signed distance. Negative = inside, positive = outside, zero = on edge
	   * @param x
	   * @param y
	   * @returns {number}
	   */
	  function findNearestSignedDistance(x, y) {
	    sortSegments();
	    var closestDistSq = Infinity;
	    var closestDist = Infinity;

	    for (var i = segments.length; i--;) {
	      var seg = segments[i];
	      if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit
	      if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
	        var distSq = absSquareDistanceToLineSegment(x, y, seg.x0, seg.y0, seg.x1, seg.y1);
	        if (distSq < closestDistSq) {
	          closestDistSq = distSq;
	          closestDist = Math.sqrt(closestDistSq);
	        }
	      }
	    }

	    // Flip to negative distance if inside the poly
	    if (isPointInPoly(x, y)) {
	      closestDist = -closestDist;
	    }
	    return closestDist
	  }

	  // Determine whether the given point lies inside or outside the glyph. Uses a simple
	  // ray casting algorithm using a ray pointing east from the point.
	  function isPointInPoly(x, y) {
	    sortSegments();
	    var inside = false;
	    for (var i = segments.length; i--;) {
	      var seg = segments[i];
	      if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit
	      if (seg.minY < y && seg.maxY > y) {
	        var intersects = ((seg.y0 > y) !== (seg.y1 > y)) && (x < (seg.x1 - seg.x0) * (y - seg.y0) / (seg.y1 - seg.y0) + seg.x0);
	        if (intersects) {
	          inside = !inside;
	        }
	      }
	    }
	    return inside
	  }

	  // Find the absolute distance from a point to a line segment at closest approach
	  function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {
	    var ldx = lineX1 - lineX0;
	    var ldy = lineY1 - lineY0;
	    var lengthSq = ldx * ldx + ldy * ldy;
	    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
	    var dx = x - (lineX0 + t * ldx);
	    var dy = y - (lineY0 + t * ldy);
	    return dx * dx + dy * dy
	  }

	  return {
	    addLineSegment: addLineSegment,
	    findNearestSignedDistance: findNearestSignedDistance
	  }
	}

	function bidiFactory() {
	var bidi = (function (exports) {

	  // Bidi character types data, auto generated
	  var DATA = {
	    "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
	    "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
	    "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
	    "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
	    "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
	    "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
	    "B": "a,3,f+2,2v,690",
	    "S": "9,2,k",
	    "WS": "c,k,4f4,1vk+a,u,1j,335",
	    "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
	    "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
	    "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
	    "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
	    "LRO": "6ct",
	    "RLO": "6cu",
	    "LRE": "6cq",
	    "RLE": "6cr",
	    "PDF": "6cs",
	    "LRI": "6ee",
	    "RLI": "6ef",
	    "FSI": "6eg",
	    "PDI": "6eh"
	  };

	  var TYPES = {};
	  var TYPES_TO_NAMES = {};
	  TYPES.L = 1; //L is the default
	  TYPES_TO_NAMES[1] = 'L';
	  Object.keys(DATA).forEach(function (type, i) {
	    TYPES[type] = 1 << (i + 1);
	    TYPES_TO_NAMES[TYPES[type]] = type;
	  });
	  Object.freeze(TYPES);

	  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
	  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
	  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
	  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
	  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;

	  var map = null;

	  function parseData () {
	    if (!map) {
	      //const start = performance.now()
	      map = new Map();
	      var loop = function ( type ) {
	        if (DATA.hasOwnProperty(type)) {
	          var lastCode = 0;
	          DATA[type].split(',').forEach(function (range) {
	            var ref = range.split('+');
	            var skip = ref[0];
	            var step = ref[1];
	            skip = parseInt(skip, 36);
	            step = step ? parseInt(step, 36) : 0;
	            map.set(lastCode += skip, TYPES[type]);
	            for (var i = 0; i < step; i++) {
	              map.set(++lastCode, TYPES[type]);
	            }
	          });
	        }
	      };

	      for (var type in DATA) loop( type );
	      //console.log(`char types parsed in ${performance.now() - start}ms`)
	    }
	  }

	  /**
	   * @param {string} char
	   * @return {number}
	   */
	  function getBidiCharType (char) {
	    parseData();
	    return map.get(char.codePointAt(0)) || TYPES.L
	  }

	  function getBidiCharTypeName(char) {
	    return TYPES_TO_NAMES[getBidiCharType(char)]
	  }

	  // Bidi bracket pairs data, auto generated
	  var data$1 = {
	    "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
	    "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
	  };

	  /**
	   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or
	   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object
	   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.
	   * @param {string} encodedString
	   * @param {boolean} includeReverse - true if you want reverseMap in the output
	   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}
	   */
	  function parseCharacterMap (encodedString, includeReverse) {
	    var radix = 36;
	    var lastCode = 0;
	    var map = new Map();
	    var reverseMap = includeReverse && new Map();
	    var prevPair;
	    encodedString.split(',').forEach(function visit(entry) {
	      if (entry.indexOf('+') !== -1) {
	        for (var i = +entry; i--;) {
	          visit(prevPair);
	        }
	      } else {
	        prevPair = entry;
	        var ref = entry.split('>');
	        var a = ref[0];
	        var b = ref[1];
	        a = String.fromCodePoint(lastCode += parseInt(a, radix));
	        b = String.fromCodePoint(lastCode += parseInt(b, radix));
	        map.set(a, b);
	        includeReverse && reverseMap.set(b, a);
	      }
	    });
	    return { map: map, reverseMap: reverseMap }
	  }

	  var openToClose, closeToOpen, canonical;

	  function parse$1 () {
	    if (!openToClose) {
	      //const start = performance.now()
	      var ref = parseCharacterMap(data$1.pairs, true);
	      var map = ref.map;
	      var reverseMap = ref.reverseMap;
	      openToClose = map;
	      closeToOpen = reverseMap;
	      canonical = parseCharacterMap(data$1.canonical, false).map;
	      //console.log(`brackets parsed in ${performance.now() - start}ms`)
	    }
	  }

	  function openingToClosingBracket (char) {
	    parse$1();
	    return openToClose.get(char) || null
	  }

	  function closingToOpeningBracket (char) {
	    parse$1();
	    return closeToOpen.get(char) || null
	  }

	  function getCanonicalBracket (char) {
	    parse$1();
	    return canonical.get(char) || null
	  }

	  // Local type aliases
	  var TYPE_L = TYPES.L;
	  var TYPE_R = TYPES.R;
	  var TYPE_EN = TYPES.EN;
	  var TYPE_ES = TYPES.ES;
	  var TYPE_ET = TYPES.ET;
	  var TYPE_AN = TYPES.AN;
	  var TYPE_CS = TYPES.CS;
	  var TYPE_B = TYPES.B;
	  var TYPE_S = TYPES.S;
	  var TYPE_ON = TYPES.ON;
	  var TYPE_BN = TYPES.BN;
	  var TYPE_NSM = TYPES.NSM;
	  var TYPE_AL = TYPES.AL;
	  var TYPE_LRO = TYPES.LRO;
	  var TYPE_RLO = TYPES.RLO;
	  var TYPE_LRE = TYPES.LRE;
	  var TYPE_RLE = TYPES.RLE;
	  var TYPE_PDF = TYPES.PDF;
	  var TYPE_LRI = TYPES.LRI;
	  var TYPE_RLI = TYPES.RLI;
	  var TYPE_FSI = TYPES.FSI;
	  var TYPE_PDI = TYPES.PDI;

	  /**
	   * @typedef {object} GetEmbeddingLevelsResult
	   * @property {{start, end, level}[]} paragraphs
	   * @property {Uint8Array} levels
	   */

	  /**
	   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels
	   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved
	   * base embedding level.
	   *
	   * @param {string} string - The input string
	   * @param {"ltr"|"rtl"|"auto"} [baseDirection] - Use "ltr" or "rtl" to force a base paragraph direction,
	   *        otherwise a direction will be chosen automatically from each paragraph's contents.
	   * @return {GetEmbeddingLevelsResult}
	   */
	  function getEmbeddingLevels (string, baseDirection) {
	    var MAX_DEPTH = 125;

	    // Start by mapping all characters to their unicode type, as a bitmask integer
	    var charTypes = new Uint32Array(string.length);
	    for (var i = 0; i < string.length; i++) {
	      charTypes[i] = getBidiCharType(string[i]);
	    }

	    var charTypeCounts = new Map(); //will be cleared at start of each paragraph
	    function changeCharType(i, type) {
	      var oldType = charTypes[i];
	      charTypes[i] = type;
	      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
	      if (oldType & NEUTRAL_ISOLATE_TYPES) {
	        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
	      }
	      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);
	      if (type & NEUTRAL_ISOLATE_TYPES) {
	        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
	      }
	    }

	    var embedLevels = new Uint8Array(string.length);
	    var isolationPairs = new Map(); //init->pdi and pdi->init

	    // === 3.3.1 The Paragraph Level ===
	    // 3.3.1 P1: Split the text into paragraphs
	    var paragraphs = []; // [{start, end, level}, ...]
	    var paragraph = null;
	    for (var i$1 = 0; i$1 < string.length; i$1++) {
	      if (!paragraph) {
	        paragraphs.push(paragraph = {
	          start: i$1,
	          end: string.length - 1,
	          // 3.3.1 P2-P3: Determine the paragraph level
	          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)
	        });
	      }
	      if (charTypes[i$1] & TYPE_B) {
	        paragraph.end = i$1;
	        paragraph = null;
	      }
	    }

	    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
	    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };
	    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };

	    // Everything from here on will operate per paragraph.
	    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
	      paragraph = paragraphs[paraIdx];
	      var statusStack = [{
	        _level: paragraph.level,
	        _override: 0, //0=neutral, 1=L, 2=R
	        _isolate: 0 //bool
	      }];
	      var stackTop = (void 0);
	      var overflowIsolateCount = 0;
	      var overflowEmbeddingCount = 0;
	      var validIsolateCount = 0;
	      charTypeCounts.clear();

	      // === 3.3.2 Explicit Levels and Directions ===
	      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
	        var charType = charTypes[i$2];
	        stackTop = statusStack[statusStack.length - 1];

	        // Set initial counts
	        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
	        if (charType & NEUTRAL_ISOLATE_TYPES) {
	          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
	        }

	        // Explicit Embeddings: 3.3.2 X2 - X3
	        if (charType & FORMATTING_TYPES) { //prefilter all formatters
	          if (charType & (TYPE_RLE | TYPE_LRE)) {
	            embedLevels[i$2] = stackTop._level; // 5.2
	            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
	            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
	              statusStack.push({
	                _level: level,
	                _override: 0,
	                _isolate: 0
	              });
	            } else if (!overflowIsolateCount) {
	              overflowEmbeddingCount++;
	            }
	          }

	          // Explicit Overrides: 3.3.2 X4 - X5
	          else if (charType & (TYPE_RLO | TYPE_LRO)) {
	            embedLevels[i$2] = stackTop._level; // 5.2
	            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
	            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
	              statusStack.push({
	                _level: level$1,
	                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,
	                _isolate: 0
	              });
	            } else if (!overflowIsolateCount) {
	              overflowEmbeddingCount++;
	            }
	          }

	          // Isolates: 3.3.2 X5a - X5c
	          else if (charType & ISOLATE_INIT_TYPES) {
	            // X5c - FSI becomes either RLI or LRI
	            if (charType & TYPE_FSI) {
	              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
	            }

	            embedLevels[i$2] = stackTop._level;
	            if (stackTop._override) {
	              changeCharType(i$2, stackTop._override);
	            }
	            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
	            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
	              validIsolateCount++;
	              statusStack.push({
	                _level: level$2,
	                _override: 0,
	                _isolate: 1,
	                _isolInitIndex: i$2
	              });
	            } else {
	              overflowIsolateCount++;
	            }
	          }

	          // Terminating Isolates: 3.3.2 X6a
	          else if (charType & TYPE_PDI) {
	            if (overflowIsolateCount > 0) {
	              overflowIsolateCount--;
	            } else if (validIsolateCount > 0) {
	              overflowEmbeddingCount = 0;
	              while (!statusStack[statusStack.length - 1]._isolate) {
	                statusStack.pop();
	              }
	              // Add to isolation pairs bidirectional mapping:
	              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
	              if (isolInitIndex != null) {
	                isolationPairs.set(isolInitIndex, i$2);
	                isolationPairs.set(i$2, isolInitIndex);
	              }
	              statusStack.pop();
	              validIsolateCount--;
	            }
	            stackTop = statusStack[statusStack.length - 1];
	            embedLevels[i$2] = stackTop._level;
	            if (stackTop._override) {
	              changeCharType(i$2, stackTop._override);
	            }
	          }


	          // Terminating Embeddings and Overrides: 3.3.2 X7
	          else if (charType & TYPE_PDF) {
	            if (overflowIsolateCount === 0) {
	              if (overflowEmbeddingCount > 0) {
	                overflowEmbeddingCount--;
	              } else if (!stackTop._isolate && statusStack.length > 1) {
	                statusStack.pop();
	                stackTop = statusStack[statusStack.length - 1];
	              }
	            }
	            embedLevels[i$2] = stackTop._level; // 5.2
	          }

	          // End of Paragraph: 3.3.2 X8
	          else if (charType & TYPE_B) {
	            embedLevels[i$2] = paragraph.level;
	          }
	        }

	        // Non-formatting characters: 3.3.2 X6
	        else {
	          embedLevels[i$2] = stackTop._level;
	          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage
	          if (stackTop._override && charType !== TYPE_BN) {
	            changeCharType(i$2, stackTop._override);
	          }
	        }
	      }

	      // === 3.3.3 Preparations for Implicit Processing ===

	      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9
	      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to
	      // easily ignore them all from here on out.

	      // 3.3.3 X10
	      // Compute the set of isolating run sequences as specified by BD13
	      var levelRuns = [];
	      var currentRun = null;
	      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
	        var charType$1 = charTypes[i$3];
	        if (!(charType$1 & BN_LIKE_TYPES)) {
	          var lvl = embedLevels[i$3];
	          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
	          var isPDI = charType$1 === TYPE_PDI;
	          if (currentRun && lvl === currentRun._level) {
	            currentRun._end = i$3;
	            currentRun._endsWithIsolInit = isIsolInit;
	          } else {
	            levelRuns.push(currentRun = {
	              _start: i$3,
	              _end: i$3,
	              _level: lvl,
	              _startsWithPDI: isPDI,
	              _endsWithIsolInit: isIsolInit
	            });
	          }
	        }
	      }
	      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]
	      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
	        var run = levelRuns[runIdx];
	        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {
	          var seqRuns = [currentRun = run];
	          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {
	            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
	              if (levelRuns[i$4]._start === pdiIndex) {
	                seqRuns.push(currentRun = levelRuns[i$4]);
	                break
	              }
	            }
	          }
	          // build flat list of indices across all runs:
	          var seqIndices = [];
	          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
	            var run$1 = seqRuns[i$5];
	            for (var j = run$1._start; j <= run$1._end; j++) {
	              seqIndices.push(j);
	            }
	          }
	          // determine the sos/eos types:
	          var firstLevel = embedLevels[seqIndices[0]];
	          var prevLevel = paragraph.level;
	          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
	            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2
	              prevLevel = embedLevels[i$6];
	              break
	            }
	          }
	          var lastIndex = seqIndices[seqIndices.length - 1];
	          var lastLevel = embedLevels[lastIndex];
	          var nextLevel = paragraph.level;
	          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
	            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
	              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2
	                nextLevel = embedLevels[i$7];
	                break
	              }
	            }
	          }
	          isolatingRunSeqs.push({
	            _seqIndices: seqIndices,
	            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
	            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
	          });
	        }
	      }

	      // The next steps are done per isolating run sequence
	      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
	        var ref = isolatingRunSeqs[seqIdx];
	        var seqIndices$1 = ref._seqIndices;
	        var sosType = ref._sosType;
	        var eosType = ref._eosType;

	        // === 3.3.4 Resolving Weak Types ===

	        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose
	        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its
	        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.
	        if (charTypeCounts.get(TYPE_NSM)) {
	          for (var si = 0; si < seqIndices$1.length; si++) {
	            var i$8 = seqIndices$1[si];
	            if (charTypes[i$8] & TYPE_NSM) {
	              var prevType = sosType;
	              for (var sj = si - 1; sj >= 0; sj--) {
	                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN
	                  prevType = charTypes[seqIndices$1[sj]];
	                  break
	                }
	              }
	              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);
	            }
	          }
	        }

	        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)
	        // is found. If an AL is found, change the type of the European number to Arabic number.
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
	            var i$9 = seqIndices$1[si$1];
	            if (charTypes[i$9] & TYPE_EN) {
	              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
	                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
	                if (prevCharType & STRONG_TYPES) {
	                  if (prevCharType === TYPE_AL) {
	                    changeCharType(i$9, TYPE_AN);
	                  }
	                  break
	                }
	              }
	            }
	          }
	        }

	        // W3. Change all ALs to R
	        if (charTypeCounts.get(TYPE_AL)) {
	          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
	            var i$10 = seqIndices$1[si$2];
	            if (charTypes[i$10] & TYPE_AL) {
	              changeCharType(i$10, TYPE_R);
	            }
	          }
	        }

	        // W4. A single European separator between two European numbers changes to a European number. A single common
	        // separator between two numbers of the same type changes to that type.
	        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
	          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
	            var i$11 = seqIndices$1[si$3];
	            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
	              var prevType$1 = 0, nextType = 0;
	              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
	                prevType$1 = charTypes[seqIndices$1[sj$2]];
	                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2
	                  break
	                }
	              }
	              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
	                nextType = charTypes[seqIndices$1[sj$3]];
	                if (!(nextType & BN_LIKE_TYPES)) { //5.2
	                  break
	                }
	              }
	              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {
	                changeCharType(i$11, prevType$1);
	              }
	            }
	          }
	        }

	        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
	            var i$12 = seqIndices$1[si$4];
	            if (charTypes[i$12] & TYPE_EN) {
	              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {
	                changeCharType(seqIndices$1[sj$4], TYPE_EN);
	              }
	              for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && (charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES)); sj$5++) {
	                changeCharType(seqIndices$1[sj$5], TYPE_EN);
	              }
	            }
	          }
	        }

	        // W6. Otherwise, separators and terminators change to Other Neutral.
	        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
	          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
	            var i$13 = seqIndices$1[si$5];
	            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
	              changeCharType(i$13, TYPE_ON);
	              // 5.2 transform adjacent BNs too:
	              for (var sj$6 = si$5 - 1; sj$6 >= 0 && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6--) {
	                changeCharType(seqIndices$1[sj$6], TYPE_ON);
	              }
	              for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && (charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES); sj$7++) {
	                changeCharType(seqIndices$1[sj$7], TYPE_ON);
	              }
	            }
	          }
	        }

	        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)
	        // is found. If an L is found, then change the type of the European number to L.
	        // NOTE: implemented in single forward pass for efficiency
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
	            var i$14 = seqIndices$1[si$6];
	            var type = charTypes[i$14];
	            if (type & TYPE_EN) {
	              if (prevStrongType === TYPE_L) {
	                changeCharType(i$14, TYPE_L);
	              }
	            } else if (type & STRONG_TYPES) {
	              prevStrongType = type;
	            }
	          }
	        }

	        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===

	        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
	          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text
	          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional
	          // types EN and AN are treated as R.
	          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);
	          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;

	          // * Identify the bracket pairs in the current isolating run sequence according to BD16.
	          var bracketPairs = [];
	          {
	            var openerStack = [];
	            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
	              // NOTE: for any potential bracket character we also test that it still carries a NI
	              // type, as that may have been changed earlier. This doesn't seem to be explicitly
	              // called out in the spec, but is required for passage of certain tests.
	              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
	                var char = string[seqIndices$1[si$7]];
	                var oppositeBracket = (void 0);
	                // Opening bracket
	                if (openingToClosingBracket(char) !== null) {
	                  if (openerStack.length < 63) {
	                    openerStack.push({ char: char, seqIndex: si$7 });
	                  } else {
	                    break
	                  }
	                }
	                // Closing bracket
	                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
	                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
	                    var stackChar = openerStack[stackIdx].char;
	                    if (stackChar === oppositeBracket ||
	                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||
	                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char
	                    ) {
	                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
	                      openerStack.length = stackIdx; //pop the matching bracket and all following
	                      break
	                    }
	                  }
	                }
	              }
	            }
	            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });
	          }
	          // * For each bracket-pair element in the list of pairs of text positions
	          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
	            var ref$1 = bracketPairs[pairIdx];
	            var openSeqIdx = ref$1[0];
	            var closeSeqIdx = ref$1[1];
	            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.
	            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both
	            // brackets in the pair to match the embedding direction.
	            var foundStrongType = false;
	            var useStrongType = 0;
	            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
	              var i$15 = seqIndices$1[si$8];
	              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
	                foundStrongType = true;
	                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                if (lr === getEmbedDirection(i$15)) {
	                  useStrongType = lr;
	                  break
	                }
	              }
	            }
	            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test
	            // for an established context with a preceding strong type by checking backwards before the opening paired
	            // bracket until the first strong type (L, R, or sos) is found.
	            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so
	            //    set the type for both brackets in the pair to that direction.
	            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.
	            if (foundStrongType && !useStrongType) {
	              useStrongType = sosType;
	              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
	                var i$16 = seqIndices$1[si$9];
	                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
	                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  if (lr$1 !== getEmbedDirection(i$16)) {
	                    useStrongType = lr$1;
	                  } else {
	                    useStrongType = getEmbedDirection(i$16);
	                  }
	                  break
	                }
	              }
	            }
	            if (useStrongType) {
	              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
	              // * Any number of characters that had original bidirectional character type NSM prior to the application
	              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match
	              // the type of their preceding bracket.
	              if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
	                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
	                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
	                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
	                      charTypes[seqIndices$1[si$10]] = useStrongType;
	                    }
	                    break
	                  }
	                }
	              }
	              if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
	                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
	                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
	                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
	                      charTypes[seqIndices$1[si$11]] = useStrongType;
	                    }
	                    break
	                  }
	                }
	              }
	            }
	          }

	          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the
	          // same direction.
	          // N2. Any remaining NIs take the embedding direction.
	          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
	            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
	              var niRunStart = si$12, niRunEnd = si$12;
	              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L
	              for (var si2 = si$12 - 1; si2 >= 0; si2--) {
	                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
	                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs
	                } else {
	                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  break
	                }
	              }
	              var nextType$1 = eosType;
	              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
	                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
	                  niRunEnd = si2$1;
	                } else {
	                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  break
	                }
	              }
	              for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
	                charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
	              }
	              si$12 = niRunEnd;
	            }
	          }
	        }
	      }

	      // === 3.3.6 Resolving Implicit Levels ===

	      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
	        var level$3 = embedLevels[i$17];
	        var type$1 = charTypes[i$17];
	        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.
	        if (level$3 & 1) {
	          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
	            embedLevels[i$17]++;
	          }
	        }
	          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level
	        // and those of type AN or EN go up two levels.
	        else {
	          if (type$1 & TYPE_R) {
	            embedLevels[i$17]++;
	          } else if (type$1 & (TYPE_AN | TYPE_EN)) {
	            embedLevels[i$17] += 2;
	          }
	        }

	        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,
	        // and otherwise to the base level.
	        if (type$1 & BN_LIKE_TYPES) {
	          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
	        }

	        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or
	        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.
	        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.
	        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
	          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {
	            embedLevels[j$1] = paragraph.level;
	          }
	        }
	      }
	    }

	    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters
	    // according to section 3.4 Reordering Resolved Levels
	    return {
	      levels: embedLevels,
	      paragraphs: paragraphs
	    }

	    function determineAutoEmbedLevel (start, isFSI) {
	      // 3.3.1 P2 - P3
	      for (var i = start; i < string.length; i++) {
	        var charType = charTypes[i];
	        if (charType & (TYPE_R | TYPE_AL)) {
	          return 1
	        }
	        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {
	          return 0
	        }
	        if (charType & ISOLATE_INIT_TYPES) {
	          var pdi = indexOfMatchingPDI(i);
	          i = pdi === -1 ? string.length : pdi;
	        }
	      }
	      return 0
	    }

	    function indexOfMatchingPDI (isolateStart) {
	      // 3.1.2 BD9
	      var isolationLevel = 1;
	      for (var i = isolateStart + 1; i < string.length; i++) {
	        var charType = charTypes[i];
	        if (charType & TYPE_B) {
	          break
	        }
	        if (charType & TYPE_PDI) {
	          if (--isolationLevel === 0) {
	            return i
	          }
	        } else if (charType & ISOLATE_INIT_TYPES) {
	          isolationLevel++;
	        }
	      }
	      return -1
	    }

	    function getEmbedDirection (i) {
	      return (embedLevels[i] & 1) ? TYPE_R : TYPE_L
	    }

	  }

	  // Bidi mirrored chars data, auto generated
	  var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";

	  var mirrorMap;

	  function parse () {
	    if (!mirrorMap) {
	      //const start = performance.now()
	      var ref = parseCharacterMap(data, true);
	      var map = ref.map;
	      var reverseMap = ref.reverseMap;
	      // Combine both maps into one
	      reverseMap.forEach(function (value, key) {
	        map.set(key, value);
	      });
	      mirrorMap = map;
	      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)
	    }
	  }

	  function getMirroredCharacter (char) {
	    parse();
	    return mirrorMap.get(char) || null
	  }

	  /**
	   * Given a string and its resolved embedding levels, build a map of indices to replacement chars
	   * for any characters in right-to-left segments that have defined mirrored characters.
	   * @param string
	   * @param embeddingLevels
	   * @param [start]
	   * @param [end]
	   * @return {Map<number, string>}
	   */
	  function getMirroredCharactersMap(string, embeddingLevels, start, end) {
	    var strLen = string.length;
	    start = Math.max(0, start == null ? 0 : +start);
	    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

	    var map = new Map();
	    for (var i = start; i <= end; i++) {
	      if (embeddingLevels[i] & 1) { //only odd (rtl) levels
	        var mirror = getMirroredCharacter(string[i]);
	        if (mirror !== null) {
	          map.set(i, mirror);
	        }
	      }
	    }
	    return map
	  }

	  /**
	   * Given a start and end denoting a single line within a string, and a set of precalculated
	   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.
	   * @param {string} string - the full input string
	   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels
	   * @param {number} [start] - first character in a subset of the full string
	   * @param {number} [end] - last character in a subset of the full string
	   * @return {number[][]} - the list of start/end segments that should be flipped, in order.
	   */
	  function getReorderSegments(string, embeddingLevelsResult, start, end) {
	    var strLen = string.length;
	    start = Math.max(0, start == null ? 0 : +start);
	    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

	    var segments = [];
	    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {
	      var lineStart = Math.max(start, paragraph.start);
	      var lineEnd = Math.min(end, paragraph.end);
	      if (lineStart < lineEnd) {
	        // Local slice for mutation
	        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);

	        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the
	        // end of the line to the paragraph level.
	        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {
	          lineLevels[i] = paragraph.level;
	        }

	        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels
	        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.
	        var maxLevel = paragraph.level;
	        var minOddLevel = Infinity;
	        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
	          var level = lineLevels[i$1];
	          if (level > maxLevel) { maxLevel = level; }
	          if (level < minOddLevel) { minOddLevel = level | 1; }
	        }
	        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
	          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
	            if (lineLevels[i$2] >= lvl) {
	              var segStart = i$2;
	              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
	                i$2++;
	              }
	              if (i$2 > segStart) {
	                segments.push([segStart + start, i$2 + start]);
	              }
	            }
	          }
	        }
	      }
	    });
	    return segments
	  }

	  /**
	   * @param {string} string
	   * @param {GetEmbeddingLevelsResult} embedLevelsResult
	   * @param {number} [start]
	   * @param {number} [end]
	   * @return {string} the new string with bidi segments reordered
	   */
	  function getReorderedString(string, embedLevelsResult, start, end) {
	    var indices = getReorderedIndices(string, embedLevelsResult, start, end);
	    var chars = [].concat( string );
	    indices.forEach(function (charIndex, i) {
	      chars[i] = (
	        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null
	      ) || string[charIndex];
	    });
	    return chars.join('')
	  }

	  /**
	   * @param {string} string
	   * @param {GetEmbeddingLevelsResult} embedLevelsResult
	   * @param {number} [start]
	   * @param {number} [end]
	   * @return {number[]} an array with character indices in their new bidi order
	   */
	  function getReorderedIndices(string, embedLevelsResult, start, end) {
	    var segments = getReorderSegments(string, embedLevelsResult, start, end);
	    // Fill an array with indices
	    var indices = [];
	    for (var i = 0; i < string.length; i++) {
	      indices[i] = i;
	    }
	    // Reverse each segment in order
	    segments.forEach(function (ref) {
	      var start = ref[0];
	      var end = ref[1];

	      var slice = indices.slice(start, end + 1);
	      for (var i = slice.length; i--;) {
	        indices[end - i] = slice[i];
	      }
	    });
	    return indices
	  }

	  exports.closingToOpeningBracket = closingToOpeningBracket;
	  exports.getBidiCharType = getBidiCharType;
	  exports.getBidiCharTypeName = getBidiCharTypeName;
	  exports.getCanonicalBracket = getCanonicalBracket;
	  exports.getEmbeddingLevels = getEmbeddingLevels;
	  exports.getMirroredCharacter = getMirroredCharacter;
	  exports.getMirroredCharactersMap = getMirroredCharactersMap;
	  exports.getReorderSegments = getReorderSegments;
	  exports.getReorderedIndices = getReorderedIndices;
	  exports.getReorderedString = getReorderedString;
	  exports.openingToClosingBracket = openingToClosingBracket;

	  Object.defineProperty(exports, '__esModule', { value: true });

	  return exports;

	}({}));
	return bidi}

	/*!
	Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
	Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
	*/
	function typrFactory(){return "undefined"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if("ttcf"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=["cmap","head","hhea","maxp","hmtx","name","OS/2","post","loca","glyf","kern","CFF ","GPOS","GSUB","SVG "],i={_data:r,_offset:n},h={},f=0;f<o;f++){var d=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[d]={offset:u,length:l};}for(f=0;f<s.length;f++){var v=s[f];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var f=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t){ return f }}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){var a=e._bin.t.uint8;return a[0]=r[t+3],a[1]=r[t+2],a[2]=r[t+1],a[3]=r[t],e._bin.t.int32[0]},readInt8:function(r,t){return e._bin.t.uint8[0]=r[t],e._bin.t.int8[0]},readShort:function(r,t){var a=e._bin.t.uint8;return a[1]=r[t],a[0]=r[t+1],e._bin.t.int16[0]},readUshort:function(r,e){return r[e]<<8|r[e+1]},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++){ n.push(e._bin.readUshort(r,t+2*o)); }return n},readUint:function(r,t){var a=e._bin.t.uint8;return a[3]=r[t],a[2]=r[t+1],a[1]=r[t+2],a[0]=r[t+3],e._bin.t.uint32[0]},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a="",n=0;n<t;n++){ a+=String.fromCharCode(r[e+n]); }return a},readUnicode:function(r,e,t){for(var a="",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:"undefined"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++){ a.push(r[e+n]); }return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++){ a.push(String.fromCharCode(r[e+n])); }return a}},e._bin.t={buff:new ArrayBuffer(8)},e._bin.t.int8=new Int8Array(e._bin.t.buff),e._bin.t.uint8=new Uint8Array(e._bin.t.buff),e._bin.t.int16=new Int16Array(e._bin.t.buff),e._bin.t.uint16=new Uint16Array(e._bin.t.buff),e._bin.t.int32=new Int32Array(e._bin.t.buff),e._bin.t.uint32=new Uint32Array(e._bin.t.buff),e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var f=s.readUshort(r,t);t+=2;var d=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+f),i.featureList=e._lctf.readFeatureList(r,h+d),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=n.readUshort(r,t);t+=2;var d=e._lctf.readLookupTable(r,o+f,a);s.push(d);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,f=0;f<i;f++){var d=n.readUshort(r,t);t+=2;var u=a(r,h,o+d,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++){ 0!=(r>>>t&1)&&e++; }return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){ n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2; }}if(2==o){var f=a.readUshort(r,t);t+=2;for(h=0;h<f;h++){ n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2; }}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n){ return t }}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt){ return a.indexOf(t); }if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n){ return a[n+2]+(t-a[n]) }}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2;var d=e._lctf.readFeatureTable(r,n+f);d.tag=h.trim(),o.push(d);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++){ o.tab.push(a.readUshort(r,t+2*h)); }return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+f);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,o.default=e._lctf.readLangSysTable(r,n+s);var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[f.trim()]=e._lctf.readLangSysTable(r,n+d);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++){ s.push(n.readASCII(r,t+o[i],o[i+1]-o[i])); }t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var f=[];for(i=0;i<h.length-1;i++){ f.push(e.CFF.readDict(r,t+h[i],t+h[i+1])); }t+=h[h.length-1];var d=f[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++){ l.push(n.readASCII(r,t+u[i],u[i+1]-u[i])); }if(t+=u[u.length-1],e.CFF.readSubrs(r,t,d),d.CharStrings){t=d.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++){ v.push(n.readBytes(r,t+u[i],u[i+1]-u[i])); }d.CharStrings=v;}if(d.ROS){t=d.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),d.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),d.FDArray.push(p);}t+=c[c.length-1],t=d.FDSelect,d.FDSelect=[];var U=r[t];if(t++,3!=U){ throw U; }var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++){ d.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3; }}return d.Encoding&&(d.Encoding=e.CFF.readEncoding(r,d.Encoding,d.CharStrings.length)),d.charset&&(d.charset=e.CFF.readCharset(r,d.charset,d.CharStrings.length)),e.CFF._readFDict(r,d,l),d},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t){ -1!=["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(o)&&(t[o]=a[t[o]-426+35]); }},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++){ a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h])); }},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++){ if(r.charset[t]==e){ return t; } }return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[".notdef"],o=r[t];if(t++,0!=o){ throw "error: unknown encoding format: "+o; }var s=r[t];t++;for(var i=0;i<s;i++){ n.push(r[t+i]); }return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[".notdef"],s=r[t];if(t++,0==s){ for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);} }else {if(1!=s&&2!=s){ throw "error: format: "+s; }for(;o.length<a;){h=n.readUshort(r,t);t+=2;var f=0;1==s?(f=r[t],t++):(f=n.readUshort(r,t),t+=2);for(i=0;i<=f;i++){ o.push(h),h++; }}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s){ for(var i=0;i<o;i++){ a.push(r[t+i]); } }else if(2==s){ for(i=0;i<o;i++){ a.push(n.readUshort(r,t+2*i)); } }else if(3==s){ for(i=0;i<o;i++){ a.push(16777215&n.readUint(r,t+3*i-1)); } }else if(1!=o){ throw "unsupported offset size: "+s+", count: "+o; }return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,f=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(f=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(f=o-139,i=1),247<=o&&o<=250&&(f=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(f=256*-(o-251)-s-108,i=2),255==o&&(f=n.readInt(r,t+1)/65535,i=5),a.val=null!=f?f:"o"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;i<=20&&(d=i,f=1),12==i&&(d=100*i+h,f=2),19!=i&&20!=i||(d=i,f=2),21<=i&&i<=27&&(d=i,f=1),28==i&&(u=o.readShort(r,t+1),f=3),29<=i&&i<=31&&(d=i,f=1),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i&&(u=o.readInt(r,t+1)/65535,f=5),s.push(null!=u?u:"o"+d),t+=f;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;if(28==i&&(u=n.readShort(r,t+1),f=3),29==i&&(u=n.readInt(r,t+1),f=5),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i){ throw u=n.readInt(r,t+1)/65535,f=5,"unknown number"; }if(30==i){var l=[];for(f=1;;){var v=r[t+f];f++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p){ break }}for(var U="",g=[0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"],S=0;S<l.length;S++){ U+=g[l[S]]; }u=parseFloat(U);}if(i<=21){ if(d=["version","Notice","FullName","FamilyName","Weight","FontBBox","BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StdHW","StdVW","escape","UniqueID","XUID","charset","Encoding","CharStrings","Private","Subrs","defaultWidthX","nominalWidthX"][i],f=1,12==i){ d=["Copyright","isFixedPitch","ItalicAngle","UnderlinePosition","UnderlineThickness","PaintType","CharstringType","FontMatrix","StrokeWidth","BlueScale","BlueShift","BlueFuzz","StemSnapH","StemSnapV","ForceBold",0,0,"LanguageGroup","ExpansionFactor","initialRandomSeed","SyntheticBase","PostScript","BaseFontName","BaseFontBlend",0,0,0,0,0,0,"ROS","CIDFontVersion","CIDFontRevision","CIDFontType","CIDCount","UIDBase","FDArray","FDSelect","FontName"][h],f=2; } }null!=d?(o[d]=1==s.length?s[0]:s,s=[]):s.push(u),t+=f;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var f=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l="p"+f+"e"+d,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug("unknown format: "+p,f,d,u),o.tables.push(c);}if(null!=o[l]){ throw "multiple tables for one platform+encoding"; }o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++){ n.map.push(r[t+s]); }return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var f=0;f<h;f++){ o.idDelta.push(a.readShort(r,t)),t+=2; }for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;){ o.glyphIdArray.push(a.readUshort(r,t)),t+=2; }return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++){ n.glyphIdArray.push(a.readUshort(r,t)),t+=2; }return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),f=a.readUint(r,i+4),d=a.readUint(r,i+8);n.groups.push([h,f,d]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++){ n.push(null); }return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,"glyf",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1]){ return null; }var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax){ return null; }if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++){ s.endPts.push(a.readUshort(n,o)),o+=2; }var h=a.readUshort(n,o);if(o+=2,n.length-o<h){ return null; }s.instructions=a.readBytes(n,o,h),o+=h;var f=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<f;i++){var d=n[o];if(o++,s.flags.push(d),0!=(8&d)){var u=n[o];o++;for(var l=0;l<u;l++){ s.flags.push(d),i++; }}}s.xs=[];for(i=0;i<f;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<f;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<f;i++){ p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U; }}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++){ s.instr.push(n[o]),o++; }}}return s},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var f=o.readUshort(r,a);a+=2;var d=e._lctf.numOfOnes(f);0!=f&&(i.pos=e.GPOS.readValueRecord(r,a,f));}else if(2==t&&i.fmt>=1&&i.fmt<=2){f=o.readUshort(r,a);a+=2;var u=o.readUshort(r,a);a+=2;d=e._lctf.numOfOnes(f);var l=e._lctf.numOfOnes(u);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,p,u),p+=2*l),g.push({gid2:m,val1:x,val2:P});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var _=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var C=[];for(S=0;S<_;S++){var x=null,P=null;0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,a,u),a+=2*l),C.push({val1:x,val2:P});}i.matrix.push(C);}}}else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype){ n.ltype=I; }else if(n.ltype!=I){ throw "invalid extension substitution"; }return e.GPOS.subt(r,n.ltype,s+w)}console.debug("unsupported GPOS table LookupType",t,"format",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&4!=t&&5!=t&&6!=t){ return null; }if(1==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt){ i.delta=o.readShort(r,a),a+=2; }else if(2==i.fmt){var f=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,f),a+=2*i.newg.length;}}else if(4==t){i.vals=[];f=o.readUshort(r,a);a+=2;for(var d=0;d<f;d++){var u=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+u));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var l=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+l),i.scset=[];var v=o.readUshort(r,a);a+=2;for(d=0;d<v;d++){var c=o.readUshort(r,a);a+=2,i.scset.push(0==c?null:e.GSUB.readSubClassSet(r,s+c));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(d=0;d<3;d++){f=o.readUshort(r,a);a+=2;for(var p=[],U=0;U<f;U++){ p.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*U))); }a+=2*f,0==d&&(i.backCvg=p),1==d&&(i.inptCvg=p),2==d&&(i.ahedCvg=p);}f=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,f);}}else {if(7==t&&1==i.fmt){var g=o.readUshort(r,a);a+=2;var S=o.readUint(r,a);if(a+=4,9==n.ltype){ n.ltype=g; }else if(n.ltype!=g){ throw "invalid extension substitution"; }return e.GSUB.subt(r,n.ltype,s+S)}console.debug("unsupported GSUB table LookupType",t,"format",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++){ n.input.push(a(r,t)),t+=2; }return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++){ o.push(n(r,t),n(r,t+2)),t+=4; }return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=["backtrack","input","lookahead"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++){ n.chain.push(a.readUshort(r,t)),t+=2; }return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,f=0;f<n.maxp.numGlyphs;f++){ f<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h); }return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s){ return e.kern.parseV1(r,t-2,a,n); }var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},f=0;f<i;f++){t+=2;a=o.readUshort(r,t);t+=2;var d=o.readUshort(r,t);t+=2;var u=d>>>8;if(0!=(u&=15)){ throw "unknown kern table format: "+u; }t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var f=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var d=f>>>8;if(0!=(d&=15)){ throw "unknown kern table format: "+d; }t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var d=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(f),u.vals.push(d),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i){ for(var f=0;f<h;f++){ s.push(o.readUshort(r,t+(f<<1))<<1); } }if(1==i){ for(f=0;f<h;f++){ s.push(o.readUint(r,t+(f<<2))); } }return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=["copyright","fontFamily","fontSubfamily","ID","fullName","version","postScriptName","trademark","manufacturer","designer","description","urlVendor","urlDesigner","licence","licenceURL","---","typoFamilyName","typoSubfamilyName","compatibleFull","sampleText","postScriptCID","wwsFamilyName","wwsSubfamilyName","lightPalette","darkPalette"],f=t+=2,d=0;d<s;d++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=f+12*s+U;if(0==u){ g=n.readUnicode(r,m,p/2); }else if(3==u&&0==l){ g=n.readUnicode(r,m,p/2); }else if(0==l){ g=n.readASCII(r,m,p); }else if(1==l){ g=n.readUnicode(r,m,p/2); }else if(3==l){ g=n.readUnicode(r,m,p/2); }else {if(1!=u){ throw "unknown encoding "+l+", platformID: "+u; }g=n.readASCII(r,m,p),console.debug("reading unknown MAC encoding "+l+" as ASCII");}var b="p"+u+","+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o){ if(null!=o[y].postScriptName&&1033==o[y]._lang){ return o[y]; } }for(var y in o){ if(null!=o[y].postScriptName&&0==o[y]._lang){ return o[y]; } }for(var y in o){ if(null!=o[y].postScriptName&&3084==o[y]._lang){ return o[y]; } }for(var y in o){ if(null!=o[y].postScriptName){ return o[y]; } }for(var y in o){i=y;break}return console.debug("returning name table with languageID "+o[i]._lang),o[i]},e["OS/2"]={},e["OS/2"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n){ e["OS/2"].version0(r,t,o); }else if(1==n){ e["OS/2"].version1(r,t,o); }else if(2==n||3==n||4==n){ e["OS/2"].version2(r,t,o); }else {if(5!=n){ throw "unknown OS/2 table version: "+n; }e["OS/2"].version5(r,t,o);}return o},e["OS/2"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e["OS/2"].version1=function(r,t,a){var n=e._bin;return t=e["OS/2"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e["OS/2"].version2=function(r,t,a){var n=e._bin;return t=e["OS/2"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e["OS/2"].version5=function(r,t,a){var n=e._bin;return t=e["OS/2"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a){ throw "no familiar platform and encoding!"; }var n=t.tables[a];if(0==n.format){ return e>=n.map.length?0:n.map[e]; }if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++){ if(e<=n.endCount[s]){o=s;break} }if(-1==o){ return 0; }if(n.startCount[o]>e){ return 0; }return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1]){ return 0; }for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1]){ return i[2]+(e-i[0]) }}return 0}throw "unknown cmap table format "+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:("string"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;){ h+=2; }i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else { r.glyf&&e.U._drawGlyf(t,r,a); }return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,f=1&r.flags[s],d=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n){ if(f){if(!d){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else { d?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2); } }f?d&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var f=o.crds[h],d=o.crds[h+1];a.crds.push(f*i.a+d*i.b+i.tx),a.crds.push(f*i.c+d*i.d+i.ty);}for(h=0;h<o.cmds.length;h++){ a.cmds.push(o.cmds[h]); }}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U.getPairAdjustment=function(r,t,a){var n=0;if(r.GPOS){ for(var o=r.GPOS,s=o.lookupList,i=o.featureList,h=[],f=0;f<i.length;f++){var d=i[f];if("kern"==d.tag){ for(var u=0;u<d.tab.length;u++){ if(!h[d.tab[u]]){h[d.tab[u]]=!0;for(var l=s[d.tab[u]],v=0;v<l.tabs.length;v++){ if(null!=l.tabs[v]){var c,p=l.tabs[v];if(!p.coverage||-1!=(c=e._lctf.coverageIndex(p.coverage,t))){ if(1==l.ltype);else if(2==l.ltype){var U;if(1==p.fmt){var g=p.pairsets[c];for(f=0;f<g.length;f++){ g[f].gid2==a&&(U=g[f]); }}else if(2==p.fmt){var S=e.U._getGlyphClass(t,p.classDef1),m=e.U._getGlyphClass(a,p.classDef2);U=p.matrix[S][m];}U&&U.val1&&U.val1[2]&&(n+=U.val1[2]),U&&U.val2&&U.val2[0]&&(n+=U.val2[0]);} }} }} } }} }if(r.kern){var b=r.kern.glyph1.indexOf(t);if(-1!=b){var y=r.kern.rval[b].glyph2.indexOf(a);-1!=y&&(n+=r.kern.rval[b].vals[y]);}}return n},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++){ if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t]))){ if(1==a.ltype){ r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i]; }else if(4==a.ltype){ for(var f=h.vals[i],d=0;d<f.length;d++){var u=f[d],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];){ c++; }u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++){ r[t+p+1]=-1; }break}}} }else if(5==a.ltype&&2==h.fmt){ for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var _=b.substLookupRecords;for(d=0;d<_.length;d+=2){ _[d],_[d+1]; }}}} }else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length)){ continue; }if(!e.U._glsCovered(r,h.inptCvg,t)){ continue; }if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length)){ continue; }var C=h.lookupRec;for(m=0;m<C.length;m+=2){U=C[m];var x=n[C[m+1]];e.U._applySubs(r,t+U,x,n);}} }} }},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n])){ return !1 }}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,f=e.U.glyphToPath(r,i),d=0;d<f.crds.length;d+=2){ n.crds.push(f.crds[d]+o),n.crds.push(f.crds[d+1]); }a&&n.cmds.push(a);for(d=0;d<f.cmds.length;d++){ n.cmds.push(f.cmds[d]); }a&&n.cmds.push("X"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push("M"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push("L"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push("C"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push("Q"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push("Z");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,_=0,C={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,C);var x=C.val;if(u+=C.size,"o1"==x||"o18"==x){ s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0; }else if("o3"==x||"o23"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if("o4"==x){ s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),d&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),d=!0; }else if("o5"==x){ for(;s.length>0;){ l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v); } }else if("o6"==x||"o7"==x){ for(var P=s.length,I="o6"==x,w=0;w<P;w++){var O=s.shift();I?l+=O:v+=O,I=!I,e.U.P.lineTo(o,l,v);} }else if("o8"==x||"o24"==x){P=s.length;for(var T=0;T+6<=P;){ c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),T+=6; }"o24"==x&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if("o11"==x){ break; }if("o1234"==x||"o1235"==x||"o1236"==x||"o1237"==x){ "o1234"==x&&(p=v,U=(c=l+s.shift())+s.shift(),_=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1235"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1236"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),_=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1237"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)); }else if("o14"==x){if(s.length>0&&!h&&(f=s.shift()+a.nominalWidthX,h=!0),4==s.length){var k=s.shift(),G=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=k,t.y=G,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}d&&(e.U.P.closePath(o),d=!1);}else if("o19"==x||"o20"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if("o21"==x){ s.length>2&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0; }else if("o22"==x){ s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0; }else if("o25"==x){for(;s.length>6;){ l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v); }c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if("o26"==x){ for(s.length%2&&(l+=s.shift());s.length>0;){ c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v); } }else if("o27"==x){ for(s.length%2&&(v+=s.shift());s.length>0;){ p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v); } }else if("o10"==x||"o29"==x){var L="o10"==x?n:a;if(0==s.length){ console.debug("error: empty stack"); }else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open;}}else if("o30"==x||"o31"==x){var N=s.length,V=(T=0,"o31"==x);for(T+=N-(P=-3&N);T<P;){ V?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),P-T==5?(l=U+s.shift(),T++):l=U,V=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),P-T==5?(v=g+s.shift(),T++):v=g,V=!0),e.U.P.curveTo(o,c,p,U,g,l,v),T+=4; }}else {if("o"==(x+"").charAt(0)){ throw console.debug("Unknown operation: "+x,r),x; }s.push(x);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,"__esModule",{value:!0}),r}({}).Typr}

	/*!
	Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
	(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
	Original licenses apply: 
	- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
	- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
	*/
	function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),f=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),i=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=function(r,e){for(var a=new n(31),f=0;f<31;++f){ a[f]=e+=1<<r[f-1]; }var i=new t(a[30]);for(f=1;f<30;++f){ for(var o=a[f];o<a[f+1];++o){ i[o]=o-a[f]<<5|f; } }return [a,i]},u=o(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=o(f,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,f=0,i=new n(e);f<a;++f){ ++i[r[f]-1]; }var o,u=new n(e);for(f=0;f<e;++f){ u[f]=u[f-1]+i[f-1]<<1; }if(t){o=new n(1<<e);var v=15-e;for(f=0;f<a;++f){ if(r[f]){ for(var s=f<<4|r[f],l=e-r[f],g=u[r[f]-1]++<<l,h=g|(1<<l)-1;g<=h;++g){ o[c[g]>>>v]=s; } } }}else { for(o=new n(a),f=0;f<a;++f){ o[f]=c[u[r[f]-1]++]>>>15-r[f]; } }return o},m=new e(288);for(g=0;g<144;++g){ m[g]=8; }for(g=144;g<256;++g){ m[g]=9; }for(g=256;g<280;++g){ m[g]=7; }for(g=280;g<288;++g){ m[g]=8; }var b=new e(32);for(g=0;g<32;++g){ b[g]=5; }var p=w(m,9,1),d=w(b,5,1),L=function(r){for(var e=r[0],n=1;n<r.length;++n){ r[n]>e&&(e=r[n]); }return e},y=function(r,e,n){var t=e/8>>0;return (r[t]|r[t+1]<<8)>>>(7&e)&n},U=function(r,e){var n=e/8>>0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>>(7&e)},O=function(r,o,u){var s=r.length,c=!o||u,g=!u||u.i;u||(u={}),o||(o=new e(3*s));var h,m=function(r){var n=o.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(o),o=t;}},b=u.f||0,O=u.p||0,A=u.b||0,k=u.l,x=u.d,E=u.m,T=u.n,F=8*s;do{if(!k){u.f=b=y(r,O,1);var V=y(r,O+1,3);if(O+=3,!V){var M=r[(I=((h=O)/8>>0)+(7&h&&1)+4)-4]|r[I-3]<<8,C=I+M;if(C>s){if(g){ throw "unexpected EOF"; }break}c&&m(A+M),o.set(r.subarray(I,C),A),u.b=A+=M,u.p=O=8*C;continue}if(1==V){ k=p,x=d,E=9,T=5; }else {if(2!=V){ throw "invalid block type"; }var D=y(r,O,31)+257,S=y(r,O+10,15)+4,_=D+y(r,O+5,31)+1;O+=14;for(var j=new e(_),z=new e(19),q=0;q<S;++q){ z[i[q]]=y(r,O+3*q,7); }O+=3*S;var B=L(z),G=(1<<B)-1;if(!g&&O+_*(B+7)>F){ break; }var H=w(z,B,1);for(q=0;q<_;){var I,J=H[y(r,O,G)];if(O+=15&J,(I=J>>>4)<16){ j[q++]=I; }else {var K=0,N=0;for(16==I?(N=3+y(r,O,3),O+=2,K=j[q-1]):17==I?(N=3+y(r,O,7),O+=3):18==I&&(N=11+y(r,O,127),O+=7);N--;){ j[q++]=K; }}}var P=j.subarray(0,D),Q=j.subarray(D);E=L(P),T=L(Q),k=w(P,E,1),x=w(Q,T,1);}if(O>F){ throw "unexpected EOF" }}c&&m(A+131072);for(var R=(1<<E)-1,W=(1<<T)-1,X=E+T+18;g||O+X<F;){var Y=(K=k[U(r,O)&R])>>>4;if((O+=15&K)>F){ throw "unexpected EOF"; }if(!K){ throw "invalid length/literal"; }if(Y<256){ o[A++]=Y; }else {if(256==Y){k=null;break}var Z=Y-254;if(Y>264){var $=a[q=Y-257];Z=y(r,O,(1<<$)-1)+v[q],O+=$;}var rr=x[U(r,O)&W],er=rr>>>4;if(!rr){ throw "invalid distance"; }O+=15&rr;Q=l[er];if(er>3){$=f[er];Q+=U(r,O)&(1<<$)-1,O+=$;}if(O>F){ throw "unexpected EOF"; }c&&m(A+131072);for(var nr=A+Z;A<nr;A+=4){ o[A]=o[A-Q],o[A+1]=o[A+1-Q],o[A+2]=o[A+2-Q],o[A+3]=o[A+3-Q]; }A=nr;}}u.l=k,u.p=O,u.b=A,k&&(b=1,u.m=E,u.d=x,u.n=T);}while(!b);return A==o.length?o:function(r,a,f){(null==a||a<0)&&(a=0),(null==f||f>r.length)&&(f=r.length);var i=new(r instanceof n?n:r instanceof t?t:e)(f-a);return i.set(r.subarray(a,f)),i}(o,0,A)};return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function f(r){b.setUint16(p,r),p+=2;}function i(r){b.setUint32(p,r),p+=4;}for(var o={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=o.numTables;){ u++; }u--;for(var v=16*Math.pow(2,u),s=16*o.numTables-v,l=12,c=[],g=0;g<o.numTables;g++){ c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16; }var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),m=w.buffer,b=new DataView(m),p=0;return i(o.flavor),f(o.numTables),f(v),f(u),f(s),c.forEach((function(r){i(r.tag),i(r.origChecksum),i(l),i(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else { a=new Uint8Array(t); }w.set(a,e.outOffset);var f=0;(l=e.outOffset+e.origLength)%4!=0&&(f=4-l%4),w.set(new Uint8Array(f).buffer,e.outOffset+e.origLength),h=l+f;})),m.slice(0,h)},r}({}).convert_streams}

	/**
	 * An adapter that allows Typr.js to be used as if it were (a subset of) the OpenType.js API.
	 * Also adds support for WOFF files (not WOFF2).
	 */

	function parserFactory(Typr, woff2otf) {
	  var cmdArgLengths = {
	    M: 2,
	    L: 2,
	    Q: 4,
	    C: 6,
	    Z: 0
	  };

	  // {joinType: "skip+step,..."}
	  var joiningTypeRawData = {"C":"18g,ca,368,1kz","D":"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v","R":"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6","L":"x9u,jff,a,fd,jv","T":"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"};

	  var JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.
	    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.
	    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.
	    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.
	    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.
	    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,

	  var joiningTypeMap;
	  function getCharJoiningType(ch) {
	    if (!joiningTypeMap) {
	      var m = {
	        R: JT_RIGHT,
	        L: JT_LEFT,
	        D: JT_DUAL,
	        C: JT_JOIN_CAUSING,
	        U: JT_NON_JOINING,
	        T: JT_TRANSPARENT
	      };
	      joiningTypeMap = new Map();
	      var loop = function ( type ) {
	        var lastCode = 0;
	        joiningTypeRawData[type].split(',').forEach(function (range) {
	          var ref = range.split('+');
	          var skip = ref[0];
	          var step = ref[1];
	          skip = parseInt(skip,36);
	          step = step ? parseInt(step, 36) : 0;
	          joiningTypeMap.set(lastCode += skip, m[type]);
	          for (var i = step; i--;) {
	            joiningTypeMap.set(++lastCode, m[type]);
	          }
	        });
	      };

	      for (var type in joiningTypeRawData) loop( type );
	    }
	    return joiningTypeMap.get(ch) || JT_NON_JOINING
	  }

	  var ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
	  var formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];

	  function detectJoiningForms(str) {
	    // This implements the algorithm described here:
	    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md
	    var joiningForms = new Uint8Array(str.length);
	    var prevJoiningType = JT_NON_JOINING;
	    var prevForm = ISOL;
	    var prevIndex = -1;
	    for (var i = 0; i < str.length; i++) {
	      var code = str.codePointAt(i);
	      var joiningType = getCharJoiningType(code) | 0;
	      var form = ISOL;
	      if (joiningType & JT_TRANSPARENT) {
	        continue
	      }
	      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
	        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
	          form = FINA;
	          // isol->init, fina->medi
	          if (prevForm === ISOL || prevForm === FINA) {
	            joiningForms[prevIndex]++;
	          }
	        }
	        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
	          // medi->fina, init->isol
	          if (prevForm === INIT || prevForm === MEDI) {
	            joiningForms[prevIndex]--;
	          }
	        }
	      }
	      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
	        // medi->fina, init->isol
	        if (prevForm === INIT || prevForm === MEDI) {
	          joiningForms[prevIndex]--;
	        }
	      }
	      prevForm = joiningForms[i] = form;
	      prevJoiningType = joiningType;
	      prevIndex = i;
	      if (code > 0xffff) { i++; }
	    }
	    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))
	    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))
	    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))
	    return joiningForms
	  }

	  function stringToGlyphs (font, str) {
	    var glyphIds = [];
	    for (var i = 0; i < str.length; i++) {
	      var cc = str.codePointAt(i);
	      if (cc > 0xffff) { i++; }
	      glyphIds.push(Typr.U.codeToGlyph(font, cc));
	    }

	    var gsub = font['GSUB'];
	    if (gsub) {
	      var lookupList = gsub.lookupList;
	      var featureList = gsub.featureList;
	      var joiningForms;
	      var supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
	      var usedLookups = [];
	      featureList.forEach(function (feature) {
	        if (supportedFeatures.test(feature.tag)) {
	          for (var ti = 0; ti < feature.tab.length; ti++) {
	            if (usedLookups[feature.tab[ti]]) { continue }
	            usedLookups[feature.tab[ti]] = true;
	            var tab = lookupList[feature.tab[ti]];
	            var isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
	            if (isJoiningFeature && !joiningForms) { //lazy
	              joiningForms = detectJoiningForms(str);
	            }
	            for (var ci = 0; ci < glyphIds.length; ci++) {
	              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
	                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
	              }
	            }
	          }
	        }
	      });
	    }

	    return glyphIds
	  }


	  function wrapFontObj(typrFont) {
	    var glyphMap = Object.create(null);

	    var fontObj = {
	      unitsPerEm: typrFont.head.unitsPerEm,
	      ascender: typrFont.hhea.ascender,
	      descender: typrFont.hhea.descender,
	      forEachGlyph: function forEachGlyph(text, fontSize, letterSpacing, callback) {
	        var glyphX = 0;
	        var fontScale = 1 / fontObj.unitsPerEm * fontSize;

	        var glyphIndices = stringToGlyphs(typrFont, text);
	        var charIndex = 0;
	        var prevGlyphIndex = -1;
	        glyphIndices.forEach(function (glyphIndex, i) {
	          // Typr returns a glyph index per string codepoint, with -1s in place of those that
	          // were omitted due to ligature substitution. So we can track original index in the
	          // string via simple increment, and skip everything else when seeing a -1.
	          if (glyphIndex !== -1) {
	            var glyphObj = glyphMap[glyphIndex];
	            if (!glyphObj) {
	              var ref = Typr.U.glyphToPath(typrFont, glyphIndex);
	              var cmds = ref.cmds;
	              var crds = ref.crds;

	              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't
	              // normalize the two, so it's simplest just to iterate ourselves.
	              var xMin, yMin, xMax, yMax;
	              if (crds.length) {
	                xMin = yMin = Infinity;
	                xMax = yMax = -Infinity;
	                for (var i$1 = 0, len = crds.length; i$1 < len; i$1 += 2) {
	                  var x = crds[i$1];
	                  var y = crds[i$1 + 1];
	                  if (x < xMin) { xMin = x; }
	                  if (y < yMin) { yMin = y; }
	                  if (x > xMax) { xMax = x; }
	                  if (y > yMax) { yMax = y; }
	                }
	              } else {
	                xMin = xMax = yMin = yMax = 0;
	              }

	              glyphObj = glyphMap[glyphIndex] = {
	                index: glyphIndex,
	                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
	                xMin: xMin,
	                yMin: yMin,
	                xMax: xMax,
	                yMax: yMax,
	                pathCommandCount: cmds.length,
	                forEachPathCommand: function forEachPathCommand(callback) {
	                  var argsIndex = 0;
	                  var argsArray = [];
	                  for (var i = 0, len = cmds.length; i < len; i++) {
	                    var numArgs = cmdArgLengths[cmds[i]];
	                    argsArray.length = 1 + numArgs;
	                    argsArray[0] = cmds[i];
	                    for (var j = 1; j <= numArgs; j++) {
	                      argsArray[j] = crds[argsIndex++];
	                    }
	                    callback.apply(null, argsArray);
	                  }
	                }
	              };
	            }

	            // Kerning
	            if (prevGlyphIndex !== -1) {
	              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
	            }

	            callback.call(null, glyphObj, glyphX, charIndex);

	            if (glyphObj.advanceWidth) {
	              glyphX += glyphObj.advanceWidth * fontScale;
	            }
	            if (letterSpacing) {
	              glyphX += letterSpacing * fontSize;
	            }

	            prevGlyphIndex = glyphIndex;
	          }
	          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);
	        });
	        return glyphX
	      }
	    };

	    return fontObj
	  }

	  return function parse(buffer) {
	    // Look to see if we have a WOFF file and convert it if so:
	    var peek = new Uint8Array(buffer, 0, 4);
	    var tag = Typr._bin.readASCII(peek, 0, 4);
	    if (tag === 'wOFF') {
	      buffer = woff2otf(buffer);
	    } else if (tag === 'wOF2') {
	      throw new Error('woff2 fonts not supported')
	    }
	    return wrapFontObj(Typr.parse(buffer)[0])
	  }
	}


	var workerModule = /*#__PURE__*/defineWorkerModule({
	  name: 'Typr Font Parser',
	  dependencies: [typrFactory, woff2otfFactory, parserFactory],
	  init: function init(typrFactory, woff2otfFactory, parserFactory) {
	    var Typr = typrFactory();
	    var woff2otf = woff2otfFactory();
	    return parserFactory(Typr, woff2otf)
	  }
	});

	// import fontParser from './worker/FontParser_OpenType.js'


	var CONFIG = {
	  defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular
	  sdfGlyphSize: 64,
	  sdfMargin: 1 / 16,
	  sdfExponent: 9,
	  textureWidth: 2048
	};
	var tempColor = /*#__PURE__*/new Color();

	/**
	 * Repository for all font SDF atlas textures
	 *
	 *   {
	 *     [font]: {
	 *       sdfTexture: DataTexture
	 *     }
	 *   }
	 */
	var atlases = Object.create(null);

	/**
	 * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.
	 * @property {object} parameters - The normalized input arguments to the render call.
	 * @property {DataTexture} sdfTexture - The SDF atlas texture.
	 * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.
	 * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.
	 * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.
	 * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.
	 * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.
	 * @property {Float32Array} [caretPositions] - A list of caret positions for all glyphs; this is
	 *           the bottom [x,y] of the cursor position before each char, plus one after the last char.
	 * @property {number} [caretHeight] - An appropriate height for all selection carets.
	 * @property {number} ascender - The font's ascender metric.
	 * @property {number} descender - The font's descender metric.
	 * @property {number} lineHeight - The final computed lineHeight measurement.
	 * @property {number} topBaseline - The y position of the top line's baseline.
	 * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
	 *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is
	 *           equivalent to the dimensions of a block-level text element in CSS.
	 * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
	 *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.
	 * @property {Array<number>} totalBounds - DEPRECATED; use blockBounds instead.
	 * @property {Array<number>} totalBlockSize - DEPRECATED; use blockBounds instead
	 * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,
	 *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.
	 * @property {object} timings - Timing info for various parts of the rendering logic including SDF
	 *           generation, layout, etc.
	 * @frozen
	 */

	/**
	 * @callback getTextRenderInfo~callback
	 * @param {TroikaTextRenderInfo} textRenderInfo
	 */

	/**
	 * Main entry point for requesting the data needed to render a text string with given font parameters.
	 * This is an asynchronous call, performing most of the logic in a web worker thread.
	 * @param {object} args
	 * @param {getTextRenderInfo~callback} callback
	 */
	function getTextRenderInfo(args, callback) {
	  args = assign$6({}, args);

	  // Apply default font here to avoid a 'null' atlas, and convert relative
	  // URLs to absolute so they can be resolved in the worker
	  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);

	  // Normalize text to a string
	  args.text = '' + args.text;

	  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;

	  // Normalize colors
	  if (args.colorRanges != null) {
	    var colors = {};
	    for (var key in args.colorRanges) {
	      if (args.colorRanges.hasOwnProperty(key)) {
	        var val = args.colorRanges[key];
	        if (typeof val !== 'number') {
	          val = tempColor.set(val).getHex();
	        }
	        colors[key] = val;
	      }
	    }
	    args.colorRanges = colors;
	  }

	  Object.freeze(args);

	  // Init the atlas for this font if needed
	  var textureWidth = CONFIG.textureWidth;
	  var sdfExponent = CONFIG.sdfExponent;
	  var sdfGlyphSize = args.sdfGlyphSize;
	  var atlasKey = (args.font) + "@" + sdfGlyphSize;
	  var atlas = atlases[atlasKey];
	  if (!atlas) {
	    atlas = atlases[atlasKey] = {
	      sdfTexture: new DataTexture(
	        new Uint8Array(sdfGlyphSize * textureWidth * 4),
	        textureWidth,
	        sdfGlyphSize,
	        RGBAFormat,
	        undefined,
	        undefined,
	        undefined,
	        undefined,
	        LinearFilter,
	        LinearFilter
	      )
	    };
	    atlas.sdfTexture.font = args.font;
	  }

	  // Issue request to the FontProcessor in the worker
	  processInWorker(args).then(function (result) {
	    // If the response has newGlyphs, copy them into the atlas texture at the specified indices
	    if (result.newGlyphSDFs) {
	      result.newGlyphSDFs.forEach(function (ref) {
	        var textureData = ref.textureData;
	        var atlasIndex = ref.atlasIndex;

	        var texImg = atlas.sdfTexture.image;

	        // Grow the texture by power of 2 if needed
	        while (texImg.data.length < (atlasIndex + 1) * sdfGlyphSize * sdfGlyphSize) {
	          var biggerArray = new Uint8Array(texImg.data.length * 2);
	          biggerArray.set(texImg.data);
	          texImg.data = biggerArray;
	          texImg.height *= 2;
	        }

	        // Insert the new glyph's data into the full texture image at the correct offsets
	        // Glyphs are packed sequentially into the R,G,B,A channels of a square, advancing
	        // to the next square every 4 glyphs.
	        var squareIndex = Math.floor(atlasIndex / 4);
	        var cols = texImg.width / sdfGlyphSize;
	        var baseStartIndex = Math.floor(squareIndex / cols) * texImg.width * sdfGlyphSize * 4 //full rows
	          + (squareIndex % cols) * sdfGlyphSize * 4 //partial row
	          + (atlasIndex % 4); //color channel
	        for (var y = 0; y < sdfGlyphSize; y++) {
	          var srcStartIndex = y * sdfGlyphSize;
	          var rowStartIndex = baseStartIndex + (y * texImg.width * 4);
	          for (var x = 0; x < sdfGlyphSize; x++) {
	            texImg.data[rowStartIndex + x * 4] = textureData[srcStartIndex + x];
	          }
	        }
	      });
	      atlas.sdfTexture.needsUpdate = true;
	    }

	    // Invoke callback with the text layout arrays and updated texture
	    callback(Object.freeze({
	      parameters: args,
	      sdfTexture: atlas.sdfTexture,
	      sdfGlyphSize: sdfGlyphSize,
	      sdfExponent: sdfExponent,
	      glyphBounds: result.glyphBounds,
	      glyphAtlasIndices: result.glyphAtlasIndices,
	      glyphColors: result.glyphColors,
	      caretPositions: result.caretPositions,
	      caretHeight: result.caretHeight,
	      chunkedBounds: result.chunkedBounds,
	      ascender: result.ascender,
	      descender: result.descender,
	      lineHeight: result.lineHeight,
	      topBaseline: result.topBaseline,
	      blockBounds: result.blockBounds,
	      visibleBounds: result.visibleBounds,
	      timings: result.timings,
	      get totalBounds() {
	        console.log('totalBounds deprecated, use blockBounds instead');
	        return result.blockBounds
	      },
	      get totalBlockSize() {
	        console.log('totalBlockSize deprecated, use blockBounds instead');
	        var ref = result.blockBounds;
	        var x0 = ref[0];
	        var y0 = ref[1];
	        var x1 = ref[2];
	        var y1 = ref[3];
	        return [x1 - x0, y1 - y0]
	      }
	    }));
	  });
	}


	// Local assign impl so we don't have to import troika-core
	function assign$6(toObj, fromObj) {
	  for (var key in fromObj) {
	    if (fromObj.hasOwnProperty(key)) {
	      toObj[key] = fromObj[key];
	    }
	  }
	  return toObj
	}

	// Utility for making URLs absolute
	var linkEl;
	function toAbsoluteURL(path) {
	  if (!linkEl) {
	    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');
	  }
	  linkEl.href = path;
	  return linkEl.href
	}


	var fontProcessorWorkerModule = /*#__PURE__*/defineWorkerModule({
	  name: 'FontProcessor',
	  dependencies: [
	    CONFIG,
	    workerModule,
	    createGlyphSegmentsIndex,
	    createSDFGenerator,
	    createFontProcessor,
	    bidiFactory
	  ],
	  init: function init(config, fontParser, createGlyphSegmentsIndex, createSDFGenerator, createFontProcessor, bidiFactory) {
	    var sdfExponent = config.sdfExponent;
	    var sdfMargin = config.sdfMargin;
	    var defaultFontURL = config.defaultFontURL;
	    var sdfGenerator = createSDFGenerator(createGlyphSegmentsIndex, { sdfExponent: sdfExponent, sdfMargin: sdfMargin });
	    return createFontProcessor(fontParser, sdfGenerator, bidiFactory(), { defaultFontURL: defaultFontURL })
	  }
	});

	var processInWorker = /*#__PURE__*/defineWorkerModule({
	  name: 'TextBuilder',
	  dependencies: [fontProcessorWorkerModule, ThenableWorkerModule],
	  init: function init(fontProcessor, Thenable) {
	    return function(args) {
	      var thenable = new Thenable();
	      fontProcessor.process(args, thenable.resolve);
	      return thenable
	    }
	  },
	  getTransferables: function getTransferables(result) {
	    // Mark array buffers as transferable to avoid cloning during postMessage
	    var transferables = [
	      result.glyphBounds.buffer,
	      result.glyphAtlasIndices.buffer
	    ];
	    if (result.caretPositions) {
	      transferables.push(result.caretPositions.buffer);
	    }
	    if (result.newGlyphSDFs) {
	      result.newGlyphSDFs.forEach(function (d) {
	        transferables.push(d.textureData.buffer);
	      });
	    }
	    return transferables
	  }
	});

	var GlyphsGeometry = /*#__PURE__*/(function () {

	  var templateGeometries = {};
	  function getTemplateGeometry(detail) {
	    var geom = templateGeometries[detail];
	    if (!geom) {
	      geom = templateGeometries[detail] = new PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);
	    }
	    return geom
	  }
	  new Vector3();

	  var glyphBoundsAttrName = 'aTroikaGlyphBounds';
	  var glyphIndexAttrName = 'aTroikaGlyphIndex';
	  var glyphColorAttrName = 'aTroikaGlyphColor';

	  /**
	  @class GlyphsGeometry

	  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to
	  render the glyphs using GPU instancing of a single quad, rather than constructing a whole
	  geometry with vertices, for much smaller attribute arraybuffers according to this math:

	    Where N = number of glyphs...

	    Instanced:
	    - position: 4 * 3
	    - index: 2 * 3
	    - normal: 4 * 3
	    - uv: 4 * 2
	    - glyph x/y bounds: N * 4
	    - glyph indices: N * 1
	    = 5N + 38

	    Non-instanced:
	    - position: N * 4 * 3
	    - index: N * 2 * 3
	    - normal: N * 4 * 3
	    - uv: N * 4 * 2
	    - glyph indices: N * 1
	    = 39N

	  A downside of this is the rare-but-possible lack of the instanced arrays extension,
	  which we could potentially work around with a fallback non-instanced implementation.

	  */
	  var GlyphsGeometry = /*@__PURE__*/(function (InstancedBufferGeometry) {
	    function GlyphsGeometry() {
	      InstancedBufferGeometry.call(this);

	      this.detail = 1;
	      this.curveRadius = 0;

	      // Define groups for rendering text outline as a separate pass; these will only
	      // be used when the `material` getter returns an array, i.e. outlineWidth > 0.
	      this.groups = [
	        {start: 0, count: Infinity, materialIndex: 0},
	        {start: 0, count: Infinity, materialIndex: 1}
	      ];

	      // Preallocate empty bounding objects
	      this.boundingSphere = new Sphere();
	      this.boundingBox = new Box3();
	    }

	    if ( InstancedBufferGeometry ) GlyphsGeometry.__proto__ = InstancedBufferGeometry;
	    GlyphsGeometry.prototype = Object.create( InstancedBufferGeometry && InstancedBufferGeometry.prototype );
	    GlyphsGeometry.prototype.constructor = GlyphsGeometry;

	    var prototypeAccessors = { detail: { configurable: true },curveRadius: { configurable: true } };

	    GlyphsGeometry.prototype.computeBoundingSphere = function computeBoundingSphere () {
	      // No-op; we'll sync the boundingSphere proactively when needed.
	    };

	    GlyphsGeometry.prototype.computeBoundingBox = function computeBoundingBox () {
	      // No-op; we'll sync the boundingBox proactively when needed.
	    };

	    prototypeAccessors.detail.set = function (detail) {
	      var this$1 = this;

	      if (detail !== this._detail) {
	        this._detail = detail;
	        if (typeof detail !== 'number' || detail < 1) {
	          detail = 1;
	        }
	        var tpl = getTemplateGeometry(detail)
	        ;['position', 'normal', 'uv'].forEach(function (attr) {
	          this$1.attributes[attr] = tpl.attributes[attr].clone();
	        });
	        this.setIndex(tpl.getIndex().clone());
	      }
	    };
	    prototypeAccessors.detail.get = function () {
	      return this._detail
	    };

	    prototypeAccessors.curveRadius.set = function (r) {
	      if (r !== this._curveRadius) {
	        this._curveRadius = r;
	        this._updateBounds();
	      }
	    };
	    prototypeAccessors.curveRadius.get = function () {
	      return this._curveRadius
	    };

	    /**
	     * Update the geometry for a new set of glyphs.
	     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
	     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
	     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
	     *        the SDF atlas texture.
	     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
	     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
	     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
	     *        used with `applyClipRect` to choose an optimized `instanceCount`.
	     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
	     */
	    GlyphsGeometry.prototype.updateGlyphs = function updateGlyphs (glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
	      // Update the instance attributes
	      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
	      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
	      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
	      this._blockBounds = blockBounds;
	      this._chunkedBounds = chunkedBounds;
	      setInstanceCount(this, glyphAtlasIndices.length);
	      this._updateBounds();
	    };

	    GlyphsGeometry.prototype._updateBounds = function _updateBounds () {
	      var bounds = this._blockBounds;
	      if (bounds) {
	        var ref = this;
	        var curveRadius = ref.curveRadius;
	        var bbox = ref.boundingBox;
	        if (curveRadius) {
	          var PI = Math.PI;
	          var floor = Math.floor;
	          var min = Math.min;
	          var max = Math.max;
	          var sin = Math.sin;
	          var cos = Math.cos;
	          var halfPi = PI / 2;
	          var twoPi = PI * 2;
	          var absR = Math.abs(curveRadius);
	          var leftAngle = bounds[0] / absR;
	          var rightAngle = bounds[2] / absR;
	          var minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)
	            ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
	          var maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)
	            ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
	          var maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)
	            ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
	          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
	          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
	        } else {
	          bbox.min.set(bounds[0], bounds[1], 0);
	          bbox.max.set(bounds[2], bounds[3], 0);
	        }
	        bbox.getBoundingSphere(this.boundingSphere);
	      }
	    };

	    /**
	     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
	     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
	     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
	     * be clipped anyway.
	     *
	     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
	     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
	     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
	     * but at the expense of much larger attribute buffers (see classdoc above.)
	     *
	     * @param {Vector4} clipRect
	     */
	    GlyphsGeometry.prototype.applyClipRect = function applyClipRect (clipRect) {
	      var count = this.getAttribute(glyphIndexAttrName).count;
	      var chunks = this._chunkedBounds;
	      if (chunks) {
	        for (var i = chunks.length; i--;) {
	          count = chunks[i].end;
	          var rect = chunks[i].rect;
	          // note: both rects are l-b-r-t
	          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
	            break
	          }
	        }
	      }
	      setInstanceCount(this, count);
	    };

	    Object.defineProperties( GlyphsGeometry.prototype, prototypeAccessors );

	    return GlyphsGeometry;
	  }(InstancedBufferGeometry));

	  // Compat for pre r109:
	  if (!GlyphsGeometry.prototype.setAttribute) {
	    GlyphsGeometry.prototype.setAttribute = function(name, attribute) {
	      this.attributes[ name ] = attribute;
	      return this
	    };
	  }


	  function updateBufferAttr(geom, attrName, newArray, itemSize) {
	    var attr = geom.getAttribute(attrName);
	    if (newArray) {
	      // If length isn't changing, just update the attribute's array data
	      if (attr && attr.array.length === newArray.length) {
	        attr.array.set(newArray);
	        attr.needsUpdate = true;
	      } else {
	        geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
	        // If the new attribute has a different size, we also have to (as of r117) manually clear the
	        // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706
	        // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in
	        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a
	        // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly
	        // implies it should be supported. It's possible we need to
	        delete geom._maxInstanceCount; //for r117+, could be fragile
	        geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like
	      }
	    } else if (attr) {
	      geom.deleteAttribute(attrName);
	    }
	  }

	  // Handle maxInstancedCount -> instanceCount rename that happened in three r117
	  function setInstanceCount(geom, count) {
	    geom[geom.hasOwnProperty('instanceCount') ? 'instanceCount' : 'maxInstancedCount'] = count;
	  }

	  return GlyphsGeometry
	})();

	// language=GLSL
	var VERTEX_DEFS = "\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n";

	// language=GLSL prefix="void main() {" suffix="}"
	var VERTEX_TRANSFORM = "\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n" + ('') + "\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n";

	// language=GLSL
	var FRAGMENT_DEFS = "\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of encoding in SDFGenerator.js\n  " + ('') + "\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  " + ('') + "\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  " + ('') + "\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n";

	// language=GLSL prefix="void main() {" suffix="}"
	var FRAGMENT_TRANSFORM = "\nfloat aaDist = troikaGetAADist();\nfloat distance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(distance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  distance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n";


	/**
	 * Create a material for rendering text, derived from a baseMaterial
	 */
	function createTextDerivedMaterial(baseMaterial) {
	  var textMaterial = createDerivedMaterial(baseMaterial, {
	    chained: true,
	    extensions: {
	      derivatives: true
	    },
	    uniforms: {
	      uTroikaSDFTexture: {value: null},
	      uTroikaSDFTextureSize: {value: new Vector2()},
	      uTroikaSDFGlyphSize: {value: 0},
	      uTroikaSDFExponent: {value: 0},
	      uTroikaTotalBounds: {value: new Vector4(0,0,0,0)},
	      uTroikaClipRect: {value: new Vector4(0,0,0,0)},
	      uTroikaDistanceOffset: {value: 0},
	      uTroikaOutlineOpacity: {value: 0},
	      uTroikaFillOpacity: {value: 1},
	      uTroikaPositionOffset: {value: new Vector2()},
	      uTroikaCurveRadius: {value: 0},
	      uTroikaBlurRadius: {value: 0},
	      uTroikaStrokeWidth: {value: 0},
	      uTroikaStrokeColor: {value: new Color()},
	      uTroikaStrokeOpacity: {value: 1},
	      uTroikaOrient: {value: new Matrix3()},
	      uTroikaUseGlyphColors: {value: true},
	      uTroikaSDFDebug: {value: false}
	    },
	    vertexDefs: VERTEX_DEFS,
	    vertexTransform: VERTEX_TRANSFORM,
	    fragmentDefs: FRAGMENT_DEFS,
	    fragmentColorTransform: FRAGMENT_TRANSFORM,
	    customRewriter: function customRewriter(ref) {
	      var vertexShader = ref.vertexShader;
	      var fragmentShader = ref.fragmentShader;

	      var uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
	      if (uDiffuseRE.test(fragmentShader)) {
	        // Replace all instances of `diffuse` with our varying
	        fragmentShader = fragmentShader
	          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')
	          .replace(/\bdiffuse\b/g, 'vTroikaGlyphColor');
	        // Make sure the vertex shader declares the uniform so we can grab it as a fallback
	        if (!uDiffuseRE.test(vertexShader)) {
	          vertexShader = vertexShader.replace(
	            voidMainRegExp,
	            'uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n'
	          );
	        }
	      }
	      return { vertexShader: vertexShader, fragmentShader: fragmentShader }
	    }
	  });

	  // Force transparency - TODO is this reasonable?
	  textMaterial.transparent = true;

	  Object.defineProperties(textMaterial, {
	    isTroikaTextMaterial: {value: true},

	    // WebGLShadowMap reverses the side of the shadow material by default, which fails
	    // for planes, so here we force the `shadowSide` to always match the main side.
	    shadowSide: {
	      get: function get() {
	        return this.side
	      },
	      set: function set() {
	        //no-op
	      }
	    }
	  });

	  return textMaterial
	}

	var Text = /*#__PURE__*/(function () {

	  var defaultMaterial = new MeshBasicMaterial({
	    color: 0xffffff,
	    side: DoubleSide,
	    transparent: true
	  });
	  var defaultStrokeColor = 0x808080;

	  var tempMat4 = new Matrix4();
	  var tempVec3a = new Vector3();
	  var tempVec3b = new Vector3();
	  var tempArray = [];
	  var origin = new Vector3();
	  var defaultOrient = '+x+y';

	  function first(o) {
	    return Array.isArray(o) ? o[0] : o
	  }

	  var getFlatRaycastMesh = function () {
	    var mesh = new Mesh(
	      new PlaneGeometry(1, 1),
	      defaultMaterial
	    );
	    getFlatRaycastMesh = function () { return mesh; };
	    return mesh
	  };
	  var getCurvedRaycastMesh = function () {
	    var mesh = new Mesh(
	      new PlaneGeometry(1, 1, 32, 1),
	      defaultMaterial
	    );
	    getCurvedRaycastMesh = function () { return mesh; };
	    return mesh
	  };

	  var syncStartEvent = {type: 'syncstart'};
	  var syncCompleteEvent = {type: 'synccomplete'};

	  var SYNCABLE_PROPS = [
	    'font',
	    'fontSize',
	    'letterSpacing',
	    'lineHeight',
	    'maxWidth',
	    'overflowWrap',
	    'text',
	    'direction',
	    'textAlign',
	    'textIndent',
	    'whiteSpace',
	    'anchorX',
	    'anchorY',
	    'colorRanges',
	    'sdfGlyphSize'
	  ];

	  var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
	    'material',
	    'color',
	    'depthOffset',
	    'clipRect',
	    'curveRadius',
	    'orientation',
	    'glyphGeometryDetail'
	  );



	  /**
	   * @class Text
	   *
	   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance
	   * fields (SDF).
	   */
	  var Text = /*@__PURE__*/(function (Mesh) {
	    function Text() {
	      var geometry = new GlyphsGeometry();
	      Mesh.call(this, geometry, null);

	      // === Text layout properties: === //

	      /**
	       * @member {string} text
	       * The string of text to be rendered.
	       */
	      this.text = '';

	      /**
	       * @deprecated Use `anchorX` and `anchorY` instead
	       * @member {Array<number>} anchor
	       * Defines where in the text block should correspond to the mesh's local position, as a set
	       * of horizontal and vertical percentages from 0 to 1. A value of `[0, 0]` (the default)
	       * anchors at the top-left, `[1, 1]` at the bottom-right, and `[0.5, 0.5]` centers the
	       * block at the mesh's position.
	       */
	      //this.anchor = null

	      /**
	       * @member {number|string} anchorX
	       * Defines the horizontal position in the text block that should line up with the local origin.
	       * Can be specified as a numeric x position in local units, a string percentage of the total
	       * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',
	       * or 'right'.
	       */
	      this.anchorX = 0;

	      /**
	       * @member {number|string} anchorX
	       * Defines the vertical position in the text block that should line up with the local origin.
	       * Can be specified as a numeric y position in local units (note: down is negative y), a string
	       * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:
	       * 'top', 'top-baseline', 'middle', 'bottom-baseline', or 'bottom'.
	       */
	      this.anchorY = 0;

	      /**
	       * @member {number} curveRadius
	       * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put
	       * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave
	       * curvature, while negative numbers put it behind the text for a convex curvature. The centerline
	       * will be aligned with the text's local origin; you can use `anchorX` to offset it.
	       *
	       * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane
	       * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.
	       */
	      this.curveRadius = 0;

	      /**
	       * @member {string} direction
	       * Sets the base direction for the text. The default value of "auto" will choose a direction based
	       * on the text's content according to the bidi spec. A value of "ltr" or "rtl" will force the direction.
	       */
	      this.direction = 'auto';

	      /**
	       * @member {string} font
	       * URL of a custom font to be used. Font files can be any of the formats supported by
	       * OpenType (see https://github.com/opentypejs/opentype.js).
	       * Defaults to the Roboto font loaded from Google Fonts.
	       */
	      this.font = null; //will use default from TextBuilder

	      /**
	       * @member {number} fontSize
	       * The size at which to render the font in local units; corresponds to the em-box height
	       * of the chosen `font`.
	       */
	      this.fontSize = 0.1;

	      /**
	       * @member {number} letterSpacing
	       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive
	       * numbers increase spacing and negative numbers decrease it.
	       */
	      this.letterSpacing = 0;

	      /**
	       * @member {number|string} lineHeight
	       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'
	       * which chooses a reasonable height based on the chosen font's ascender/descender metrics.
	       */
	      this.lineHeight = 'normal';

	      /**
	       * @member {number} maxWidth
	       * The maximum width of the text block, above which text may start wrapping according to the
	       * `whiteSpace` and `overflowWrap` properties.
	       */
	      this.maxWidth = Infinity;

	      /**
	       * @member {string} overflowWrap
	       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`
	       * to break at whitespace characters, or `'break-word'` to allow breaking within words.
	       * Defaults to `'normal'`.
	       */
	      this.overflowWrap = 'normal';

	      /**
	       * @member {string} textAlign
	       * The horizontal alignment of each line of text within the overall text bounding box.
	       */
	      this.textAlign = 'left';

	      /**
	       * @member {number} textIndent
	       * Indentation for the first character of a line; see CSS `text-indent`.
	       */
	      this.textIndent = 0;

	      /**
	       * @member {string} whiteSpace
	       * Defines whether text should wrap when a line reaches the `maxWidth`. Can
	       * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,
	       * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to
	       * manually break lines, making it behave more like `'pre-wrap'` does in CSS.
	       */
	      this.whiteSpace = 'normal';


	      // === Presentation properties: === //

	      /**
	       * @member {THREE.Material} material
	       * Defines a _base_ material to be used when rendering the text. This material will be
	       * automatically replaced with a material derived from it, that adds shader code to
	       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.
	       * By default it will derive from a simple white MeshBasicMaterial, but you can use any
	       * of the other mesh materials to gain other features like lighting, texture maps, etc.
	       *
	       * Also see the `color` shortcut property.
	       */
	      this.material = null;

	      /**
	       * @member {string|number|THREE.Color} color
	       * This is a shortcut for setting the `color` of the text's material. You can use this
	       * if you don't want to specify a whole custom `material`. Also, if you do use a custom
	       * `material`, this color will only be used for this particuar Text instance, even if
	       * that same material instance is shared across multiple Text objects.
	       */
	      this.color = null;

	      /**
	       * @member {object|null} colorRanges
	       * WARNING: This API is experimental and may change.
	       * This allows more fine-grained control of colors for individual or ranges of characters,
	       * taking precedence over the material's `color`. Its format is an Object whose keys each
	       * define a starting character index for a range, and whose values are the color for each
	       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or
	       * any of the strings accepted by `THREE.Color`.
	       */
	      this.colorRanges = null;

	      /**
	       * @member {number|string} outlineWidth
	       * WARNING: This API is experimental and may change.
	       * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.
	       * Can be specified as either an absolute number in local units, or as a percentage string e.g.
	       * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means
	       * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.
	       */
	      this.outlineWidth = 0;

	      /**
	       * @member {string|number|THREE.Color} outlineColor
	       * WARNING: This API is experimental and may change.
	       * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
	       * Defaults to black.
	       */
	      this.outlineColor = 0x000000;

	      /**
	       * @member {number} outlineOpacity
	       * WARNING: This API is experimental and may change.
	       * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
	       * Defaults to `1`.
	       */
	      this.outlineOpacity = 1;

	      /**
	       * @member {number|string} outlineBlur
	       * WARNING: This API is experimental and may change.
	       * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is
	       * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.
	       * Can be specified as either an absolute number in local units, or as a percentage string e.g.
	       * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`.
	       */
	      this.outlineBlur = 0;

	      /**
	       * @member {number|string} outlineOffsetX
	       * WARNING: This API is experimental and may change.
	       * A horizontal offset for the text outline.
	       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	       * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	       */
	      this.outlineOffsetX = 0;

	      /**
	       * @member {number|string} outlineOffsetY
	       * WARNING: This API is experimental and may change.
	       * A vertical offset for the text outline.
	       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	       * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	       */
	      this.outlineOffsetY = 0;

	      /**
	       * @member {number|string} strokeWidth
	       * WARNING: This API is experimental and may change.
	       * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.
	       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	       * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	       */
	      this.strokeWidth = 0;

	      /**
	       * @member {string|number|THREE.Color} strokeColor
	       * WARNING: This API is experimental and may change.
	       * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.
	       */
	      this.strokeColor = defaultStrokeColor;

	      /**
	       * @member {number} strokeOpacity
	       * WARNING: This API is experimental and may change.
	       * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.
	       */
	      this.strokeOpacity = 1;

	      /**
	       * @member {number} fillOpacity
	       * WARNING: This API is experimental and may change.
	       * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows
	       * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the
	       * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.
	       */
	      this.fillOpacity = 1;

	      /**
	       * @member {number} depthOffset
	       * This is a shortcut for setting the material's `polygonOffset` and related properties,
	       * which can be useful in preventing z-fighting when this text is laid on top of another
	       * plane in the scene. Positive numbers are further from the camera, negatives closer.
	       */
	      this.depthOffset = 0;

	      /**
	       * @member {Array<number>} clipRect
	       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all
	       * pixels will be discarded. This can be used for example to clip overflowing text when
	       * `whiteSpace='nowrap'`.
	       */
	      this.clipRect = null;

	      /**
	       * @member {string} orientation
	       * Defines the axis plane on which the text should be laid out when the mesh has no extra
	       * rotation transform. It is specified as a string with two axes: the horizontal axis with
	       * positive pointing right, and the vertical axis with positive pointing up. By default this
	       * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y
	       * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's
	       * top toward negative z and facing positive y.
	       */
	      this.orientation = defaultOrient;

	      /**
	       * @member {number} glyphGeometryDetail
	       * Controls number of vertical/horizontal segments that make up each glyph's rectangular
	       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom
	       * vertex shader effects, for example.
	       */
	      this.glyphGeometryDetail = 1;

	      /**
	       * @member {number|null} sdfGlyphSize
	       * The size of each glyph's SDF (signed distance field) used for rendering. This must be a
	       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality
	       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing
	       * the sharpness of corners and preventing loss of very thin lines, at the expense of
	       * increased memory footprint and longer SDF generation time.
	       */
	      this.sdfGlyphSize = null;

	      this.debugSDF = false;
	    }

	    if ( Mesh ) Text.__proto__ = Mesh;
	    Text.prototype = Object.create( Mesh && Mesh.prototype );
	    Text.prototype.constructor = Text;

	    var prototypeAccessors = { textRenderInfo: { configurable: true },material: { configurable: true },glyphGeometryDetail: { configurable: true },curveRadius: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };

	    /**
	     * Updates the text rendering according to the current text-related configuration properties.
	     * This is an async process, so you can pass in a callback function to be executed when it
	     * finishes.
	     * @param {function} [callback]
	     */
	    Text.prototype.sync = function sync (callback) {
	      var this$1 = this;

	      if (this._needsSync) {
	        this._needsSync = false;

	        // If there's another sync still in progress, queue
	        if (this._isSyncing) {
	          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
	        } else {
	          this._isSyncing = true;
	          this.dispatchEvent(syncStartEvent);

	          getTextRenderInfo({
	            text: this.text,
	            font: this.font,
	            fontSize: this.fontSize || 0.1,
	            letterSpacing: this.letterSpacing || 0,
	            lineHeight: this.lineHeight || 'normal',
	            maxWidth: this.maxWidth,
	            direction: this.direction || 'auto',
	            textAlign: this.textAlign,
	            textIndent: this.textIndent,
	            whiteSpace: this.whiteSpace,
	            overflowWrap: this.overflowWrap,
	            anchorX: this.anchorX,
	            anchorY: this.anchorY,
	            colorRanges: this.colorRanges,
	            includeCaretPositions: true, //TODO parameterize
	            sdfGlyphSize: this.sdfGlyphSize
	          }, function (textRenderInfo) {
	            this$1._isSyncing = false;

	            // Save result for later use in onBeforeRender
	            this$1._textRenderInfo = textRenderInfo;

	            // Update the geometry attributes
	            this$1.geometry.updateGlyphs(
	              textRenderInfo.glyphBounds,
	              textRenderInfo.glyphAtlasIndices,
	              textRenderInfo.blockBounds,
	              textRenderInfo.chunkedBounds,
	              textRenderInfo.glyphColors
	            );

	            // If we had extra sync requests queued up, kick it off
	            var queued = this$1._queuedSyncs;
	            if (queued) {
	              this$1._queuedSyncs = null;
	              this$1._needsSync = true;
	              this$1.sync(function () {
	                queued.forEach(function (fn) { return fn && fn(); });
	              });
	            }

	            this$1.dispatchEvent(syncCompleteEvent);
	            if (callback) {
	              callback();
	            }
	          });
	        }
	      }
	    };

	    /**
	     * Initiate a sync if needed - note it won't complete until next frame at the
	     * earliest so if possible it's a good idea to call sync() manually as soon as
	     * all the properties have been set.
	     * @override
	     */
	    Text.prototype.onBeforeRender = function onBeforeRender (renderer, scene, camera, geometry, material, group) {
	      this.sync();

	      // This may not always be a text material, e.g. if there's a scene.overrideMaterial present
	      if (material.isTroikaTextMaterial) {
	        this._prepareForRender(material);
	      }
	    };

	    /**
	     * Shortcut to dispose the geometry specific to this instance.
	     * Note: we don't also dispose the derived material here because if anything else is
	     * sharing the same base material it will result in a pause next frame as the program
	     * is recompiled. Instead users can dispose the base material manually, like normal,
	     * and we'll also dispose the derived material at that time.
	     */
	    Text.prototype.dispose = function dispose () {
	      this.geometry.dispose();
	    };

	    /**
	     * @property {TroikaTextRenderInfo|null} textRenderInfo
	     * @readonly
	     * The current processed rendering data for this TextMesh, returned by the TextBuilder after
	     * a `sync()` call. This will be `null` initially, and may be stale for a short period until
	     * the asynchrous `sync()` process completes.
	     */
	    prototypeAccessors.textRenderInfo.get = function () {
	      return this._textRenderInfo || null
	    };

	    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
	    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
	    prototypeAccessors.material.get = function () {
	      var derivedMaterial = this._derivedMaterial;
	      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
	      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
	        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
	        // dispose the derived material when its base material is disposed:
	        baseMaterial.addEventListener('dispose', function onDispose() {
	          baseMaterial.removeEventListener('dispose', onDispose);
	          derivedMaterial.dispose();
	        });
	      }
	      // If text outline is configured, render it as a preliminary draw using Three's multi-material
	      // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi
	      // materials ensures the layers are always rendered consecutively in a consistent order.
	      // Each layer will trigger onBeforeRender with the appropriate material.
	      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
	        var outlineMaterial = derivedMaterial._outlineMtl;
	        if (!outlineMaterial) {
	          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
	            id: {value: derivedMaterial.id + 0.1}
	          });
	          outlineMaterial.isTextOutlineMaterial = true;
	          outlineMaterial.depthWrite = false;
	          outlineMaterial.map = null; //???
	          derivedMaterial.addEventListener('dispose', function onDispose() {
	            derivedMaterial.removeEventListener('dispose', onDispose);
	            outlineMaterial.dispose();
	          });
	        }
	        return [
	          outlineMaterial,
	          derivedMaterial
	        ]
	      } else {
	        return derivedMaterial
	      }
	    };
	    prototypeAccessors.material.set = function (baseMaterial) {
	      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation
	        this._derivedMaterial = baseMaterial;
	        this._baseMaterial = baseMaterial.baseMaterial;
	      } else {
	        this._baseMaterial = baseMaterial;
	      }
	    };

	    prototypeAccessors.glyphGeometryDetail.get = function () {
	      return this.geometry.detail
	    };
	    prototypeAccessors.glyphGeometryDetail.set = function (detail) {
	      this.geometry.detail = detail;
	    };

	    prototypeAccessors.curveRadius.get = function () {
	      return this.geometry.curveRadius
	    };
	    prototypeAccessors.curveRadius.set = function (r) {
	      this.geometry.curveRadius = r;
	    };

	    // Create and update material for shadows upon request:
	    prototypeAccessors.customDepthMaterial.get = function () {
	      return first(this.material).getDepthMaterial()
	    };
	    prototypeAccessors.customDistanceMaterial.get = function () {
	      return first(this.material).getDistanceMaterial()
	    };

	    Text.prototype._prepareForRender = function _prepareForRender (material) {
	      var isOutline = material.isTextOutlineMaterial;
	      var uniforms = material.uniforms;
	      var textInfo = this.textRenderInfo;
	      if (textInfo) {
	        var sdfTexture = textInfo.sdfTexture;
	        var blockBounds = textInfo.blockBounds;
	        uniforms.uTroikaSDFTexture.value = sdfTexture;
	        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
	        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
	        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
	        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
	        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;

	        var distanceOffset = 0;
	        var blurRadius = 0;
	        var strokeWidth = 0;
	        var fillOpacity;
	        var strokeOpacity;
	        var strokeColor;
	        var offsetX = 0;
	        var offsetY = 0;

	        if (isOutline) {
	          var ref = this;
	          var outlineWidth = ref.outlineWidth;
	          var outlineOffsetX = ref.outlineOffsetX;
	          var outlineOffsetY = ref.outlineOffsetY;
	          var outlineBlur = ref.outlineBlur;
	          var outlineOpacity = ref.outlineOpacity;
	          distanceOffset = this._parsePercent(outlineWidth) || 0;
	          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
	          fillOpacity = outlineOpacity;
	          offsetX = this._parsePercent(outlineOffsetX) || 0;
	          offsetY = this._parsePercent(outlineOffsetY) || 0;
	        } else {
	          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
	          if (strokeWidth) {
	            strokeColor = this.strokeColor;
	            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
	            strokeOpacity = this.strokeOpacity;
	            if (strokeOpacity == null) { strokeOpacity = 1; }
	          }
	          fillOpacity = this.fillOpacity;
	        }

	        uniforms.uTroikaDistanceOffset.value = distanceOffset;
	        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
	        uniforms.uTroikaBlurRadius.value = blurRadius;
	        uniforms.uTroikaStrokeWidth.value = strokeWidth;
	        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
	        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
	        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;

	        var clipRect = this.clipRect;
	        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
	          uniforms.uTroikaClipRect.value.fromArray(clipRect);
	        } else {
	          // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines
	          var pad = (this.fontSize || 0.1) * 100;
	          uniforms.uTroikaClipRect.value.set(
	            blockBounds[0] - pad,
	            blockBounds[1] - pad,
	            blockBounds[2] + pad,
	            blockBounds[3] + pad
	          );
	        }
	        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
	      }
	      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
	      material.polygonOffset = !!this.depthOffset;
	      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;

	      // Shortcut for setting material color via `color` prop on the mesh; this is
	      // applied only to the derived material to avoid mutating a shared base material.
	      var color = isOutline ? (this.outlineColor || 0) : this.color;

	      if (color == null) {
	        delete material.color; //inherit from base
	      } else {
	        var colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new Color());
	        if (color !== colorObj._input || typeof color === 'object') {
	          colorObj.set(colorObj._input = color);
	        }
	      }

	      // base orientation
	      var orient = this.orientation || defaultOrient;
	      if (orient !== material._orientation) {
	        var rotMat = uniforms.uTroikaOrient.value;
	        orient = orient.replace(/[^-+xyz]/g, '');
	        var match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
	        if (match) {
	          var hSign = match[1];
	          var hAxis = match[2];
	          var vSign = match[3];
	          var vAxis = match[4];
	          tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;
	          tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;
	          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
	          rotMat.setFromMatrix4(tempMat4);
	        } else {
	          rotMat.identity();
	        }
	        material._orientation = orient;
	      }
	    };

	    Text.prototype._parsePercent = function _parsePercent (value) {
	      if (typeof value === 'string') {
	        var match = value.match(/^(-?[\d.]+)%$/);
	        var pct = match ? parseFloat(match[1]) : NaN;
	        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
	      }
	      return value
	    };

	    /**
	     * Translate a point in local space to an x/y in the text plane.
	     */
	    Text.prototype.localPositionToTextCoords = function localPositionToTextCoords (position, target) {
	      if ( target === void 0 ) target = new Vector2();

	      target.copy(position); //simple non-curved case is 1:1
	      var r = this.curveRadius;
	      if (r) { //flatten the curve
	        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
	      }
	      return target
	    };

	    /**
	     * Translate a point in world space to an x/y in the text plane.
	     */
	    Text.prototype.worldPositionToTextCoords = function worldPositionToTextCoords (position, target) {
	      if ( target === void 0 ) target = new Vector2();

	      tempVec3a.copy(position);
	      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)
	    };

	    /**
	     * @override Custom raycasting to test against the whole text block's max rectangular bounds
	     * TODO is there any reason to make this more granular, like within individual line or glyph rects?
	     */
	    Text.prototype.raycast = function raycast (raycaster, intersects) {
	      var ref = this;
	      var textRenderInfo = ref.textRenderInfo;
	      var curveRadius = ref.curveRadius;
	      if (textRenderInfo) {
	        var bounds = textRenderInfo.blockBounds;
	        var raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
	        var geom = raycastMesh.geometry;
	        var ref$1 = geom.attributes;
	        var position = ref$1.position;
	        var uv = ref$1.uv;
	        for (var i = 0; i < uv.count; i++) {
	          var x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));
	          var y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));
	          var z = 0;
	          if (curveRadius) {
	            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
	            x = Math.sin(x / curveRadius) * curveRadius;
	          }
	          position.setXYZ(i, x, y, z);
	        }
	        geom.boundingSphere = this.geometry.boundingSphere;
	        geom.boundingBox = this.geometry.boundingBox;
	        raycastMesh.matrixWorld = this.matrixWorld;
	        raycastMesh.material.side = this.material.side;
	        tempArray.length = 0;
	        raycastMesh.raycast(raycaster, tempArray);
	        for (var i$1 = 0; i$1 < tempArray.length; i$1++) {
	          tempArray[i$1].object = this;
	          intersects.push(tempArray[i$1]);
	        }
	      }
	    };

	    Text.prototype.copy = function copy (source) {
	      var this$1 = this;

	      // Prevent copying the geometry reference so we don't end up sharing attributes between instances
	      var geom = this.geometry;
	      Mesh.prototype.copy.call(this, source);
	      this.geometry = geom;

	      COPYABLE_PROPS.forEach(function (prop) {
	        this$1[prop] = source[prop];
	      });
	      return this
	    };

	    Text.prototype.clone = function clone () {
	      return new this.constructor().copy(this)
	    };

	    Object.defineProperties( Text.prototype, prototypeAccessors );

	    return Text;
	  }(Mesh));


	  // Create setters for properties that affect text layout:
	  SYNCABLE_PROPS.forEach(function (prop) {
	    var privateKey = '_private_' + prop;
	    Object.defineProperty(Text.prototype, prop, {
	      get: function get() {
	        return this[privateKey]
	      },
	      set: function set(value) {
	        if (value !== this[privateKey]) {
	          this[privateKey] = value;
	          this._needsSync = true;
	        }
	      }
	    });
	  });


	  // Deprecation handler for `anchor` array:
	  var deprMsgShown = false;
	  Object.defineProperty(Text.prototype, 'anchor', {
	    get: function get() {
	      return this._deprecated_anchor
	    },
	    set: function set(val) {
	      this._deprecated_anchor = val;
	      if (!deprMsgShown) {
	        console.warn('TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead.');
	        deprMsgShown = true;
	      }
	      if (Array.isArray(val)) {
	        this.anchorX = ((+val[0] || 0) * 100) + "%";
	        this.anchorY = ((+val[1] || 0) * 100) + "%";
	      } else {
	        this.anchorX = this.anchorY = 0;
	      }
	    }
	  });

	  return Text
	})();

	//=== Utility functions for dealing with carets and selection ranges ===//

	/**
	 * @typedef {object} TextCaret
	 * @property {number} x - x position of the caret
	 * @property {number} y - y position of the caret's bottom
	 * @property {number} height - height of the caret
	 * @property {number} charIndex - the index in the original input string of this caret's target
	 *   character; the caret will be for the position _before_ that character.
	 */

	/**
	 * Given a local x/y coordinate in the text block plane, find the nearest caret position.
	 * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo
	 * @param {number} x
	 * @param {number} y
	 * @return {TextCaret | null}
	 */
	function getCaretAtPoint(textRenderInfo, x, y) {
	  var closestCaret = null;
	  var caretHeight = textRenderInfo.caretHeight;
	  var caretsByRow = groupCaretsByRow(textRenderInfo);

	  // Find nearest row by y first
	  var closestRowY = Infinity;
	  caretsByRow.forEach(function (carets, rowY) {
	    if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {
	      closestRowY = rowY;
	    }
	  });

	  // Then find closest caret by x within that row
	  caretsByRow.get(closestRowY).forEach(function (caret) {
	    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {
	      closestCaret = caret;
	    }
	  });
	  return closestCaret
	}


	var _rectsCache = new WeakMap();

	/**
	 * Given start and end character indexes, return a list of rectangles covering all the
	 * characters within that selection.
	 * @param {TroikaTextRenderInfo} textRenderInfo
	 * @param {number} start - index of the first char in the selection
	 * @param {number} end - index of the first char after the selection
	 * @return {Array<{left, top, right, bottom}> | null}
	 */
	function getSelectionRects(textRenderInfo, start, end) {
	  var rects;
	  if (textRenderInfo) {
	    // Check cache - textRenderInfo is frozen so it's safe to cache based on it
	    var prevResult = _rectsCache.get(textRenderInfo);
	    if (prevResult && prevResult.start === start && prevResult.end === end) {
	      return prevResult.rects
	    }

	    var caretPositions = textRenderInfo.caretPositions;
	    var caretHeight = textRenderInfo.caretHeight;

	    // Normalize
	    if (end < start) {
	      var s = start;
	      start = end;
	      end = s;
	    }
	    start = Math.max(start, 0);
	    end = Math.min(end, caretPositions.length + 1);

	    // Build list of rects, expanding the current rect for all characters in a run and starting
	    // a new rect whenever reaching a new line or a new bidi direction
	    rects = [];
	    var currentRect = null;
	    for (var i = start; i < end; i++) {
	      var x1 = caretPositions[i * 3];
	      var x2 = caretPositions[i * 3 + 1];
	      var left = Math.min(x1, x2);
	      var right = Math.max(x1, x2);
	      var bottom = caretPositions[i * 3 + 2];
	      if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {
	        currentRect = {
	          left: Infinity,
	          right: -Infinity,
	          bottom: bottom,
	          top: bottom + caretHeight
	        };
	        rects.push(currentRect);
	      }
	      currentRect.left = Math.min(left, currentRect.left);
	      currentRect.right = Math.max(right, currentRect.right);
	    }

	    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs
	    rects.sort(function (a, b) { return b.bottom - a.bottom || a.left - b.left; });
	    for (var i$1 = rects.length - 1; i$1-- > 0;) {
	      var rectA = rects[i$1];
	      var rectB = rects[i$1 + 1];
	      if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {
	        rectB.left = Math.min(rectB.left, rectA.left);
	        rectB.right = Math.max(rectB.right, rectA.right);
	        rects.splice(i$1, 1);
	      }
	    }

	    _rectsCache.set(textRenderInfo, {start: start, end: end, rects: rects});
	  }
	  return rects
	}

	var _caretsByRowCache = new WeakMap();

	function groupCaretsByRow(textRenderInfo) {
	  // textRenderInfo is frozen so it's safe to cache based on it
	  var caretsByRow = _caretsByRowCache.get(textRenderInfo);
	  if (!caretsByRow) {
	    var caretPositions = textRenderInfo.caretPositions;
	    var caretHeight = textRenderInfo.caretHeight;
	    caretsByRow = new Map();
	    for (var i = 0; i < caretPositions.length; i += 3) {
	      var rowY = caretPositions[i + 2];
	      var rowCarets = caretsByRow.get(rowY);
	      if (!rowCarets) {
	        caretsByRow.set(rowY, rowCarets = []);
	      }
	      rowCarets.push({
	        x: caretPositions[i],
	        y: rowY,
	        height: caretHeight,
	        charIndex: i / 3
	      });
	      // Add one more caret after the final char
	      if (i + 3 >= caretPositions.length) {
	        rowCarets.push({
	          x: caretPositions[i + 1],
	          y: rowY,
	          height: caretHeight,
	          charIndex: i / 3 + 1
	        });
	      }
	    }
	  }
	  _caretsByRowCache.set(textRenderInfo, caretsByRow);
	  return caretsByRow
	}

	// Custom build of Yoga (https://yogalayout.com/) for use in troika-flex-layout.
	// Original MIT license applies: https://github.com/facebook/yoga/blob/master/LICENSE

	function yogaFactory() {
	  
	var Yoga = (function () {

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */

	  var CONSTANTS = {
	    ALIGN_COUNT: 8,
	    ALIGN_AUTO: 0,
	    ALIGN_FLEX_START: 1,
	    ALIGN_CENTER: 2,
	    ALIGN_FLEX_END: 3,
	    ALIGN_STRETCH: 4,
	    ALIGN_BASELINE: 5,
	    ALIGN_SPACE_BETWEEN: 6,
	    ALIGN_SPACE_AROUND: 7,

	    DIMENSION_COUNT: 2,
	    DIMENSION_WIDTH: 0,
	    DIMENSION_HEIGHT: 1,

	    DIRECTION_COUNT: 3,
	    DIRECTION_INHERIT: 0,
	    DIRECTION_LTR: 1,
	    DIRECTION_RTL: 2,

	    DISPLAY_COUNT: 2,
	    DISPLAY_FLEX: 0,
	    DISPLAY_NONE: 1,

	    EDGE_COUNT: 9,
	    EDGE_LEFT: 0,
	    EDGE_TOP: 1,
	    EDGE_RIGHT: 2,
	    EDGE_BOTTOM: 3,
	    EDGE_START: 4,
	    EDGE_END: 5,
	    EDGE_HORIZONTAL: 6,
	    EDGE_VERTICAL: 7,
	    EDGE_ALL: 8,

	    EXPERIMENTAL_FEATURE_COUNT: 1,
	    EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: 0,

	    FLEX_DIRECTION_COUNT: 4,
	    FLEX_DIRECTION_COLUMN: 0,
	    FLEX_DIRECTION_COLUMN_REVERSE: 1,
	    FLEX_DIRECTION_ROW: 2,
	    FLEX_DIRECTION_ROW_REVERSE: 3,

	    JUSTIFY_COUNT: 6,
	    JUSTIFY_FLEX_START: 0,
	    JUSTIFY_CENTER: 1,
	    JUSTIFY_FLEX_END: 2,
	    JUSTIFY_SPACE_BETWEEN: 3,
	    JUSTIFY_SPACE_AROUND: 4,
	    JUSTIFY_SPACE_EVENLY: 5,

	    LOG_LEVEL_COUNT: 6,
	    LOG_LEVEL_ERROR: 0,
	    LOG_LEVEL_WARN: 1,
	    LOG_LEVEL_INFO: 2,
	    LOG_LEVEL_DEBUG: 3,
	    LOG_LEVEL_VERBOSE: 4,
	    LOG_LEVEL_FATAL: 5,

	    MEASURE_MODE_COUNT: 3,
	    MEASURE_MODE_UNDEFINED: 0,
	    MEASURE_MODE_EXACTLY: 1,
	    MEASURE_MODE_AT_MOST: 2,

	    NODE_TYPE_COUNT: 2,
	    NODE_TYPE_DEFAULT: 0,
	    NODE_TYPE_TEXT: 1,

	    OVERFLOW_COUNT: 3,
	    OVERFLOW_VISIBLE: 0,
	    OVERFLOW_HIDDEN: 1,
	    OVERFLOW_SCROLL: 2,

	    POSITION_TYPE_COUNT: 2,
	    POSITION_TYPE_RELATIVE: 0,
	    POSITION_TYPE_ABSOLUTE: 1,

	    PRINT_OPTIONS_COUNT: 3,
	    PRINT_OPTIONS_LAYOUT: 1,
	    PRINT_OPTIONS_STYLE: 2,
	    PRINT_OPTIONS_CHILDREN: 4,

	    UNIT_COUNT: 4,
	    UNIT_UNDEFINED: 0,
	    UNIT_POINT: 1,
	    UNIT_PERCENT: 2,
	    UNIT_AUTO: 3,

	    WRAP_COUNT: 3,
	    WRAP_NO_WRAP: 0,
	    WRAP_WRAP: 1,
	    WRAP_WRAP_REVERSE: 2
	  };

	  var YGEnums = CONSTANTS;

	  var _extends = Object.assign || function (target) {
	  var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */



	  var Layout = function () {
	    function Layout(left, right, top, bottom, width, height) {
	      _classCallCheck(this, Layout);

	      this.left = left;
	      this.right = right;
	      this.top = top;
	      this.bottom = bottom;
	      this.width = width;
	      this.height = height;
	    }

	    _createClass(Layout, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.left, this.right, this.top, this.bottom, this.width, this.height);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        return '<Layout#' + this.left + ':' + this.right + ';' + this.top + ':' + this.bottom + ';' + this.width + ':' + this.height + '>';
	      }
	    }]);

	    return Layout;
	  }();

	  var Size = function () {
	    _createClass(Size, null, [{
	      key: 'fromJS',
	      value: function fromJS(_ref) {
	        var width = _ref.width,
	            height = _ref.height;

	        return new Size(width, height);
	      }
	    }]);

	    function Size(width, height) {
	      _classCallCheck(this, Size);

	      this.width = width;
	      this.height = height;
	    }

	    _createClass(Size, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.width, this.height);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        return '<Size#' + this.width + 'x' + this.height + '>';
	      }
	    }]);

	    return Size;
	  }();

	  var Value = function () {
	    function Value(unit, value) {
	      _classCallCheck(this, Value);

	      this.unit = unit;
	      this.value = value;
	    }

	    _createClass(Value, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.unit, this.value);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        switch (this.unit) {
	          case YGEnums.UNIT_POINT:
	            return String(this.value);
	          case YGEnums.UNIT_PERCENT:
	            return this.value + '%';
	          case YGEnums.UNIT_AUTO:
	            return 'auto';
	          default:
	            {
	              return this.value + '?';
	            }
	        }
	      }
	    }, {
	      key: 'valueOf',
	      value: function valueOf() {
	        return this.value;
	      }
	    }]);

	    return Value;
	  }();

	  var entryCommon = function (bind, lib) {
	    function patch(prototype, name, fn) {
	      var original = prototype[name];

	      prototype[name] = function () {
	        var arguments$1 = arguments;

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments$1[_key];
	        }

	        return fn.call.apply(fn, [this, original].concat(args));
	      };
	    }

	    var _arr = ['setPosition', 'setMargin', 'setFlexBasis', 'setWidth', 'setHeight', 'setMinWidth', 'setMinHeight', 'setMaxWidth', 'setMaxHeight', 'setPadding'];

	    var _loop = function _loop() {
	      var _methods;

	      var fnName = _arr[_i];
	      var methods = (_methods = {}, _defineProperty(_methods, YGEnums.UNIT_POINT, lib.Node.prototype[fnName]), _defineProperty(_methods, YGEnums.UNIT_PERCENT, lib.Node.prototype[fnName + 'Percent']), _defineProperty(_methods, YGEnums.UNIT_AUTO, lib.Node.prototype[fnName + 'Auto']), _methods);

	      patch(lib.Node.prototype, fnName, function (original) {
	        var arguments$1 = arguments;

	        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          args[_key2 - 1] = arguments$1[_key2];
	        }

	        // We patch all these functions to add support for the following calls:
	        // .setWidth(100) / .setWidth("100%") / .setWidth(.getWidth()) / .setWidth("auto")

	        var value = args.pop();
	        var unit = void 0,
	            asNumber = void 0;

	        if (value === 'auto') {
	          unit = YGEnums.UNIT_AUTO;
	          asNumber = undefined;
	        } else if (value instanceof Value) {
	          unit = value.unit;
	          asNumber = value.valueOf();
	        } else {
	          unit = typeof value === 'string' && value.endsWith('%') ? YGEnums.UNIT_PERCENT : YGEnums.UNIT_POINT;
	          asNumber = parseFloat(value);
	          if (!Number.isNaN(value) && Number.isNaN(asNumber)) {
	            throw new Error('Invalid value ' + value + ' for ' + fnName);
	          }
	        }

	        if (!methods[unit]) { throw new Error('Failed to execute "' + fnName + '": Unsupported unit \'' + value + '\''); }

	        if (asNumber !== undefined) {
	          var _methods$unit;

	          return (_methods$unit = methods[unit]).call.apply(_methods$unit, [this].concat(args, [asNumber]));
	        } else {
	          var _methods$unit2;

	          return (_methods$unit2 = methods[unit]).call.apply(_methods$unit2, [this].concat(args));
	        }
	      });
	    };

	    for (var _i = 0; _i < _arr.length; _i++) {
	      _loop();
	    }

	    patch(lib.Config.prototype, 'free', function () {
	      // Since we handle the memory allocation ourselves (via lib.Config.create),
	      // we also need to handle the deallocation
	      lib.Config.destroy(this);
	    });

	    patch(lib.Node, 'create', function (_, config) {
	      // We decide the constructor we want to call depending on the parameters
	      return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
	    });

	    patch(lib.Node.prototype, 'free', function () {
	      // Since we handle the memory allocation ourselves (via lib.Node.create),
	      // we also need to handle the deallocation
	      lib.Node.destroy(this);
	    });

	    patch(lib.Node.prototype, 'freeRecursive', function () {
	      for (var t = 0, T = this.getChildCount(); t < T; ++t) {
	        this.getChild(0).freeRecursive();
	      }
	      this.free();
	    });

	    patch(lib.Node.prototype, 'setMeasureFunc', function (original, measureFunc) {
	      // This patch is just a convenience patch, since it helps write more
	      // idiomatic source code (such as .setMeasureFunc(null))
	      // We also automatically convert the return value of the measureFunc
	      // to a Size object, so that we can return anything that has .width and
	      // .height properties
	      if (measureFunc) {
	        return original.call(this, function () {
	          return Size.fromJS(measureFunc.apply(undefined, arguments));
	        });
	      } else {
	        return this.unsetMeasureFunc();
	      }
	    });

	    patch(lib.Node.prototype, 'calculateLayout', function (original) {
	      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
	      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
	      var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : YGEnums.DIRECTION_LTR;

	      // Just a small patch to add support for the function default parameters
	      return original.call(this, width, height, direction);
	    });

	    return _extends({
	      Config: lib.Config,
	      Node: lib.Node,
	      Layout: bind('Layout', Layout),
	      Size: bind('Size', Size),
	      Value: bind('Value', Value),
	      getInstanceCount: function getInstanceCount() {
	        return lib.getInstanceCount.apply(lib, arguments);
	      }
	    }, YGEnums);
	  };

	  var $module={exports:{}};
	              (new Function('module', "!function(n,e){\"function\"==typeof define&&define.amd?define([],(function(){return e})):\"object\"==typeof module&&module.exports?module.exports=e:(n.nbind=n.nbind||{}).init=e}(this,(function(Module,cb){var Module;\"function\"==typeof Module&&(cb=Module,Module={}),Module.onRuntimeInitialized=function(n,e){return function(){n&&n.apply(this,arguments);try{Module.ccall(\"nbind_init\")}catch(n){return void e(n)}e(null,{bind:Module._nbind_value,reflect:Module.NBind.reflect,queryType:Module.NBind.queryType,toggleLightGC:Module.toggleLightGC,lib:Module})}}(Module.onRuntimeInitialized,cb),Module||(Module=(void 0!==Module?Module:null)||{});var moduleOverrides={};for(var key in Module)Module.hasOwnProperty(key)&&(moduleOverrides[key]=Module[key]);var ENVIRONMENT_IS_WEB=!1,ENVIRONMENT_IS_WORKER=!1,ENVIRONMENT_IS_NODE=!1,ENVIRONMENT_IS_SHELL=!1,nodeFS,nodePath;if(Module.ENVIRONMENT)if(\"WEB\"===Module.ENVIRONMENT)ENVIRONMENT_IS_WEB=!0;else if(\"WORKER\"===Module.ENVIRONMENT)ENVIRONMENT_IS_WORKER=!0;else if(\"NODE\"===Module.ENVIRONMENT)ENVIRONMENT_IS_NODE=!0;else{if(\"SHELL\"!==Module.ENVIRONMENT)throw new Error(\"The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.\");ENVIRONMENT_IS_SHELL=!0}else ENVIRONMENT_IS_WEB=\"object\"==typeof window,ENVIRONMENT_IS_WORKER=\"function\"==typeof importScripts,ENVIRONMENT_IS_NODE=\"object\"==typeof process&&\"function\"==typeof require&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER,ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE)Module.print||(Module.print=console.log),Module.printErr||(Module.printErr=console.warn),Module.read=function(n,e){nodeFS||(nodeFS={}(\"\")),nodePath||(nodePath={}(\"\")),n=nodePath.normalize(n);var r=nodeFS.readFileSync(n);return e?r:r.toString()},Module.readBinary=function(n){var e=Module.read(n,!0);return e.buffer||(e=new Uint8Array(e)),assert(e.buffer),e},Module.load=function(n){globalEval(read(n))},Module.thisProgram||(process.argv.length>1?Module.thisProgram=process.argv[1].replace(/\\\\/g,\"/\"):Module.thisProgram=\"unknown-program\"),Module.arguments=process.argv.slice(2),\"undefined\"!=typeof module&&(module.exports=Module),process.on(\"uncaughtException\",(function(n){if(!(n instanceof ExitStatus))throw n})),Module.inspect=function(){return\"[Emscripten Module object]\"};else if(ENVIRONMENT_IS_SHELL)Module.print||(Module.print=print),\"undefined\"!=typeof printErr&&(Module.printErr=printErr),\"undefined\"!=typeof read?Module.read=read:Module.read=function(){throw\"no read() available\"},Module.readBinary=function(n){if(\"function\"==typeof readbuffer)return new Uint8Array(readbuffer(n));var e=read(n,\"binary\");return assert(\"object\"==typeof e),e},\"undefined\"!=typeof scriptArgs?Module.arguments=scriptArgs:void 0!==arguments&&(Module.arguments=arguments),\"function\"==typeof quit&&(Module.quit=function(n,e){quit(n)});else{if(!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER)throw\"Unknown runtime environment. Where are we?\";if(Module.read=function(n){var e=new XMLHttpRequest;return e.open(\"GET\",n,!1),e.send(null),e.responseText},ENVIRONMENT_IS_WORKER&&(Module.readBinary=function(n){var e=new XMLHttpRequest;return e.open(\"GET\",n,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),Module.readAsync=function(n,e,r){var t=new XMLHttpRequest;t.open(\"GET\",n,!0),t.responseType=\"arraybuffer\",t.onload=function(){200==t.status||0==t.status&&t.response?e(t.response):r()},t.onerror=r,t.send(null)},void 0!==arguments&&(Module.arguments=arguments),\"undefined\"!=typeof console)Module.print||(Module.print=function(n){console.log(n)}),Module.printErr||(Module.printErr=function(n){console.warn(n)});else{var TRY_USE_DUMP=!1;Module.print||(Module.print=TRY_USE_DUMP&&\"undefined\"!=typeof dump?function(n){dump(n)}:function(n){})}ENVIRONMENT_IS_WORKER&&(Module.load=importScripts),void 0===Module.setWindowTitle&&(Module.setWindowTitle=function(n){document.title=n})}function globalEval(n){eval.call(null,n)}for(var key in!Module.load&&Module.read&&(Module.load=function(n){globalEval(Module.read(n))}),Module.print||(Module.print=function(){}),Module.printErr||(Module.printErr=Module.print),Module.arguments||(Module.arguments=[]),Module.thisProgram||(Module.thisProgram=\"./this.program\"),Module.quit||(Module.quit=function(n,e){throw e}),Module.print=Module.print,Module.printErr=Module.printErr,Module.preRun=[],Module.postRun=[],moduleOverrides)moduleOverrides.hasOwnProperty(key)&&(Module[key]=moduleOverrides[key]);moduleOverrides=void 0;var Runtime={setTempRet0:function(n){return tempRet0=n,n},getTempRet0:function(){return tempRet0},stackSave:function(){return STACKTOP},stackRestore:function(n){STACKTOP=n},getNativeTypeSize:function(n){switch(n){case\"i1\":case\"i8\":return 1;case\"i16\":return 2;case\"i32\":return 4;case\"i64\":return 8;case\"float\":return 4;case\"double\":return 8;default:if(\"*\"===n[n.length-1])return Runtime.QUANTUM_SIZE;if(\"i\"===n[0]){var e=parseInt(n.substr(1));return assert(e%8==0),e/8}return 0}},getNativeFieldSize:function(n){return Math.max(Runtime.getNativeTypeSize(n),Runtime.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(n,e){return\"double\"===e||\"i64\"===e?7&n&&(assert(4==(7&n)),n+=4):assert(0==(3&n)),n},getAlignSize:function(n,e,r){return r||\"i64\"!=n&&\"double\"!=n?n?Math.min(e||(n?Runtime.getNativeFieldSize(n):0),Runtime.QUANTUM_SIZE):Math.min(e,8):8},dynCall:function(n,e,r){return r&&r.length?Module[\"dynCall_\"+n].apply(null,[e].concat(r)):Module[\"dynCall_\"+n].call(null,e)},functionPointers:[],addFunction:function(n){for(var e=0;e<Runtime.functionPointers.length;e++)if(!Runtime.functionPointers[e])return Runtime.functionPointers[e]=n,2*(1+e);throw\"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.\"},removeFunction:function(n){Runtime.functionPointers[(n-2)/2]=null},warnOnce:function(n){Runtime.warnOnce.shown||(Runtime.warnOnce.shown={}),Runtime.warnOnce.shown[n]||(Runtime.warnOnce.shown[n]=1,Module.printErr(n))},funcWrappers:{},getFuncWrapper:function(n,e){if(n){assert(e),Runtime.funcWrappers[e]||(Runtime.funcWrappers[e]={});var r=Runtime.funcWrappers[e];return r[n]||(1===e.length?r[n]=function(){return Runtime.dynCall(e,n)}:2===e.length?r[n]=function(r){return Runtime.dynCall(e,n,[r])}:r[n]=function(){return Runtime.dynCall(e,n,Array.prototype.slice.call(arguments))}),r[n]}},getCompilerSetting:function(n){throw\"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work\"},stackAlloc:function(n){var e=STACKTOP;return STACKTOP=(STACKTOP=STACKTOP+n|0)+15&-16,e},staticAlloc:function(n){var e=STATICTOP;return STATICTOP=(STATICTOP=STATICTOP+n|0)+15&-16,e},dynamicAlloc:function(n){var e=HEAP32[DYNAMICTOP_PTR>>2],r=-16&(e+n+15|0);if((HEAP32[DYNAMICTOP_PTR>>2]=r,r>=TOTAL_MEMORY)&&!enlargeMemory())return HEAP32[DYNAMICTOP_PTR>>2]=e,0;return e},alignMemory:function(n,e){return n=Math.ceil(n/(e||16))*(e||16)},makeBigInt:function(n,e,r){return r?+(n>>>0)+4294967296*+(e>>>0):+(n>>>0)+4294967296*+(0|e)},GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module.Runtime=Runtime;var ABORT=0,EXITSTATUS=0,cwrap,ccall;function assert(n,e){n||abort(\"Assertion failed: \"+e)}function getCFunc(ident){var func=Module[\"_\"+ident];if(!func)try{func=eval(\"_\"+ident)}catch(n){}return assert(func,\"Cannot call unknown function \"+ident+\" (perhaps LLVM optimizations or closure removed it?)\"),func}function setValue(n,e,r,t){switch(\"*\"===(r=r||\"i8\").charAt(r.length-1)&&(r=\"i32\"),r){case\"i1\":case\"i8\":HEAP8[n>>0]=e;break;case\"i16\":HEAP16[n>>1]=e;break;case\"i32\":HEAP32[n>>2]=e;break;case\"i64\":tempI64=[e>>>0,(tempDouble=e,+Math_abs(tempDouble)>=1?tempDouble>0?(0|Math_min(+Math_floor(tempDouble/4294967296),4294967295))>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[n>>2]=tempI64[0],HEAP32[n+4>>2]=tempI64[1];break;case\"float\":HEAPF32[n>>2]=e;break;case\"double\":HEAPF64[n>>3]=e;break;default:abort(\"invalid type for setValue: \"+r)}}function getValue(n,e,r){switch(\"*\"===(e=e||\"i8\").charAt(e.length-1)&&(e=\"i32\"),e){case\"i1\":case\"i8\":return HEAP8[n>>0];case\"i16\":return HEAP16[n>>1];case\"i32\":case\"i64\":return HEAP32[n>>2];case\"float\":return HEAPF32[n>>2];case\"double\":return HEAPF64[n>>3];default:abort(\"invalid type for setValue: \"+e)}return null}!function(){var JSfuncs={stackSave:function(){Runtime.stackSave()},stackRestore:function(){Runtime.stackRestore()},arrayToC:function(n){var e=Runtime.stackAlloc(n.length);return writeArrayToMemory(n,e),e},stringToC:function(n){var e=0;if(null!=n&&0!==n){var r=1+(n.length<<2);stringToUTF8(n,e=Runtime.stackAlloc(r),r)}return e}},toC={string:JSfuncs.stringToC,array:JSfuncs.arrayToC};ccall=function(n,e,r,t,i){var u=getCFunc(n),o=[],a=0;if(t)for(var f=0;f<t.length;f++){var c=toC[r[f]];c?(0===a&&(a=Runtime.stackSave()),o[f]=c(t[f])):o[f]=t[f]}var l=u.apply(null,o);if(\"string\"===e&&(l=Pointer_stringify(l)),0!==a){if(i&&i.async)return void EmterpreterAsync.asyncFinalizers.push((function(){Runtime.stackRestore(a)}));Runtime.stackRestore(a)}return l};var sourceRegex=/^function\\s*[a-zA-Z$_0-9]*\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;function parseJSFunc(n){var e=n.toString().match(sourceRegex).slice(1);return{arguments:e[0],body:e[1],returnValue:e[2]}}var JSsource=null;function ensureJSsource(){if(!JSsource)for(var n in JSsource={},JSfuncs)JSfuncs.hasOwnProperty(n)&&(JSsource[n]=parseJSFunc(JSfuncs[n]))}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident),numericArgs=argTypes.every((function(n){return\"number\"===n})),numericRet=\"string\"!==returnType;if(numericRet&&numericArgs)return cfunc;var argNames=argTypes.map((function(n,e){return\"$\"+e})),funcstr=\"(function(\"+argNames.join(\",\")+\") {\",nargs=argTypes.length;if(!numericArgs){ensureJSsource(),funcstr+=\"var stack = \"+JSsource.stackSave.body+\";\";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(\"number\"!==type){var convertCode=JSsource[type+\"ToC\"];funcstr+=\"var \"+convertCode.arguments+\" = \"+arg+\";\",funcstr+=convertCode.body+\";\",funcstr+=arg+\"=(\"+convertCode.returnValue+\");\"}}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;if(funcstr+=\"var ret = \"+cfuncname+\"(\"+argNames.join(\",\")+\");\",!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+=\"ret = \"+strgfy+\"(ret);\"}return numericArgs||(ensureJSsource(),funcstr+=JSsource.stackRestore.body.replace(\"()\",\"(stack)\")+\";\"),funcstr+=\"return ret})\",eval(funcstr)}}(),Module.ccall=ccall,Module.cwrap=cwrap,Module.setValue=setValue,Module.getValue=getValue;var ALLOC_NORMAL=0,ALLOC_STACK=1,ALLOC_STATIC=2,ALLOC_DYNAMIC=3,ALLOC_NONE=4;function allocate(n,e,r,t){var i,u;\"number\"==typeof n?(i=!0,u=n):(i=!1,u=n.length);var o,a=\"string\"==typeof e?e:null;if(o=r==ALLOC_NONE?t:[\"function\"==typeof _malloc?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][void 0===r?ALLOC_STATIC:r](Math.max(u,a?1:e.length)),i){var f;t=o;for(assert(0==(3&o)),f=o+(-4&u);t<f;t+=4)HEAP32[t>>2]=0;for(f=o+u;t<f;)HEAP8[t++>>0]=0;return o}if(\"i8\"===a)return n.subarray||n.slice?HEAPU8.set(n,o):HEAPU8.set(new Uint8Array(n),o),o;for(var c,l,s,d=0;d<u;){var _=n[d];\"function\"==typeof _&&(_=Runtime.getFunctionIndex(_)),0!==(c=a||e[d])?(\"i64\"==c&&(c=\"i32\"),setValue(o+d,_,c),s!==c&&(l=Runtime.getNativeTypeSize(c),s=c),d+=l):d++}return o}function getMemory(n){return staticSealed?runtimeInitialized?_malloc(n):Runtime.dynamicAlloc(n):Runtime.staticAlloc(n)}function Pointer_stringify(n,e){if(0===e||!n)return\"\";for(var r,t=0,i=0;t|=r=HEAPU8[n+i>>0],(0!=r||e)&&(i++,!e||i!=e););e||(e=i);var u=\"\";if(t<128){for(var o;e>0;)o=String.fromCharCode.apply(String,HEAPU8.subarray(n,n+Math.min(e,1024))),u=u?u+o:o,n+=1024,e-=1024;return u}return Module.UTF8ToString(n)}function AsciiToString(n){for(var e=\"\";;){var r=HEAP8[n++>>0];if(!r)return e;e+=String.fromCharCode(r)}}function stringToAscii(n,e){return writeAsciiToMemory(n,e,!1)}Module.ALLOC_NORMAL=ALLOC_NORMAL,Module.ALLOC_STACK=ALLOC_STACK,Module.ALLOC_STATIC=ALLOC_STATIC,Module.ALLOC_DYNAMIC=ALLOC_DYNAMIC,Module.ALLOC_NONE=ALLOC_NONE,Module.allocate=allocate,Module.getMemory=getMemory,Module.Pointer_stringify=Pointer_stringify,Module.AsciiToString=AsciiToString,Module.stringToAscii=stringToAscii;var UTF8Decoder=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function UTF8ArrayToString(n,e){for(var r=e;n[r];)++r;if(r-e>16&&n.subarray&&UTF8Decoder)return UTF8Decoder.decode(n.subarray(e,r));for(var t,i,u,o,a,f=\"\";;){if(!(t=n[e++]))return f;if(128&t)if(i=63&n[e++],192!=(224&t))if(u=63&n[e++],224==(240&t)?t=(15&t)<<12|i<<6|u:(o=63&n[e++],240==(248&t)?t=(7&t)<<18|i<<12|u<<6|o:(a=63&n[e++],t=248==(252&t)?(3&t)<<24|i<<18|u<<12|o<<6|a:(1&t)<<30|i<<24|u<<18|o<<12|a<<6|63&n[e++])),t<65536)f+=String.fromCharCode(t);else{var c=t-65536;f+=String.fromCharCode(55296|c>>10,56320|1023&c)}else f+=String.fromCharCode((31&t)<<6|i);else f+=String.fromCharCode(t)}}function UTF8ToString(n){return UTF8ArrayToString(HEAPU8,n)}function stringToUTF8Array(n,e,r,t){if(!(t>0))return 0;for(var i=r,u=r+t-1,o=0;o<n.length;++o){var a=n.charCodeAt(o);if(a>=55296&&a<=57343&&(a=65536+((1023&a)<<10)|1023&n.charCodeAt(++o)),a<=127){if(r>=u)break;e[r++]=a}else if(a<=2047){if(r+1>=u)break;e[r++]=192|a>>6,e[r++]=128|63&a}else if(a<=65535){if(r+2>=u)break;e[r++]=224|a>>12,e[r++]=128|a>>6&63,e[r++]=128|63&a}else if(a<=2097151){if(r+3>=u)break;e[r++]=240|a>>18,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}else if(a<=67108863){if(r+4>=u)break;e[r++]=248|a>>24,e[r++]=128|a>>18&63,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}else{if(r+5>=u)break;e[r++]=252|a>>30,e[r++]=128|a>>24&63,e[r++]=128|a>>18&63,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}}return e[r]=0,r-i}function stringToUTF8(n,e,r){return stringToUTF8Array(n,HEAPU8,e,r)}function lengthBytesUTF8(n){for(var e=0,r=0;r<n.length;++r){var t=n.charCodeAt(r);t>=55296&&t<=57343&&(t=65536+((1023&t)<<10)|1023&n.charCodeAt(++r)),t<=127?++e:e+=t<=2047?2:t<=65535?3:t<=2097151?4:t<=67108863?5:6}return e}Module.UTF8ArrayToString=UTF8ArrayToString,Module.UTF8ToString=UTF8ToString,Module.stringToUTF8Array=stringToUTF8Array,Module.stringToUTF8=stringToUTF8,Module.lengthBytesUTF8=lengthBytesUTF8;var UTF16Decoder=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0,HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64,STATIC_BASE,STATICTOP,staticSealed,STACK_BASE,STACKTOP,STACK_MAX,DYNAMIC_BASE,DYNAMICTOP_PTR;function demangle(n){var e=Module.___cxa_demangle||Module.__cxa_demangle;if(e){try{var r=n.substr(1),t=lengthBytesUTF8(r)+1,i=_malloc(t);stringToUTF8(r,i,t);var u=_malloc(4),o=e(i,0,0,u);if(0===getValue(u,\"i32\")&&o)return Pointer_stringify(o)}catch(n){}finally{i&&_free(i),u&&_free(u),o&&_free(o)}return n}return Runtime.warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\"),n}function demangleAll(n){return n.replace(/__Z[\\w\\d_]+/g,(function(n){var e=demangle(n);return n===e?n:n+\" [\"+e+\"]\"}))}function jsStackTrace(){var n=new Error;if(!n.stack){try{throw new Error(0)}catch(e){n=e}if(!n.stack)return\"(no stack trace available)\"}return n.stack.toString()}function stackTrace(){var n=jsStackTrace();return Module.extraStackTrace&&(n+=\"\\n\"+Module.extraStackTrace()),demangleAll(n)}function updateGlobalBufferViews(){Module.HEAP8=HEAP8=new Int8Array(buffer),Module.HEAP16=HEAP16=new Int16Array(buffer),Module.HEAP32=HEAP32=new Int32Array(buffer),Module.HEAPU8=HEAPU8=new Uint8Array(buffer),Module.HEAPU16=HEAPU16=new Uint16Array(buffer),Module.HEAPU32=HEAPU32=new Uint32Array(buffer),Module.HEAPF32=HEAPF32=new Float32Array(buffer),Module.HEAPF64=HEAPF64=new Float64Array(buffer)}function abortOnCannotGrowMemory(){abort(\"Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \"+TOTAL_MEMORY+\", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \")}function enlargeMemory(){abortOnCannotGrowMemory()}Module.stackTrace=stackTrace,STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0,staticSealed=!1;var TOTAL_STACK=Module.TOTAL_STACK||5242880,TOTAL_MEMORY=Module.TOTAL_MEMORY||134217728;function getTotalMemory(){return TOTAL_MEMORY}if(TOTAL_MEMORY<TOTAL_STACK&&Module.printErr(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \"+TOTAL_MEMORY+\"! (TOTAL_STACK=\"+TOTAL_STACK+\")\"),buffer=Module.buffer?Module.buffer:new ArrayBuffer(TOTAL_MEMORY),updateGlobalBufferViews(),HEAP32[0]=1668509029,HEAP16[1]=25459,115!==HEAPU8[2]||99!==HEAPU8[3])throw\"Runtime error: expected the system to be little-endian!\";function callRuntimeCallbacks(n){for(;n.length>0;){var e=n.shift();if(\"function\"!=typeof e){var r=e.func;\"number\"==typeof r?void 0===e.arg?Module.dynCall_v(r):Module.dynCall_vi(r,e.arg):r(void 0===e.arg?null:e.arg)}else e()}}Module.HEAP=HEAP,Module.buffer=buffer,Module.HEAP8=HEAP8,Module.HEAP16=HEAP16,Module.HEAP32=HEAP32,Module.HEAPU8=HEAPU8,Module.HEAPU16=HEAPU16,Module.HEAPU32=HEAPU32,Module.HEAPF32=HEAPF32,Module.HEAPF64=HEAPF64;var __ATPRERUN__=[],__ATINIT__=[],__ATMAIN__=[],__ATEXIT__=[],__ATPOSTRUN__=[],runtimeInitialized=!1,runtimeExited=!1;function preRun(){if(Module.preRun)for(\"function\"==typeof Module.preRun&&(Module.preRun=[Module.preRun]);Module.preRun.length;)addOnPreRun(Module.preRun.shift());callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){runtimeInitialized||(runtimeInitialized=!0,callRuntimeCallbacks(__ATINIT__))}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__),runtimeExited=!0}function postRun(){if(Module.postRun)for(\"function\"==typeof Module.postRun&&(Module.postRun=[Module.postRun]);Module.postRun.length;)addOnPostRun(Module.postRun.shift());callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(n){__ATPRERUN__.unshift(n)}function addOnInit(n){__ATINIT__.unshift(n)}function addOnPreMain(n){__ATMAIN__.unshift(n)}function addOnExit(n){__ATEXIT__.unshift(n)}function addOnPostRun(n){__ATPOSTRUN__.unshift(n)}function intArrayFromString(n,e,r){var t=r>0?r:lengthBytesUTF8(n)+1,i=new Array(t),u=stringToUTF8Array(n,i,0,i.length);return e&&(i.length=u),i}function intArrayToString(n){for(var e=[],r=0;r<n.length;r++){var t=n[r];t>255&&(t&=255),e.push(String.fromCharCode(t))}return e.join(\"\")}function writeStringToMemory(n,e,r){var t,i;Runtime.warnOnce(\"writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!\"),r&&(i=e+lengthBytesUTF8(n),t=HEAP8[i]),stringToUTF8(n,e,1/0),r&&(HEAP8[i]=t)}function writeArrayToMemory(n,e){HEAP8.set(n,e)}function writeAsciiToMemory(n,e,r){for(var t=0;t<n.length;++t)HEAP8[e++>>0]=n.charCodeAt(t);r||(HEAP8[e>>0]=0)}if(Module.addOnPreRun=addOnPreRun,Module.addOnInit=addOnInit,Module.addOnPreMain=addOnPreMain,Module.addOnExit=addOnExit,Module.addOnPostRun=addOnPostRun,Module.intArrayFromString=intArrayFromString,Module.intArrayToString=intArrayToString,Module.writeStringToMemory=writeStringToMemory,Module.writeArrayToMemory=writeArrayToMemory,Module.writeAsciiToMemory=writeAsciiToMemory,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(n,e){var r=65535&n,t=65535&e;return r*t+((n>>>16)*t+r*(e>>>16)<<16)|0}),Math.imul=Math.imul,!Math.fround){var froundBuffer=new Float32Array(1);Math.fround=function(n){return froundBuffer[0]=n,froundBuffer[0]}}Math.fround=Math.fround,Math.clz32||(Math.clz32=function(n){n>>>=0;for(var e=0;e<32;e++)if(n&1<<31-e)return e;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(n){return n<0?Math.ceil(n):Math.floor(n)}),Math.trunc=Math.trunc;var Math_abs=Math.abs,Math_cos=Math.cos,Math_sin=Math.sin,Math_tan=Math.tan,Math_acos=Math.acos,Math_asin=Math.asin,Math_atan=Math.atan,Math_atan2=Math.atan2,Math_exp=Math.exp,Math_log=Math.log,Math_sqrt=Math.sqrt,Math_ceil=Math.ceil,Math_floor=Math.floor,Math_pow=Math.pow,Math_imul=Math.imul,Math_fround=Math.fround,Math_round=Math.round,Math_min=Math.min,Math_clz32=Math.clz32,Math_trunc=Math.trunc,runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function getUniqueRunDependency(n){return n}function addRunDependency(n){runDependencies++,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies)}function removeRunDependency(n){if(runDependencies--,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies),0==runDependencies&&(null!==runDependencyWatcher&&(clearInterval(runDependencyWatcher),runDependencyWatcher=null),dependenciesFulfilled)){var e=dependenciesFulfilled;dependenciesFulfilled=null,e()}}Module.addRunDependency=addRunDependency,Module.removeRunDependency=removeRunDependency,Module.preloadedImages={},Module.preloadedAudios={};var ASM_CONSTS=[function(n,e,r,t,i,u,o,a){return _nbind.callbackSignatureList[n].apply(this,arguments)}];function _emscripten_asm_const_iiiiiiii(n,e,r,t,i,u,o,a){return ASM_CONSTS[n](e,r,t,i,u,o,a)}function _emscripten_asm_const_iiiii(n,e,r,t,i){return ASM_CONSTS[n](e,r,t,i)}function _emscripten_asm_const_iiidddddd(n,e,r,t,i,u,o,a,f){return ASM_CONSTS[n](e,r,t,i,u,o,a,f)}function _emscripten_asm_const_iiididi(n,e,r,t,i,u,o){return ASM_CONSTS[n](e,r,t,i,u,o)}function _emscripten_asm_const_iiii(n,e,r,t){return ASM_CONSTS[n](e,r,t)}function _emscripten_asm_const_iiiid(n,e,r,t,i){return ASM_CONSTS[n](e,r,t,i)}function _emscripten_asm_const_iiiiii(n,e,r,t,i,u){return ASM_CONSTS[n](e,r,t,i,u)}STATIC_BASE=Runtime.GLOBAL_BASE,STATICTOP=STATIC_BASE+12800,__ATINIT__.push({func:function(){__GLOBAL__sub_I_Yoga_cpp()}},{func:function(){__GLOBAL__sub_I_nbind_cc()}},{func:function(){__GLOBAL__sub_I_common_cc()}},{func:function(){__GLOBAL__sub_I_Binding_cc()}}),allocate([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,192,127,0,0,192,127,3,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,3,0,0,0,0,0,192,127,3,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,128,191,0,0,128,191,0,0,192,127,0,0,0,0,0,0,0,0,0,0,128,63,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,190,12,0,0,200,12,0,0,208,12,0,0,216,12,0,0,230,12,0,0,242,12,0,0,1,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,192,127,3,0,0,0,180,45,0,0,181,45,0,0,182,45,0,0,181,45,0,0,182,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,1,0,0,0,4,0,0,0,183,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,184,45,0,0,185,45,0,0,181,45,0,0,181,45,0,0,182,45,0,0,186,45,0,0,185,45,0,0,148,4,0,0,3,0,0,0,187,45,0,0,164,4,0,0,188,45,0,0,2,0,0,0,189,45,0,0,164,4,0,0,188,45,0,0,185,45,0,0,164,4,0,0,185,45,0,0,164,4,0,0,188,45,0,0,181,45,0,0,182,45,0,0,181,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,5,0,0,0,6,0,0,0,1,0,0,0,7,0,0,0,183,45,0,0,182,45,0,0,181,45,0,0,190,45,0,0,190,45,0,0,182,45,0,0,182,45,0,0,185,45,0,0,181,45,0,0,185,45,0,0,182,45,0,0,181,45,0,0,185,45,0,0,182,45,0,0,185,45,0,0,48,5,0,0,3,0,0,0,56,5,0,0,1,0,0,0,189,45,0,0,185,45,0,0,164,4,0,0,76,5,0,0,2,0,0,0,191,45,0,0,186,45,0,0,182,45,0,0,185,45,0,0,192,45,0,0,185,45,0,0,182,45,0,0,186,45,0,0,185,45,0,0,76,5,0,0,76,5,0,0,136,5,0,0,182,45,0,0,181,45,0,0,2,0,0,0,190,45,0,0,136,5,0,0,56,19,0,0,156,5,0,0,2,0,0,0,184,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,8,0,0,0,9,0,0,0,1,0,0,0,10,0,0,0,204,5,0,0,181,45,0,0,181,45,0,0,2,0,0,0,180,45,0,0,204,5,0,0,2,0,0,0,195,45,0,0,236,5,0,0,97,19,0,0,198,45,0,0,211,45,0,0,212,45,0,0,213,45,0,0,214,45,0,0,215,45,0,0,188,45,0,0,182,45,0,0,216,45,0,0,217,45,0,0,218,45,0,0,219,45,0,0,192,45,0,0,181,45,0,0,0,0,0,0,185,45,0,0,110,19,0,0,186,45,0,0,115,19,0,0,221,45,0,0,120,19,0,0,148,4,0,0,132,19,0,0,96,6,0,0,145,19,0,0,222,45,0,0,164,19,0,0,223,45,0,0,173,19,0,0,0,0,0,0,3,0,0,0,104,6,0,0,1,0,0,0,187,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,11,0,0,0,12,0,0,0,1,0,0,0,13,0,0,0,185,45,0,0,224,45,0,0,164,6,0,0,188,45,0,0,172,6,0,0,180,6,0,0,2,0,0,0,188,6,0,0,7,0,0,0,224,45,0,0,7,0,0,0,164,6,0,0,1,0,0,0,213,45,0,0,185,45,0,0,224,45,0,0,172,6,0,0,185,45,0,0,224,45,0,0,164,6,0,0,185,45,0,0,224,45,0,0,211,45,0,0,211,45,0,0,222,45,0,0,211,45,0,0,224,45,0,0,222,45,0,0,211,45,0,0,224,45,0,0,172,6,0,0,222,45,0,0,211,45,0,0,224,45,0,0,188,45,0,0,222,45,0,0,211,45,0,0,40,7,0,0,188,45,0,0,2,0,0,0,224,45,0,0,185,45,0,0,188,45,0,0,188,45,0,0,188,45,0,0,188,45,0,0,222,45,0,0,224,45,0,0,148,4,0,0,185,45,0,0,148,4,0,0,148,4,0,0,148,4,0,0,148,4,0,0,148,4,0,0,185,45,0,0,164,6,0,0,148,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,15,0,0,0,1,0,0,0,16,0,0,0,148,7,0,0,2,0,0,0,225,45,0,0,183,45,0,0,188,45,0,0,168,7,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,234,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,148,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,2,0,0,0,242,45,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,111,117,108,100,32,110,111,116,32,97,108,108,111,99,97,116,101,32,109,101,109,111,114,121,32,102,111,114,32,110,111,100,101,0,67,97,110,110,111,116,32,114,101,115,101,116,32,97,32,110,111,100,101,32,119,104,105,99,104,32,115,116,105,108,108,32,104,97,115,32,99,104,105,108,100,114,101,110,32,97,116,116,97,99,104,101,100,0,67,97,110,110,111,116,32,114,101,115,101,116,32,97,32,110,111,100,101,32,115,116,105,108,108,32,97,116,116,97,99,104,101,100,32,116,111,32,97,32,112,97,114,101,110,116,0,67,111,117,108,100,32,110,111,116,32,97,108,108,111,99,97,116,101,32,109,101,109,111,114,121,32,102,111,114,32,99,111,110,102,105,103,0,67,97,110,110,111,116,32,115,101,116,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,58,32,78,111,100,101,115,32,119,105,116,104,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,32,99,97,110,110,111,116,32,104,97,118,101,32,99,104,105,108,100,114,101,110,46,0,67,104,105,108,100,32,97,108,114,101,97,100,121,32,104,97,115,32,97,32,112,97,114,101,110,116,44,32,105,116,32,109,117,115,116,32,98,101,32,114,101,109,111,118,101,100,32,102,105,114,115,116,46,0,67,97,110,110,111,116,32,97,100,100,32,99,104,105,108,100,58,32,78,111,100,101,115,32,119,105,116,104,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,32,99,97,110,110,111,116,32,104,97,118,101,32,99,104,105,108,100,114,101,110,46,0,79,110,108,121,32,108,101,97,102,32,110,111,100,101,115,32,119,105,116,104,32,99,117,115,116,111,109,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,115,104,111,117,108,100,32,109,97,110,117,97,108,108,121,32,109,97,114,107,32,116,104,101,109,115,101,108,118,101,115,32,97,115,32,100,105,114,116,121,0,67,97,110,110,111,116,32,103,101,116,32,108,97,121,111,117,116,32,112,114,111,112,101,114,116,105,101,115,32,111,102,32,109,117,108,116,105,45,101,100,103,101,32,115,104,111,114,116,104,97,110,100,115,0,37,115,37,100,46,123,91,115,107,105,112,112,101,100,93,32,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,97,119,58,32,37,102,32,97,104,58,32,37,102,32,61,62,32,100,58,32,40,37,102,44,32,37,102,41,32,37,115,10,0,37,115,37,100,46,123,37,115,0,42,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,97,119,58,32,37,102,32,97,104,58,32,37,102,32,37,115,10,0,37,115,37,100,46,125,37,115,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,100,58,32,40,37,102,44,32,37,102,41,32,37,115,10,0,79,117,116,32,111,102,32,99,97,99,104,101,32,101,110,116,114,105,101,115,33,10,0,83,99,97,108,101,32,102,97,99,116,111,114,32,115,104,111,117,108,100,32,110,111,116,32,98,101,32,108,101,115,115,32,116,104,97,110,32,122,101,114,111,0,105,110,105,116,105,97,108,0,37,115,10,0,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0,85,78,68,69,70,73,78,69,68,0,69,88,65,67,84,76,89,0,65,84,95,77,79,83,84,0,76,65,89,95,85,78,68,69,70,73,78,69,68,0,76,65,89,95,69,88,65,67,84,76,89,0,76,65,89,95,65,84,95,77,79,83,84,0,97,118,97,105,108,97,98,108,101,87,105,100,116,104,32,105,115,32,105,110,100,101,102,105,110,105,116,101,32,115,111,32,119,105,100,116,104,77,101,97,115,117,114,101,77,111,100,101,32,109,117,115,116,32,98,101,32,89,71,77,101,97,115,117,114,101,77,111,100,101,85,110,100,101,102,105,110,101,100,0,97,118,97,105,108,97,98,108,101,72,101,105,103,104,116,32,105,115,32,105,110,100,101,102,105,110,105,116,101,32,115,111,32,104,101,105,103,104,116,77,101,97,115,117,114,101,77,111,100,101,32,109,117,115,116,32,98,101,32,89,71,77,101,97,115,117,114,101,77,111,100,101,85,110,100,101,102,105,110,101,100,0,102,108,101,120,0,115,116,114,101,116,99,104,0,109,117,108,116,105,108,105,110,101,45,115,116,114,101,116,99,104,0,69,120,112,101,99,116,101,100,32,110,111,100,101,32,116,111,32,104,97,118,101,32,99,117,115,116,111,109,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,0,109,101,97,115,117,114,101,0,69,120,112,101,99,116,32,99,117,115,116,111,109,32,98,97,115,101,108,105,110,101,32,102,117,110,99,116,105,111,110,32,116,111,32,110,111,116,32,114,101,116,117,114,110,32,78,97,78,0,97,98,115,45,109,101,97,115,117,114,101,0,97,98,115,45,108,97,121,111,117,116,0,78,111,100,101,0,99,114,101,97,116,101,68,101,102,97,117,108,116,0,99,114,101,97,116,101,87,105,116,104,67,111,110,102,105,103,0,100,101,115,116,114,111,121,0,114,101,115,101,116,0,99,111,112,121,83,116,121,108,101,0,115,101,116,80,111,115,105,116,105,111,110,84,121,112,101,0,115,101,116,80,111,115,105,116,105,111,110,0,115,101,116,80,111,115,105,116,105,111,110,80,101,114,99,101,110,116,0,115,101,116,65,108,105,103,110,67,111,110,116,101,110,116,0,115,101,116,65,108,105,103,110,73,116,101,109,115,0,115,101,116,65,108,105,103,110,83,101,108,102,0,115,101,116,70,108,101,120,68,105,114,101,99,116,105,111,110,0,115,101,116,70,108,101,120,87,114,97,112,0,115,101,116,74,117,115,116,105,102,121,67,111,110,116,101,110,116,0,115,101,116,77,97,114,103,105,110,0,115,101,116,77,97,114,103,105,110,80,101,114,99,101,110,116,0,115,101,116,77,97,114,103,105,110,65,117,116,111,0,115,101,116,79,118,101,114,102,108,111,119,0,115,101,116,68,105,115,112,108,97,121,0,115,101,116,70,108,101,120,0,115,101,116,70,108,101,120,66,97,115,105,115,0,115,101,116,70,108,101,120,66,97,115,105,115,80,101,114,99,101,110,116,0,115,101,116,70,108,101,120,71,114,111,119,0,115,101,116,70,108,101,120,83,104,114,105,110,107,0,115,101,116,87,105,100,116,104,0,115,101,116,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,87,105,100,116,104,65,117,116,111,0,115,101,116,72,101,105,103,104,116,0,115,101,116,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,72,101,105,103,104,116,65,117,116,111,0,115,101,116,77,105,110,87,105,100,116,104,0,115,101,116,77,105,110,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,77,105,110,72,101,105,103,104,116,0,115,101,116,77,105,110,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,77,97,120,87,105,100,116,104,0,115,101,116,77,97,120,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,77,97,120,72,101,105,103,104,116,0,115,101,116,77,97,120,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,65,115,112,101,99,116,82,97,116,105,111,0,115,101,116,66,111,114,100,101,114,0,115,101,116,80,97,100,100,105,110,103,0,115,101,116,80,97,100,100,105,110,103,80,101,114,99,101,110,116,0,103,101,116,80,111,115,105,116,105,111,110,84,121,112,101,0,103,101,116,80,111,115,105,116,105,111,110,0,103,101,116,65,108,105,103,110,67,111,110,116,101,110,116,0,103,101,116,65,108,105,103,110,73,116,101,109,115,0,103,101,116,65,108,105,103,110,83,101,108,102,0,103,101,116,70,108,101,120,68,105,114,101,99,116,105,111,110,0,103,101,116,70,108,101,120,87,114,97,112,0,103,101,116,74,117,115,116,105,102,121,67,111,110,116,101,110,116,0,103,101,116,77,97,114,103,105,110,0,103,101,116,70,108,101,120,66,97,115,105,115,0,103,101,116,70,108,101,120,71,114,111,119,0,103,101,116,70,108,101,120,83,104,114,105,110,107,0,103,101,116,87,105,100,116,104,0,103,101,116,72,101,105,103,104,116,0,103,101,116,77,105,110,87,105,100,116,104,0,103,101,116,77,105,110,72,101,105,103,104,116,0,103,101,116,77,97,120,87,105,100,116,104,0,103,101,116,77,97,120,72,101,105,103,104,116,0,103,101,116,65,115,112,101,99,116,82,97,116,105,111,0,103,101,116,66,111,114,100,101,114,0,103,101,116,79,118,101,114,102,108,111,119,0,103,101,116,68,105,115,112,108,97,121,0,103,101,116,80,97,100,100,105,110,103,0,105,110,115,101,114,116,67,104,105,108,100,0,114,101,109,111,118,101,67,104,105,108,100,0,103,101,116,67,104,105,108,100,67,111,117,110,116,0,103,101,116,80,97,114,101,110,116,0,103,101,116,67,104,105,108,100,0,115,101,116,77,101,97,115,117,114,101,70,117,110,99,0,117,110,115,101,116,77,101,97,115,117,114,101,70,117,110,99,0,109,97,114,107,68,105,114,116,121,0,105,115,68,105,114,116,121,0,99,97,108,99,117,108,97,116,101,76,97,121,111,117,116,0,103,101,116,67,111,109,112,117,116,101,100,76,101,102,116,0,103,101,116,67,111,109,112,117,116,101,100,82,105,103,104,116,0,103,101,116,67,111,109,112,117,116,101,100,84,111,112,0,103,101,116,67,111,109,112,117,116,101,100,66,111,116,116,111,109,0,103,101,116,67,111,109,112,117,116,101,100,87,105,100,116,104,0,103,101,116,67,111,109,112,117,116,101,100,72,101,105,103,104,116,0,103,101,116,67,111,109,112,117,116,101,100,76,97,121,111,117,116,0,103,101,116,67,111,109,112,117,116,101,100,77,97,114,103,105,110,0,103,101,116,67,111,109,112,117,116,101,100,66,111,114,100,101,114,0,103,101,116,67,111,109,112,117,116,101,100,80,97,100,100,105,110,103,0,67,111,110,102,105,103,0,99,114,101,97,116,101,0,115,101,116,69,120,112,101,114,105,109,101,110,116,97,108,70,101,97,116,117,114,101,69,110,97,98,108,101,100,0,115,101,116,80,111,105,110,116,83,99,97,108,101,70,97,99,116,111,114,0,105,115,69,120,112,101,114,105,109,101,110,116,97,108,70,101,97,116,117,114,101,69,110,97,98,108,101,100,0,86,97,108,117,101,0,76,97,121,111,117,116,0,83,105,122,101,0,103,101,116,73,110,115,116,97,110,99,101,67,111,117,110,116,0,73,110,116,54,52,0,1,1,1,2,2,4,4,4,4,8,8,4,8,118,111,105,100,0,98,111,111,108,0,115,116,100,58,58,115,116,114,105,110,103,0,99,98,70,117,110,99,116,105,111,110,32,38,0,99,111,110,115,116,32,99,98,70,117,110,99,116,105,111,110,32,38,0,69,120,116,101,114,110,97,108,0,66,117,102,102,101,114,0,78,66,105,110,100,73,68,0,78,66,105,110,100,0,98,105,110,100,95,118,97,108,117,101,0,114,101,102,108,101,99,116,0,113,117,101,114,121,84,121,112,101,0,108,97,108,108,111,99,0,108,114,101,115,101,116,0,123,114,101,116,117,114,110,40,95,110,98,105,110,100,46,99,97,108,108,98,97,99,107,83,105,103,110,97,116,117,114,101,76,105,115,116,91,36,48,93,46,97,112,112,108,121,40,116,104,105,115,44,97,114,103,117,109,101,110,116,115,41,41,59,125,0,95,110,98,105,110,100,95,110,101,119,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,45,43,32,32,32,48,88,48,120,0,40,110,117,108,108,41,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,105,110,102,0,73,78,70,0,110,97,110,0,78,65,78,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,46,0,84,33,34,25,13,1,2,3,17,75,28,12,16,4,11,29,18,30,39,104,110,111,112,113,98,32,5,6,15,19,20,21,26,8,22,7,40,36,23,24,9,10,14,27,31,37,35,131,130,125,38,42,43,60,61,62,63,67,71,74,77,88,89,90,91,92,93,94,95,96,97,99,100,101,102,103,105,106,107,108,114,115,116,121,122,123,124,0,73,108,108,101,103,97,108,32,98,121,116,101,32,115,101,113,117,101,110,99,101,0,68,111,109,97,105,110,32,101,114,114,111,114,0,82,101,115,117,108,116,32,110,111,116,32,114,101,112,114,101,115,101,110,116,97,98,108,101,0,78,111,116,32,97,32,116,116,121,0,80,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100,0,79,112,101,114,97,116,105,111,110,32,110,111,116,32,112,101,114,109,105,116,116,101,100,0,78,111,32,115,117,99,104,32,102,105,108,101,32,111,114,32,100,105,114,101,99,116,111,114,121,0,78,111,32,115,117,99,104,32,112,114,111,99,101,115,115,0,70,105,108,101,32,101,120,105,115,116,115,0,86,97,108,117,101,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,100,97,116,97,32,116,121,112,101,0,78,111,32,115,112,97,99,101,32,108,101,102,116,32,111,110,32,100,101,118,105,99,101,0,79,117,116,32,111,102,32,109,101,109,111,114,121,0,82,101,115,111,117,114,99,101,32,98,117,115,121,0,73,110,116,101,114,114,117,112,116,101,100,32,115,121,115,116,101,109,32,99,97,108,108,0,82,101,115,111,117,114,99,101,32,116,101,109,112,111,114,97,114,105,108,121,32,117,110,97,118,97,105,108,97,98,108,101,0,73,110,118,97,108,105,100,32,115,101,101,107,0,67,114,111,115,115,45,100,101,118,105,99,101,32,108,105,110,107,0,82,101,97,100,45,111,110,108,121,32,102,105,108,101,32,115,121,115,116,101,109,0,68,105,114,101,99,116,111,114,121,32,110,111,116,32,101,109,112,116,121,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,112,101,101,114,0,79,112,101,114,97,116,105,111,110,32,116,105,109,101,100,32,111,117,116,0,67,111,110,110,101,99,116,105,111,110,32,114,101,102,117,115,101,100,0,72,111,115,116,32,105,115,32,100,111,119,110,0,72,111,115,116,32,105,115,32,117,110,114,101,97,99,104,97,98,108,101,0,65,100,100,114,101,115,115,32,105,110,32,117,115,101,0,66,114,111,107,101,110,32,112,105,112,101,0,73,47,79,32,101,114,114,111,114,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,32,111,114,32,97,100,100,114,101,115,115,0,66,108,111,99,107,32,100,101,118,105,99,101,32,114,101,113,117,105,114,101,100,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,0,78,111,116,32,97,32,100,105,114,101,99,116,111,114,121,0,73,115,32,97,32,100,105,114,101,99,116,111,114,121,0,84,101,120,116,32,102,105,108,101,32,98,117,115,121,0,69,120,101,99,32,102,111,114,109,97,116,32,101,114,114,111,114,0,73,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116,0,65,114,103,117,109,101,110,116,32,108,105,115,116,32,116,111,111,32,108,111,110,103,0,83,121,109,98,111,108,105,99,32,108,105,110,107,32,108,111,111,112,0,70,105,108,101,110,97,109,101,32,116,111,111,32,108,111,110,103,0,84,111,111,32,109,97,110,121,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,115,121,115,116,101,109,0,78,111,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,115,32,97,118,97,105,108,97,98,108,101,0,66,97,100,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,0,78,111,32,99,104,105,108,100,32,112,114,111,99,101,115,115,0,66,97,100,32,97,100,100,114,101,115,115,0,70,105,108,101,32,116,111,111,32,108,97,114,103,101,0,84,111,111,32,109,97,110,121,32,108,105,110,107,115,0,78,111,32,108,111,99,107,115,32,97,118,97,105,108,97,98,108,101,0,82,101,115,111,117,114,99,101,32,100,101,97,100,108,111,99,107,32,119,111,117,108,100,32,111,99,99,117,114,0,83,116,97,116,101,32,110,111,116,32,114,101,99,111,118,101,114,97,98,108,101,0,80,114,101,118,105,111,117,115,32,111,119,110,101,114,32,100,105,101,100,0,79,112,101,114,97,116,105,111,110,32,99,97,110,99,101,108,101,100,0,70,117,110,99,116,105,111,110,32,110,111,116,32,105,109,112,108,101,109,101,110,116,101,100,0,78,111,32,109,101,115,115,97,103,101,32,111,102,32,100,101,115,105,114,101,100,32,116,121,112,101,0,73,100,101,110,116,105,102,105,101,114,32,114,101,109,111,118,101,100,0,68,101,118,105,99,101,32,110,111,116,32,97,32,115,116,114,101,97,109,0,78,111,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,0,68,101,118,105,99,101,32,116,105,109,101,111,117,116,0,79,117,116,32,111,102,32,115,116,114,101,97,109,115,32,114,101,115,111,117,114,99,101,115,0,76,105,110,107,32,104,97,115,32,98,101,101,110,32,115,101,118,101,114,101,100,0,80,114,111,116,111,99,111,108,32,101,114,114,111,114,0,66,97,100,32,109,101,115,115,97,103,101,0,70,105,108,101,32,100,101,115,99,114,105,112,116,111,114,32,105,110,32,98,97,100,32,115,116,97,116,101,0,78,111,116,32,97,32,115,111,99,107,101,116,0,68,101,115,116,105,110,97,116,105,111,110,32,97,100,100,114,101,115,115,32,114,101,113,117,105,114,101,100,0,77,101,115,115,97,103,101,32,116,111,111,32,108,97,114,103,101,0,80,114,111,116,111,99,111,108,32,119,114,111,110,103,32,116,121,112,101,32,102,111,114,32,115,111,99,107,101,116,0,80,114,111,116,111,99,111,108,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,80,114,111,116,111,99,111,108,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,83,111,99,107,101,116,32,116,121,112,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,78,111,116,32,115,117,112,112,111,114,116,101,100,0,80,114,111,116,111,99,111,108,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,65,100,100,114,101,115,115,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,98,121,32,112,114,111,116,111,99,111,108,0,65,100,100,114,101,115,115,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,78,101,116,119,111,114,107,32,105,115,32,100,111,119,110,0,78,101,116,119,111,114,107,32,117,110,114,101,97,99,104,97,98,108,101,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,110,101,116,119,111,114,107,0,67,111,110,110,101,99,116,105,111,110,32,97,98,111,114,116,101,100,0,78,111,32,98,117,102,102,101,114,32,115,112,97,99,101,32,97,118,97,105,108,97,98,108,101,0,83,111,99,107,101,116,32,105,115,32,99,111,110,110,101,99,116,101,100,0,83,111,99,107,101,116,32,110,111,116,32,99,111,110,110,101,99,116,101,100,0,67,97,110,110,111,116,32,115,101,110,100,32,97,102,116,101,114,32,115,111,99,107,101,116,32,115,104,117,116,100,111,119,110,0,79,112,101,114,97,116,105,111,110,32,97,108,114,101,97,100,121,32,105,110,32,112,114,111,103,114,101,115,115,0,79,112,101,114,97,116,105,111,110,32,105,110,32,112,114,111,103,114,101,115,115,0,83,116,97,108,101,32,102,105,108,101,32,104,97,110,100,108,101,0,82,101,109,111,116,101,32,73,47,79,32,101,114,114,111,114,0,81,117,111,116,97,32,101,120,99,101,101,100,101,100,0,78,111,32,109,101,100,105,117,109,32,102,111,117,110,100,0,87,114,111,110,103,32,109,101,100,105,117,109,32,116,121,112,101,0,78,111,32,101,114,114,111,114,32,105,110,102,111,114,109,97,116,105,111,110,0,0],\"i8\",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=STATICTOP;function _atexit(n,e){__ATEXIT__.unshift({func:n,arg:e})}function ___cxa_atexit(){return _atexit.apply(null,arguments)}function _abort(){Module.abort()}function __ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj(){Module.printErr(\"missing function: _ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj\"),abort(-1)}function __decorate(n,e,r,t){var i,u=arguments.length,o=u<3?e:null===t?t=Object.getOwnPropertyDescriptor(e,r):t;if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.decorate)o=Reflect.decorate(n,e,r,t);else for(var a=n.length-1;a>=0;a--)(i=n[a])&&(o=(u<3?i(o):u>3?i(e,r,o):i(e,r))||o);return u>3&&o&&Object.defineProperty(e,r,o),o}function _defineHidden(n){return function(e,r){Object.defineProperty(e,r,{configurable:!1,enumerable:!1,value:n,writable:!0})}}STATICTOP+=16;var _nbind={};function __nbind_free_external(n){_nbind.externalList[n].dereference(n)}function __nbind_reference_external(n){_nbind.externalList[n].reference()}function _llvm_stackrestore(n){var e=_llvm_stacksave,r=e.LLVM_SAVEDSTACKS[n];e.LLVM_SAVEDSTACKS.splice(n,1),Runtime.stackRestore(r)}function __nbind_register_pool(n,e,r,t){_nbind.Pool.pageSize=n,_nbind.Pool.usedPtr=e/4,_nbind.Pool.rootPtr=r,_nbind.Pool.pagePtr=t/4,HEAP32[e/4]=16909060,1==HEAP8[e]&&(_nbind.bigEndian=!0),HEAP32[e/4]=0,_nbind.makeTypeKindTbl=((i={})[1024]=_nbind.PrimitiveType,i[64]=_nbind.Int64Type,i[2048]=_nbind.BindClass,i[3072]=_nbind.BindClassPtr,i[4096]=_nbind.SharedClassPtr,i[5120]=_nbind.ArrayType,i[6144]=_nbind.ArrayType,i[7168]=_nbind.CStringType,i[9216]=_nbind.CallbackType,i[10240]=_nbind.BindType,i),_nbind.makeTypeNameTbl={Buffer:_nbind.BufferType,External:_nbind.ExternalType,Int64:_nbind.Int64Type,_nbind_new:_nbind.CreateValueType,bool:_nbind.BooleanType,\"cbFunction &\":_nbind.CallbackType,\"const cbFunction &\":_nbind.CallbackType,\"const std::string &\":_nbind.StringType,\"std::string\":_nbind.StringType},Module.toggleLightGC=_nbind.toggleLightGC,_nbind.callUpcast=Module.dynCall_ii;var i,u=_nbind.makeType(_nbind.constructType,{flags:2048,id:0,name:\"\"});u.proto=Module,_nbind.BindClass.list.push(u)}function _emscripten_set_main_loop_timing(n,e){if(Browser.mainLoop.timingMode=n,Browser.mainLoop.timingValue=e,!Browser.mainLoop.func)return 1;if(0==n)Browser.mainLoop.scheduler=function(){var n=0|Math.max(0,Browser.mainLoop.tickStartTime+e-_emscripten_get_now());setTimeout(Browser.mainLoop.runner,n)},Browser.mainLoop.method=\"timeout\";else if(1==n)Browser.mainLoop.scheduler=function(){Browser.requestAnimationFrame(Browser.mainLoop.runner)},Browser.mainLoop.method=\"rAF\";else if(2==n){if(!window.setImmediate){var r=[];window.addEventListener(\"message\",(function(n){n.source===window&&\"setimmediate\"===n.data&&(n.stopPropagation(),r.shift()())}),!0),window.setImmediate=function(n){r.push(n),ENVIRONMENT_IS_WORKER?(void 0===Module.setImmediates&&(Module.setImmediates=[]),Module.setImmediates.push(n),window.postMessage({target:\"setimmediate\"})):window.postMessage(\"setimmediate\",\"*\")}}Browser.mainLoop.scheduler=function(){window.setImmediate(Browser.mainLoop.runner)},Browser.mainLoop.method=\"immediate\"}return 0}function _emscripten_get_now(){abort()}function _emscripten_set_main_loop(n,e,r,t,i){var u;Module.noExitRuntime=!0,assert(!Browser.mainLoop.func,\"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.\"),Browser.mainLoop.func=n,Browser.mainLoop.arg=t,u=void 0!==t?function(){Module.dynCall_vi(n,t)}:function(){Module.dynCall_v(n)};var o=Browser.mainLoop.currentlyRunningMainloop;if(Browser.mainLoop.runner=function(){if(!ABORT)if(Browser.mainLoop.queue.length>0){var n=Date.now(),e=Browser.mainLoop.queue.shift();if(e.func(e.arg),Browser.mainLoop.remainingBlockers){var r=Browser.mainLoop.remainingBlockers,t=r%1==0?r-1:Math.floor(r);e.counted?Browser.mainLoop.remainingBlockers=t:(t+=.5,Browser.mainLoop.remainingBlockers=(8*r+t)/9)}if(console.log('main loop blocker \"'+e.name+'\" took '+(Date.now()-n)+\" ms\"),Browser.mainLoop.updateStatus(),o<Browser.mainLoop.currentlyRunningMainloop)return;setTimeout(Browser.mainLoop.runner,0)}else o<Browser.mainLoop.currentlyRunningMainloop||(Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0,1==Browser.mainLoop.timingMode&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0?Browser.mainLoop.scheduler():(0==Browser.mainLoop.timingMode&&(Browser.mainLoop.tickStartTime=_emscripten_get_now()),\"timeout\"===Browser.mainLoop.method&&Module.ctx&&(Module.printErr(\"Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!\"),Browser.mainLoop.method=\"\"),Browser.mainLoop.runIter(u),o<Browser.mainLoop.currentlyRunningMainloop||(\"object\"==typeof SDL&&SDL.audio&&SDL.audio.queueNewAudioData&&SDL.audio.queueNewAudioData(),Browser.mainLoop.scheduler())))},i||(e&&e>0?_emscripten_set_main_loop_timing(0,1e3/e):_emscripten_set_main_loop_timing(1,1),Browser.mainLoop.scheduler()),r)throw\"SimulateInfiniteLoop\"}var Browser={mainLoop:{scheduler:null,method:\"\",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function(){Browser.mainLoop.scheduler=null,Browser.mainLoop.currentlyRunningMainloop++},resume:function(){Browser.mainLoop.currentlyRunningMainloop++;var n=Browser.mainLoop.timingMode,e=Browser.mainLoop.timingValue,r=Browser.mainLoop.func;Browser.mainLoop.func=null,_emscripten_set_main_loop(r,0,!1,Browser.mainLoop.arg,!0),_emscripten_set_main_loop_timing(n,e),Browser.mainLoop.scheduler()},updateStatus:function(){if(Module.setStatus){var n=Module.statusMessage||\"Please wait...\",e=Browser.mainLoop.remainingBlockers,r=Browser.mainLoop.expectedBlockers;e?e<r?Module.setStatus(n+\" (\"+(r-e)+\"/\"+r+\")\"):Module.setStatus(n):Module.setStatus(\"\")}},runIter:function(n){if(!ABORT){if(Module.preMainLoop)if(!1===Module.preMainLoop())return;try{n()}catch(n){if(n instanceof ExitStatus)return;throw n&&\"object\"==typeof n&&n.stack&&Module.printErr(\"exception thrown: \"+[n,n.stack]),n}Module.postMainLoop&&Module.postMainLoop()}}},isFullscreen:!1,pointerLock:!1,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(Module.preloadPlugins||(Module.preloadPlugins=[]),!Browser.initted){Browser.initted=!0;try{new Blob,Browser.hasBlobConstructor=!0}catch(n){Browser.hasBlobConstructor=!1,console.log(\"warning: no blob constructor, cannot create blobs with mimetypes\")}Browser.BlobBuilder=\"undefined\"!=typeof MozBlobBuilder?MozBlobBuilder:\"undefined\"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:Browser.hasBlobConstructor?null:console.log(\"warning: no BlobBuilder\"),Browser.URLObject=\"undefined\"!=typeof window?window.URL?window.URL:window.webkitURL:void 0,Module.noImageDecoding||void 0!==Browser.URLObject||(console.log(\"warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.\"),Module.noImageDecoding=!0);var n={canHandle:function(n){return!Module.noImageDecoding&&/\\.(jpg|jpeg|png|bmp)$/i.test(n)},handle:function(n,e,r,t){var i=null;if(Browser.hasBlobConstructor)try{(i=new Blob([n],{type:Browser.getMimetype(e)})).size!==n.length&&(i=new Blob([new Uint8Array(n).buffer],{type:Browser.getMimetype(e)}))}catch(n){Runtime.warnOnce(\"Blob constructor present but fails: \"+n+\"; falling back to blob builder\")}if(!i){var u=new Browser.BlobBuilder;u.append(new Uint8Array(n).buffer),i=u.getBlob()}var o=Browser.URLObject.createObjectURL(i),a=new Image;a.onload=function(){assert(a.complete,\"Image \"+e+\" could not be decoded\");var t=document.createElement(\"canvas\");t.width=a.width,t.height=a.height,t.getContext(\"2d\").drawImage(a,0,0),Module.preloadedImages[e]=t,Browser.URLObject.revokeObjectURL(o),r&&r(n)},a.onerror=function(n){console.log(\"Image \"+o+\" could not be decoded\"),t&&t()},a.src=o}};Module.preloadPlugins.push(n);var e={canHandle:function(n){return!Module.noAudioDecoding&&n.substr(-4)in{\".ogg\":1,\".wav\":1,\".mp3\":1}},handle:function(n,e,r,t){var i=!1;function u(t){i||(i=!0,Module.preloadedAudios[e]=t,r&&r(n))}function o(){i||(i=!0,Module.preloadedAudios[e]=new Audio,t&&t())}if(!Browser.hasBlobConstructor)return o();try{var a=new Blob([n],{type:Browser.getMimetype(e)})}catch(n){return o()}var f=Browser.URLObject.createObjectURL(a),c=new Audio;c.addEventListener(\"canplaythrough\",(function(){u(c)}),!1),c.onerror=function(r){i||(console.log(\"warning: browser could not fully decode audio \"+e+\", trying slower base64 approach\"),c.src=\"data:audio/x-\"+e.substr(-3)+\";base64,\"+function(n){for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",r=\"\",t=0,i=0,u=0;u<n.length;u++)for(t=t<<8|n[u],i+=8;i>=6;){var o=t>>i-6&63;i-=6,r+=e[o]}return 2==i?(r+=e[(3&t)<<4],r+=\"==\"):4==i&&(r+=e[(15&t)<<2],r+=\"=\"),r}(n),u(c))},c.src=f,Browser.safeSetTimeout((function(){u(c)}),1e4)}};Module.preloadPlugins.push(e);var r=Module.canvas;r&&(r.requestPointerLock=r.requestPointerLock||r.mozRequestPointerLock||r.webkitRequestPointerLock||r.msRequestPointerLock||function(){},r.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock||document.msExitPointerLock||function(){},r.exitPointerLock=r.exitPointerLock.bind(document),document.addEventListener(\"pointerlockchange\",t,!1),document.addEventListener(\"mozpointerlockchange\",t,!1),document.addEventListener(\"webkitpointerlockchange\",t,!1),document.addEventListener(\"mspointerlockchange\",t,!1),Module.elementPointerLock&&r.addEventListener(\"click\",(function(n){!Browser.pointerLock&&Module.canvas.requestPointerLock&&(Module.canvas.requestPointerLock(),n.preventDefault())}),!1))}function t(){Browser.pointerLock=document.pointerLockElement===Module.canvas||document.mozPointerLockElement===Module.canvas||document.webkitPointerLockElement===Module.canvas||document.msPointerLockElement===Module.canvas}},createContext:function(n,e,r,t){if(e&&Module.ctx&&n==Module.canvas)return Module.ctx;var i,u;if(e){var o={antialias:!1,alpha:!1};if(t)for(var a in t)o[a]=t[a];(u=GL.createContext(n,o))&&(i=GL.getContext(u).GLctx)}else i=n.getContext(\"2d\");return i?(r&&(e||assert(\"undefined\"==typeof GLctx,\"cannot set in module if GLctx is used, but we are a non-GL context that would replace it\"),Module.ctx=i,e&&GL.makeContextCurrent(u),Module.useWebGL=e,Browser.moduleContextCreatedCallbacks.forEach((function(n){n()})),Browser.init()),i):null},destroyContext:function(n,e,r){},fullscreenHandlersInstalled:!1,lockPointer:void 0,resizeCanvas:void 0,requestFullscreen:function(n,e,r){Browser.lockPointer=n,Browser.resizeCanvas=e,Browser.vrDevice=r,void 0===Browser.lockPointer&&(Browser.lockPointer=!0),void 0===Browser.resizeCanvas&&(Browser.resizeCanvas=!1),void 0===Browser.vrDevice&&(Browser.vrDevice=null);var t=Module.canvas;function i(){Browser.isFullscreen=!1;var n=t.parentNode;(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===n?(t.exitFullscreen=document.exitFullscreen||document.cancelFullScreen||document.mozCancelFullScreen||document.msExitFullscreen||document.webkitCancelFullScreen||function(){},t.exitFullscreen=t.exitFullscreen.bind(document),Browser.lockPointer&&t.requestPointerLock(),Browser.isFullscreen=!0,Browser.resizeCanvas&&Browser.setFullscreenCanvasSize()):(n.parentNode.insertBefore(t,n),n.parentNode.removeChild(n),Browser.resizeCanvas&&Browser.setWindowedCanvasSize()),Module.onFullScreen&&Module.onFullScreen(Browser.isFullscreen),Module.onFullscreen&&Module.onFullscreen(Browser.isFullscreen),Browser.updateCanvasDimensions(t)}Browser.fullscreenHandlersInstalled||(Browser.fullscreenHandlersInstalled=!0,document.addEventListener(\"fullscreenchange\",i,!1),document.addEventListener(\"mozfullscreenchange\",i,!1),document.addEventListener(\"webkitfullscreenchange\",i,!1),document.addEventListener(\"MSFullscreenChange\",i,!1));var u=document.createElement(\"div\");t.parentNode.insertBefore(u,t),u.appendChild(t),u.requestFullscreen=u.requestFullscreen||u.mozRequestFullScreen||u.msRequestFullscreen||(u.webkitRequestFullscreen?function(){u.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT)}:null)||(u.webkitRequestFullScreen?function(){u.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}:null),r?u.requestFullscreen({vrDisplay:r}):u.requestFullscreen()},requestFullScreen:function(n,e,r){return Module.printErr(\"Browser.requestFullScreen() is deprecated. Please call Browser.requestFullscreen instead.\"),Browser.requestFullScreen=function(n,e,r){return Browser.requestFullscreen(n,e,r)},Browser.requestFullscreen(n,e,r)},nextRAF:0,fakeRequestAnimationFrame:function(n){var e=Date.now();if(0===Browser.nextRAF)Browser.nextRAF=e+1e3/60;else for(;e+2>=Browser.nextRAF;)Browser.nextRAF+=1e3/60;var r=Math.max(Browser.nextRAF-e,0);setTimeout(n,r)},requestAnimationFrame:function(n){\"undefined\"==typeof window?Browser.fakeRequestAnimationFrame(n):(window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||Browser.fakeRequestAnimationFrame),window.requestAnimationFrame(n))},safeCallback:function(n){return function(){if(!ABORT)return n.apply(null,arguments)}},allowAsyncCallbacks:!0,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function(){Browser.allowAsyncCallbacks=!1},resumeAsyncCallbacks:function(){if(Browser.allowAsyncCallbacks=!0,Browser.queuedAsyncCallbacks.length>0){var n=Browser.queuedAsyncCallbacks;Browser.queuedAsyncCallbacks=[],n.forEach((function(n){n()}))}},safeRequestAnimationFrame:function(n){return Browser.requestAnimationFrame((function(){ABORT||(Browser.allowAsyncCallbacks?n():Browser.queuedAsyncCallbacks.push(n))}))},safeSetTimeout:function(n,e){return Module.noExitRuntime=!0,setTimeout((function(){ABORT||(Browser.allowAsyncCallbacks?n():Browser.queuedAsyncCallbacks.push(n))}),e)},safeSetInterval:function(n,e){return Module.noExitRuntime=!0,setInterval((function(){ABORT||Browser.allowAsyncCallbacks&&n()}),e)},getMimetype:function(n){return{jpg:\"image/jpeg\",jpeg:\"image/jpeg\",png:\"image/png\",bmp:\"image/bmp\",ogg:\"audio/ogg\",wav:\"audio/wav\",mp3:\"audio/mpeg\"}[n.substr(n.lastIndexOf(\".\")+1)]},getUserMedia:function(n){window.getUserMedia||(window.getUserMedia=navigator.getUserMedia||navigator.mozGetUserMedia),window.getUserMedia(n)},getMovementX:function(n){return n.movementX||n.mozMovementX||n.webkitMovementX||0},getMovementY:function(n){return n.movementY||n.mozMovementY||n.webkitMovementY||0},getMouseWheelDelta:function(n){var e=0;switch(n.type){case\"DOMMouseScroll\":e=n.detail;break;case\"mousewheel\":e=n.wheelDelta;break;case\"wheel\":e=n.deltaY;break;default:throw\"unrecognized mouse wheel event: \"+n.type}return e},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(n){if(Browser.pointerLock)\"mousemove\"!=n.type&&\"mozMovementX\"in n?Browser.mouseMovementX=Browser.mouseMovementY=0:(Browser.mouseMovementX=Browser.getMovementX(n),Browser.mouseMovementY=Browser.getMovementY(n)),\"undefined\"!=typeof SDL?(Browser.mouseX=SDL.mouseX+Browser.mouseMovementX,Browser.mouseY=SDL.mouseY+Browser.mouseMovementY):(Browser.mouseX+=Browser.mouseMovementX,Browser.mouseY+=Browser.mouseMovementY);else{var e=Module.canvas.getBoundingClientRect(),r=Module.canvas.width,t=Module.canvas.height,i=void 0!==window.scrollX?window.scrollX:window.pageXOffset,u=void 0!==window.scrollY?window.scrollY:window.pageYOffset;if(\"touchstart\"===n.type||\"touchend\"===n.type||\"touchmove\"===n.type){var o=n.touch;if(void 0===o)return;var a=o.pageX-(i+e.left),f=o.pageY-(u+e.top),c={x:a*=r/e.width,y:f*=t/e.height};if(\"touchstart\"===n.type)Browser.lastTouches[o.identifier]=c,Browser.touches[o.identifier]=c;else if(\"touchend\"===n.type||\"touchmove\"===n.type){var l=Browser.touches[o.identifier];l||(l=c),Browser.lastTouches[o.identifier]=l,Browser.touches[o.identifier]=c}return}var s=n.pageX-(i+e.left),d=n.pageY-(u+e.top);s*=r/e.width,d*=t/e.height,Browser.mouseMovementX=s-Browser.mouseX,Browser.mouseMovementY=d-Browser.mouseY,Browser.mouseX=s,Browser.mouseY=d}},asyncLoad:function(n,e,r,t){var i=t?\"\":getUniqueRunDependency(\"al \"+n);Module.readAsync(n,(function(r){assert(r,'Loading data file \"'+n+'\" failed (no arrayBuffer).'),e(new Uint8Array(r)),i&&removeRunDependency(i)}),(function(e){if(!r)throw'Loading data file \"'+n+'\" failed.';r()})),i&&addRunDependency(i)},resizeListeners:[],updateResizeListeners:function(){var n=Module.canvas;Browser.resizeListeners.forEach((function(e){e(n.width,n.height)}))},setCanvasSize:function(n,e,r){var t=Module.canvas;Browser.updateCanvasDimensions(t,n,e),r||Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function(){if(\"undefined\"!=typeof SDL){var n=HEAPU32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2];n|=8388608,HEAP32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2]=n}Browser.updateResizeListeners()},setWindowedCanvasSize:function(){if(\"undefined\"!=typeof SDL){var n=HEAPU32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2];n&=-8388609,HEAP32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2]=n}Browser.updateResizeListeners()},updateCanvasDimensions:function(n,e,r){e&&r?(n.widthNative=e,n.heightNative=r):(e=n.widthNative,r=n.heightNative);var t=e,i=r;if(Module.forcedAspectRatio&&Module.forcedAspectRatio>0&&(t/i<Module.forcedAspectRatio?t=Math.round(i*Module.forcedAspectRatio):i=Math.round(t/Module.forcedAspectRatio)),(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===n.parentNode&&\"undefined\"!=typeof screen){var u=Math.min(screen.width/t,screen.height/i);t=Math.round(t*u),i=Math.round(i*u)}Browser.resizeCanvas?(n.width!=t&&(n.width=t),n.height!=i&&(n.height=i),void 0!==n.style&&(n.style.removeProperty(\"width\"),n.style.removeProperty(\"height\"))):(n.width!=e&&(n.width=e),n.height!=r&&(n.height=r),void 0!==n.style&&(t!=e||i!=r?(n.style.setProperty(\"width\",t+\"px\",\"important\"),n.style.setProperty(\"height\",i+\"px\",\"important\")):(n.style.removeProperty(\"width\"),n.style.removeProperty(\"height\"))))},wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function(){var n=Browser.nextWgetRequestHandle;return Browser.nextWgetRequestHandle++,n}},SYSCALLS={varargs:0,get:function(n){return SYSCALLS.varargs+=4,HEAP32[SYSCALLS.varargs-4>>2]},getStr:function(){return Pointer_stringify(SYSCALLS.get())},get64:function(){var n=SYSCALLS.get(),e=SYSCALLS.get();return assert(n>=0?0===e:-1===e),n},getZero:function(){assert(0===SYSCALLS.get())}};function ___syscall6(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.getStreamFromFD();return FS.close(r),0}catch(n){return\"undefined\"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function ___syscall54(n,e){SYSCALLS.varargs=e;try{return 0}catch(n){return\"undefined\"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function _typeModule(n){var e=[[0,1,\"X\"],[1,1,\"const X\"],[128,1,\"X *\"],[256,1,\"X &\"],[384,1,\"X &&\"],[512,1,\"std::shared_ptr<X>\"],[640,1,\"std::unique_ptr<X>\"],[5120,1,\"std::vector<X>\"],[6144,2,\"std::array<X, Y>\"],[9216,-1,\"std::function<X (Y)>\"]];function r(n,e,r,t,i,u){if(1==e){var o=896&t;128!=o&&256!=o&&384!=o||(n=\"X const\")}return(u?r.replace(\"X\",n).replace(\"Y\",i):n.replace(\"X\",r).replace(\"Y\",i)).replace(/([*&]) (?=[*&])/g,\"$1\")}function t(n,e){var r=e.flags,t=896&r,i=15360&r;return e.name||1024!=i||(1==e.ptrSize?e.name=(16&r?\"\":(8&r?\"un\":\"\")+\"signed \")+\"char\":e.name=(8&r?\"u\":\"\")+(32&r?\"float\":\"int\")+8*e.ptrSize+\"_t\"),8!=e.ptrSize||32&r||(i=64),2048==i&&(512==t||640==t?i=4096:t&&(i=3072)),n(i,e)}var i={Type:function(){function n(n){this.id=n.id,this.name=n.name,this.flags=n.flags,this.spec=n}return n.prototype.toString=function(){return this.name},n}(),getComplexType:function n(i,u,o,a,f,c,l,s){void 0===c&&(c=\"X\"),void 0===s&&(s=1);var d=o(i);if(d)return d;var _,v=a(i),p=v.placeholderFlag,m=e[p];l&&m&&(c=r(l[2],l[0],c,m[0],\"?\",!0)),0==p&&(_=\"Unbound\"),p>=10&&(_=\"Corrupt\"),s>20&&(_=\"Deeply nested\"),_&&function(n,e,r,t,i){throw new Error(n+\" type \"+r.replace(\"X\",e+\"?\")+(t?\" with flag \"+t:\"\")+\" in \"+i)}(_,i,c,p,f||\"?\");var b,h=n(v.paramList[0],u,o,a,f,c,m,s+1),y={flags:m[0],id:i,name:\"\",paramList:[h]},w=[],M=\"?\";switch(v.placeholderFlag){case 1:b=h.spec;break;case 2:if(1024==(15360&h.flags)&&1==h.spec.ptrSize){y.flags=7168;break}case 3:case 6:case 5:b=h.spec,h.flags;break;case 8:M=\"\"+v.paramList[1],y.paramList.push(v.paramList[1]);break;case 9:for(var k=0,g=v.paramList[1];k<g.length;k++){var T=n(g[k],u,o,a,f,c,m,s+1);w.push(T.name),y.paramList.push(T)}M=w.join(\", \")}if(y.name=r(m[2],m[0],h.name,h.flags,M),b){for(var A=0,S=Object.keys(b);A<S.length;A++){var E=S[A];y[E]=y[E]||b[E]}y.flags|=b.flags}return t(u,y)},makeType:t,structureList:e};return n.output=i,n.output||i}function __nbind_register_type(n,e){var r={flags:10240,id:n,name:_nbind.readAsciiString(e)};_nbind.makeType(_nbind.constructType,r)}function __nbind_register_callback_signature(n,e){var r=_nbind.readTypeIdList(n,e),t=_nbind.callbackSignatureList.length;return _nbind.callbackSignatureList[t]=_nbind.makeJSCaller(r),t}function __extends(n,e){for(var r in e)e.hasOwnProperty(r)&&(n[r]=e[r]);function t(){this.constructor=n}t.prototype=e.prototype,n.prototype=new t}function __nbind_register_class(n,e,r,t,i,u,o){var a=_nbind.readAsciiString(o),f=_nbind.readPolicyList(e),c=HEAPU32.subarray(n/4,n/4+2),l={flags:2048|(f.Value?2:0),id:c[0],name:a},s=_nbind.makeType(_nbind.constructType,l);s.ptrType=_nbind.getComplexType(c[1],_nbind.constructType,_nbind.getType,_nbind.queryType),s.destroy=_nbind.makeMethodCaller(s.ptrType,{boundID:l.id,flags:0,name:\"destroy\",num:0,ptr:u,title:s.name+\".free\",typeList:[\"void\",\"uint32_t\",\"uint32_t\"]}),i&&(s.superIdList=Array.prototype.slice.call(HEAPU32.subarray(r/4,r/4+i)),s.upcastList=Array.prototype.slice.call(HEAPU32.subarray(t/4,t/4+i))),Module[s.name]=s.makeBound(f),_nbind.BindClass.list.push(s)}function _removeAccessorPrefix(n){return n.replace(/^[Gg]et_?([A-Z]?([A-Z]?))/,(function(n,e,r){return r?e:e.toLowerCase()}))}function __nbind_register_function(n,e,r,t,i,u,o,a,f,c){var l,s=_nbind.getType(n),d=_nbind.readPolicyList(e),_=_nbind.readTypeIdList(r,t);if(5==o)l=[{direct:i,name:\"__nbindConstructor\",ptr:0,title:s.name+\" constructor\",typeList:[\"uint32_t\"].concat(_.slice(1))},{direct:u,name:\"__nbindValueConstructor\",ptr:0,title:s.name+\" value constructor\",typeList:[\"void\",\"uint32_t\"].concat(_.slice(1))}];else{var v=_nbind.readAsciiString(a),p=(s.name&&s.name+\".\")+v;3!=o&&4!=o||(v=_removeAccessorPrefix(v)),l=[{boundID:n,direct:u,name:v,ptr:i,title:p,typeList:_}]}for(var m=0,b=l;m<b.length;m++){var h=b[m];h.signatureType=o,h.policyTbl=d,h.num=f,h.flags=c,s.addMethod(h)}}function _nbind_value(n,e){_nbind.typeNameTbl[n]||_nbind.throwError(\"Unknown value type \"+n),Module.NBind.bind_value(n,e),_defineHidden(_nbind.typeNameTbl[n].proto.prototype.__nbindValueConstructor)(e.prototype,\"__nbindValueConstructor\")}function __nbind_get_value_object(n,e){var r=_nbind.popValue(n);if(!r.fromJS)throw new Error(\"Object \"+r+\" has no fromJS function\");r.fromJS((function(){r.__nbindValueConstructor.apply(this,Array.prototype.concat.apply([e],arguments))}))}function _emscripten_memcpy_big(n,e,r){return HEAPU8.set(HEAPU8.subarray(e,e+r),n),n}function __nbind_register_primitive(n,e,r){var t={flags:1024|r,id:n,ptrSize:e};_nbind.makeType(_nbind.constructType,t)}Module._nbind_value=_nbind_value;var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],\"i8\",ALLOC_STATIC);function ___setErrNo(n){return Module.___errno_location&&(HEAP32[Module.___errno_location()>>2]=n),n}function _llvm_stacksave(){var n=_llvm_stacksave;return n.LLVM_SAVEDSTACKS||(n.LLVM_SAVEDSTACKS=[]),n.LLVM_SAVEDSTACKS.push(Runtime.stackSave()),n.LLVM_SAVEDSTACKS.length-1}function ___syscall140(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.getStreamFromFD(),t=(SYSCALLS.get(),SYSCALLS.get()),i=SYSCALLS.get(),u=SYSCALLS.get(),o=t;return FS.llseek(r,o,u),HEAP32[i>>2]=r.position,r.getdents&&0===o&&0===u&&(r.getdents=null),0}catch(n){return\"undefined\"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function ___syscall146(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.get(),t=SYSCALLS.get(),i=SYSCALLS.get(),u=0;___syscall146.buffer||(___syscall146.buffers=[null,[],[]],___syscall146.printChar=function(n,e){var r=___syscall146.buffers[n];assert(r),0===e||10===e?((1===n?Module.print:Module.printErr)(UTF8ArrayToString(r,0)),r.length=0):r.push(e)});for(var o=0;o<i;o++){for(var a=HEAP32[t+8*o>>2],f=HEAP32[t+(8*o+4)>>2],c=0;c<f;c++)___syscall146.printChar(r,HEAPU8[a+c]);u+=f}return u}catch(n){return\"undefined\"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function __nbind_finish(){for(var n=0,e=_nbind.BindClass.list;n<e.length;n++){e[n].finish()}}var ___dso_handle=STATICTOP;function invoke_viiiii(n,e,r,t,i,u){try{Module.dynCall_viiiii(n,e,r,t,i,u)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_vif(n,e,r){try{Module.dynCall_vif(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_vid(n,e,r){try{Module.dynCall_vid(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_fiff(n,e,r,t){try{return Module.dynCall_fiff(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_vi(n,e){try{Module.dynCall_vi(n,e)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_vii(n,e,r){try{Module.dynCall_vii(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_ii(n,e){try{return Module.dynCall_ii(n,e)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viddi(n,e,r,t,i){try{Module.dynCall_viddi(n,e,r,t,i)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_vidd(n,e,r,t){try{Module.dynCall_vidd(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_iiii(n,e,r,t){try{return Module.dynCall_iiii(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_diii(n,e,r,t){try{return Module.dynCall_diii(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_di(n,e){try{return Module.dynCall_di(n,e)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_iid(n,e,r){try{return Module.dynCall_iid(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_iii(n,e,r){try{return Module.dynCall_iii(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiddi(n,e,r,t,i,u){try{Module.dynCall_viiddi(n,e,r,t,i,u)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiiiii(n,e,r,t,i,u,o){try{Module.dynCall_viiiiii(n,e,r,t,i,u,o)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_dii(n,e,r){try{return Module.dynCall_dii(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_i(n){try{return Module.dynCall_i(n)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_iiiiii(n,e,r,t,i,u){try{return Module.dynCall_iiiiii(n,e,r,t,i,u)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiid(n,e,r,t,i){try{Module.dynCall_viiid(n,e,r,t,i)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viififi(n,e,r,t,i,u,o){try{Module.dynCall_viififi(n,e,r,t,i,u,o)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viii(n,e,r,t){try{Module.dynCall_viii(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_v(n){try{Module.dynCall_v(n)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viid(n,e,r,t){try{Module.dynCall_viid(n,e,r,t)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_idd(n,e,r){try{return Module.dynCall_idd(n,e,r)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiii(n,e,r,t,i){try{Module.dynCall_viiii(n,e,r,t,i)}catch(n){if(\"number\"!=typeof n&&\"longjmp\"!==n)throw n;Module.setThrew(1,0)}}STATICTOP+=16,function(_nbind){var typeIdTbl={};_nbind.typeNameTbl={};var Pool=function(){function n(){}return n.lalloc=function(e){e=e+7&-8;var r=HEAPU32[n.usedPtr];return e>n.pageSize/2||e>n.pageSize-r?_nbind.typeNameTbl.NBind.proto.lalloc(e):(HEAPU32[n.usedPtr]=r+e,n.rootPtr+r)},n.lreset=function(e,r){HEAPU32[n.pagePtr]?_nbind.typeNameTbl.NBind.proto.lreset(e,r):HEAPU32[n.usedPtr]=e},n}();function constructType(n,e){var r=new(10240==n?_nbind.makeTypeNameTbl[e.name]||_nbind.BindType:_nbind.makeTypeKindTbl[n])(e);return typeIdTbl[e.id]=r,_nbind.typeNameTbl[e.name]=r,r}function getType(n){return typeIdTbl[n]}function queryType(n){var e=HEAPU8[n],r=_nbind.structureList[e][1];n/=4,r<0&&(++n,r=HEAPU32[n]+1);var t=Array.prototype.slice.call(HEAPU32.subarray(n+1,n+1+r));return 9==e&&(t=[t[0],t.slice(1)]),{paramList:t,placeholderFlag:e}}function getTypes(n,e){return n.map((function(n){return\"number\"==typeof n?_nbind.getComplexType(n,constructType,getType,queryType,e):_nbind.typeNameTbl[n]}))}function readTypeIdList(n,e){return Array.prototype.slice.call(HEAPU32,n/4,n/4+e)}function readAsciiString(n){for(var e=n;HEAPU8[e++];);return String.fromCharCode.apply(\"\",HEAPU8.subarray(n,e-1))}function readPolicyList(n){var e={};if(n)for(;;){var r=HEAPU32[n/4];if(!r)break;e[readAsciiString(r)]=!0,n+=4}return e}function getDynCall(n,e){var r={float32_t:\"d\",float64_t:\"d\",int64_t:\"d\",uint64_t:\"d\",void:\"v\"},t=n.map((function(n){return r[n.name]||\"i\"})).join(\"\"),i=Module[\"dynCall_\"+t];if(!i)throw new Error(\"dynCall_\"+t+\" not found for \"+e+\"(\"+n.map((function(n){return n.name})).join(\", \")+\")\");return i}function addMethod(n,e,r,t){var i=n[e];n.hasOwnProperty(e)&&i?((i.arity||0===i.arity)&&(i=_nbind.makeOverloader(i,i.arity),n[e]=i),i.addMethod(r,t)):(r.arity=t,n[e]=r)}function throwError(n){throw new Error(n)}_nbind.Pool=Pool,_nbind.constructType=constructType,_nbind.getType=getType,_nbind.queryType=queryType,_nbind.getTypes=getTypes,_nbind.readTypeIdList=readTypeIdList,_nbind.readAsciiString=readAsciiString,_nbind.readPolicyList=readPolicyList,_nbind.getDynCall=getDynCall,_nbind.addMethod=addMethod,_nbind.throwError=throwError,_nbind.bigEndian=!1;var _a=_typeModule(_typeModule);_nbind.Type=_a.Type,_nbind.makeType=_a.makeType,_nbind.getComplexType=_a.getComplexType,_nbind.structureList=_a.structureList;var BindType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.heap=HEAPU32,e.ptrSize=4,e}return __extends(e,n),e.prototype.needsWireRead=function(n){return!!this.wireRead||!!this.makeWireRead},e.prototype.needsWireWrite=function(n){return!!this.wireWrite||!!this.makeWireWrite},e}(_nbind.Type);_nbind.BindType=BindType;var PrimitiveType=function(n){function e(e){var r=n.call(this,e)||this,t=32&e.flags?{32:HEAPF32,64:HEAPF64}:8&e.flags?{8:HEAPU8,16:HEAPU16,32:HEAPU32}:{8:HEAP8,16:HEAP16,32:HEAP32};return r.heap=t[8*e.ptrSize],r.ptrSize=e.ptrSize,r}return __extends(e,n),e.prototype.needsWireWrite=function(n){return!!n&&!!n.Strict},e.prototype.makeWireWrite=function(n,e){return e&&e.Strict&&function(n){if(\"number\"==typeof n)return n;throw new Error(\"Type mismatch\")}},e}(BindType);function pushCString(n,e){if(null==n){if(e&&e.Nullable)return 0;throw new Error(\"Type mismatch\")}if(e&&e.Strict){if(\"string\"!=typeof n)throw new Error(\"Type mismatch\")}else n=n.toString();var r=Module.lengthBytesUTF8(n)+1,t=_nbind.Pool.lalloc(r);return Module.stringToUTF8Array(n,HEAPU8,t,r),t}function popCString(n){return 0===n?null:Module.Pointer_stringify(n)}_nbind.PrimitiveType=PrimitiveType,_nbind.pushCString=pushCString,_nbind.popCString=popCString;var CStringType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popCString,e.wireWrite=pushCString,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushCString(n,e)}},e}(BindType);_nbind.CStringType=CStringType;var BooleanType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=function(n){return!!n},e}return __extends(e,n),e.prototype.needsWireWrite=function(n){return!!n&&!!n.Strict},e.prototype.makeWireRead=function(n){return\"!!(\"+n+\")\"},e.prototype.makeWireWrite=function(n,e){return e&&e.Strict&&function(n){if(\"boolean\"==typeof n)return n;throw new Error(\"Type mismatch\")}||n},e}(BindType);_nbind.BooleanType=BooleanType;var Wrapper=function(){function n(){}return n.prototype.persist=function(){this.__nbindState|=1},n}();function makeBound(n,e){var r=function(n){function r(e,t,i,u){var o=n.call(this)||this;if(!(o instanceof r))return new(Function.prototype.bind.apply(r,Array.prototype.concat.apply([null],arguments)));var a=t,f=i,c=u;if(e!==_nbind.ptrMarker){var l=o.__nbindConstructor.apply(o,arguments);a=4608,c=HEAPU32[l/4],f=HEAPU32[l/4+1]}var s={configurable:!0,enumerable:!1,value:null,writable:!1},d={__nbindFlags:a,__nbindPtr:f};c&&(d.__nbindShared=c,_nbind.mark(o));for(var _=0,v=Object.keys(d);_<v.length;_++){var p=v[_];s.value=d[p],Object.defineProperty(o,p,s)}return _defineHidden(0)(o,\"__nbindState\"),o}return __extends(r,n),r.prototype.free=function(){e.destroy.call(this,this.__nbindShared,this.__nbindFlags),this.__nbindState|=2,disableMember(this,\"__nbindShared\"),disableMember(this,\"__nbindPtr\")},r}(Wrapper);return __decorate([_defineHidden()],r.prototype,\"__nbindConstructor\",void 0),__decorate([_defineHidden()],r.prototype,\"__nbindValueConstructor\",void 0),__decorate([_defineHidden(n)],r.prototype,\"__nbindPolicies\",void 0),r}function disableMember(n,e){function r(){throw new Error(\"Accessing deleted object\")}Object.defineProperty(n,e,{configurable:!1,enumerable:!1,get:r,set:r})}_nbind.Wrapper=Wrapper,_nbind.makeBound=makeBound,_nbind.ptrMarker={};var BindClass=function(n){function e(e){var r=n.call(this,e)||this;return r.wireRead=function(n){return _nbind.popValue(n,r.ptrType)},r.wireWrite=function(n){return pushPointer(n,r.ptrType,!0)},r.pendingSuperCount=0,r.ready=!1,r.methodTbl={},e.paramList?(r.classType=e.paramList[0].classType,r.proto=r.classType.proto):r.classType=r,r}return __extends(e,n),e.prototype.makeBound=function(n){var e=_nbind.makeBound(n,this);return this.proto=e,this.ptrType.proto=e,e},e.prototype.addMethod=function(n){var e=this.methodTbl[n.name]||[];e.push(n),this.methodTbl[n.name]=e},e.prototype.registerMethods=function(n,e){for(var r,t=0,i=Object.keys(n.methodTbl);t<i.length;t++)for(var u=i[t],o=0,a=n.methodTbl[u];o<a.length;o++){var f=a[o],c=void 0,l=void 0;if(c=this.proto.prototype,!e||1==f.signatureType)switch(f.signatureType){case 1:c=this.proto;case 5:l=_nbind.makeCaller(f),_nbind.addMethod(c,f.name,l,f.typeList.length-1);break;case 4:r=_nbind.makeMethodCaller(n.ptrType,f);break;case 3:Object.defineProperty(c,f.name,{configurable:!0,enumerable:!1,get:_nbind.makeMethodCaller(n.ptrType,f),set:r});break;case 2:l=_nbind.makeMethodCaller(n.ptrType,f),_nbind.addMethod(c,f.name,l,f.typeList.length-1)}}},e.prototype.registerSuperMethods=function(n,e,r){if(!r[n.name]){r[n.name]=!0;for(var t,i=0,u=0,o=n.superIdList||[];u<o.length;u++){var a=o[u],f=_nbind.getType(a);t=i++<e||e<0?-1:0,this.registerSuperMethods(f,t,r)}this.registerMethods(n,e<0)}},e.prototype.finish=function(){if(this.ready)return this;this.ready=!0,this.superList=(this.superIdList||[]).map((function(n){return _nbind.getType(n).finish()}));var n=this.proto;if(this.superList.length){var e=function(){this.constructor=n};e.prototype=this.superList[0].proto.prototype,n.prototype=new e}return n!=Module&&(n.prototype.__nbindType=this),this.registerSuperMethods(this,1,{}),this},e.prototype.upcastStep=function(n,e){if(n==this)return e;for(var r=0;r<this.superList.length;++r){var t=this.superList[r].upcastStep(n,_nbind.callUpcast(this.upcastList[r],e));if(t)return t}return 0},e}(_nbind.BindType);function popPointer(n,e){return n?new e.proto(_nbind.ptrMarker,e.flags,n):null}function pushPointer(n,e,r){if(!(n instanceof _nbind.Wrapper)){if(r)return _nbind.pushValue(n);throw new Error(\"Type mismatch\")}var t=n.__nbindPtr,i=n.__nbindType.classType,u=e.classType;if(n instanceof e.proto)for(;i!=u;)t=_nbind.callUpcast(i.upcastList[0],t),i=i.superList[0];else if(!(t=i.upcastStep(u,t)))throw new Error(\"Type mismatch\");return t}function pushMutablePointer(n,e){var r=pushPointer(n,e);if(1&n.__nbindFlags)throw new Error(\"Passing a const value as a non-const argument\");return r}BindClass.list=[],_nbind.BindClass=BindClass,_nbind.popPointer=popPointer,_nbind.pushPointer=pushPointer;var BindClassPtr=function(n){function e(e){var r=n.call(this,e)||this;r.classType=e.paramList[0].classType,r.proto=r.classType.proto;var t=1&e.flags,i=256==(896&r.flags)&&2&e.flags,u=t?pushPointer:pushMutablePointer,o=i?_nbind.popValue:popPointer;return r.makeWireWrite=function(n,e){return e.Nullable?function(n){return n?u(n,r):0}:function(n){return u(n,r)}},r.wireRead=function(n){return o(n,r)},r.wireWrite=function(n){return u(n,r)},r}return __extends(e,n),e}(_nbind.BindType);function popShared(n,e){var r=HEAPU32[n/4],t=HEAPU32[n/4+1];return t?new e.proto(_nbind.ptrMarker,e.flags,t,r):null}function pushShared(n,e){if(!(n instanceof e.proto))throw new Error(\"Type mismatch\");return n.__nbindShared}function pushMutableShared(n,e){if(!(n instanceof e.proto))throw new Error(\"Type mismatch\");if(1&n.__nbindFlags)throw new Error(\"Passing a const value as a non-const argument\");return n.__nbindShared}_nbind.BindClassPtr=BindClassPtr,_nbind.popShared=popShared;var SharedClassPtr=function(n){function e(e){var r=n.call(this,e)||this;r.readResources=[_nbind.resources.pool],r.classType=e.paramList[0].classType,r.proto=r.classType.proto;var t=1&e.flags?pushShared:pushMutableShared;return r.wireRead=function(n){return popShared(n,r)},r.wireWrite=function(n){return t(n,r)},r}return __extends(e,n),e}(_nbind.BindType);_nbind.SharedClassPtr=SharedClassPtr,_nbind.externalList=[0];var firstFreeExternal=0,External=function(){function n(n){this.refCount=1,this.data=n}return n.prototype.register=function(){var n=firstFreeExternal;return n?firstFreeExternal=_nbind.externalList[n]:n=_nbind.externalList.length,_nbind.externalList[n]=this,n},n.prototype.reference=function(){++this.refCount},n.prototype.dereference=function(n){0==--this.refCount&&(this.free&&this.free(),_nbind.externalList[n]=firstFreeExternal,firstFreeExternal=n)},n}();function popExternal(n){var e=_nbind.externalList[n];return e.dereference(n),e.data}function pushExternal(n){var e=new External(n);return e.reference(),e.register()}_nbind.External=External;var ExternalType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popExternal,e.wireWrite=pushExternal,e}return __extends(e,n),e}(_nbind.BindType);_nbind.ExternalType=ExternalType,_nbind.callbackSignatureList=[];var CallbackType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=function(n){return\"function\"!=typeof n&&_nbind.throwError(\"Type mismatch\"),new _nbind.External(n).register()},e}return __extends(e,n),e}(_nbind.BindType);_nbind.CallbackType=CallbackType,_nbind.valueList=[0];var firstFreeValue=0;function pushValue(n){var e=firstFreeValue;return e?firstFreeValue=_nbind.valueList[e]:e=_nbind.valueList.length,_nbind.valueList[e]=n,2*e+1}function popValue(n,e){if(n||_nbind.throwError(\"Value type JavaScript class is missing or not registered\"),1&n){n>>=1;var r=_nbind.valueList[n];return _nbind.valueList[n]=firstFreeValue,firstFreeValue=n,r}if(e)return _nbind.popShared(n,e);throw new Error(\"Invalid value slot \"+n)}_nbind.pushValue=pushValue,_nbind.popValue=popValue;var valueBase=0x10000000000000000;function push64(n){return\"number\"==typeof n?n:4096*pushValue(n)+valueBase}function pop64(n){return n<valueBase?n:popValue((n-valueBase)/4096)}var CreateValueType=function(n){function e(){return null!==n&&n.apply(this,arguments)||this}return __extends(e,n),e.prototype.makeWireWrite=function(n){return\"(_nbind.pushValue(new \"+n+\"))\"},e}(_nbind.BindType);_nbind.CreateValueType=CreateValueType;var Int64Type=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=push64,e.wireRead=pop64,e}return __extends(e,n),e}(_nbind.BindType);function pushArray(n,e){if(!n)return 0;var r=n.length;if((e.size||0===e.size)&&r<e.size)throw new Error(\"Type mismatch\");var t=e.memberType.ptrSize,i=_nbind.Pool.lalloc(4+r*t);HEAPU32[i/4]=r;var u=e.memberType.heap,o=(i+4)/t,a=e.memberType.wireWrite,f=0;if(a)for(;f<r;)u[o++]=a(n[f++]);else for(;f<r;)u[o++]=n[f++];return i}function popArray(n,e){if(0===n)return null;var r=HEAPU32[n/4],t=new Array(r),i=e.memberType.heap;n=(n+4)/e.memberType.ptrSize;var u=e.memberType.wireRead,o=0;if(u)for(;o<r;)t[o++]=u(i[n++]);else for(;o<r;)t[o++]=i[n++];return t}_nbind.Int64Type=Int64Type,_nbind.pushArray=pushArray,_nbind.popArray=popArray;var ArrayType=function(n){function e(e){var r=n.call(this,e)||this;return r.wireRead=function(n){return popArray(n,r)},r.wireWrite=function(n){return pushArray(n,r)},r.readResources=[_nbind.resources.pool],r.writeResources=[_nbind.resources.pool],r.memberType=e.paramList[0],e.paramList[1]&&(r.size=e.paramList[1]),r}return __extends(e,n),e}(_nbind.BindType);function pushString(n,e){if(null==n){if(!e||!e.Nullable)throw new Error(\"Type mismatch\");n=\"\"}if(e&&e.Strict){if(\"string\"!=typeof n)throw new Error(\"Type mismatch\")}else n=n.toString();var r=Module.lengthBytesUTF8(n),t=_nbind.Pool.lalloc(4+r+1);return HEAPU32[t/4]=r,Module.stringToUTF8Array(n,HEAPU8,t+4,r+1),t}function popString(n){if(0===n)return null;var e=HEAPU32[n/4];return Module.Pointer_stringify(n+4,e)}_nbind.ArrayType=ArrayType,_nbind.pushString=pushString,_nbind.popString=popString;var StringType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popString,e.wireWrite=pushString,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushString(n,e)}},e}(_nbind.BindType);function makeArgList(n){return Array.apply(null,Array(n)).map((function(n,e){return\"a\"+(e+1)}))}function anyNeedsWireWrite(n,e){return n.reduce((function(n,r){return n||r.needsWireWrite(e)}),!1)}function anyNeedsWireRead(n,e){return n.reduce((function(n,r){return n||!!r.needsWireRead(e)}),!1)}function makeWireRead(n,e,r,t){var i=n.length;return r.makeWireRead?r.makeWireRead(t,n,i):r.wireRead?(n[i]=r.wireRead,\"(convertParamList[\"+i+\"](\"+t+\"))\"):t}function makeWireWrite(n,e,r,t){var i,u=n.length;return(i=r.makeWireWrite?r.makeWireWrite(t,e,n,u):r.wireWrite)?\"string\"==typeof i?i:(n[u]=i,\"(convertParamList[\"+u+\"](\"+t+\"))\"):t}function buildCallerFunction(dynCall,ptrType,ptr,num,policyTbl,needsWireWrite,prefix,returnType,argTypeList,mask,err){var argList=makeArgList(argTypeList.length),convertParamList=[],callExpression=makeWireRead(convertParamList,policyTbl,returnType,\"dynCall(\"+[prefix].concat(argList.map((function(n,e){return makeWireWrite(convertParamList,policyTbl,argTypeList[e],n)}))).join(\",\")+\")\"),resourceSet=_nbind.listResources([returnType],argTypeList),sourceCode=\"function(\"+argList.join(\",\")+\"){\"+(mask?\"this.__nbindFlags&mask&&err();\":\"\")+resourceSet.makeOpen()+\"var r=\"+callExpression+\";\"+resourceSet.makeClose()+\"return r;}\";return eval(\"(\"+sourceCode+\")\")}function buildJSCallerFunction(returnType,argTypeList){var argList=makeArgList(argTypeList.length),convertParamList=[],callExpression=makeWireWrite(convertParamList,null,returnType,\"_nbind.externalList[num].data(\"+argList.map((function(n,e){return makeWireRead(convertParamList,null,argTypeList[e],n)})).join(\",\")+\")\"),resourceSet=_nbind.listResources(argTypeList,[returnType]);resourceSet.remove(_nbind.resources.pool);var sourceCode=\"function(\"+[\"dummy\",\"num\"].concat(argList).join(\",\")+\"){\"+resourceSet.makeOpen()+\"var r=\"+callExpression+\";\"+resourceSet.makeClose()+\"return r;}\";return eval(\"(\"+sourceCode+\")\")}function makeJSCaller(n){var e=n.length-1,r=_nbind.getTypes(n,\"callback\"),t=r[0],i=r.slice(1),u=anyNeedsWireRead(i,null);if(!t.needsWireWrite(null)&&!u)switch(e){case 0:return function(n,e){return _nbind.externalList[e].data()};case 1:return function(n,e,r){return _nbind.externalList[e].data(r)};case 2:return function(n,e,r,t){return _nbind.externalList[e].data(r,t)};case 3:return function(n,e,r,t,i){return _nbind.externalList[e].data(r,t,i)}}return buildJSCallerFunction(t,i)}function makeMethodCaller(n,e){var r=e.typeList.length-1,t=e.typeList.slice(0);t.splice(1,0,\"uint32_t\",e.boundID);var i=_nbind.getTypes(t,e.title),u=i[0],o=i.slice(3),a=u.needsWireRead(e.policyTbl),f=anyNeedsWireWrite(o,e.policyTbl),c=e.ptr,l=e.num,s=_nbind.getDynCall(i,e.title),d=1&~e.flags;function _(){throw new Error(\"Calling a non-const method on a const object\")}if(!a&&!f)switch(r){case 0:return function(){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n))};case 1:return function(e){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e)};case 2:return function(e,r){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e,r)};case 3:return function(e,r,t){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e,r,t)}}return buildCallerFunction(s,n,c,l,e.policyTbl,f,\"ptr,num,pushPointer(this,ptrType)\",u,o,d,_)}function makeCaller(n){var e,r=n.typeList.length-1,t=_nbind.getTypes(n.typeList,n.title),i=t[0],u=t.slice(1),o=i.needsWireRead(n.policyTbl),a=anyNeedsWireWrite(u,n.policyTbl),f=n.direct,c=n.ptr;if(n.direct&&!o&&!a){var l=_nbind.getDynCall(t,n.title);switch(r){case 0:return function(){return l(f)};case 1:return function(n){return l(f,n)};case 2:return function(n,e){return l(f,n,e)};case 3:return function(n,e,r){return l(f,n,e,r)}}c=0}if(c){var s=n.typeList.slice(0);s.splice(1,0,\"uint32_t\"),t=_nbind.getTypes(s,n.title),e=\"ptr,num\"}else c=f,e=\"ptr\";return buildCallerFunction(_nbind.getDynCall(t,n.title),null,c,n.num,n.policyTbl,a,e,i,u)}function makeOverloader(n,e){var r=[];function t(){return r[arguments.length].apply(this,arguments)}return t.addMethod=function(n,e){r[e]=n},t.addMethod(n,e),t}_nbind.StringType=StringType,_nbind.buildJSCallerFunction=buildJSCallerFunction,_nbind.makeJSCaller=makeJSCaller,_nbind.makeMethodCaller=makeMethodCaller,_nbind.makeCaller=makeCaller,_nbind.makeOverloader=makeOverloader;var Resource=function(){function n(n,e){var r=this;this.makeOpen=function(){return Object.keys(r.openTbl).join(\"\")},this.makeClose=function(){return Object.keys(r.closeTbl).join(\"\")},this.openTbl={},this.closeTbl={},n&&(this.openTbl[n]=!0),e&&(this.closeTbl[e]=!0)}return n.prototype.add=function(n){for(var e=0,r=Object.keys(n.openTbl);e<r.length;e++){var t=r[e];this.openTbl[t]=!0}for(var i=0,u=Object.keys(n.closeTbl);i<u.length;i++){t=u[i];this.closeTbl[t]=!0}},n.prototype.remove=function(n){for(var e=0,r=Object.keys(n.openTbl);e<r.length;e++){var t=r[e];delete this.openTbl[t]}for(var i=0,u=Object.keys(n.closeTbl);i<u.length;i++){t=u[i];delete this.closeTbl[t]}},n}();function listResources(n,e){for(var r=new Resource,t=0,i=n;t<i.length;t++)for(var u=0,o=i[t].readResources||[];u<o.length;u++){var a=o[u];r.add(a)}for(var f=0,c=e;f<c.length;f++)for(var l=0,s=c[f].writeResources||[];l<s.length;l++){a=s[l];r.add(a)}return r}_nbind.Resource=Resource,_nbind.listResources=listResources,_nbind.resources={pool:new Resource(\"var used=HEAPU32[_nbind.Pool.usedPtr],page=HEAPU32[_nbind.Pool.pagePtr];\",\"_nbind.Pool.lreset(used,page);\")};var ExternalBuffer=function(n){function e(e,r){var t=n.call(this,e)||this;return t.ptr=r,t}return __extends(e,n),e.prototype.free=function(){_free(this.ptr)},e}(_nbind.External);function getBuffer(n){return n instanceof ArrayBuffer?new Uint8Array(n):n instanceof DataView?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n}function pushBuffer(n,e){if(null==n&&e&&e.Nullable&&(n=[]),\"object\"!=typeof n)throw new Error(\"Type mismatch\");var r=n,t=r.byteLength||r.length;if(!t&&0!==t&&0!==r.byteLength)throw new Error(\"Type mismatch\");var i=_nbind.Pool.lalloc(8),u=_malloc(t),o=i/4;return HEAPU32[o++]=t,HEAPU32[o++]=u,HEAPU32[o++]=new ExternalBuffer(n,u).register(),HEAPU8.set(getBuffer(n),u),i}var BufferType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=pushBuffer,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushBuffer(n,e)}},e}(_nbind.BindType);function commitBuffer(n,e,r){var t=_nbind.externalList[n].data,i=Buffer;if(\"function\"!=typeof Buffer&&(i=function(){}),t instanceof Array);else{var u=HEAPU8.subarray(e,e+r);if(t instanceof i){(\"function\"==typeof Buffer.from&&Buffer.from.length>=3?Buffer.from(u):new Buffer(u)).copy(t)}else getBuffer(t).set(u)}}_nbind.BufferType=BufferType,_nbind.commitBuffer=commitBuffer;var dirtyList=[],gcTimer=0;function sweep(){for(var n=0,e=dirtyList;n<e.length;n++){var r=e[n];3&r.__nbindState||r.free()}dirtyList=[],gcTimer=0}function toggleLightGC(n){_nbind.mark=n?function(n){dirtyList.push(n),gcTimer||(gcTimer=setTimeout(sweep,0))}:function(n){}}_nbind.mark=function(n){},_nbind.toggleLightGC=toggleLightGC}(_nbind),Module.requestFullScreen=function(n,e,r){Module.printErr(\"Module.requestFullScreen is deprecated. Please call Module.requestFullscreen instead.\"),Module.requestFullScreen=Module.requestFullscreen,Browser.requestFullScreen(n,e,r)},Module.requestFullscreen=function(n,e,r){Browser.requestFullscreen(n,e,r)},Module.requestAnimationFrame=function(n){Browser.requestAnimationFrame(n)},Module.setCanvasSize=function(n,e,r){Browser.setCanvasSize(n,e,r)},Module.pauseMainLoop=function(){Browser.mainLoop.pause()},Module.resumeMainLoop=function(){Browser.mainLoop.resume()},Module.getUserMedia=function(){Browser.getUserMedia()},Module.createContext=function(n,e,r,t){return Browser.createContext(n,e,r,t)},_emscripten_get_now=ENVIRONMENT_IS_NODE?function(){var n=process.hrtime();return 1e3*n[0]+n[1]/1e6}:\"undefined\"!=typeof dateNow?dateNow:\"object\"==typeof self&&self.performance&&\"function\"==typeof self.performance.now?function(){return self.performance.now()}:\"object\"==typeof performance&&\"function\"==typeof performance.now?function(){return performance.now()}:Date.now,__ATEXIT__.push((function(){var n=Module._fflush;n&&n(0);var e=___syscall146.printChar;if(e){var r=___syscall146.buffers;r[1].length&&e(1,10),r[2].length&&e(2,10)}})),DYNAMICTOP_PTR=allocate(1,\"i32\",ALLOC_STATIC),STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP),STACK_MAX=STACK_BASE+TOTAL_STACK,DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX),HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE,staticSealed=!0,Module.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},Module.asmLibraryArg={abort:abort,assert:assert,enlargeMemory:enlargeMemory,getTotalMemory:getTotalMemory,abortOnCannotGrowMemory:abortOnCannotGrowMemory,invoke_viiiii:invoke_viiiii,invoke_vif:invoke_vif,invoke_vid:invoke_vid,invoke_fiff:invoke_fiff,invoke_vi:invoke_vi,invoke_vii:invoke_vii,invoke_ii:invoke_ii,invoke_viddi:invoke_viddi,invoke_vidd:invoke_vidd,invoke_iiii:invoke_iiii,invoke_diii:invoke_diii,invoke_di:invoke_di,invoke_iid:invoke_iid,invoke_iii:invoke_iii,invoke_viiddi:invoke_viiddi,invoke_viiiiii:invoke_viiiiii,invoke_dii:invoke_dii,invoke_i:invoke_i,invoke_iiiiii:invoke_iiiiii,invoke_viiid:invoke_viiid,invoke_viififi:invoke_viififi,invoke_viii:invoke_viii,invoke_v:invoke_v,invoke_viid:invoke_viid,invoke_idd:invoke_idd,invoke_viiii:invoke_viiii,_emscripten_asm_const_iiiii:_emscripten_asm_const_iiiii,_emscripten_asm_const_iiidddddd:_emscripten_asm_const_iiidddddd,_emscripten_asm_const_iiiid:_emscripten_asm_const_iiiid,__nbind_reference_external:__nbind_reference_external,_emscripten_asm_const_iiiiiiii:_emscripten_asm_const_iiiiiiii,_removeAccessorPrefix:_removeAccessorPrefix,_typeModule:_typeModule,__nbind_register_pool:__nbind_register_pool,__decorate:__decorate,_llvm_stackrestore:_llvm_stackrestore,___cxa_atexit:___cxa_atexit,__extends:__extends,__nbind_get_value_object:__nbind_get_value_object,__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj:__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj,_emscripten_set_main_loop_timing:_emscripten_set_main_loop_timing,__nbind_register_primitive:__nbind_register_primitive,__nbind_register_type:__nbind_register_type,_emscripten_memcpy_big:_emscripten_memcpy_big,__nbind_register_function:__nbind_register_function,___setErrNo:___setErrNo,__nbind_register_class:__nbind_register_class,__nbind_finish:__nbind_finish,_abort:_abort,_nbind_value:_nbind_value,_llvm_stacksave:_llvm_stacksave,___syscall54:___syscall54,_defineHidden:_defineHidden,_emscripten_set_main_loop:_emscripten_set_main_loop,_emscripten_get_now:_emscripten_get_now,__nbind_register_callback_signature:__nbind_register_callback_signature,_emscripten_asm_const_iiiiii:_emscripten_asm_const_iiiiii,__nbind_free_external:__nbind_free_external,_emscripten_asm_const_iiii:_emscripten_asm_const_iiii,_emscripten_asm_const_iiididi:_emscripten_asm_const_iiididi,___syscall6:___syscall6,_atexit:_atexit,___syscall140:___syscall140,___syscall146:___syscall146,DYNAMICTOP_PTR:DYNAMICTOP_PTR,tempDoublePtr:tempDoublePtr,ABORT:ABORT,STACKTOP:STACKTOP,STACK_MAX:STACK_MAX,cttz_i8:cttz_i8,___dso_handle:___dso_handle};var asm=function(n,e,r){\"use asm\";var t=new n.Int8Array(r);var i=new n.Int16Array(r);var u=new n.Int32Array(r);var o=new n.Uint8Array(r);var a=new n.Uint16Array(r);var f=new n.Uint32Array(r);var c=new n.Float32Array(r);var l=new n.Float64Array(r);var s=e.DYNAMICTOP_PTR|0;var d=e.tempDoublePtr|0;var _=e.ABORT|0;var v=e.STACKTOP|0;var p=e.STACK_MAX|0;var m=e.cttz_i8|0;var b=e.___dso_handle|0;var h=0;var y=0;var w=0;var M=0;var k=n.NaN,g=n.Infinity;var T=0,A=0,S=0,E=0,C=0.0;var L=0;var R=n.Math.floor;var P=n.Math.abs;var B=n.Math.sqrt;var O=n.Math.pow;var N=n.Math.cos;var I=n.Math.sin;var F=n.Math.tan;var x=n.Math.acos;var U=n.Math.asin;var H=n.Math.atan;var D=n.Math.atan2;var W=n.Math.exp;var Y=n.Math.log;var V=n.Math.ceil;var j=n.Math.imul;var q=n.Math.min;var z=n.Math.max;var G=n.Math.clz32;var K=n.Math.fround;var X=e.abort;var J=e.assert;var Z=e.enlargeMemory;var Q=e.getTotalMemory;var $=e.abortOnCannotGrowMemory;var nn=e.invoke_viiiii;var en=e.invoke_vif;var rn=e.invoke_vid;var tn=e.invoke_fiff;var un=e.invoke_vi;var on=e.invoke_vii;var an=e.invoke_ii;var fn=e.invoke_viddi;var cn=e.invoke_vidd;var ln=e.invoke_iiii;var sn=e.invoke_diii;var dn=e.invoke_di;var _n=e.invoke_iid;var vn=e.invoke_iii;var pn=e.invoke_viiddi;var mn=e.invoke_viiiiii;var bn=e.invoke_dii;var hn=e.invoke_i;var yn=e.invoke_iiiiii;var wn=e.invoke_viiid;var Mn=e.invoke_viififi;var kn=e.invoke_viii;var gn=e.invoke_v;var Tn=e.invoke_viid;var An=e.invoke_idd;var Sn=e.invoke_viiii;var En=e._emscripten_asm_const_iiiii;var Cn=e._emscripten_asm_const_iiidddddd;var Ln=e._emscripten_asm_const_iiiid;var Rn=e.__nbind_reference_external;var Pn=e._emscripten_asm_const_iiiiiiii;var Bn=e._removeAccessorPrefix;var On=e._typeModule;var Nn=e.__nbind_register_pool;var In=e.__decorate;var Fn=e._llvm_stackrestore;var xn=e.___cxa_atexit;var Un=e.__extends;var Hn=e.__nbind_get_value_object;var Dn=e.__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj;var Wn=e._emscripten_set_main_loop_timing;var Yn=e.__nbind_register_primitive;var Vn=e.__nbind_register_type;var jn=e._emscripten_memcpy_big;var qn=e.__nbind_register_function;var zn=e.___setErrNo;var Gn=e.__nbind_register_class;var Kn=e.__nbind_finish;var Xn=e._abort;var Jn=e._nbind_value;var Zn=e._llvm_stacksave;var Qn=e.___syscall54;var $n=e._defineHidden;var ne=e._emscripten_set_main_loop;var ee=e._emscripten_get_now;var re=e.__nbind_register_callback_signature;var te=e._emscripten_asm_const_iiiiii;var ie=e.__nbind_free_external;var ue=e._emscripten_asm_const_iiii;var oe=e._emscripten_asm_const_iiididi;var ae=e.___syscall6;var fe=e._atexit;var ce=e.___syscall140;var le=e.___syscall146;var se=K(0);const de=K(0);function _e(n){n=n|0;var e=0;e=v;v=v+n|0;v=v+15&-16;return e|0}function ve(){return v|0}function pe(n){n=n|0;v=n}function me(n,e){n=n|0;e=e|0;v=n;p=e}function be(n,e){n=n|0;e=e|0;if(!h){h=n;y=e}}function he(n){n=n|0;L=n}function ye(){return L|0}function we(){var n=0,e=0;iC(8104,8,400)|0;iC(8504,408,540)|0;n=9044;e=n+44|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));t[9088]=0;t[9089]=1;u[2273]=0;u[2274]=948;u[2275]=948;xn(17,8104,b|0)|0;return}function Me(n){n=n|0;ze(n+948|0);return}function ke(n){n=K(n);return((Bi(n)|0)&2147483647)>>>0>2139095040|0}function ge(n,e,r){n=n|0;e=e|0;r=r|0;n:do{if(!(u[n+(e<<3)+4>>2]|0)){if((e|2|0)==3?u[n+60>>2]|0:0){n=n+56|0;break}switch(e|0){case 0:case 2:case 4:case 5:{if(u[n+52>>2]|0){n=n+48|0;break n}break}default:{}}if(!(u[n+68>>2]|0)){n=(e|1|0)==5?948:r;break}else{n=n+64|0;break}}else n=n+(e<<3)|0}while(0);return n|0}function Te(n){n=n|0;var e=0;e=qS(1e3)|0;Ae(n,(e|0)!=0,2456);u[2276]=(u[2276]|0)+1;iC(e|0,8104,1e3)|0;if(t[n+2>>0]|0){u[e+4>>2]=2;u[e+12>>2]=4}u[e+976>>2]=n;return e|0}function Ae(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;i=v;v=v+16|0;t=i;if(!e){u[t>>2]=r;xt(n,5,3197,t)}v=i;return}function Se(){return Te(956)|0}function Ee(n){n=n|0;var e=0;e=GE(1e3)|0;Ce(e,n);Ae(u[n+976>>2]|0,1,2456);u[2276]=(u[2276]|0)+1;u[e+944>>2]=0;return e|0}function Ce(n,e){n=n|0;e=e|0;var r=0;iC(n|0,e|0,948)|0;Dt(n+948|0,e+948|0);r=n+960|0;n=e+960|0;e=r+40|0;do{u[r>>2]=u[n>>2];r=r+4|0;n=n+4|0}while((r|0)<(e|0));return}function Le(n){n=n|0;var e=0,r=0,t=0,i=0;e=n+944|0;r=u[e>>2]|0;if(r|0){Re(r+948|0,n)|0;u[e>>2]=0}r=Pe(n)|0;if(r|0){e=0;do{u[(Be(n,e)|0)+944>>2]=0;e=e+1|0}while((e|0)!=(r|0))}r=n+948|0;t=u[r>>2]|0;i=n+952|0;e=u[i>>2]|0;if((e|0)!=(t|0))u[i>>2]=e+(~((e+-4-t|0)>>>2)<<2);Oe(r);zS(n);u[2276]=(u[2276]|0)+-1;return}function Re(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0;t=u[n>>2]|0;f=n+4|0;r=u[f>>2]|0;o=r;n:do{if((t|0)==(r|0)){i=t;a=4}else{n=t;while(1){if((u[n>>2]|0)==(e|0)){i=n;a=4;break n}n=n+4|0;if((n|0)==(r|0)){n=0;break}}}}while(0);if((a|0)==4)if((i|0)!=(r|0)){t=i+4|0;n=o-t|0;e=n>>2;if(e){cC(i|0,t|0,n|0)|0;r=u[f>>2]|0}n=i+(e<<2)|0;if((r|0)==(n|0))n=1;else{u[f>>2]=r+(~((r+-4-n|0)>>>2)<<2);n=1}}else n=0;return n|0}function Pe(n){n=n|0;return(u[n+952>>2]|0)-(u[n+948>>2]|0)>>2|0}function Be(n,e){n=n|0;e=e|0;var r=0;r=u[n+948>>2]|0;if((u[n+952>>2]|0)-r>>2>>>0>e>>>0)n=u[r+(e<<2)>>2]|0;else n=0;return n|0}function Oe(n){n=n|0;var e=0,r=0,t=0,i=0;t=v;v=v+32|0;e=t;i=u[n>>2]|0;r=(u[n+4>>2]|0)-i|0;if(((u[n+8>>2]|0)-i|0)>>>0>r>>>0){i=r>>2;Oi(e,i,i,n+8|0);Ni(n,e);Ii(e)}v=t;return}function Ne(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;l=Pe(n)|0;do{if(l|0){if((u[(Be(n,0)|0)+944>>2]|0)==(n|0)){if(!(Re(n+948|0,e)|0))break;iC(e+400|0,8504,540)|0;u[e+944>>2]=0;qe(n);break}a=u[(u[n+976>>2]|0)+12>>2]|0;f=n+948|0;c=(a|0)==0;r=0;o=0;do{t=u[(u[f>>2]|0)+(o<<2)>>2]|0;if((t|0)==(e|0))qe(n);else{i=Ee(t)|0;u[(u[f>>2]|0)+(r<<2)>>2]=i;u[i+944>>2]=n;if(!c)IL[a&15](t,i,n,r);r=r+1|0}o=o+1|0}while((o|0)!=(l|0));if(r>>>0<l>>>0){c=n+948|0;f=n+952|0;a=r;r=u[f>>2]|0;do{o=(u[c>>2]|0)+(a<<2)|0;t=o+4|0;i=r-t|0;e=i>>2;if(!e)i=r;else{cC(o|0,t|0,i|0)|0;r=u[f>>2]|0;i=r}t=o+(e<<2)|0;if((i|0)!=(t|0)){r=i+(~((i+-4-t|0)>>>2)<<2)|0;u[f>>2]=r}a=a+1|0}while((a|0)!=(l|0))}}}while(0);return}function Ie(n){n=n|0;var e=0,r=0,i=0,o=0;Fe(n,(Pe(n)|0)==0,2491);Fe(n,(u[n+944>>2]|0)==0,2545);e=n+948|0;r=u[e>>2]|0;i=n+952|0;o=u[i>>2]|0;if((o|0)!=(r|0))u[i>>2]=o+(~((o+-4-r|0)>>>2)<<2);Oe(e);e=n+976|0;r=u[e>>2]|0;iC(n|0,8104,1e3)|0;if(t[r+2>>0]|0){u[n+4>>2]=2;u[n+12>>2]=4}u[e>>2]=r;return}function Fe(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;i=v;v=v+16|0;t=i;if(!e){u[t>>2]=r;At(n,5,3197,t)}v=i;return}function xe(){return u[2276]|0}function Ue(){var n=0;n=qS(20)|0;He((n|0)!=0,2592);u[2277]=(u[2277]|0)+1;u[n>>2]=u[239];u[n+4>>2]=u[240];u[n+8>>2]=u[241];u[n+12>>2]=u[242];u[n+16>>2]=u[243];return n|0}function He(n,e){n=n|0;e=e|0;var r=0,t=0;t=v;v=v+16|0;r=t;if(!n){u[r>>2]=e;At(0,5,3197,r)}v=t;return}function De(n){n=n|0;zS(n);u[2277]=(u[2277]|0)+-1;return}function We(n,e){n=n|0;e=e|0;var r=0;if(!e){r=0;e=0}else{Fe(n,(Pe(n)|0)==0,2629);r=1}u[n+964>>2]=e;u[n+988>>2]=r;return}function Ye(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;o=t+8|0;i=t+4|0;a=t;u[i>>2]=e;Fe(n,(u[e+944>>2]|0)==0,2709);Fe(n,(u[n+964>>2]|0)==0,2763);Ve(n);e=n+948|0;u[a>>2]=(u[e>>2]|0)+(r<<2);u[o>>2]=u[a>>2];je(e,o,i)|0;u[(u[i>>2]|0)+944>>2]=n;qe(n);v=t;return}function Ve(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=Pe(n)|0;if(r|0?(u[(Be(n,0)|0)+944>>2]|0)!=(n|0):0){t=u[(u[n+976>>2]|0)+12>>2]|0;i=n+948|0;o=(t|0)==0;e=0;do{a=u[(u[i>>2]|0)+(e<<2)>>2]|0;f=Ee(a)|0;u[(u[i>>2]|0)+(e<<2)>>2]=f;u[f+944>>2]=n;if(!o)IL[t&15](a,f,n,e);e=e+1|0}while((e|0)!=(r|0))}return}function je(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0;h=v;v=v+64|0;d=h+52|0;f=h+48|0;_=h+28|0;p=h+24|0;m=h+20|0;b=h;t=u[n>>2]|0;o=t;e=t+((u[e>>2]|0)-o>>2<<2)|0;t=n+4|0;i=u[t>>2]|0;a=n+8|0;do{if(i>>>0<(u[a>>2]|0)>>>0){if((e|0)==(i|0)){u[e>>2]=u[r>>2];u[t>>2]=(u[t>>2]|0)+4;break}Fi(n,e,i,e+4|0);if(e>>>0<=r>>>0)r=(u[t>>2]|0)>>>0>r>>>0?r+4|0:r;u[e>>2]=u[r>>2]}else{t=(i-o>>2)+1|0;i=Vt(n)|0;if(i>>>0<t>>>0)DE(n);s=u[n>>2]|0;l=(u[a>>2]|0)-s|0;o=l>>1;Oi(b,l>>2>>>0<i>>>1>>>0?o>>>0<t>>>0?t:o:i,e-s>>2,n+8|0);s=b+8|0;t=u[s>>2]|0;o=b+12|0;l=u[o>>2]|0;a=l;c=t;do{if((t|0)==(l|0)){l=b+4|0;t=u[l>>2]|0;y=u[b>>2]|0;i=y;if(t>>>0<=y>>>0){t=a-i>>1;t=(t|0)==0?1:t;Oi(_,t,t>>>2,u[b+16>>2]|0);u[p>>2]=u[l>>2];u[m>>2]=u[s>>2];u[f>>2]=u[p>>2];u[d>>2]=u[m>>2];Ui(_,f,d);t=u[b>>2]|0;u[b>>2]=u[_>>2];u[_>>2]=t;t=_+4|0;y=u[l>>2]|0;u[l>>2]=u[t>>2];u[t>>2]=y;t=_+8|0;y=u[s>>2]|0;u[s>>2]=u[t>>2];u[t>>2]=y;t=_+12|0;y=u[o>>2]|0;u[o>>2]=u[t>>2];u[t>>2]=y;Ii(_);t=u[s>>2]|0;break}o=t;a=((o-i>>2)+1|0)/-2|0;f=t+(a<<2)|0;i=c-o|0;o=i>>2;if(o){cC(f|0,t|0,i|0)|0;t=u[l>>2]|0}y=f+(o<<2)|0;u[s>>2]=y;u[l>>2]=t+(a<<2);t=y}}while(0);u[t>>2]=u[r>>2];u[s>>2]=(u[s>>2]|0)+4;e=xi(n,b,e)|0;Ii(b)}}while(0);v=h;return e|0}function qe(n){n=n|0;var e=0;do{e=n+984|0;if(t[e>>0]|0)break;t[e>>0]=1;c[n+504>>2]=K(k);n=u[n+944>>2]|0}while((n|0)!=0);return}function ze(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function Ge(n){n=n|0;return u[n+944>>2]|0}function Ke(n){n=n|0;Fe(n,(u[n+964>>2]|0)!=0,2832);qe(n);return}function Xe(n){n=n|0;return(t[n+984>>0]|0)!=0|0}function Je(n,e){n=n|0;e=e|0;if(iE(n,e,400)|0){iC(n|0,e|0,400)|0;qe(n)}return}function Ze(n){n=n|0;var e=de;e=K(c[n+44>>2]);n=ke(e)|0;return K(n?K(0.0):e)}function Qe(n){n=n|0;var e=de;e=K(c[n+48>>2]);if(ke(e)|0)e=t[(u[n+976>>2]|0)+2>>0]|0?K(1.0):K(0.0);return K(e)}function $e(n,e){n=n|0;e=e|0;u[n+980>>2]=e;return}function nr(n){n=n|0;return u[n+980>>2]|0}function er(n,e){n=n|0;e=e|0;var r=0;r=n+4|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function rr(n){n=n|0;return u[n+4>>2]|0}function tr(n,e){n=n|0;e=e|0;var r=0;r=n+8|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function ir(n){n=n|0;return u[n+8>>2]|0}function ur(n,e){n=n|0;e=e|0;var r=0;r=n+12|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function or(n){n=n|0;return u[n+12>>2]|0}function ar(n,e){n=n|0;e=e|0;var r=0;r=n+16|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function fr(n){n=n|0;return u[n+16>>2]|0}function cr(n,e){n=n|0;e=e|0;var r=0;r=n+20|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function lr(n){n=n|0;return u[n+20>>2]|0}function sr(n,e){n=n|0;e=e|0;var r=0;r=n+24|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function dr(n){n=n|0;return u[n+24>>2]|0}function _r(n,e){n=n|0;e=e|0;var r=0;r=n+28|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function vr(n){n=n|0;return u[n+28>>2]|0}function pr(n,e){n=n|0;e=e|0;var r=0;r=n+32|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function mr(n){n=n|0;return u[n+32>>2]|0}function br(n,e){n=n|0;e=e|0;var r=0;r=n+36|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function hr(n){n=n|0;return u[n+36>>2]|0}function yr(n,e){n=n|0;e=K(e);var r=0;r=n+40|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function wr(n,e){n=n|0;e=K(e);var r=0;r=n+44|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function Mr(n,e){n=n|0;e=K(e);var r=0;r=n+48|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function kr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+52|0;i=n+56|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function gr(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+52|0;r=n+56|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Tr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+52|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Ar(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+132+(e<<3)|0;e=n+132+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Sr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+132+(e<<3)|0;e=n+132+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Er(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+132+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Cr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+60+(e<<3)|0;e=n+60+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Lr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+60+(e<<3)|0;e=n+60+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Rr(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+60+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Pr(n,e){n=n|0;e=e|0;var r=0;r=n+60+(e<<3)+4|0;if((u[r>>2]|0)!=3){c[n+60+(e<<3)>>2]=K(k);u[r>>2]=3;qe(n)}return}function Br(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+204+(e<<3)|0;e=n+204+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Or(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+204+(e<<3)|0;e=n+204+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Nr(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+204+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Ir(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+276+(e<<3)|0;e=n+276+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Fr(n,e){n=n|0;e=e|0;return K(c[n+276+(e<<3)>>2])}function xr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+348|0;i=n+352|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Ur(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+348|0;r=n+352|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Hr(n){n=n|0;var e=0;e=n+352|0;if((u[e>>2]|0)!=3){c[n+348>>2]=K(k);u[e>>2]=3;qe(n)}return}function Dr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+348|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Wr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+356|0;i=n+360|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Yr(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+356|0;r=n+360|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Vr(n){n=n|0;var e=0;e=n+360|0;if((u[e>>2]|0)!=3){c[n+356>>2]=K(k);u[e>>2]=3;qe(n)}return}function jr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+356|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function qr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+364|0;i=n+368|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function zr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+364|0;i=n+368|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Gr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+364|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Kr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+372|0;i=n+376|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Xr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+372|0;i=n+376|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Jr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+372|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Zr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+380|0;i=n+384|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Qr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+380|0;i=n+384|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function $r(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+380|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function nt(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+388|0;i=n+392|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function et(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+388|0;i=n+392|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function rt(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+388|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function tt(n,e){n=n|0;e=K(e);var r=0;r=n+396|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function it(n){n=n|0;return K(c[n+396>>2])}function ut(n){n=n|0;return K(c[n+400>>2])}function ot(n){n=n|0;return K(c[n+404>>2])}function at(n){n=n|0;return K(c[n+408>>2])}function ft(n){n=n|0;return K(c[n+412>>2])}function ct(n){n=n|0;return K(c[n+416>>2])}function lt(n){n=n|0;return K(c[n+420>>2])}function st(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+424+(e<<2)>>2])}function dt(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+448+(e<<2)>>2])}function _t(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+472+(e<<2)>>2])}function vt(n,e){n=n|0;e=e|0;var r=0,t=de;r=u[n+4>>2]|0;if((r|0)==(u[e+4>>2]|0)){if(!r)n=1;else{t=K(c[n>>2]);n=K(P(K(t-K(c[e>>2]))))<K(.0000999999974)}}else n=0;return n|0}function pt(n,e){n=K(n);e=K(e);var r=0;if(ke(n)|0)r=ke(e)|0;else r=K(P(K(n-e)))<K(.0000999999974);return r|0}function mt(n,e){n=n|0;e=e|0;bt(n,e);return}function bt(n,e){n=n|0;e=e|0;var r=0,i=0;r=v;v=v+16|0;i=r+4|0;u[i>>2]=0;u[i+4>>2]=0;u[i+8>>2]=0;Dn(i|0,n|0,e|0,0);At(n,3,(t[i+11>>0]|0)<0?u[i>>2]|0:i,r);JE(i);v=r;return}function ht(n,e,r,t){n=K(n);e=K(e);r=r|0;t=t|0;var i=de;n=K(n*e);i=K(xE(n,K(1.0)));do{if(!(pt(i,K(0.0))|0)){n=K(n-i);if(pt(i,K(1.0))|0){n=K(n+K(1.0));break}if(r){n=K(n+K(1.0));break}if(!t){if(i>K(.5))i=K(1.0);else{t=pt(i,K(.5))|0;i=t?K(1.0):K(0.0)}n=K(n+i)}}else n=K(n-i)}while(0);return K(n/e)}function yt(n,e,r,t,i,u,o,a,f,l,s,d,_){n=n|0;e=K(e);r=r|0;t=K(t);i=i|0;u=K(u);o=o|0;a=K(a);f=K(f);l=K(l);s=K(s);d=K(d);_=_|0;var v=0,p=de,m=de,b=de,h=de,y=de,w=de;if(f<K(0.0)|l<K(0.0))_=0;else{if((_|0)!=0?(p=K(c[_+4>>2]),p!=K(0.0)):0){b=K(ht(e,p,0,0));h=K(ht(t,p,0,0));m=K(ht(u,p,0,0));p=K(ht(a,p,0,0))}else{m=u;b=e;p=a;h=t}if((i|0)==(n|0))v=pt(m,b)|0;else v=0;if((o|0)==(r|0))_=pt(p,h)|0;else _=0;if((!v?(y=K(e-s),!(wt(n,y,f)|0)):0)?!(Mt(n,y,i,f)|0):0)v=kt(n,y,i,u,f)|0;else v=1;if((!_?(w=K(t-d),!(wt(r,w,l)|0)):0)?!(Mt(r,w,o,l)|0):0)_=kt(r,w,o,a,l)|0;else _=1;_=v&_}return _|0}function wt(n,e,r){n=n|0;e=K(e);r=K(r);if((n|0)==1)n=pt(e,r)|0;else n=0;return n|0}function Mt(n,e,r,t){n=n|0;e=K(e);r=r|0;t=K(t);if((n|0)==2&(r|0)==0){if(!(e>=t))n=pt(e,t)|0;else n=1}else n=0;return n|0}function kt(n,e,r,t,i){n=n|0;e=K(e);r=r|0;t=K(t);i=K(i);if((n|0)==2&(r|0)==2&t>e){if(!(i<=e))n=pt(e,i)|0;else n=1}else n=0;return n|0}function gt(n,e,r,i,o,a,f,s,d,_,p){n=n|0;e=K(e);r=K(r);i=i|0;o=o|0;a=a|0;f=K(f);s=K(s);d=d|0;_=_|0;p=p|0;var m=0,b=0,h=0,y=0,w=de,M=de,k=0,g=0,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=de,N=de,I=de,F=0.0,x=0.0;B=v;v=v+160|0;L=B+152|0;C=B+120|0;E=B+104|0;T=B+72|0;y=B+56|0;S=B+8|0;g=B;A=(u[2279]|0)+1|0;u[2279]=A;R=n+984|0;if((t[R>>0]|0)!=0?(u[n+512>>2]|0)!=(u[2278]|0):0)k=4;else if((u[n+516>>2]|0)==(i|0))P=0;else k=4;if((k|0)==4){u[n+520>>2]=0;u[n+924>>2]=-1;u[n+928>>2]=-1;c[n+932>>2]=K(-1.0);c[n+936>>2]=K(-1.0);P=1}n:do{if(!(u[n+964>>2]|0)){if(d){m=n+916|0;if(!(pt(K(c[m>>2]),e)|0)){k=21;break}if(!(pt(K(c[n+920>>2]),r)|0)){k=21;break}if((u[n+924>>2]|0)!=(o|0)){k=21;break}m=(u[n+928>>2]|0)==(a|0)?m:0;k=22;break}h=u[n+520>>2]|0;if(!h)k=21;else{b=0;while(1){m=n+524+(b*24|0)|0;if(((pt(K(c[m>>2]),e)|0?pt(K(c[n+524+(b*24|0)+4>>2]),r)|0:0)?(u[n+524+(b*24|0)+8>>2]|0)==(o|0):0)?(u[n+524+(b*24|0)+12>>2]|0)==(a|0):0){k=22;break n}b=b+1|0;if(b>>>0>=h>>>0){k=21;break}}}}else{w=K(Tt(n,2,f));M=K(Tt(n,0,f));m=n+916|0;I=K(c[m>>2]);N=K(c[n+920>>2]);O=K(c[n+932>>2]);if(!(yt(o,e,a,r,u[n+924>>2]|0,I,u[n+928>>2]|0,N,O,K(c[n+936>>2]),w,M,p)|0)){h=u[n+520>>2]|0;if(!h)k=21;else{b=0;while(1){m=n+524+(b*24|0)|0;O=K(c[m>>2]);N=K(c[n+524+(b*24|0)+4>>2]);I=K(c[n+524+(b*24|0)+16>>2]);if(yt(o,e,a,r,u[n+524+(b*24|0)+8>>2]|0,O,u[n+524+(b*24|0)+12>>2]|0,N,I,K(c[n+524+(b*24|0)+20>>2]),w,M,p)|0){k=22;break n}b=b+1|0;if(b>>>0>=h>>>0){k=21;break}}}}else k=22}}while(0);do{if((k|0)==21){if(!(t[11697]|0)){m=0;k=31}else{m=0;k=28}}else if((k|0)==22){b=(t[11697]|0)!=0;if(!((m|0)!=0&(P^1)))if(b){k=28;break}else{k=31;break}y=m+16|0;u[n+908>>2]=u[y>>2];h=m+20|0;u[n+912>>2]=u[h>>2];if(!((t[11698]|0)==0|b^1)){u[g>>2]=St(A)|0;u[g+4>>2]=A;At(n,4,2972,g);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);o=Et(o,d)|0;a=Et(a,d)|0;x=+K(c[y>>2]);F=+K(c[h>>2]);u[S>>2]=o;u[S+4>>2]=a;l[S+8>>3]=+e;l[S+16>>3]=+r;l[S+24>>3]=x;l[S+32>>3]=F;u[S+40>>2]=_;At(n,4,2989,S)}}}while(0);if((k|0)==28){b=St(A)|0;u[y>>2]=b;u[y+4>>2]=A;u[y+8>>2]=P?3047:11699;At(n,4,3038,y);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);S=Et(o,d)|0;k=Et(a,d)|0;u[T>>2]=S;u[T+4>>2]=k;l[T+8>>3]=+e;l[T+16>>3]=+r;u[T+24>>2]=_;At(n,4,3049,T);k=31}if((k|0)==31){Ct(n,e,r,i,o,a,f,s,d,p);if(t[11697]|0){b=u[2279]|0;S=St(b)|0;u[E>>2]=S;u[E+4>>2]=b;u[E+8>>2]=P?3047:11699;At(n,4,3083,E);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);S=Et(o,d)|0;E=Et(a,d)|0;F=+K(c[n+908>>2]);x=+K(c[n+912>>2]);u[C>>2]=S;u[C+4>>2]=E;l[C+8>>3]=F;l[C+16>>3]=x;u[C+24>>2]=_;At(n,4,3092,C)}u[n+516>>2]=i;if(!m){b=n+520|0;m=u[b>>2]|0;if((m|0)==16){if(t[11697]|0)At(n,4,3124,L);u[b>>2]=0;m=0}if(d)m=n+916|0;else{u[b>>2]=m+1;m=n+524+(m*24|0)|0}c[m>>2]=e;c[m+4>>2]=r;u[m+8>>2]=o;u[m+12>>2]=a;u[m+16>>2]=u[n+908>>2];u[m+20>>2]=u[n+912>>2];m=0}}if(d){u[n+416>>2]=u[n+908>>2];u[n+420>>2]=u[n+912>>2];t[n+985>>0]=1;t[R>>0]=0}u[2279]=(u[2279]|0)+-1;u[n+512>>2]=u[2278];v=B;return P|(m|0)==0|0}function Tt(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(jt(n,e,r));return K(t+K(qt(n,e,r)))}function At(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=v;v=v+16|0;i=o;u[i>>2]=t;if(!n)t=0;else t=u[n+976>>2]|0;Ut(t,n,e,r,i);v=o;return}function St(n){n=n|0;return(n>>>0>60?3201:3201+(60-n)|0)|0}function Et(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i+12|0;t=i;u[r>>2]=u[254];u[r+4>>2]=u[255];u[r+8>>2]=u[256];u[t>>2]=u[257];u[t+4>>2]=u[258];u[t+8>>2]=u[259];if((n|0)>2)n=11699;else n=u[(e?t:r)+(n<<2)>>2]|0;v=i;return n|0}function Ct(n,e,r,i,a,f,l,s,_,p){n=n|0;e=K(e);r=K(r);i=i|0;a=a|0;f=f|0;l=K(l);s=K(s);_=_|0;p=p|0;var m=0,b=0,h=0,y=0,w=de,M=de,k=de,g=de,T=de,A=de,S=de,E=0,C=0,L=0,R=de,P=de,B=0,O=de,N=0,I=0,F=0,x=0,U=0,H=0,D=0,W=0,Y=0,V=0,j=0,q=0,z=0,G=0,X=0,J=0,Z=0,Q=0,$=de,nn=de,en=de,rn=de,tn=de,un=0,on=0,an=0,fn=0,cn=0,ln=de,sn=de,dn=de,_n=de,vn=de,pn=de,mn=0,bn=de,hn=de,yn=de,wn=de,Mn=de,kn=de,gn=0,Tn=0,An=de,Sn=de,En=0,Cn=0,Ln=0,Rn=0,Pn=de,Bn=0,On=0,Nn=0,In=0,Fn=0,xn=0,Un=0,Hn=de,Dn=0,Wn=0;Un=v;v=v+16|0;un=Un+12|0;on=Un+8|0;an=Un+4|0;fn=Un;Fe(n,(a|0)==0|(ke(e)|0)^1,3326);Fe(n,(f|0)==0|(ke(r)|0)^1,3406);On=Kt(n,i)|0;u[n+496>>2]=On;Fn=Xt(2,On)|0;xn=Xt(0,On)|0;c[n+440>>2]=K(jt(n,Fn,l));c[n+444>>2]=K(qt(n,Fn,l));c[n+428>>2]=K(jt(n,xn,l));c[n+436>>2]=K(qt(n,xn,l));c[n+464>>2]=K(Jt(n,Fn));c[n+468>>2]=K(Zt(n,Fn));c[n+452>>2]=K(Jt(n,xn));c[n+460>>2]=K(Zt(n,xn));c[n+488>>2]=K(Qt(n,Fn,l));c[n+492>>2]=K($t(n,Fn,l));c[n+476>>2]=K(Qt(n,xn,l));c[n+484>>2]=K($t(n,xn,l));do{if(!(u[n+964>>2]|0)){Nn=n+948|0;In=(u[n+952>>2]|0)-(u[Nn>>2]|0)>>2;if(!In){ei(n,e,r,a,f,l,s);break}if(!_?ri(n,e,r,a,f,l,s)|0:0)break;Ve(n);J=n+508|0;t[J>>0]=0;Fn=Xt(u[n+4>>2]|0,On)|0;xn=ti(Fn,On)|0;Bn=zt(Fn)|0;Z=u[n+8>>2]|0;Cn=n+28|0;Q=(u[Cn>>2]|0)!=0;Mn=Bn?l:s;An=Bn?s:l;$=K(ii(n,Fn,l));nn=K(ui(n,Fn,l));w=K(ii(n,xn,l));kn=K(oi(n,Fn,l));Sn=K(oi(n,xn,l));L=Bn?a:f;En=Bn?f:a;Pn=Bn?kn:Sn;T=Bn?Sn:kn;wn=K(Tt(n,2,l));g=K(Tt(n,0,l));M=K(K(Ot(n+364|0,l))-Pn);k=K(K(Ot(n+380|0,l))-Pn);A=K(K(Ot(n+372|0,s))-T);S=K(K(Ot(n+388|0,s))-T);en=Bn?M:A;rn=Bn?k:S;wn=K(e-wn);e=K(wn-Pn);if(ke(e)|0)Pn=e;else Pn=K(OE(K(IE(e,k)),M));hn=K(r-g);e=K(hn-T);if(ke(e)|0)yn=e;else yn=K(OE(K(IE(e,S)),A));M=Bn?Pn:yn;bn=Bn?yn:Pn;n:do{if((L|0)==1){i=0;b=0;while(1){m=Be(n,b)|0;if(!i){if(K(fi(m))>K(0.0)?K(ci(m))>K(0.0):0)i=m;else i=0}else if(ai(m)|0){y=0;break n}b=b+1|0;if(b>>>0>=In>>>0){y=i;break}}}else y=0}while(0);E=y+500|0;C=y+504|0;i=0;m=0;e=K(0.0);h=0;do{b=u[(u[Nn>>2]|0)+(h<<2)>>2]|0;if((u[b+36>>2]|0)==1){li(b);t[b+985>>0]=1;t[b+984>>0]=0}else{Pt(b);if(_)Nt(b,Kt(b,On)|0,M,bn,Pn);do{if((u[b+24>>2]|0)!=1){if((b|0)==(y|0)){u[E>>2]=u[2278];c[C>>2]=K(0.0);break}else{si(n,b,Pn,a,yn,Pn,yn,f,On,p);break}}else{if(m|0)u[m+960>>2]=b;u[b+960>>2]=0;m=b;i=(i|0)==0?b:i}}while(0);pn=K(c[b+504>>2]);e=K(e+K(pn+K(Tt(b,Fn,Pn))))}h=h+1|0}while((h|0)!=(In|0));F=e>M;mn=Q&((L|0)==2&F)?1:L;N=(En|0)==1;U=N&(_^1);H=(mn|0)==1;D=(mn|0)==2;W=976+(Fn<<2)|0;Y=(En|2|0)==2;G=N&(Q^1);V=1040+(xn<<2)|0;j=1040+(Fn<<2)|0;q=976+(xn<<2)|0;z=(En|0)!=1;F=Q&((L|0)!=0&F);I=n+976|0;N=N^1;e=M;B=0;x=0;pn=K(0.0);tn=K(0.0);while(1){n:do{if(B>>>0<In>>>0){C=u[Nn>>2]|0;h=0;S=K(0.0);A=K(0.0);k=K(0.0);M=K(0.0);b=0;m=0;y=B;while(1){E=u[C+(y<<2)>>2]|0;if((u[E+36>>2]|0)!=1?(u[E+940>>2]=x,(u[E+24>>2]|0)!=1):0){g=K(Tt(E,Fn,Pn));X=u[W>>2]|0;r=K(Ot(E+380+(X<<3)|0,Mn));T=K(c[E+504>>2]);r=K(IE(r,T));r=K(OE(K(Ot(E+364+(X<<3)|0,Mn)),r));if(Q&(h|0)!=0&K(g+K(A+r))>e){f=h;g=S;L=y;break n}g=K(g+r);r=K(A+g);g=K(S+g);if(ai(E)|0){k=K(k+K(fi(E)));M=K(M-K(T*K(ci(E))))}if(m|0)u[m+960>>2]=E;u[E+960>>2]=0;h=h+1|0;m=E;b=(b|0)==0?E:b}else{g=S;r=A}y=y+1|0;if(y>>>0<In>>>0){S=g;A=r}else{f=h;L=y;break}}}else{f=0;g=K(0.0);k=K(0.0);M=K(0.0);b=0;L=B}}while(0);X=k>K(0.0)&k<K(1.0);R=X?K(1.0):k;X=M>K(0.0)&M<K(1.0);S=X?K(1.0):M;do{if(!H){if(!(g<en&((ke(en)|0)^1))){if(!(g>rn&((ke(rn)|0)^1))){if(!(t[(u[I>>2]|0)+3>>0]|0)){if(!(R==K(0.0))?!(K(fi(n))==K(0.0)):0){X=53;break}e=g;X=53}else X=51}else{e=rn;X=51}}else{e=en;X=51}}else X=51}while(0);if((X|0)==51){X=0;if(ke(e)|0)X=53;else{P=K(e-g);O=e}}if((X|0)==53){X=0;if(g<K(0.0)){P=K(-g);O=e}else{P=K(0.0);O=e}}if(!U?(cn=(b|0)==0,!cn):0){h=u[W>>2]|0;y=P<K(0.0);T=K(P/S);E=P>K(0.0);A=K(P/R);k=K(0.0);g=K(0.0);e=K(0.0);m=b;do{r=K(Ot(m+380+(h<<3)|0,Mn));M=K(Ot(m+364+(h<<3)|0,Mn));M=K(IE(r,K(OE(M,K(c[m+504>>2])))));if(y){r=K(M*K(ci(m)));if(r!=K(-0.0)?(Hn=K(M-K(T*r)),ln=K(di(m,Fn,Hn,O,Pn)),Hn!=ln):0){k=K(k-K(ln-M));e=K(e+r)}}else if((E?(sn=K(fi(m)),sn!=K(0.0)):0)?(Hn=K(M+K(A*sn)),dn=K(di(m,Fn,Hn,O,Pn)),Hn!=dn):0){k=K(k-K(dn-M));g=K(g-sn)}m=u[m+960>>2]|0}while((m|0)!=0);e=K(S+e);M=K(P+k);if(!cn){T=K(R+g);y=u[W>>2]|0;E=M<K(0.0);C=e==K(0.0);A=K(M/e);h=M>K(0.0);T=K(M/T);e=K(0.0);do{Hn=K(Ot(b+380+(y<<3)|0,Mn));k=K(Ot(b+364+(y<<3)|0,Mn));k=K(IE(Hn,K(OE(k,K(c[b+504>>2])))));if(E){Hn=K(k*K(ci(b)));M=K(-Hn);if(Hn!=K(-0.0)){Hn=K(A*M);M=K(di(b,Fn,K(k+(C?M:Hn)),O,Pn))}else M=k}else if(h?(_n=K(fi(b)),_n!=K(0.0)):0)M=K(di(b,Fn,K(k+K(T*_n)),O,Pn));else M=k;e=K(e-K(M-k));g=K(Tt(b,Fn,Pn));r=K(Tt(b,xn,Pn));M=K(M+g);c[on>>2]=M;u[fn>>2]=1;k=K(c[b+396>>2]);n:do{if(ke(k)|0){m=ke(bn)|0;do{if(!m){if(F|(Bt(b,xn,bn)|0|N))break;if((_i(n,b)|0)!=4)break;if((u[(vi(b,xn)|0)+4>>2]|0)==3)break;if((u[(pi(b,xn)|0)+4>>2]|0)==3)break;c[un>>2]=bn;u[an>>2]=1;break n}}while(0);if(Bt(b,xn,bn)|0){m=u[b+992+(u[q>>2]<<2)>>2]|0;Hn=K(r+K(Ot(m,bn)));c[un>>2]=Hn;m=z&(u[m+4>>2]|0)==2;u[an>>2]=((ke(Hn)|0|m)^1)&1;break}else{c[un>>2]=bn;u[an>>2]=m?0:2;break}}else{Hn=K(M-g);R=K(Hn/k);Hn=K(k*Hn);u[an>>2]=1;c[un>>2]=K(r+(Bn?R:Hn))}}while(0);mi(b,Fn,O,Pn,fn,on);mi(b,xn,bn,Pn,an,un);do{if(!(Bt(b,xn,bn)|0)?(_i(n,b)|0)==4:0){if((u[(vi(b,xn)|0)+4>>2]|0)==3){m=0;break}m=(u[(pi(b,xn)|0)+4>>2]|0)!=3}else m=0}while(0);Hn=K(c[on>>2]);R=K(c[un>>2]);Dn=u[fn>>2]|0;Wn=u[an>>2]|0;gt(b,Bn?Hn:R,Bn?R:Hn,On,Bn?Dn:Wn,Bn?Wn:Dn,Pn,yn,_&(m^1),3488,p)|0;t[J>>0]=t[J>>0]|t[b+508>>0];b=u[b+960>>2]|0}while((b|0)!=0)}else e=K(0.0)}else e=K(0.0);e=K(P+e);Wn=e<K(0.0)&1;t[J>>0]=Wn|o[J>>0];if(D&e>K(0.0)){m=u[W>>2]|0;if((u[n+364+(m<<3)+4>>2]|0)!=0?(vn=K(Ot(n+364+(m<<3)|0,Mn)),vn>=K(0.0)):0)M=K(OE(K(0.0),K(vn-K(O-e))));else M=K(0.0)}else M=e;E=B>>>0<L>>>0;if(E){y=u[Nn>>2]|0;h=B;m=0;do{b=u[y+(h<<2)>>2]|0;if(!(u[b+24>>2]|0)){m=((u[(vi(b,Fn)|0)+4>>2]|0)==3&1)+m|0;m=m+((u[(pi(b,Fn)|0)+4>>2]|0)==3&1)|0}h=h+1|0}while((h|0)!=(L|0));if(m){g=K(0.0);r=K(0.0)}else X=101}else X=101;n:do{if((X|0)==101){X=0;switch(Z|0){case 1:{m=0;g=K(M*K(.5));r=K(0.0);break n}case 2:{m=0;g=M;r=K(0.0);break n}case 3:{if(f>>>0<=1){m=0;g=K(0.0);r=K(0.0);break n}r=K((f+-1|0)>>>0);m=0;g=K(0.0);r=K(K(OE(M,K(0.0)))/r);break n}case 5:{r=K(M/K((f+1|0)>>>0));m=0;g=r;break n}case 4:{r=K(M/K(f>>>0));m=0;g=K(r*K(.5));break n}default:{m=0;g=K(0.0);r=K(0.0);break n}}}}while(0);e=K($+g);if(E){k=K(M/K(m|0));h=u[Nn>>2]|0;b=B;M=K(0.0);do{m=u[h+(b<<2)>>2]|0;n:do{if((u[m+36>>2]|0)!=1){switch(u[m+24>>2]|0){case 1:{if(bi(m,Fn)|0){if(!_)break n;Hn=K(hi(m,Fn,O));Hn=K(Hn+K(Jt(n,Fn)));Hn=K(Hn+K(jt(m,Fn,Pn)));c[m+400+(u[j>>2]<<2)>>2]=Hn;break n}break}case 0:{Wn=(u[(vi(m,Fn)|0)+4>>2]|0)==3;Hn=K(k+e);e=Wn?Hn:e;if(_){Wn=m+400+(u[j>>2]<<2)|0;c[Wn>>2]=K(e+K(c[Wn>>2]))}Wn=(u[(pi(m,Fn)|0)+4>>2]|0)==3;Hn=K(k+e);e=Wn?Hn:e;if(U){Hn=K(r+K(Tt(m,Fn,Pn)));M=bn;e=K(e+K(Hn+K(c[m+504>>2])));break n}else{e=K(e+K(r+K(yi(m,Fn,Pn))));M=K(OE(M,K(yi(m,xn,Pn))));break n}}default:{}}if(_){Hn=K(g+K(Jt(n,Fn)));Wn=m+400+(u[j>>2]<<2)|0;c[Wn>>2]=K(Hn+K(c[Wn>>2]))}}}while(0);b=b+1|0}while((b|0)!=(L|0))}else M=K(0.0);r=K(nn+e);if(Y)g=K(K(di(n,xn,K(Sn+M),An,l))-Sn);else g=bn;k=K(K(di(n,xn,K(Sn+(G?bn:M)),An,l))-Sn);if(E&_){b=B;do{h=u[(u[Nn>>2]|0)+(b<<2)>>2]|0;do{if((u[h+36>>2]|0)!=1){if((u[h+24>>2]|0)==1){if(bi(h,xn)|0){Hn=K(hi(h,xn,bn));Hn=K(Hn+K(Jt(n,xn)));Hn=K(Hn+K(jt(h,xn,Pn)));m=u[V>>2]|0;c[h+400+(m<<2)>>2]=Hn;if(!(ke(Hn)|0))break}else m=u[V>>2]|0;Hn=K(Jt(n,xn));c[h+400+(m<<2)>>2]=K(Hn+K(jt(h,xn,Pn)));break}m=_i(n,h)|0;do{if((m|0)==4){if((u[(vi(h,xn)|0)+4>>2]|0)==3){X=139;break}if((u[(pi(h,xn)|0)+4>>2]|0)==3){X=139;break}if(Bt(h,xn,bn)|0){e=w;break}Dn=u[h+908+(u[W>>2]<<2)>>2]|0;u[un>>2]=Dn;e=K(c[h+396>>2]);Wn=ke(e)|0;M=(u[d>>2]=Dn,K(c[d>>2]));if(Wn)e=k;else{P=K(Tt(h,xn,Pn));Hn=K(M/e);e=K(e*M);e=K(P+(Bn?Hn:e))}c[on>>2]=e;c[un>>2]=K(K(Tt(h,Fn,Pn))+M);u[an>>2]=1;u[fn>>2]=1;mi(h,Fn,O,Pn,an,un);mi(h,xn,bn,Pn,fn,on);e=K(c[un>>2]);P=K(c[on>>2]);Hn=Bn?e:P;e=Bn?P:e;Wn=((ke(Hn)|0)^1)&1;gt(h,Hn,e,On,Wn,((ke(e)|0)^1)&1,Pn,yn,1,3493,p)|0;e=w}else X=139}while(0);n:do{if((X|0)==139){X=0;e=K(g-K(yi(h,xn,Pn)));do{if((u[(vi(h,xn)|0)+4>>2]|0)==3){if((u[(pi(h,xn)|0)+4>>2]|0)!=3)break;e=K(w+K(OE(K(0.0),K(e*K(.5)))));break n}}while(0);if((u[(pi(h,xn)|0)+4>>2]|0)==3){e=w;break}if((u[(vi(h,xn)|0)+4>>2]|0)==3){e=K(w+K(OE(K(0.0),e)));break}switch(m|0){case 1:{e=w;break n}case 2:{e=K(w+K(e*K(.5)));break n}default:{e=K(w+e);break n}}}}while(0);Hn=K(pn+e);Wn=h+400+(u[V>>2]<<2)|0;c[Wn>>2]=K(Hn+K(c[Wn>>2]))}}while(0);b=b+1|0}while((b|0)!=(L|0))}pn=K(pn+k);tn=K(OE(tn,r));f=x+1|0;if(L>>>0>=In>>>0)break;else{e=O;B=L;x=f}}do{if(_){m=f>>>0>1;if(!m?!(wi(n)|0):0)break;if(!(ke(bn)|0)){e=K(bn-pn);n:do{switch(u[n+12>>2]|0){case 3:{w=K(w+e);A=K(0.0);break}case 2:{w=K(w+K(e*K(.5)));A=K(0.0);break}case 4:{if(bn>pn)A=K(e/K(f>>>0));else A=K(0.0);break}case 7:if(bn>pn){w=K(w+K(e/K(f<<1>>>0)));A=K(e/K(f>>>0));A=m?A:K(0.0);break n}else{w=K(w+K(e*K(.5)));A=K(0.0);break n}case 6:{A=K(e/K(x>>>0));A=bn>pn&m?A:K(0.0);break}default:A=K(0.0)}}while(0);if(f|0){E=1040+(xn<<2)|0;C=976+(xn<<2)|0;y=0;b=0;while(1){n:do{if(b>>>0<In>>>0){M=K(0.0);k=K(0.0);e=K(0.0);h=b;while(1){m=u[(u[Nn>>2]|0)+(h<<2)>>2]|0;do{if((u[m+36>>2]|0)!=1?(u[m+24>>2]|0)==0:0){if((u[m+940>>2]|0)!=(y|0))break n;if(Mi(m,xn)|0){Hn=K(c[m+908+(u[C>>2]<<2)>>2]);e=K(OE(e,K(Hn+K(Tt(m,xn,Pn)))))}if((_i(n,m)|0)!=5)break;vn=K(ki(m));vn=K(vn+K(jt(m,0,Pn)));Hn=K(c[m+912>>2]);Hn=K(K(Hn+K(Tt(m,0,Pn)))-vn);vn=K(OE(k,vn));Hn=K(OE(M,Hn));M=Hn;k=vn;e=K(OE(e,K(vn+Hn)))}}while(0);m=h+1|0;if(m>>>0<In>>>0)h=m;else{h=m;break}}}else{k=K(0.0);e=K(0.0);h=b}}while(0);T=K(A+e);r=w;w=K(w+T);if(b>>>0<h>>>0){g=K(r+k);m=b;do{b=u[(u[Nn>>2]|0)+(m<<2)>>2]|0;n:do{if((u[b+36>>2]|0)!=1?(u[b+24>>2]|0)==0:0)switch(_i(n,b)|0){case 1:{Hn=K(r+K(jt(b,xn,Pn)));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 3:{Hn=K(K(w-K(qt(b,xn,Pn)))-K(c[b+908+(u[C>>2]<<2)>>2]));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 2:{Hn=K(r+K(K(T-K(c[b+908+(u[C>>2]<<2)>>2]))*K(.5)));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 4:{Hn=K(r+K(jt(b,xn,Pn)));c[b+400+(u[E>>2]<<2)>>2]=Hn;if(Bt(b,xn,bn)|0)break n;if(Bn){M=K(c[b+908>>2]);e=K(M+K(Tt(b,Fn,Pn)));k=T}else{k=K(c[b+912>>2]);k=K(k+K(Tt(b,xn,Pn)));e=T;M=K(c[b+908>>2])}if(pt(e,M)|0?pt(k,K(c[b+912>>2]))|0:0)break n;gt(b,e,k,On,1,1,Pn,yn,1,3501,p)|0;break n}case 5:{c[b+404>>2]=K(K(g-K(ki(b)))+K(hi(b,0,bn)));break n}default:break n}}while(0);m=m+1|0}while((m|0)!=(h|0))}y=y+1|0;if((y|0)==(f|0))break;else b=h}}}}}while(0);c[n+908>>2]=K(di(n,2,wn,l,l));c[n+912>>2]=K(di(n,0,hn,s,l));if((mn|0)!=0?(gn=u[n+32>>2]|0,Tn=(mn|0)==2,!(Tn&(gn|0)!=2)):0){if(Tn&(gn|0)==2){e=K(kn+O);e=K(OE(K(IE(e,K(gi(n,Fn,tn,Mn)))),kn));X=198}}else{e=K(di(n,Fn,tn,Mn,l));X=198}if((X|0)==198)c[n+908+(u[976+(Fn<<2)>>2]<<2)>>2]=e;if((En|0)!=0?(Ln=u[n+32>>2]|0,Rn=(En|0)==2,!(Rn&(Ln|0)!=2)):0){if(Rn&(Ln|0)==2){e=K(Sn+bn);e=K(OE(K(IE(e,K(gi(n,xn,K(Sn+pn),An)))),Sn));X=204}}else{e=K(di(n,xn,K(Sn+pn),An,l));X=204}if((X|0)==204)c[n+908+(u[976+(xn<<2)>>2]<<2)>>2]=e;if(_){if((u[Cn>>2]|0)==2){b=976+(xn<<2)|0;h=1040+(xn<<2)|0;m=0;do{y=Be(n,m)|0;if(!(u[y+24>>2]|0)){Dn=u[b>>2]|0;Hn=K(c[n+908+(Dn<<2)>>2]);Wn=y+400+(u[h>>2]<<2)|0;Hn=K(Hn-K(c[Wn>>2]));c[Wn>>2]=K(Hn-K(c[y+908+(Dn<<2)>>2]))}m=m+1|0}while((m|0)!=(In|0))}if(i|0){m=Bn?mn:a;do{Ti(n,i,Pn,m,yn,On,p);i=u[i+960>>2]|0}while((i|0)!=0)}m=(Fn|2|0)==3;b=(xn|2|0)==3;if(m|b){i=0;do{h=u[(u[Nn>>2]|0)+(i<<2)>>2]|0;if((u[h+36>>2]|0)!=1){if(m)Ai(n,h,Fn);if(b)Ai(n,h,xn)}i=i+1|0}while((i|0)!=(In|0))}}}else ni(n,e,r,a,f,l,s)}while(0);v=Un;return}function Lt(n,e){n=n|0;e=K(e);var r=0;Ae(n,e>=K(0.0),3147);r=e==K(0.0);c[n+4>>2]=r?K(0.0):e;return}function Rt(n,e,r,i){n=n|0;e=K(e);r=K(r);i=i|0;var o=de,a=de,f=0,l=0,s=0;u[2278]=(u[2278]|0)+1;Pt(n);if(!(Bt(n,2,e)|0)){o=K(Ot(n+380|0,e));if(!(o>=K(0.0))){s=((ke(e)|0)^1)&1;o=e}else s=2}else{o=K(Ot(u[n+992>>2]|0,e));s=1;o=K(o+K(Tt(n,2,e)))}if(!(Bt(n,0,r)|0)){a=K(Ot(n+388|0,r));if(!(a>=K(0.0))){l=((ke(r)|0)^1)&1;a=r}else l=2}else{a=K(Ot(u[n+996>>2]|0,r));l=1;a=K(a+K(Tt(n,0,e)))}f=n+976|0;if(gt(n,o,a,i,s,l,e,r,1,3189,u[f>>2]|0)|0?(Nt(n,u[n+496>>2]|0,e,r,e),It(n,K(c[(u[f>>2]|0)+4>>2]),K(0.0),K(0.0)),t[11696]|0):0)mt(n,7);return}function Pt(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;a=f+24|0;o=f+16|0;t=f+8|0;i=f;r=0;do{e=n+380+(r<<3)|0;if(!((u[n+380+(r<<3)+4>>2]|0)!=0?(c=e,l=u[c+4>>2]|0,s=t,u[s>>2]=u[c>>2],u[s+4>>2]=l,s=n+364+(r<<3)|0,l=u[s+4>>2]|0,c=i,u[c>>2]=u[s>>2],u[c+4>>2]=l,u[o>>2]=u[t>>2],u[o+4>>2]=u[t+4>>2],u[a>>2]=u[i>>2],u[a+4>>2]=u[i+4>>2],vt(o,a)|0):0))e=n+348+(r<<3)|0;u[n+992+(r<<2)>>2]=e;r=r+1|0}while((r|0)!=2);v=f;return}function Bt(n,e,r){n=n|0;e=e|0;r=K(r);var t=0;n=u[n+992+(u[976+(e<<2)>>2]<<2)>>2]|0;switch(u[n+4>>2]|0){case 0:case 3:{n=0;break}case 1:{if(K(c[n>>2])<K(0.0))n=0;else t=5;break}case 2:{if(K(c[n>>2])<K(0.0))n=0;else n=(ke(r)|0)^1;break}default:t=5}if((t|0)==5)n=1;return n|0}function Ot(n,e){n=n|0;e=K(e);switch(u[n+4>>2]|0){case 2:{e=K(K(K(c[n>>2])*e)/K(100.0));break}case 1:{e=K(c[n>>2]);break}default:e=K(k)}return K(e)}function Nt(n,e,r,t,i){n=n|0;e=e|0;r=K(r);t=K(t);i=K(i);var o=0,a=de;e=u[n+944>>2]|0?e:1;o=Xt(u[n+4>>2]|0,e)|0;e=ti(o,e)|0;r=K(Pi(n,o,r));t=K(Pi(n,e,t));a=K(r+K(jt(n,o,i)));c[n+400+(u[1040+(o<<2)>>2]<<2)>>2]=a;r=K(r+K(qt(n,o,i)));c[n+400+(u[1e3+(o<<2)>>2]<<2)>>2]=r;r=K(t+K(jt(n,e,i)));c[n+400+(u[1040+(e<<2)>>2]<<2)>>2]=r;i=K(t+K(qt(n,e,i)));c[n+400+(u[1e3+(e<<2)>>2]<<2)>>2]=i;return}function It(n,e,r,t){n=n|0;e=K(e);r=K(r);t=K(t);var i=0,o=0,a=de,f=de,l=0,s=0,d=de,_=0,v=de,p=de,m=de,b=de;if(!(e==K(0.0))){i=n+400|0;b=K(c[i>>2]);o=n+404|0;m=K(c[o>>2]);_=n+416|0;p=K(c[_>>2]);s=n+420|0;a=K(c[s>>2]);v=K(b+r);d=K(m+t);t=K(v+p);f=K(d+a);l=(u[n+988>>2]|0)==1;c[i>>2]=K(ht(b,e,0,l));c[o>>2]=K(ht(m,e,0,l));r=K(xE(K(p*e),K(1.0)));if(pt(r,K(0.0))|0)o=0;else o=(pt(r,K(1.0))|0)^1;r=K(xE(K(a*e),K(1.0)));if(pt(r,K(0.0))|0)i=0;else i=(pt(r,K(1.0))|0)^1;b=K(ht(t,e,l&o,l&(o^1)));c[_>>2]=K(b-K(ht(v,e,0,l)));b=K(ht(f,e,l&i,l&(i^1)));c[s>>2]=K(b-K(ht(d,e,0,l)));o=(u[n+952>>2]|0)-(u[n+948>>2]|0)>>2;if(o|0){i=0;do{It(Be(n,i)|0,e,v,d);i=i+1|0}while((i|0)!=(o|0))}}return}function Ft(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;switch(r|0){case 5:case 0:{n=uE(u[489]|0,t,i)|0;break}default:n=HE(t,i)|0}return n|0}function xt(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;i=v;v=v+16|0;o=i;u[o>>2]=t;Ut(n,0,e,r,o);v=i;return}function Ut(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;n=n|0?n:956;CL[u[n+8>>2]&1](n,e,r,t,i)|0;if((r|0)==5)Xn();else return}function Ht(n,e,r){n=n|0;e=e|0;r=r|0;t[n+e>>0]=r&1;return}function Dt(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){Wt(n,t);Yt(n,u[e>>2]|0,u[r>>2]|0,t)}return}function Wt(n,e){n=n|0;e=e|0;var r=0;if((Vt(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function Yt(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function Vt(n){n=n|0;return 1073741823}function jt(n,e,r){n=n|0;e=e|0;r=K(r);if(zt(e)|0?(u[n+96>>2]|0)!=0:0)n=n+92|0;else n=ge(n+60|0,u[1040+(e<<2)>>2]|0,992)|0;return K(Gt(n,r))}function qt(n,e,r){n=n|0;e=e|0;r=K(r);if(zt(e)|0?(u[n+104>>2]|0)!=0:0)n=n+100|0;else n=ge(n+60|0,u[1e3+(e<<2)>>2]|0,992)|0;return K(Gt(n,r))}function zt(n){n=n|0;return(n|1|0)==3|0}function Gt(n,e){n=n|0;e=K(e);if((u[n+4>>2]|0)==3)e=K(0.0);else e=K(Ot(n,e));return K(e)}function Kt(n,e){n=n|0;e=e|0;n=u[n>>2]|0;return((n|0)==0?(e|0)>1?e:1:n)|0}function Xt(n,e){n=n|0;e=e|0;var r=0;n:do{if((e|0)==2){switch(n|0){case 2:{n=3;break n}case 3:break;default:{r=4;break n}}n=2}else r=4}while(0);return n|0}function Jt(n,e){n=n|0;e=e|0;var r=de;if(!((zt(e)|0?(u[n+312>>2]|0)!=0:0)?(r=K(c[n+308>>2]),r>=K(0.0)):0))r=K(OE(K(c[(ge(n+276|0,u[1040+(e<<2)>>2]|0,992)|0)>>2]),K(0.0)));return K(r)}function Zt(n,e){n=n|0;e=e|0;var r=de;if(!((zt(e)|0?(u[n+320>>2]|0)!=0:0)?(r=K(c[n+316>>2]),r>=K(0.0)):0))r=K(OE(K(c[(ge(n+276|0,u[1e3+(e<<2)>>2]|0,992)|0)>>2]),K(0.0)));return K(r)}function Qt(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;if(!((zt(e)|0?(u[n+240>>2]|0)!=0:0)?(t=K(Ot(n+236|0,r)),t>=K(0.0)):0))t=K(OE(K(Ot(ge(n+204|0,u[1040+(e<<2)>>2]|0,992)|0,r)),K(0.0)));return K(t)}function $t(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;if(!((zt(e)|0?(u[n+248>>2]|0)!=0:0)?(t=K(Ot(n+244|0,r)),t>=K(0.0)):0))t=K(OE(K(Ot(ge(n+204|0,u[1e3+(e<<2)>>2]|0,992)|0,r)),K(0.0)));return K(t)}function ni(n,e,r,t,i,o,a){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;o=K(o);a=K(a);var f=de,l=de,s=de,d=de,_=de,p=de,m=0,b=0,h=0;h=v;v=v+16|0;m=h;b=n+964|0;Fe(n,(u[b>>2]|0)!=0,3519);f=K(oi(n,2,e));l=K(oi(n,0,e));s=K(Tt(n,2,e));d=K(Tt(n,0,e));if(ke(e)|0)_=e;else _=K(OE(K(0.0),K(K(e-s)-f)));if(ke(r)|0)p=r;else p=K(OE(K(0.0),K(K(r-d)-l)));if((t|0)==1&(i|0)==1){c[n+908>>2]=K(di(n,2,K(e-s),o,o));e=K(di(n,0,K(r-d),a,o))}else{RL[u[b>>2]&1](m,n,_,t,p,i);_=K(f+K(c[m>>2]));p=K(e-s);c[n+908>>2]=K(di(n,2,(t|2|0)==2?_:p,o,o));p=K(l+K(c[m+4>>2]));e=K(r-d);e=K(di(n,0,(i|2|0)==2?p:e,a,o))}c[n+912>>2]=e;v=h;return}function ei(n,e,r,t,i,u,o){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;u=K(u);o=K(o);var a=de,f=de,l=de,s=de;l=K(oi(n,2,u));a=K(oi(n,0,u));s=K(Tt(n,2,u));f=K(Tt(n,0,u));e=K(e-s);c[n+908>>2]=K(di(n,2,(t|2|0)==2?l:e,u,u));r=K(r-f);c[n+912>>2]=K(di(n,0,(i|2|0)==2?a:r,o,u));return}function ri(n,e,r,t,i,u,o){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;u=K(u);o=K(o);var a=0,f=de,l=de;a=(t|0)==2;if((!(e<=K(0.0)&a)?!(r<=K(0.0)&(i|0)==2):0)?!((t|0)==1&(i|0)==1):0)n=0;else{f=K(Tt(n,0,u));l=K(Tt(n,2,u));a=e<K(0.0)&a|(ke(e)|0);e=K(e-l);c[n+908>>2]=K(di(n,2,a?K(0.0):e,u,u));e=K(r-f);a=r<K(0.0)&(i|0)==2|(ke(r)|0);c[n+912>>2]=K(di(n,0,a?K(0.0):e,o,u));n=1}return n|0}function ti(n,e){n=n|0;e=e|0;if(Si(n)|0)n=Xt(2,e)|0;else n=0;return n|0}function ii(n,e,r){n=n|0;e=e|0;r=K(r);r=K(Qt(n,e,r));return K(r+K(Jt(n,e)))}function ui(n,e,r){n=n|0;e=e|0;r=K(r);r=K($t(n,e,r));return K(r+K(Zt(n,e)))}function oi(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(ii(n,e,r));return K(t+K(ui(n,e,r)))}function ai(n){n=n|0;if(!(u[n+24>>2]|0)){if(K(fi(n))!=K(0.0))n=1;else n=K(ci(n))!=K(0.0)}else n=0;return n|0}function fi(n){n=n|0;var e=de;if(u[n+944>>2]|0){e=K(c[n+44>>2]);if(ke(e)|0){e=K(c[n+40>>2]);n=e>K(0.0)&((ke(e)|0)^1);return K(n?e:K(0.0))}}else e=K(0.0);return K(e)}function ci(n){n=n|0;var e=de,r=0,i=de;do{if(u[n+944>>2]|0){e=K(c[n+48>>2]);if(ke(e)|0){r=t[(u[n+976>>2]|0)+2>>0]|0;if(r<<24>>24==0?(i=K(c[n+40>>2]),i<K(0.0)&((ke(i)|0)^1)):0){e=K(-i);break}e=r<<24>>24?K(1.0):K(0.0)}}else e=K(0.0)}while(0);return K(e)}function li(n){n=n|0;var e=0,r=0;eC(n+400|0,0,540)|0;t[n+985>>0]=1;Ve(n);r=Pe(n)|0;if(r|0){e=n+948|0;n=0;do{li(u[(u[e>>2]|0)+(n<<2)>>2]|0);n=n+1|0}while((n|0)!=(r|0))}return}function si(n,e,r,t,i,o,a,f,l,s){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);o=K(o);a=K(a);f=f|0;l=l|0;s=s|0;var d=0,_=de,p=0,m=0,b=de,h=de,y=0,w=de,M=0,g=de,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=0;B=v;v=v+16|0;S=B+12|0;E=B+8|0;C=B+4|0;L=B;P=Xt(u[n+4>>2]|0,l)|0;T=zt(P)|0;_=K(Ot(Ei(e)|0,T?o:a));A=Bt(e,2,o)|0;R=Bt(e,0,a)|0;do{if(!(ke(_)|0)?!(ke(T?r:i)|0):0){d=e+504|0;if(!(ke(K(c[d>>2]))|0)){if(!(Ci(u[e+976>>2]|0,0)|0))break;if((u[e+500>>2]|0)==(u[2278]|0))break}c[d>>2]=K(OE(_,K(oi(e,P,o))))}else p=7}while(0);do{if((p|0)==7){M=T^1;if(!(M|A^1)){a=K(Ot(u[e+992>>2]|0,o));c[e+504>>2]=K(OE(a,K(oi(e,2,o))));break}if(!(T|R^1)){a=K(Ot(u[e+996>>2]|0,a));c[e+504>>2]=K(OE(a,K(oi(e,0,o))));break}c[S>>2]=K(k);c[E>>2]=K(k);u[C>>2]=0;u[L>>2]=0;w=K(Tt(e,2,o));g=K(Tt(e,0,o));if(A){b=K(w+K(Ot(u[e+992>>2]|0,o)));c[S>>2]=b;u[C>>2]=1;m=1}else{m=0;b=K(k)}if(R){_=K(g+K(Ot(u[e+996>>2]|0,a)));c[E>>2]=_;u[L>>2]=1;d=1}else{d=0;_=K(k)}p=u[n+32>>2]|0;if(!(T&(p|0)==2)){if(ke(b)|0?!(ke(r)|0):0){c[S>>2]=r;u[C>>2]=2;m=2;b=r}}else p=2;if((!((p|0)==2&M)?ke(_)|0:0)?!(ke(i)|0):0){c[E>>2]=i;u[L>>2]=2;d=2;_=i}h=K(c[e+396>>2]);y=ke(h)|0;do{if(!y){if((m|0)==1&M){c[E>>2]=K(K(b-w)/h);u[L>>2]=1;d=1;p=1;break}if(T&(d|0)==1){c[S>>2]=K(h*K(_-g));u[C>>2]=1;d=1;p=1}else p=m}else p=m}while(0);O=ke(r)|0;m=(_i(n,e)|0)!=4;if(!(T|A|((t|0)!=1|O)|(m|(p|0)==1))?(c[S>>2]=r,u[C>>2]=1,!y):0){c[E>>2]=K(K(r-w)/h);u[L>>2]=1;d=1}if(!(R|M|((f|0)!=1|(ke(i)|0))|(m|(d|0)==1))?(c[E>>2]=i,u[L>>2]=1,!y):0){c[S>>2]=K(h*K(i-g));u[C>>2]=1}mi(e,2,o,o,C,S);mi(e,0,a,o,L,E);r=K(c[S>>2]);i=K(c[E>>2]);gt(e,r,i,l,u[C>>2]|0,u[L>>2]|0,o,a,0,3565,s)|0;a=K(c[e+908+(u[976+(P<<2)>>2]<<2)>>2]);c[e+504>>2]=K(OE(a,K(oi(e,P,o))))}}while(0);u[e+500>>2]=u[2278];v=B;return}function di(n,e,r,t,i){n=n|0;e=e|0;r=K(r);t=K(t);i=K(i);t=K(gi(n,e,r,t));return K(OE(t,K(oi(n,e,i))))}function _i(n,e){n=n|0;e=e|0;e=e+20|0;e=u[((u[e>>2]|0)==0?n+16|0:e)>>2]|0;if((e|0)==5?Si(u[n+4>>2]|0)|0:0)e=1;return e|0}function vi(n,e){n=n|0;e=e|0;if(zt(e)|0?(u[n+96>>2]|0)!=0:0)e=4;else e=u[1040+(e<<2)>>2]|0;return n+60+(e<<3)|0}function pi(n,e){n=n|0;e=e|0;if(zt(e)|0?(u[n+104>>2]|0)!=0:0)e=5;else e=u[1e3+(e<<2)>>2]|0;return n+60+(e<<3)|0}function mi(n,e,r,t,i,o){n=n|0;e=e|0;r=K(r);t=K(t);i=i|0;o=o|0;r=K(Ot(n+380+(u[976+(e<<2)>>2]<<3)|0,r));r=K(r+K(Tt(n,e,t)));switch(u[i>>2]|0){case 2:case 1:{i=ke(r)|0;t=K(c[o>>2]);c[o>>2]=i|t<r?t:r;break}case 0:{if(!(ke(r)|0)){u[i>>2]=2;c[o>>2]=r}break}default:{}}return}function bi(n,e){n=n|0;e=e|0;n=n+132|0;if(zt(e)|0?(u[(ge(n,4,948)|0)+4>>2]|0)!=0:0)n=1;else n=(u[(ge(n,u[1040+(e<<2)>>2]|0,948)|0)+4>>2]|0)!=0;return n|0}function hi(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0;n=n+132|0;if(zt(e)|0?(t=ge(n,4,948)|0,(u[t+4>>2]|0)!=0):0)i=4;else{t=ge(n,u[1040+(e<<2)>>2]|0,948)|0;if(!(u[t+4>>2]|0))r=K(0.0);else i=4}if((i|0)==4)r=K(Ot(t,r));return K(r)}function yi(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(c[n+908+(u[976+(e<<2)>>2]<<2)>>2]);t=K(t+K(jt(n,e,r)));return K(t+K(qt(n,e,r)))}function wi(n){n=n|0;var e=0,r=0,t=0;n:do{if(!(Si(u[n+4>>2]|0)|0)){if((u[n+16>>2]|0)!=5){r=Pe(n)|0;if(!r)e=0;else{e=0;while(1){t=Be(n,e)|0;if((u[t+24>>2]|0)==0?(u[t+20>>2]|0)==5:0){e=1;break n}e=e+1|0;if(e>>>0>=r>>>0){e=0;break}}}}else e=1}else e=0}while(0);return e|0}function Mi(n,e){n=n|0;e=e|0;var r=de;r=K(c[n+908+(u[976+(e<<2)>>2]<<2)>>2]);return r>=K(0.0)&((ke(r)|0)^1)|0}function ki(n){n=n|0;var e=de,r=0,t=0,i=0,o=0,a=0,f=0,l=de;r=u[n+968>>2]|0;if(!r){o=Pe(n)|0;do{if(o|0){r=0;i=0;while(1){t=Be(n,i)|0;if(u[t+940>>2]|0){a=8;break}if((u[t+24>>2]|0)!=1){f=(_i(n,t)|0)==5;if(f){r=t;break}else r=(r|0)==0?t:r}i=i+1|0;if(i>>>0>=o>>>0){a=8;break}}if((a|0)==8)if(!r)break;e=K(ki(r));return K(e+K(c[r+404>>2]))}}while(0);e=K(c[n+912>>2])}else{l=K(c[n+908>>2]);e=K(c[n+912>>2]);e=K(_L[r&0](n,l,e));Fe(n,(ke(e)|0)^1,3573)}return K(e)}function gi(n,e,r,t){n=n|0;e=e|0;r=K(r);t=K(t);var i=de,u=0;if(!(Si(e)|0)){if(zt(e)|0){e=0;u=3}else{t=K(k);i=K(k)}}else{e=1;u=3}if((u|0)==3){i=K(Ot(n+364+(e<<3)|0,t));t=K(Ot(n+380+(e<<3)|0,t))}u=t<r&(t>=K(0.0)&((ke(t)|0)^1));r=u?t:r;u=i>=K(0.0)&((ke(i)|0)^1)&r<i;return K(u?i:r)}function Ti(n,e,r,t,i,o,a){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);o=o|0;a=a|0;var f=de,l=de,s=0,d=0,_=de,v=de,p=de,m=0,b=0,h=0,y=0,w=de,M=0;h=Xt(u[n+4>>2]|0,o)|0;m=ti(h,o)|0;b=zt(h)|0;_=K(Tt(e,2,r));v=K(Tt(e,0,r));if(!(Bt(e,2,r)|0)){if(bi(e,2)|0?Li(e,2)|0:0){f=K(c[n+908>>2]);l=K(Jt(n,2));l=K(f-K(l+K(Zt(n,2))));f=K(hi(e,2,r));f=K(di(e,2,K(l-K(f+K(Ri(e,2,r)))),r,r))}else f=K(k)}else f=K(_+K(Ot(u[e+992>>2]|0,r)));if(!(Bt(e,0,i)|0)){if(bi(e,0)|0?Li(e,0)|0:0){l=K(c[n+912>>2]);w=K(Jt(n,0));w=K(l-K(w+K(Zt(n,0))));l=K(hi(e,0,i));l=K(di(e,0,K(w-K(l+K(Ri(e,0,i)))),i,r))}else l=K(k)}else l=K(v+K(Ot(u[e+996>>2]|0,i)));s=ke(f)|0;d=ke(l)|0;do{if(s^d?(p=K(c[e+396>>2]),!(ke(p)|0)):0)if(s){f=K(_+K(K(l-v)*p));break}else{w=K(v+K(K(f-_)/p));l=d?w:l;break}}while(0);d=ke(f)|0;s=ke(l)|0;if(d|s){M=(d^1)&1;t=r>K(0.0)&((t|0)!=0&d);f=b?f:t?r:f;gt(e,f,l,o,b?M:t?2:M,d&(s^1)&1,f,l,0,3623,a)|0;f=K(c[e+908>>2]);f=K(f+K(Tt(e,2,r)));l=K(c[e+912>>2]);l=K(l+K(Tt(e,0,r)))}gt(e,f,l,o,1,1,f,l,1,3635,a)|0;if(Li(e,h)|0?!(bi(e,h)|0):0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));w=K(w-K(Zt(n,h)));w=K(w-K(qt(e,h,r)));w=K(w-K(Ri(e,h,b?r:i)));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w}else y=21;do{if((y|0)==21){if(!(bi(e,h)|0)?(u[n+8>>2]|0)==1:0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(K(w-K(c[e+908+(M<<2)>>2]))*K(.5));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w;break}if(!(bi(e,h)|0)?(u[n+8>>2]|0)==2:0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w}}}while(0);if(Li(e,m)|0?!(bi(e,m)|0):0){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));w=K(w-K(Zt(n,m)));w=K(w-K(qt(e,m,r)));w=K(w-K(Ri(e,m,b?i:r)));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w}else y=30;do{if((y|0)==30?!(bi(e,m)|0):0){if((_i(n,e)|0)==2){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(K(w-K(c[e+908+(M<<2)>>2]))*K(.5));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w;break}M=(_i(n,e)|0)==3;if(M^(u[n+28>>2]|0)==2){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w}}}while(0);return}function Ai(n,e,r){n=n|0;e=e|0;r=r|0;var t=de,i=0;i=u[976+(r<<2)>>2]|0;t=K(c[e+908+(i<<2)>>2]);t=K(K(c[n+908+(i<<2)>>2])-t);t=K(t-K(c[e+400+(u[1040+(r<<2)>>2]<<2)>>2]));c[e+400+(u[1e3+(r<<2)>>2]<<2)>>2]=t;return}function Si(n){n=n|0;return(n|1|0)==1|0}function Ei(n){n=n|0;var e=de;switch(u[n+56>>2]|0){case 0:case 3:{e=K(c[n+40>>2]);if(e>K(0.0)&((ke(e)|0)^1))n=t[(u[n+976>>2]|0)+2>>0]|0?1056:992;else n=1056;break}default:n=n+52|0}return n|0}function Ci(n,e){n=n|0;e=e|0;return(t[n+e>>0]|0)!=0|0}function Li(n,e){n=n|0;e=e|0;n=n+132|0;if(zt(e)|0?(u[(ge(n,5,948)|0)+4>>2]|0)!=0:0)n=1;else n=(u[(ge(n,u[1e3+(e<<2)>>2]|0,948)|0)+4>>2]|0)!=0;return n|0}function Ri(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0;n=n+132|0;if(zt(e)|0?(t=ge(n,5,948)|0,(u[t+4>>2]|0)!=0):0)i=4;else{t=ge(n,u[1e3+(e<<2)>>2]|0,948)|0;if(!(u[t+4>>2]|0))r=K(0.0);else i=4}if((i|0)==4)r=K(Ot(t,r));return K(r)}function Pi(n,e,r){n=n|0;e=e|0;r=K(r);if(bi(n,e)|0)r=K(hi(n,e,r));else r=K(-K(Ri(n,e,r)));return K(r)}function Bi(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function Oi(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function Ni(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Ii(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function Fi(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;a=n+4|0;f=u[a>>2]|0;i=f-t|0;o=i>>2;n=e+(o<<2)|0;if(n>>>0<r>>>0){t=f;do{u[t>>2]=u[n>>2];n=n+4|0;t=(u[a>>2]|0)+4|0;u[a>>2]=t}while(n>>>0<r>>>0)}if(o|0)cC(f+(0-o<<2)|0,e|0,i|0)|0;return}function xi(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0;f=e+4|0;c=u[f>>2]|0;i=u[n>>2]|0;a=r;o=a-i|0;t=c+(0-(o>>2)<<2)|0;u[f>>2]=t;if((o|0)>0)iC(t|0,i|0,o|0)|0;i=n+4|0;o=e+8|0;t=(u[i>>2]|0)-a|0;if((t|0)>0){iC(u[o>>2]|0,r|0,t|0)|0;u[o>>2]=(u[o>>2]|0)+(t>>>2<<2)}a=u[n>>2]|0;u[n>>2]=u[f>>2];u[f>>2]=a;a=u[i>>2]|0;u[i>>2]=u[o>>2];u[o>>2]=a;a=n+8|0;r=e+12|0;n=u[a>>2]|0;u[a>>2]=u[r>>2];u[r>>2]=n;u[e>>2]=u[f>>2];return c|0}function Ui(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;a=u[e>>2]|0;o=u[r>>2]|0;if((a|0)!=(o|0)){i=n+8|0;r=((o+-4-a|0)>>>2)+1|0;n=a;t=u[i>>2]|0;do{u[t>>2]=u[n>>2];t=(u[i>>2]|0)+4|0;u[i>>2]=t;n=n+4|0}while((n|0)!=(o|0));u[e>>2]=a+(r<<2)}return}function Hi(){we();return}function Di(){var n=0;n=GE(4)|0;Wi(n);return n|0}function Wi(n){n=n|0;u[n>>2]=Ue()|0;return}function Yi(n){n=n|0;if(n|0){Vi(n);XE(n)}return}function Vi(n){n=n|0;De(u[n>>2]|0);return}function ji(n,e,r){n=n|0;e=e|0;r=r|0;Ht(u[n>>2]|0,e,r);return}function qi(n,e){n=n|0;e=K(e);Lt(u[n>>2]|0,e);return}function zi(n,e){n=n|0;e=e|0;return Ci(u[n>>2]|0,e)|0}function Gi(){var n=0;n=GE(8)|0;Ki(n,0);return n|0}function Ki(n,e){n=n|0;e=e|0;if(!e)e=Se()|0;else e=Te(u[e>>2]|0)|0;u[n>>2]=e;u[n+4>>2]=0;$e(e,n);return}function Xi(n){n=n|0;var e=0;e=GE(8)|0;Ki(e,n);return e|0}function Ji(n){n=n|0;if(n|0){Zi(n);XE(n)}return}function Zi(n){n=n|0;var e=0;Le(u[n>>2]|0);e=n+4|0;n=u[e>>2]|0;u[e>>2]=0;if(n|0){Qi(n);XE(n)}return}function Qi(n){n=n|0;$i(n);return}function $i(n){n=n|0;n=u[n>>2]|0;if(n|0)ie(n|0);return}function nu(n){n=n|0;return nr(n)|0}function eu(n){n=n|0;var e=0,r=0;r=n+4|0;e=u[r>>2]|0;u[r>>2]=0;if(e|0){Qi(e);XE(e)}Ie(u[n>>2]|0);return}function ru(n,e){n=n|0;e=e|0;Je(u[n>>2]|0,u[e>>2]|0);return}function tu(n,e){n=n|0;e=e|0;sr(u[n>>2]|0,e);return}function iu(n,e,r){n=n|0;e=e|0;r=+r;Ar(u[n>>2]|0,e,K(r));return}function uu(n,e,r){n=n|0;e=e|0;r=+r;Sr(u[n>>2]|0,e,K(r));return}function ou(n,e){n=n|0;e=e|0;ur(u[n>>2]|0,e);return}function au(n,e){n=n|0;e=e|0;ar(u[n>>2]|0,e);return}function fu(n,e){n=n|0;e=e|0;cr(u[n>>2]|0,e);return}function cu(n,e){n=n|0;e=e|0;er(u[n>>2]|0,e);return}function lu(n,e){n=n|0;e=e|0;_r(u[n>>2]|0,e);return}function su(n,e){n=n|0;e=e|0;tr(u[n>>2]|0,e);return}function du(n,e,r){n=n|0;e=e|0;r=+r;Cr(u[n>>2]|0,e,K(r));return}function _u(n,e,r){n=n|0;e=e|0;r=+r;Lr(u[n>>2]|0,e,K(r));return}function vu(n,e){n=n|0;e=e|0;Pr(u[n>>2]|0,e);return}function pu(n,e){n=n|0;e=e|0;pr(u[n>>2]|0,e);return}function mu(n,e){n=n|0;e=e|0;br(u[n>>2]|0,e);return}function bu(n,e){n=n|0;e=+e;yr(u[n>>2]|0,K(e));return}function hu(n,e){n=n|0;e=+e;kr(u[n>>2]|0,K(e));return}function yu(n,e){n=n|0;e=+e;gr(u[n>>2]|0,K(e));return}function wu(n,e){n=n|0;e=+e;wr(u[n>>2]|0,K(e));return}function Mu(n,e){n=n|0;e=+e;Mr(u[n>>2]|0,K(e));return}function ku(n,e){n=n|0;e=+e;xr(u[n>>2]|0,K(e));return}function gu(n,e){n=n|0;e=+e;Ur(u[n>>2]|0,K(e));return}function Tu(n){n=n|0;Hr(u[n>>2]|0);return}function Au(n,e){n=n|0;e=+e;Wr(u[n>>2]|0,K(e));return}function Su(n,e){n=n|0;e=+e;Yr(u[n>>2]|0,K(e));return}function Eu(n){n=n|0;Vr(u[n>>2]|0);return}function Cu(n,e){n=n|0;e=+e;qr(u[n>>2]|0,K(e));return}function Lu(n,e){n=n|0;e=+e;zr(u[n>>2]|0,K(e));return}function Ru(n,e){n=n|0;e=+e;Kr(u[n>>2]|0,K(e));return}function Pu(n,e){n=n|0;e=+e;Xr(u[n>>2]|0,K(e));return}function Bu(n,e){n=n|0;e=+e;Zr(u[n>>2]|0,K(e));return}function Ou(n,e){n=n|0;e=+e;Qr(u[n>>2]|0,K(e));return}function Nu(n,e){n=n|0;e=+e;nt(u[n>>2]|0,K(e));return}function Iu(n,e){n=n|0;e=+e;et(u[n>>2]|0,K(e));return}function Fu(n,e){n=n|0;e=+e;tt(u[n>>2]|0,K(e));return}function xu(n,e,r){n=n|0;e=e|0;r=+r;Ir(u[n>>2]|0,e,K(r));return}function Uu(n,e,r){n=n|0;e=e|0;r=+r;Br(u[n>>2]|0,e,K(r));return}function Hu(n,e,r){n=n|0;e=e|0;r=+r;Or(u[n>>2]|0,e,K(r));return}function Du(n){n=n|0;return dr(u[n>>2]|0)|0}function Wu(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Er(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function Yu(n,e){n=n|0;e=e|0;Vu(n,u[e+4>>2]|0,+K(c[e>>2]));return}function Vu(n,e,r){n=n|0;e=e|0;r=+r;u[n>>2]=e;l[n+8>>3]=r;return}function ju(n){n=n|0;return or(u[n>>2]|0)|0}function qu(n){n=n|0;return fr(u[n>>2]|0)|0}function zu(n){n=n|0;return lr(u[n>>2]|0)|0}function Gu(n){n=n|0;return rr(u[n>>2]|0)|0}function Ku(n){n=n|0;return vr(u[n>>2]|0)|0}function Xu(n){n=n|0;return ir(u[n>>2]|0)|0}function Ju(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Rr(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function Zu(n){n=n|0;return mr(u[n>>2]|0)|0}function Qu(n){n=n|0;return hr(u[n>>2]|0)|0}function $u(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Tr(t,u[e>>2]|0);Yu(n,t);v=r;return}function no(n){n=n|0;return+ +K(Ze(u[n>>2]|0))}function eo(n){n=n|0;return+ +K(Qe(u[n>>2]|0))}function ro(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Dr(t,u[e>>2]|0);Yu(n,t);v=r;return}function to(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;jr(t,u[e>>2]|0);Yu(n,t);v=r;return}function io(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Gr(t,u[e>>2]|0);Yu(n,t);v=r;return}function uo(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Jr(t,u[e>>2]|0);Yu(n,t);v=r;return}function oo(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;$r(t,u[e>>2]|0);Yu(n,t);v=r;return}function ao(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;rt(t,u[e>>2]|0);Yu(n,t);v=r;return}function fo(n){n=n|0;return+ +K(it(u[n>>2]|0))}function co(n,e){n=n|0;e=e|0;return+ +K(Fr(u[n>>2]|0,e))}function lo(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Nr(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function so(n,e,r){n=n|0;e=e|0;r=r|0;Ye(u[n>>2]|0,u[e>>2]|0,r);return}function _o(n,e){n=n|0;e=e|0;Ne(u[n>>2]|0,u[e>>2]|0);return}function vo(n){n=n|0;return Pe(u[n>>2]|0)|0}function po(n){n=n|0;n=Ge(u[n>>2]|0)|0;if(!n)n=0;else n=nu(n)|0;return n|0}function mo(n,e){n=n|0;e=e|0;n=Be(u[n>>2]|0,e)|0;if(!n)n=0;else n=nu(n)|0;return n|0}function bo(n,e){n=n|0;e=e|0;var r=0,t=0;t=GE(4)|0;ho(t,e);r=n+4|0;e=u[r>>2]|0;u[r>>2]=t;if(e|0){Qi(e);XE(e)}We(u[n>>2]|0,1);return}function ho(n,e){n=n|0;e=e|0;Uo(n,e);return}function yo(n,e,r,t,i,u){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);u=u|0;var o=0,a=0;o=v;v=v+16|0;a=o;wo(a,nr(e)|0,+r,t,+i,u);c[n>>2]=K(+l[a>>3]);c[n+4>>2]=K(+l[a+8>>3]);v=o;return}function wo(n,e,r,t,i,o){n=n|0;e=e|0;r=+r;t=t|0;i=+i;o=o|0;var a=0,f=0,c=0,s=0,d=0;a=v;v=v+32|0;d=a+8|0;s=a+20|0;c=a;f=a+16|0;l[d>>3]=r;u[s>>2]=t;l[c>>3]=i;u[f>>2]=o;Mo(n,u[e+4>>2]|0,d,s,c,f);v=a;return}function Mo(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0;a=v;v=v+16|0;f=a;gS(f);e=ko(e)|0;go(n,e,+l[r>>3],u[t>>2]|0,+l[i>>3],u[o>>2]|0);AS(f);v=a;return}function ko(n){n=n|0;return u[n>>2]|0}function go(n,e,r,t,i,u){n=n|0;e=e|0;r=+r;t=t|0;i=+i;u=u|0;var o=0;o=Ao(To()|0)|0;r=+So(r);t=Eo(t)|0;i=+So(i);Co(n,oe(0,o|0,e|0,+r,t|0,+i,Eo(u)|0)|0);return}function To(){var n=0;if(!(t[7608]|0)){Io(9120);n=7608;u[n>>2]=1;u[n+4>>2]=0}return 9120}function Ao(n){n=n|0;return u[n+8>>2]|0}function So(n){n=+n;return+ +No(n)}function Eo(n){n=n|0;return Oo(n)|0}function Co(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i;t=e;if(!(t&1)){u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2]}else{Lo(r,0);Hn(t|0,r|0)|0;Ro(n,r);Po(r)}v=i;return}function Lo(n,e){n=n|0;e=e|0;Bo(n,e);u[n+8>>2]=0;t[n+24>>0]=0;return}function Ro(n,e){n=n|0;e=e|0;e=e+8|0;u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2];return}function Po(n){n=n|0;t[n+24>>0]=0;return}function Bo(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function Oo(n){n=n|0;return n|0}function No(n){n=+n;return+n}function Io(n){n=n|0;xo(n,Fo()|0,4);return}function Fo(){return 1064}function xo(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=re(e|0,r+1|0)|0;return}function Uo(n,e){n=n|0;e=e|0;e=u[e>>2]|0;u[n>>2]=e;Rn(e|0);return}function Ho(n){n=n|0;var e=0,r=0;r=n+4|0;e=u[r>>2]|0;u[r>>2]=0;if(e|0){Qi(e);XE(e)}We(u[n>>2]|0,0);return}function Do(n){n=n|0;Ke(u[n>>2]|0);return}function Wo(n){n=n|0;return Xe(u[n>>2]|0)|0}function Yo(n,e,r,t){n=n|0;e=+e;r=+r;t=t|0;Rt(u[n>>2]|0,K(e),K(r),t);return}function Vo(n){n=n|0;return+ +K(ut(u[n>>2]|0))}function jo(n){n=n|0;return+ +K(at(u[n>>2]|0))}function qo(n){n=n|0;return+ +K(ot(u[n>>2]|0))}function zo(n){n=n|0;return+ +K(ft(u[n>>2]|0))}function Go(n){n=n|0;return+ +K(ct(u[n>>2]|0))}function Ko(n){n=n|0;return+ +K(lt(u[n>>2]|0))}function Xo(n,e){n=n|0;e=e|0;l[n>>3]=+K(ut(u[e>>2]|0));l[n+8>>3]=+K(at(u[e>>2]|0));l[n+16>>3]=+K(ot(u[e>>2]|0));l[n+24>>3]=+K(ft(u[e>>2]|0));l[n+32>>3]=+K(ct(u[e>>2]|0));l[n+40>>3]=+K(lt(u[e>>2]|0));return}function Jo(n,e){n=n|0;e=e|0;return+ +K(st(u[n>>2]|0,e))}function Zo(n,e){n=n|0;e=e|0;return+ +K(dt(u[n>>2]|0,e))}function Qo(n,e){n=n|0;e=e|0;return+ +K(_t(u[n>>2]|0,e))}function $o(){return xe()|0}function na(){ea();ra();ta();ia();ua();oa();return}function ea(){Ww(11713,4938,1);return}function ra(){ew(10448);return}function ta(){Iy(10408);return}function ia(){Qh(10324);return}function ua(){qm(10096);return}function oa(){aa(9132);return}function aa(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=0,N=0,I=0,F=0,x=0,U=0,H=0,D=0,W=0,Y=0,V=0,j=0,q=0,z=0,G=0,K=0,X=0,J=0,Z=0,Q=0,$=0,nn=0,en=0,rn=0,tn=0,un=0,on=0,an=0,fn=0,cn=0,ln=0,sn=0,dn=0,_n=0,vn=0,pn=0,mn=0,bn=0,hn=0,yn=0,wn=0,Mn=0,kn=0,gn=0,Tn=0,An=0,Sn=0,En=0,Cn=0,Ln=0,Rn=0,Pn=0,Bn=0,On=0;e=v;v=v+672|0;r=e+656|0;On=e+648|0;Bn=e+640|0;Pn=e+632|0;Rn=e+624|0;Ln=e+616|0;Cn=e+608|0;En=e+600|0;Sn=e+592|0;An=e+584|0;Tn=e+576|0;gn=e+568|0;kn=e+560|0;Mn=e+552|0;wn=e+544|0;yn=e+536|0;hn=e+528|0;bn=e+520|0;mn=e+512|0;pn=e+504|0;vn=e+496|0;_n=e+488|0;dn=e+480|0;sn=e+472|0;ln=e+464|0;cn=e+456|0;fn=e+448|0;an=e+440|0;on=e+432|0;un=e+424|0;tn=e+416|0;rn=e+408|0;en=e+400|0;nn=e+392|0;$=e+384|0;Q=e+376|0;Z=e+368|0;J=e+360|0;X=e+352|0;K=e+344|0;G=e+336|0;z=e+328|0;q=e+320|0;j=e+312|0;V=e+304|0;Y=e+296|0;W=e+288|0;D=e+280|0;H=e+272|0;U=e+264|0;x=e+256|0;F=e+248|0;I=e+240|0;N=e+232|0;O=e+224|0;B=e+216|0;P=e+208|0;R=e+200|0;L=e+192|0;C=e+184|0;E=e+176|0;S=e+168|0;A=e+160|0;T=e+152|0;g=e+144|0;k=e+136|0;M=e+128|0;w=e+120|0;y=e+112|0;h=e+104|0;b=e+96|0;m=e+88|0;p=e+80|0;_=e+72|0;d=e+64|0;s=e+56|0;l=e+48|0;c=e+40|0;f=e+32|0;a=e+24|0;o=e+16|0;i=e+8|0;t=e;fa(n,3646);ca(n,3651,2)|0;la(n,3665,2)|0;sa(n,3682,18)|0;u[On>>2]=19;u[On+4>>2]=0;u[r>>2]=u[On>>2];u[r+4>>2]=u[On+4>>2];da(n,3690,r)|0;u[Bn>>2]=1;u[Bn+4>>2]=0;u[r>>2]=u[Bn>>2];u[r+4>>2]=u[Bn+4>>2];_a(n,3696,r)|0;u[Pn>>2]=2;u[Pn+4>>2]=0;u[r>>2]=u[Pn>>2];u[r+4>>2]=u[Pn+4>>2];va(n,3706,r)|0;u[Rn>>2]=1;u[Rn+4>>2]=0;u[r>>2]=u[Rn>>2];u[r+4>>2]=u[Rn+4>>2];pa(n,3722,r)|0;u[Ln>>2]=2;u[Ln+4>>2]=0;u[r>>2]=u[Ln>>2];u[r+4>>2]=u[Ln+4>>2];pa(n,3734,r)|0;u[Cn>>2]=3;u[Cn+4>>2]=0;u[r>>2]=u[Cn>>2];u[r+4>>2]=u[Cn+4>>2];va(n,3753,r)|0;u[En>>2]=4;u[En+4>>2]=0;u[r>>2]=u[En>>2];u[r+4>>2]=u[En+4>>2];va(n,3769,r)|0;u[Sn>>2]=5;u[Sn+4>>2]=0;u[r>>2]=u[Sn>>2];u[r+4>>2]=u[Sn+4>>2];va(n,3783,r)|0;u[An>>2]=6;u[An+4>>2]=0;u[r>>2]=u[An>>2];u[r+4>>2]=u[An+4>>2];va(n,3796,r)|0;u[Tn>>2]=7;u[Tn+4>>2]=0;u[r>>2]=u[Tn>>2];u[r+4>>2]=u[Tn+4>>2];va(n,3813,r)|0;u[gn>>2]=8;u[gn+4>>2]=0;u[r>>2]=u[gn>>2];u[r+4>>2]=u[gn+4>>2];va(n,3825,r)|0;u[kn>>2]=3;u[kn+4>>2]=0;u[r>>2]=u[kn>>2];u[r+4>>2]=u[kn+4>>2];pa(n,3843,r)|0;u[Mn>>2]=4;u[Mn+4>>2]=0;u[r>>2]=u[Mn>>2];u[r+4>>2]=u[Mn+4>>2];pa(n,3853,r)|0;u[wn>>2]=9;u[wn+4>>2]=0;u[r>>2]=u[wn>>2];u[r+4>>2]=u[wn+4>>2];va(n,3870,r)|0;u[yn>>2]=10;u[yn+4>>2]=0;u[r>>2]=u[yn>>2];u[r+4>>2]=u[yn+4>>2];va(n,3884,r)|0;u[hn>>2]=11;u[hn+4>>2]=0;u[r>>2]=u[hn>>2];u[r+4>>2]=u[hn+4>>2];va(n,3896,r)|0;u[bn>>2]=1;u[bn+4>>2]=0;u[r>>2]=u[bn>>2];u[r+4>>2]=u[bn+4>>2];ma(n,3907,r)|0;u[mn>>2]=2;u[mn+4>>2]=0;u[r>>2]=u[mn>>2];u[r+4>>2]=u[mn+4>>2];ma(n,3915,r)|0;u[pn>>2]=3;u[pn+4>>2]=0;u[r>>2]=u[pn>>2];u[r+4>>2]=u[pn+4>>2];ma(n,3928,r)|0;u[vn>>2]=4;u[vn+4>>2]=0;u[r>>2]=u[vn>>2];u[r+4>>2]=u[vn+4>>2];ma(n,3948,r)|0;u[_n>>2]=5;u[_n+4>>2]=0;u[r>>2]=u[_n>>2];u[r+4>>2]=u[_n+4>>2];ma(n,3960,r)|0;u[dn>>2]=6;u[dn+4>>2]=0;u[r>>2]=u[dn>>2];u[r+4>>2]=u[dn+4>>2];ma(n,3974,r)|0;u[sn>>2]=7;u[sn+4>>2]=0;u[r>>2]=u[sn>>2];u[r+4>>2]=u[sn+4>>2];ma(n,3983,r)|0;u[ln>>2]=20;u[ln+4>>2]=0;u[r>>2]=u[ln>>2];u[r+4>>2]=u[ln+4>>2];da(n,3999,r)|0;u[cn>>2]=8;u[cn+4>>2]=0;u[r>>2]=u[cn>>2];u[r+4>>2]=u[cn+4>>2];ma(n,4012,r)|0;u[fn>>2]=9;u[fn+4>>2]=0;u[r>>2]=u[fn>>2];u[r+4>>2]=u[fn+4>>2];ma(n,4022,r)|0;u[an>>2]=21;u[an+4>>2]=0;u[r>>2]=u[an>>2];u[r+4>>2]=u[an+4>>2];da(n,4039,r)|0;u[on>>2]=10;u[on+4>>2]=0;u[r>>2]=u[on>>2];u[r+4>>2]=u[on+4>>2];ma(n,4053,r)|0;u[un>>2]=11;u[un+4>>2]=0;u[r>>2]=u[un>>2];u[r+4>>2]=u[un+4>>2];ma(n,4065,r)|0;u[tn>>2]=12;u[tn+4>>2]=0;u[r>>2]=u[tn>>2];u[r+4>>2]=u[tn+4>>2];ma(n,4084,r)|0;u[rn>>2]=13;u[rn+4>>2]=0;u[r>>2]=u[rn>>2];u[r+4>>2]=u[rn+4>>2];ma(n,4097,r)|0;u[en>>2]=14;u[en+4>>2]=0;u[r>>2]=u[en>>2];u[r+4>>2]=u[en+4>>2];ma(n,4117,r)|0;u[nn>>2]=15;u[nn+4>>2]=0;u[r>>2]=u[nn>>2];u[r+4>>2]=u[nn+4>>2];ma(n,4129,r)|0;u[$>>2]=16;u[$+4>>2]=0;u[r>>2]=u[$>>2];u[r+4>>2]=u[$+4>>2];ma(n,4148,r)|0;u[Q>>2]=17;u[Q+4>>2]=0;u[r>>2]=u[Q>>2];u[r+4>>2]=u[Q+4>>2];ma(n,4161,r)|0;u[Z>>2]=18;u[Z+4>>2]=0;u[r>>2]=u[Z>>2];u[r+4>>2]=u[Z+4>>2];ma(n,4181,r)|0;u[J>>2]=5;u[J+4>>2]=0;u[r>>2]=u[J>>2];u[r+4>>2]=u[J+4>>2];pa(n,4196,r)|0;u[X>>2]=6;u[X+4>>2]=0;u[r>>2]=u[X>>2];u[r+4>>2]=u[X+4>>2];pa(n,4206,r)|0;u[K>>2]=7;u[K+4>>2]=0;u[r>>2]=u[K>>2];u[r+4>>2]=u[K+4>>2];pa(n,4217,r)|0;u[G>>2]=3;u[G+4>>2]=0;u[r>>2]=u[G>>2];u[r+4>>2]=u[G+4>>2];ba(n,4235,r)|0;u[z>>2]=1;u[z+4>>2]=0;u[r>>2]=u[z>>2];u[r+4>>2]=u[z+4>>2];ha(n,4251,r)|0;u[q>>2]=4;u[q+4>>2]=0;u[r>>2]=u[q>>2];u[r+4>>2]=u[q+4>>2];ba(n,4263,r)|0;u[j>>2]=5;u[j+4>>2]=0;u[r>>2]=u[j>>2];u[r+4>>2]=u[j+4>>2];ba(n,4279,r)|0;u[V>>2]=6;u[V+4>>2]=0;u[r>>2]=u[V>>2];u[r+4>>2]=u[V+4>>2];ba(n,4293,r)|0;u[Y>>2]=7;u[Y+4>>2]=0;u[r>>2]=u[Y>>2];u[r+4>>2]=u[Y+4>>2];ba(n,4306,r)|0;u[W>>2]=8;u[W+4>>2]=0;u[r>>2]=u[W>>2];u[r+4>>2]=u[W+4>>2];ba(n,4323,r)|0;u[D>>2]=9;u[D+4>>2]=0;u[r>>2]=u[D>>2];u[r+4>>2]=u[D+4>>2];ba(n,4335,r)|0;u[H>>2]=2;u[H+4>>2]=0;u[r>>2]=u[H>>2];u[r+4>>2]=u[H+4>>2];ha(n,4353,r)|0;u[U>>2]=12;u[U+4>>2]=0;u[r>>2]=u[U>>2];u[r+4>>2]=u[U+4>>2];ya(n,4363,r)|0;u[x>>2]=1;u[x+4>>2]=0;u[r>>2]=u[x>>2];u[r+4>>2]=u[x+4>>2];wa(n,4376,r)|0;u[F>>2]=2;u[F+4>>2]=0;u[r>>2]=u[F>>2];u[r+4>>2]=u[F+4>>2];wa(n,4388,r)|0;u[I>>2]=13;u[I+4>>2]=0;u[r>>2]=u[I>>2];u[r+4>>2]=u[I+4>>2];ya(n,4402,r)|0;u[N>>2]=14;u[N+4>>2]=0;u[r>>2]=u[N>>2];u[r+4>>2]=u[N+4>>2];ya(n,4411,r)|0;u[O>>2]=15;u[O+4>>2]=0;u[r>>2]=u[O>>2];u[r+4>>2]=u[O+4>>2];ya(n,4421,r)|0;u[B>>2]=16;u[B+4>>2]=0;u[r>>2]=u[B>>2];u[r+4>>2]=u[B+4>>2];ya(n,4433,r)|0;u[P>>2]=17;u[P+4>>2]=0;u[r>>2]=u[P>>2];u[r+4>>2]=u[P+4>>2];ya(n,4446,r)|0;u[R>>2]=18;u[R+4>>2]=0;u[r>>2]=u[R>>2];u[r+4>>2]=u[R+4>>2];ya(n,4458,r)|0;u[L>>2]=3;u[L+4>>2]=0;u[r>>2]=u[L>>2];u[r+4>>2]=u[L+4>>2];wa(n,4471,r)|0;u[C>>2]=1;u[C+4>>2]=0;u[r>>2]=u[C>>2];u[r+4>>2]=u[C+4>>2];Ma(n,4486,r)|0;u[E>>2]=10;u[E+4>>2]=0;u[r>>2]=u[E>>2];u[r+4>>2]=u[E+4>>2];ba(n,4496,r)|0;u[S>>2]=11;u[S+4>>2]=0;u[r>>2]=u[S>>2];u[r+4>>2]=u[S+4>>2];ba(n,4508,r)|0;u[A>>2]=3;u[A+4>>2]=0;u[r>>2]=u[A>>2];u[r+4>>2]=u[A+4>>2];ha(n,4519,r)|0;u[T>>2]=4;u[T+4>>2]=0;u[r>>2]=u[T>>2];u[r+4>>2]=u[T+4>>2];ka(n,4530,r)|0;u[g>>2]=19;u[g+4>>2]=0;u[r>>2]=u[g>>2];u[r+4>>2]=u[g+4>>2];ga(n,4542,r)|0;u[k>>2]=12;u[k+4>>2]=0;u[r>>2]=u[k>>2];u[r+4>>2]=u[k+4>>2];Ta(n,4554,r)|0;u[M>>2]=13;u[M+4>>2]=0;u[r>>2]=u[M>>2];u[r+4>>2]=u[M+4>>2];Aa(n,4568,r)|0;u[w>>2]=2;u[w+4>>2]=0;u[r>>2]=u[w>>2];u[r+4>>2]=u[w+4>>2];Sa(n,4578,r)|0;u[y>>2]=20;u[y+4>>2]=0;u[r>>2]=u[y>>2];u[r+4>>2]=u[y+4>>2];Ea(n,4587,r)|0;u[h>>2]=22;u[h+4>>2]=0;u[r>>2]=u[h>>2];u[r+4>>2]=u[h+4>>2];da(n,4602,r)|0;u[b>>2]=23;u[b+4>>2]=0;u[r>>2]=u[b>>2];u[r+4>>2]=u[b+4>>2];da(n,4619,r)|0;u[m>>2]=14;u[m+4>>2]=0;u[r>>2]=u[m>>2];u[r+4>>2]=u[m+4>>2];Ca(n,4629,r)|0;u[p>>2]=1;u[p+4>>2]=0;u[r>>2]=u[p>>2];u[r+4>>2]=u[p+4>>2];La(n,4637,r)|0;u[_>>2]=4;u[_+4>>2]=0;u[r>>2]=u[_>>2];u[r+4>>2]=u[_+4>>2];wa(n,4653,r)|0;u[d>>2]=5;u[d+4>>2]=0;u[r>>2]=u[d>>2];u[r+4>>2]=u[d+4>>2];wa(n,4669,r)|0;u[s>>2]=6;u[s+4>>2]=0;u[r>>2]=u[s>>2];u[r+4>>2]=u[s+4>>2];wa(n,4686,r)|0;u[l>>2]=7;u[l+4>>2]=0;u[r>>2]=u[l>>2];u[r+4>>2]=u[l+4>>2];wa(n,4701,r)|0;u[c>>2]=8;u[c+4>>2]=0;u[r>>2]=u[c>>2];u[r+4>>2]=u[c+4>>2];wa(n,4719,r)|0;u[f>>2]=9;u[f+4>>2]=0;u[r>>2]=u[f>>2];u[r+4>>2]=u[f+4>>2];wa(n,4736,r)|0;u[a>>2]=21;u[a+4>>2]=0;u[r>>2]=u[a>>2];u[r+4>>2]=u[a+4>>2];Ra(n,4754,r)|0;u[o>>2]=2;u[o+4>>2]=0;u[r>>2]=u[o>>2];u[r+4>>2]=u[o+4>>2];Ma(n,4772,r)|0;u[i>>2]=3;u[i+4>>2]=0;u[r>>2]=u[i>>2];u[r+4>>2]=u[i+4>>2];Ma(n,4790,r)|0;u[t>>2]=4;u[t+4>>2]=0;u[r>>2]=u[t>>2];u[r+4>>2]=u[t+4>>2];Ma(n,4808,r)|0;v=e;return}function fa(n,e){n=n|0;e=e|0;var r=0;r=Nm()|0;u[n>>2]=r;Im(r,e);lM(u[n>>2]|0);return}function ca(n,e,r){n=n|0;e=e|0;r=r|0;bm(n,Ba(e)|0,r,0);return n|0}function la(n,e,r){n=n|0;e=e|0;r=r|0;Jp(n,Ba(e)|0,r,0);return n|0}function sa(n,e,r){n=n|0;e=e|0;r=r|0;Op(n,Ba(e)|0,r,0);return n|0}function da(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];vp(n,e,i);v=t;return n|0}function _a(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];zv(n,e,i);v=t;return n|0}function va(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ev(n,e,i);v=t;return n|0}function pa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];fv(n,e,i);v=t;return n|0}function ma(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];V_(n,e,i);v=t;return n|0}function ba(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];T_(n,e,i);v=t;return n|0}function ha(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];u_(n,e,i);v=t;return n|0}function ya(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ad(n,e,i);v=t;return n|0}function wa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];od(n,e,i);v=t;return n|0}function Ma(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ws(n,e,i);v=t;return n|0}function ka(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ks(n,e,i);v=t;return n|0}function ga(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ns(n,e,i);v=t;return n|0}function Ta(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Nl(n,e,i);v=t;return n|0}function Aa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];pl(n,e,i);v=t;return n|0}function Sa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];zc(n,e,i);v=t;return n|0}function Ea(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];kc(n,e,i);v=t;return n|0}function Ca(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];rc(n,e,i);v=t;return n|0}function La(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Pf(n,e,i);v=t;return n|0}function Ra(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Pa(n,e,i);v=t;return n|0}function Pa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Oa(n,r,i,1);v=t;return}function Ba(n){n=n|0;return n|0}function Oa(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Na()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Ia(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Fa(o,t)|0,t);v=i;return}function Na(){var n=0,e=0;if(!(t[7616]|0)){Ka(9136);xn(24,9136,b|0)|0;e=7616;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9136)|0)){n=9136;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ka(9136)}return 9136}function Ia(n){n=n|0;return 0}function Fa(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Na()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ya(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Va(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function xa(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;a=v;v=v+32|0;_=a+24|0;d=a+20|0;c=a+16|0;s=a+12|0;l=a+8|0;f=a+4|0;p=a;u[d>>2]=e;u[c>>2]=r;u[s>>2]=t;u[l>>2]=i;u[f>>2]=o;o=n+28|0;u[p>>2]=u[o>>2];u[_>>2]=u[p>>2];Ua(n+24|0,_,d,s,l,c,f)|0;u[o>>2]=u[u[o>>2]>>2];v=a;return}function Ua(n,e,r,t,i,o,a){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;a=a|0;n=Ha(e)|0;e=GE(24)|0;Da(e+4|0,u[r>>2]|0,u[t>>2]|0,u[i>>2]|0,u[o>>2]|0,u[a>>2]|0);u[e>>2]=u[n>>2];u[n>>2]=e;return e|0}function Ha(n){n=n|0;return u[n>>2]|0}function Da(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=t;u[n+12>>2]=i;u[n+16>>2]=o;return}function Wa(n,e){n=n|0;e=e|0;return e|n|0}function Ya(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Va(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=ja(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;qa(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ya(o,t,r);u[c>>2]=(u[c>>2]|0)+12;za(n,f);Ga(f);v=l;return}}function ja(n){n=n|0;return 357913941}function qa(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function za(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Ga(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Ka(n){n=n|0;Qa(n);return}function Xa(n){n=n|0;Za(n+24|0);return}function Ja(n){n=n|0;return u[n>>2]|0}function Za(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Qa(n){n=n|0;var e=0;e=$a()|0;rf(n,2,3,e,nf()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function $a(){return 9228}function nf(){return 1140}function ef(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=tf(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=uf(e,t)|0;v=r;return e|0}function rf(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=t;u[n+12>>2]=i;u[n+16>>2]=o;return}function tf(n){n=n|0;return(u[(Na()|0)+24>>2]|0)+(n*12|0)|0}function uf(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+48|0;t=i;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;pL[r&31](t,n);t=of(t)|0;v=i;return t|0}function of(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(af()|0)|0;if(!t)n=_f(n)|0;else{cf(e,t);lf(r,e);sf(n,r);n=df(e)|0}v=i;return n|0}function af(){var n=0;if(!(t[7632]|0)){Tf(9184);xn(25,9184,b|0)|0;n=7632;u[n>>2]=1;u[n+4>>2]=0}return 9184}function ff(n){n=n|0;return u[n+36>>2]|0}function cf(n,e){n=n|0;e=e|0;u[n>>2]=e;u[n+4>>2]=n;u[n+8>>2]=0;return}function lf(n,e){n=n|0;e=e|0;u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=0;return}function sf(n,e){n=n|0;e=e|0;hf(e,n,n+8|0,n+16|0,n+24|0,n+32|0,n+40|0)|0;return}function df(n){n=n|0;return u[(u[n+4>>2]|0)+8>>2]|0}function _f(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0;c=v;v=v+16|0;r=c+4|0;t=c;i=Dg(8)|0;o=i;a=GE(48)|0;f=a;e=f+48|0;do{u[f>>2]=u[n>>2];f=f+4|0;n=n+4|0}while((f|0)<(e|0));e=o+4|0;u[e>>2]=a;f=GE(8)|0;a=u[e>>2]|0;u[t>>2]=0;u[r>>2]=u[t>>2];vf(f,a,r);u[i>>2]=f;v=c;return o|0}function vf(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1092;u[r+12>>2]=e;u[n+4>>2]=r;return}function pf(n){n=n|0;WE(n);XE(n);return}function mf(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function bf(n){n=n|0;XE(n);return}function hf(n,e,r,t,i,o,a){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;a=a|0;o=yf(u[n>>2]|0,e,r,t,i,o,a)|0;a=n+4|0;u[(u[a>>2]|0)+8>>2]=o;return u[(u[a>>2]|0)+8>>2]|0}function yf(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;o=o|0;var a=0,f=0;a=v;v=v+16|0;f=a;gS(f);n=ko(n)|0;o=wf(n,+l[e>>3],+l[r>>3],+l[t>>3],+l[i>>3],+l[u>>3],+l[o>>3])|0;AS(f);v=a;return o|0}function wf(n,e,r,t,i,u,o){n=n|0;e=+e;r=+r;t=+t;i=+i;u=+u;o=+o;var a=0;a=Ao(Mf()|0)|0;e=+So(e);r=+So(r);t=+So(t);i=+So(i);u=+So(u);return Cn(0,a|0,n|0,+e,+r,+t,+i,+u,+ +So(o))|0}function Mf(){var n=0;if(!(t[7624]|0)){kf(9172);n=7624;u[n>>2]=1;u[n+4>>2]=0}return 9172}function kf(n){n=n|0;xo(n,gf()|0,6);return}function gf(){return 1112}function Tf(n){n=n|0;Rf(n);return}function Af(n){n=n|0;Sf(n+24|0);Ef(n+16|0);return}function Sf(n){n=n|0;Lf(n);return}function Ef(n){n=n|0;Cf(n);return}function Cf(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function Lf(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function Rf(n){n=n|0;var e=0;u[n+16>>2]=0;u[n+20>>2]=0;e=n+24|0;u[e>>2]=0;u[n+28>>2]=e;u[n+36>>2]=0;t[n+40>>0]=0;t[n+41>>0]=0;return}function Pf(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Bf(n,r,i,0);v=t;return}function Bf(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Of()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Nf(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,If(o,t)|0,t);v=i;return}function Of(){var n=0,e=0;if(!(t[7640]|0)){Yf(9232);xn(26,9232,b|0)|0;e=7640;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9232)|0)){n=9232;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Yf(9232)}return 9232}function Nf(n){n=n|0;return 0}function If(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Of()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ff(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{xf(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Ff(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function xf(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Uf(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Hf(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ff(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Df(n,f);Wf(f);v=l;return}}function Uf(n){n=n|0;return 357913941}function Hf(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Df(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Wf(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Yf(n){n=n|0;qf(n);return}function Vf(n){n=n|0;jf(n+24|0);return}function jf(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function qf(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,zf()|0,3);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function zf(){return 1144}function Gf(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+16|0;a=o+8|0;f=o;c=Kf(n)|0;n=u[c+4>>2]|0;u[f>>2]=u[c>>2];u[f+4>>2]=n;u[a>>2]=u[f>>2];u[a+4>>2]=u[f+4>>2];Xf(e,a,r,t,i);v=o;return}function Kf(n){n=n|0;return(u[(Of()|0)+24>>2]|0)+(n*12|0)|0}function Xf(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;var o=0,a=0,f=0,c=0,l=0;l=v;v=v+16|0;a=l+2|0;f=l+1|0;c=l;o=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)o=u[(u[n>>2]|0)+o>>2]|0;Jf(a,r);r=+Zf(a,r);Jf(f,t);t=+Zf(f,t);Qf(c,i);c=$f(c,i)|0;bL[o&1](n,r,t,c);v=l;return}function Jf(n,e){n=n|0;e=+e;return}function Zf(n,e){n=n|0;e=+e;return+ +ec(e)}function Qf(n,e){n=n|0;e=e|0;return}function $f(n,e){n=n|0;e=e|0;return nc(e)|0}function nc(n){n=n|0;return n|0}function ec(n){n=+n;return+n}function rc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];tc(n,r,i,1);v=t;return}function tc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=ic()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=uc(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,oc(o,t)|0,t);v=i;return}function ic(){var n=0,e=0;if(!(t[7648]|0)){_c(9268);xn(27,9268,b|0)|0;e=7648;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9268)|0)){n=9268;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));_c(9268)}return 9268}function uc(n){n=n|0;return 0}function oc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=ic()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];ac(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{fc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function ac(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function fc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=cc(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;lc(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];ac(o,t,r);u[c>>2]=(u[c>>2]|0)+12;sc(n,f);dc(f);v=l;return}}function cc(n){n=n|0;return 357913941}function lc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function sc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function dc(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function _c(n){n=n|0;mc(n);return}function vc(n){n=n|0;pc(n+24|0);return}function pc(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function mc(n){n=n|0;var e=0;e=$a()|0;rf(n,2,4,e,bc()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function bc(){return 1160}function hc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=yc(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=wc(e,t)|0;v=r;return e|0}function yc(n){n=n|0;return(u[(ic()|0)+24>>2]|0)+(n*12|0)|0}function wc(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return Mc(mL[r&31](n)|0)|0}function Mc(n){n=n|0;return n&1|0}function kc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];gc(n,r,i,0);v=t;return}function gc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Tc()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Ac(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Sc(o,t)|0,t);v=i;return}function Tc(){var n=0,e=0;if(!(t[7656]|0)){Oc(9304);xn(28,9304,b|0)|0;e=7656;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9304)|0)){n=9304;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Oc(9304)}return 9304}function Ac(n){n=n|0;return 0}function Sc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Tc()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ec(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Cc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Ec(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Cc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Lc(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Rc(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ec(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Pc(n,f);Bc(f);v=l;return}}function Lc(n){n=n|0;return 357913941}function Rc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Pc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Bc(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Oc(n){n=n|0;Fc(n);return}function Nc(n){n=n|0;Ic(n+24|0);return}function Ic(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Fc(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,xc()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function xc(){return 1164}function Uc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=Hc(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Dc(e,i,r);v=t;return}function Hc(n){n=n|0;return(u[(Tc()|0)+24>>2]|0)+(n*12|0)|0}function Dc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Wc(i,r);r=Yc(i,r)|0;pL[t&31](n,r);Vc(i);v=o;return}function Wc(n,e){n=n|0;e=e|0;jc(n,e);return}function Yc(n,e){n=n|0;e=e|0;return n|0}function Vc(n){n=n|0;Qi(n);return}function jc(n,e){n=n|0;e=e|0;qc(n,e);return}function qc(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function zc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Gc(n,r,i,0);v=t;return}function Gc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Kc()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Xc(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Jc(o,t)|0,t);v=i;return}function Kc(){var n=0,e=0;if(!(t[7664]|0)){tl(9340);xn(29,9340,b|0)|0;e=7664;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9340)|0)){n=9340;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));tl(9340)}return 9340}function Xc(n){n=n|0;return 0}function Jc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Kc()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Zc(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Qc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Zc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Qc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=$c(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;nl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Zc(o,t,r);u[c>>2]=(u[c>>2]|0)+12;el(n,f);rl(f);v=l;return}}function $c(n){n=n|0;return 357913941}function nl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function el(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function rl(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function tl(n){n=n|0;ol(n);return}function il(n){n=n|0;ul(n+24|0);return}function ul(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function ol(n){n=n|0;var e=0;e=$a()|0;rf(n,2,4,e,al()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function al(){return 1180}function fl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=cl(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=ll(e,i,r)|0;v=t;return r|0}function cl(n){n=n|0;return(u[(Kc()|0)+24>>2]|0)+(n*12|0)|0}function ll(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;sl(i,r);i=dl(i,r)|0;i=_l(gL[t&15](n,i)|0)|0;v=o;return i|0}function sl(n,e){n=n|0;e=e|0;return}function dl(n,e){n=n|0;e=e|0;return vl(e)|0}function _l(n){n=n|0;return n|0}function vl(n){n=n|0;return n|0}function pl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ml(n,r,i,0);v=t;return}function ml(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=bl()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=hl(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,yl(o,t)|0,t);v=i;return}function bl(){var n=0,e=0;if(!(t[7672]|0)){Sl(9376);xn(30,9376,b|0)|0;e=7672;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9376)|0)){n=9376;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Sl(9376)}return 9376}function hl(n){n=n|0;return 0}function yl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=bl()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];wl(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Ml(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function wl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Ml(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=kl(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;gl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];wl(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Tl(n,f);Al(f);v=l;return}}function kl(n){n=n|0;return 357913941}function gl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Tl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Al(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Sl(n){n=n|0;Ll(n);return}function El(n){n=n|0;Cl(n+24|0);return}function Cl(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Ll(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,Rl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Rl(){return 1196}function Pl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Bl(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Ol(e,t)|0;v=r;return e|0}function Bl(n){n=n|0;return(u[(bl()|0)+24>>2]|0)+(n*12|0)|0}function Ol(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return _l(mL[r&31](n)|0)|0}function Nl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Il(n,r,i,1);v=t;return}function Il(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Fl()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=xl(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ul(o,t)|0,t);v=i;return}function Fl(){var n=0,e=0;if(!(t[7680]|0)){ql(9412);xn(31,9412,b|0)|0;e=7680;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9412)|0)){n=9412;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));ql(9412)}return 9412}function xl(n){n=n|0;return 0}function Ul(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Fl()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Hl(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Dl(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Hl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Dl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Wl(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Yl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Hl(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Vl(n,f);jl(f);v=l;return}}function Wl(n){n=n|0;return 357913941}function Yl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Vl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function jl(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function ql(n){n=n|0;Kl(n);return}function zl(n){n=n|0;Gl(n+24|0);return}function Gl(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Kl(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,Xl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Xl(){return 1200}function Jl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Zl(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Ql(e,t)|0;v=r;return e|0}function Zl(n){n=n|0;return(u[(Fl()|0)+24>>2]|0)+(n*12|0)|0}function Ql(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return $l(mL[r&31](n)|0)|0}function $l(n){n=n|0;return n|0}function ns(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];es(n,r,i,0);v=t;return}function es(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=rs()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=ts(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,is(o,t)|0,t);v=i;return}function rs(){var n=0,e=0;if(!(t[7688]|0)){ss(9448);xn(32,9448,b|0)|0;e=7688;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9448)|0)){n=9448;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));ss(9448)}return 9448}function ts(n){n=n|0;return 0}function is(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=rs()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];us(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{os(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function us(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function os(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=as(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;fs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];us(o,t,r);u[c>>2]=(u[c>>2]|0)+12;cs(n,f);ls(f);v=l;return}}function as(n){n=n|0;return 357913941}function fs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function cs(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function ls(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function ss(n){n=n|0;vs(n);return}function ds(n){n=n|0;_s(n+24|0);return}function _s(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function vs(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,ps()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function ps(){return 1204}function ms(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=bs(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];hs(e,i,r);v=t;return}function bs(n){n=n|0;return(u[(rs()|0)+24>>2]|0)+(n*12|0)|0}function hs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;ys(i,r);i=ws(i,r)|0;pL[t&31](n,i);v=o;return}function ys(n,e){n=n|0;e=e|0;return}function ws(n,e){n=n|0;e=e|0;return Ms(e)|0}function Ms(n){n=n|0;return n|0}function ks(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];gs(n,r,i,0);v=t;return}function gs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Ts()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=As(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ss(o,t)|0,t);v=i;return}function Ts(){var n=0,e=0;if(!(t[7696]|0)){Os(9484);xn(33,9484,b|0)|0;e=7696;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9484)|0)){n=9484;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Os(9484)}return 9484}function As(n){n=n|0;return 0}function Ss(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Ts()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Es(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Cs(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Es(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Cs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Ls(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Rs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Es(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Ps(n,f);Bs(f);v=l;return}}function Ls(n){n=n|0;return 357913941}function Rs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Ps(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Bs(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Os(n){n=n|0;Fs(n);return}function Ns(n){n=n|0;Is(n+24|0);return}function Is(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Fs(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,xs()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function xs(){return 1212}function Us(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=Hs(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];Ds(e,o,r,t);v=i;return}function Hs(n){n=n|0;return(u[(Ts()|0)+24>>2]|0)+(n*12|0)|0}function Ds(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;ys(o,r);o=ws(o,r)|0;sl(a,t);a=dl(a,t)|0;PL[i&15](n,o,a);v=f;return}function Ws(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ys(n,r,i,1);v=t;return}function Ys(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Vs()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=js(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,qs(o,t)|0,t);v=i;return}function Vs(){var n=0,e=0;if(!(t[7704]|0)){Qs(9520);xn(34,9520,b|0)|0;e=7704;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9520)|0)){n=9520;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Qs(9520)}return 9520}function js(n){n=n|0;return 0}function qs(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Vs()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];zs(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Gs(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function zs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Gs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Ks(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Xs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];zs(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Js(n,f);Zs(f);v=l;return}}function Ks(n){n=n|0;return 357913941}function Xs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Js(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Zs(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Qs(n){n=n|0;ed(n);return}function $s(n){n=n|0;nd(n+24|0);return}function nd(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function ed(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,rd()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function rd(){return 1224}function td(n,e,r){n=n|0;e=e|0;r=r|0;var t=0.0,i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=id(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];t=+ud(e,o,r);v=i;return+t}function id(n){n=n|0;return(u[(Vs()|0)+24>>2]|0)+(n*12|0)|0}function ud(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0.0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;a=+No(+SL[t&7](n,i));v=o;return+a}function od(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ad(n,r,i,1);v=t;return}function ad(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=fd()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=cd(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,ld(o,t)|0,t);v=i;return}function fd(){var n=0,e=0;if(!(t[7712]|0)){bd(9556);xn(35,9556,b|0)|0;e=7712;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9556)|0)){n=9556;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));bd(9556)}return 9556}function cd(n){n=n|0;return 0}function ld(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=fd()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];sd(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{dd(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function sd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function dd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=_d(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;vd(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];sd(o,t,r);u[c>>2]=(u[c>>2]|0)+12;pd(n,f);md(f);v=l;return}}function _d(n){n=n|0;return 357913941}function vd(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function pd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function md(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function bd(n){n=n|0;wd(n);return}function hd(n){n=n|0;yd(n+24|0);return}function yd(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function wd(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,Md()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Md(){return 1232}function kd(n,e){n=n|0;e=e|0;var r=0.0,t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=gd(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=+Td(e,i);v=t;return+r}function gd(n){n=n|0;return(u[(fd()|0)+24>>2]|0)+(n*12|0)|0}function Td(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return+ +No(+ML[r&15](n))}function Ad(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Sd(n,r,i,1);v=t;return}function Sd(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Ed()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Cd(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ld(o,t)|0,t);v=i;return}function Ed(){var n=0,e=0;if(!(t[7720]|0)){Fd(9592);xn(36,9592,b|0)|0;e=7720;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9592)|0)){n=9592;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Fd(9592)}return 9592}function Cd(n){n=n|0;return 0}function Ld(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Ed()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Rd(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Pd(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Rd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Pd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Bd(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Od(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Rd(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Nd(n,f);Id(f);v=l;return}}function Bd(n){n=n|0;return 357913941}function Od(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Nd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Id(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Fd(n){n=n|0;Hd(n);return}function xd(n){n=n|0;Ud(n+24|0);return}function Ud(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Hd(n){n=n|0;var e=0;e=$a()|0;rf(n,2,7,e,Dd()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Dd(){return 1276}function Wd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Yd(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Vd(e,t)|0;v=r;return e|0}function Yd(n){n=n|0;return(u[(Ed()|0)+24>>2]|0)+(n*12|0)|0}function Vd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+16|0;t=i;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;pL[r&31](t,n);t=jd(t)|0;v=i;return t|0}function jd(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(qd()|0)|0;if(!t)n=Gd(n)|0;else{cf(e,t);lf(r,e);zd(n,r);n=df(e)|0}v=i;return n|0}function qd(){var n=0;if(!(t[7736]|0)){i_(9640);xn(25,9640,b|0)|0;n=7736;u[n>>2]=1;u[n+4>>2]=0}return 9640}function zd(n,e){n=n|0;e=e|0;Qd(e,n,n+8|0)|0;return}function Gd(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(16)|0;u[f>>2]=u[n>>2];u[f+4>>2]=u[n+4>>2];u[f+8>>2]=u[n+8>>2];u[f+12>>2]=u[n+12>>2];o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];Kd(n,o,i);u[t>>2]=n;v=r;return e|0}function Kd(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1244;u[r+12>>2]=e;u[n+4>>2]=r;return}function Xd(n){n=n|0;WE(n);XE(n);return}function Jd(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function Zd(n){n=n|0;XE(n);return}function Qd(n,e,r){n=n|0;e=e|0;r=r|0;e=$d(u[n>>2]|0,e,r)|0;r=n+4|0;u[(u[r>>2]|0)+8>>2]=e;return u[(u[r>>2]|0)+8>>2]|0}function $d(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;gS(i);n=ko(n)|0;r=n_(n,u[e>>2]|0,+l[r>>3])|0;AS(i);v=t;return r|0}function n_(n,e,r){n=n|0;e=e|0;r=+r;var t=0;t=Ao(e_()|0)|0;e=Eo(e)|0;return Ln(0,t|0,n|0,e|0,+ +So(r))|0}function e_(){var n=0;if(!(t[7728]|0)){r_(9628);n=7728;u[n>>2]=1;u[n+4>>2]=0}return 9628}function r_(n){n=n|0;xo(n,t_()|0,2);return}function t_(){return 1264}function i_(n){n=n|0;Rf(n);return}function u_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];o_(n,r,i,1);v=t;return}function o_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=a_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=f_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,c_(o,t)|0,t);v=i;return}function a_(){var n=0,e=0;if(!(t[7744]|0)){m_(9684);xn(37,9684,b|0)|0;e=7744;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9684)|0)){n=9684;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));m_(9684)}return 9684}function f_(n){n=n|0;return 0}function c_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=a_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];l_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{s_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function l_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function s_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=d_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;__(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];l_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;v_(n,f);p_(f);v=l;return}}function d_(n){n=n|0;return 357913941}function __(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function v_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function p_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function m_(n){n=n|0;y_(n);return}function b_(n){n=n|0;h_(n+24|0);return}function h_(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function y_(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,w_()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function w_(){return 1280}function M_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=k_(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=g_(e,i,r)|0;v=t;return r|0}function k_(n){n=n|0;return(u[(a_()|0)+24>>2]|0)+(n*12|0)|0}function g_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;a=v;v=v+32|0;i=a;o=a+16|0;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(o,r);o=$f(o,r)|0;PL[t&15](i,n,o);o=jd(i)|0;v=a;return o|0}function T_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];A_(n,r,i,1);v=t;return}function A_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=S_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=E_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,C_(o,t)|0,t);v=i;return}function S_(){var n=0,e=0;if(!(t[7752]|0)){I_(9720);xn(38,9720,b|0)|0;e=7752;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9720)|0)){n=9720;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));I_(9720)}return 9720}function E_(n){n=n|0;return 0}function C_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=S_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];L_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{R_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function L_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function R_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=P_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;B_(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];L_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;O_(n,f);N_(f);v=l;return}}function P_(n){n=n|0;return 357913941}function B_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function O_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function N_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function I_(n){n=n|0;U_(n);return}function F_(n){n=n|0;x_(n+24|0);return}function x_(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function U_(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,H_()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function H_(){return 1288}function D_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=W_(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Y_(e,t)|0;v=r;return e|0}function W_(n){n=n|0;return(u[(S_()|0)+24>>2]|0)+(n*12|0)|0}function Y_(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return Oo(mL[r&31](n)|0)|0}function V_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];j_(n,r,i,0);v=t;return}function j_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=q_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=z_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,G_(o,t)|0,t);v=i;return}function q_(){var n=0,e=0;if(!(t[7760]|0)){nv(9756);xn(39,9756,b|0)|0;e=7760;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9756)|0)){n=9756;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));nv(9756)}return 9756}function z_(n){n=n|0;return 0}function G_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=q_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];K_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{X_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function K_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function X_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=J_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Z_(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];K_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Q_(n,f);$_(f);v=l;return}}function J_(n){n=n|0;return 357913941}function Z_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Q_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function $_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function nv(n){n=n|0;tv(n);return}function ev(n){n=n|0;rv(n+24|0);return}function rv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function tv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,iv()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function iv(){return 1292}function uv(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=ov(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];av(e,i,r);v=t;return}function ov(n){n=n|0;return(u[(q_()|0)+24>>2]|0)+(n*12|0)|0}function av(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Jf(i,r);r=+Zf(i,r);dL[t&31](n,r);v=o;return}function fv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];cv(n,r,i,0);v=t;return}function cv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=lv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=sv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,dv(o,t)|0,t);v=i;return}function lv(){var n=0,e=0;if(!(t[7768]|0)){yv(9792);xn(40,9792,b|0)|0;e=7768;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9792)|0)){n=9792;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));yv(9792)}return 9792}function sv(n){n=n|0;return 0}function dv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=lv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];_v(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{vv(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function _v(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function vv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=pv(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;mv(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];_v(o,t,r);u[c>>2]=(u[c>>2]|0)+12;bv(n,f);hv(f);v=l;return}}function pv(n){n=n|0;return 357913941}function mv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function bv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function hv(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function yv(n){n=n|0;kv(n);return}function wv(n){n=n|0;Mv(n+24|0);return}function Mv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function kv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,gv()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function gv(){return 1300}function Tv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=Av(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];Sv(e,o,r,t);v=i;return}function Av(n){n=n|0;return(u[(lv()|0)+24>>2]|0)+(n*12|0)|0}function Sv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;Qf(o,r);o=$f(o,r)|0;Jf(a,t);t=+Zf(a,t);OL[i&15](n,o,t);v=f;return}function Ev(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Cv(n,r,i,0);v=t;return}function Cv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Lv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Rv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Pv(o,t)|0,t);v=i;return}function Lv(){var n=0,e=0;if(!(t[7776]|0)){Uv(9828);xn(41,9828,b|0)|0;e=7776;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9828)|0)){n=9828;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Uv(9828)}return 9828}function Rv(n){n=n|0;return 0}function Pv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Lv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Bv(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Ov(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Bv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Ov(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Nv(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Iv(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Bv(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Fv(n,f);xv(f);v=l;return}}function Nv(n){n=n|0;return 357913941}function Iv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Fv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function xv(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Uv(n){n=n|0;Wv(n);return}function Hv(n){n=n|0;Dv(n+24|0);return}function Dv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Wv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,7,e,Yv()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Yv(){return 1312}function Vv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=jv(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];qv(e,i,r);v=t;return}function jv(n){n=n|0;return(u[(Lv()|0)+24>>2]|0)+(n*12|0)|0}function qv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;pL[t&31](n,i);v=o;return}function zv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Gv(n,r,i,0);v=t;return}function Gv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Kv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Xv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Jv(o,t)|0,t);v=i;return}function Kv(){var n=0,e=0;if(!(t[7784]|0)){tp(9864);xn(42,9864,b|0)|0;e=7784;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9864)|0)){n=9864;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));tp(9864)}return 9864}function Xv(n){n=n|0;return 0}function Jv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Kv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Zv(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Qv(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Zv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Qv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=$v(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;np(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Zv(o,t,r);u[c>>2]=(u[c>>2]|0)+12;ep(n,f);rp(f);v=l;return}}function $v(n){n=n|0;return 357913941}function np(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function ep(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function rp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function tp(n){n=n|0;op(n);return}function ip(n){n=n|0;up(n+24|0);return}function up(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function op(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,ap()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function ap(){return 1320}function fp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=cp(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];lp(e,i,r);v=t;return}function cp(n){n=n|0;return(u[(Kv()|0)+24>>2]|0)+(n*12|0)|0}function lp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;sp(i,r);i=dp(i,r)|0;pL[t&31](n,i);v=o;return}function sp(n,e){n=n|0;e=e|0;return}function dp(n,e){n=n|0;e=e|0;return _p(e)|0}function _p(n){n=n|0;return n|0}function vp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];pp(n,r,i,0);v=t;return}function pp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=mp()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=bp(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,hp(o,t)|0,t);v=i;return}function mp(){var n=0,e=0;if(!(t[7792]|0)){Ap(9900);xn(43,9900,b|0)|0;e=7792;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9900)|0)){n=9900;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ap(9900)}return 9900}function bp(n){n=n|0;return 0}function hp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=mp()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];yp(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{wp(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function yp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function wp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Mp(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;kp(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];yp(o,t,r);u[c>>2]=(u[c>>2]|0)+12;gp(n,f);Tp(f);v=l;return}}function Mp(n){n=n|0;return 357913941}function kp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function gp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Tp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Ap(n){n=n|0;Cp(n);return}function Sp(n){n=n|0;Ep(n+24|0);return}function Ep(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Cp(n){n=n|0;var e=0;e=$a()|0;rf(n,2,22,e,Lp()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Lp(){return 1344}function Rp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Pp(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];Bp(e,t);v=r;return}function Pp(n){n=n|0;return(u[(mp()|0)+24>>2]|0)+(n*12|0)|0}function Bp(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;vL[r&127](n);return}function Op(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Np()|0;n=Ip(r)|0;xa(o,e,i,n,Fp(r,t)|0,t);return}function Np(){var n=0,e=0;if(!(t[7800]|0)){Vp(9936);xn(44,9936,b|0)|0;e=7800;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9936)|0)){n=9936;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Vp(9936)}return 9936}function Ip(n){n=n|0;return n|0}function Fp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Np()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){xp(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{Up(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function xp(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function Up(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=Hp(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Dp(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;xp(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Wp(n,i);Yp(i);v=f;return}}function Hp(n){n=n|0;return 536870911}function Dp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Wp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Yp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Vp(n){n=n|0;zp(n);return}function jp(n){n=n|0;qp(n+24|0);return}function qp(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function zp(n){n=n|0;var e=0;e=$a()|0;rf(n,1,23,e,ps()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Gp(n,e){n=n|0;e=e|0;Xp(u[(Kp(n)|0)>>2]|0,e);return}function Kp(n){n=n|0;return(u[(Np()|0)+24>>2]|0)+(n<<3)|0}function Xp(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;ys(t,e);e=ws(t,e)|0;vL[n&127](e);v=r;return}function Jp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Zp()|0;n=Qp(r)|0;xa(o,e,i,n,$p(r,t)|0,t);return}function Zp(){var n=0,e=0;if(!(t[7808]|0)){om(9972);xn(45,9972,b|0)|0;e=7808;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9972)|0)){n=9972;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));om(9972)}return 9972}function Qp(n){n=n|0;return n|0}function $p(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Zp()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){nm(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{em(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function nm(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function em(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=rm(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;tm(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;nm(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;im(n,i);um(i);v=f;return}}function rm(n){n=n|0;return 536870911}function tm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function im(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function um(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function om(n){n=n|0;cm(n);return}function am(n){n=n|0;fm(n+24|0);return}function fm(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function cm(n){n=n|0;var e=0;e=$a()|0;rf(n,1,9,e,lm()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function lm(){return 1348}function sm(n,e){n=n|0;e=e|0;return _m(u[(dm(n)|0)>>2]|0,e)|0}function dm(n){n=n|0;return(u[(Zp()|0)+24>>2]|0)+(n<<3)|0}function _m(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;vm(t,e);e=pm(t,e)|0;e=_l(mL[n&31](e)|0)|0;v=r;return e|0}function vm(n,e){n=n|0;e=e|0;return}function pm(n,e){n=n|0;e=e|0;return mm(e)|0}function mm(n){n=n|0;return n|0}function bm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=hm()|0;n=ym(r)|0;xa(o,e,i,n,wm(r,t)|0,t);return}function hm(){var n=0,e=0;if(!(t[7816]|0)){Em(10008);xn(46,10008,b|0)|0;e=7816;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10008)|0)){n=10008;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Em(10008)}return 10008}function ym(n){n=n|0;return n|0}function wm(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=hm()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Mm(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{km(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function Mm(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function km(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=gm(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Tm(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Mm(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Am(n,i);Sm(i);v=f;return}}function gm(n){n=n|0;return 536870911}function Tm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Am(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Sm(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Em(n){n=n|0;Rm(n);return}function Cm(n){n=n|0;Lm(n+24|0);return}function Lm(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Rm(n){n=n|0;var e=0;e=$a()|0;rf(n,1,15,e,Rl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Pm(n){n=n|0;return Om(u[(Bm(n)|0)>>2]|0)|0}function Bm(n){n=n|0;return(u[(hm()|0)+24>>2]|0)+(n<<3)|0}function Om(n){n=n|0;return _l(EL[n&7]()|0)|0}function Nm(){var n=0;if(!(t[7832]|0)){jm(10052);xn(25,10052,b|0)|0;n=7832;u[n>>2]=1;u[n+4>>2]=0}return 10052}function Im(n,e){n=n|0;e=e|0;u[n>>2]=Fm()|0;u[n+4>>2]=xm()|0;u[n+12>>2]=e;u[n+8>>2]=Um()|0;u[n+32>>2]=2;return}function Fm(){return 11709}function xm(){return 1188}function Um(){return Ym()|0}function Hm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Wm(r);XE(r)}}else if(e|0){Zi(e);XE(e)}return}function Dm(n,e){n=n|0;e=e|0;return e&n|0}function Wm(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Ym(){var n=0;if(!(t[7824]|0)){u[2511]=Vm()|0;u[2512]=0;n=7824;u[n>>2]=1;u[n+4>>2]=0}return 10044}function Vm(){return 0}function jm(n){n=n|0;Rf(n);return}function qm(n){n=n|0;var e=0,r=0,t=0,i=0,o=0;e=v;v=v+32|0;r=e+24|0;o=e+16|0;i=e+8|0;t=e;zm(n,4827);Gm(n,4834,3)|0;Km(n,3682,47)|0;u[o>>2]=9;u[o+4>>2]=0;u[r>>2]=u[o>>2];u[r+4>>2]=u[o+4>>2];Xm(n,4841,r)|0;u[i>>2]=1;u[i+4>>2]=0;u[r>>2]=u[i>>2];u[r+4>>2]=u[i+4>>2];Jm(n,4871,r)|0;u[t>>2]=10;u[t+4>>2]=0;u[r>>2]=u[t>>2];u[r+4>>2]=u[t+4>>2];Zm(n,4891,r)|0;v=e;return}function zm(n,e){n=n|0;e=e|0;var r=0;r=jh()|0;u[n>>2]=r;qh(r,e);lM(u[n>>2]|0);return}function Gm(n,e,r){n=n|0;e=e|0;r=r|0;Ah(n,Ba(e)|0,r,0);return n|0}function Km(n,e,r){n=n|0;e=e|0;r=r|0;ah(n,Ba(e)|0,r,0);return n|0}function Xm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Hb(n,e,i);v=t;return n|0}function Jm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];bb(n,e,i);v=t;return n|0}function Zm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Qm(n,e,i);v=t;return n|0}function Qm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];$m(n,r,i,1);v=t;return}function $m(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=nb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=eb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,rb(o,t)|0,t);v=i;return}function nb(){var n=0,e=0;if(!(t[7840]|0)){cb(10100);xn(48,10100,b|0)|0;e=7840;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10100)|0)){n=10100;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));cb(10100)}return 10100}function eb(n){n=n|0;return 0}function rb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=nb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];tb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{ib(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function tb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function ib(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=ub(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;ob(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];tb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;ab(n,f);fb(f);v=l;return}}function ub(n){n=n|0;return 357913941}function ob(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function ab(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function fb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function cb(n){n=n|0;db(n);return}function lb(n){n=n|0;sb(n+24|0);return}function sb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function db(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,_b()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function _b(){return 1364}function vb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=pb(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=mb(e,i,r)|0;v=t;return r|0}function pb(n){n=n|0;return(u[(nb()|0)+24>>2]|0)+(n*12|0)|0}function mb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;i=Mc(gL[t&15](n,i)|0)|0;v=o;return i|0}function bb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];hb(n,r,i,0);v=t;return}function hb(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=yb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=wb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Mb(o,t)|0,t);v=i;return}function yb(){var n=0,e=0;if(!(t[7848]|0)){Cb(10136);xn(49,10136,b|0)|0;e=7848;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10136)|0)){n=10136;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Cb(10136)}return 10136}function wb(n){n=n|0;return 0}function Mb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=yb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];kb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{gb(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function kb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function gb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Tb(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Ab(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];kb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Sb(n,f);Eb(f);v=l;return}}function Tb(n){n=n|0;return 357913941}function Ab(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Sb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Eb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Cb(n){n=n|0;Pb(n);return}function Lb(n){n=n|0;Rb(n+24|0);return}function Rb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Pb(n){n=n|0;var e=0;e=$a()|0;rf(n,2,9,e,Bb()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Bb(){return 1372}function Ob(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=Nb(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ib(e,i,r);v=t;return}function Nb(n){n=n|0;return(u[(yb()|0)+24>>2]|0)+(n*12|0)|0}function Ib(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=de;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Fb(i,r);a=K(xb(i,r));sL[t&1](n,a);v=o;return}function Fb(n,e){n=n|0;e=+e;return}function xb(n,e){n=n|0;e=+e;return K(Ub(e))}function Ub(n){n=+n;return K(n)}function Hb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Db(n,r,i,0);v=t;return}function Db(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Wb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Yb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Vb(o,t)|0,t);v=i;return}function Wb(){var n=0,e=0;if(!(t[7856]|0)){Jb(10172);xn(50,10172,b|0)|0;e=7856;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10172)|0)){n=10172;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Jb(10172)}return 10172}function Yb(n){n=n|0;return 0}function Vb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Wb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];jb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{qb(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function jb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function qb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=zb(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Gb(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];jb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Kb(n,f);Xb(f);v=l;return}}function zb(n){n=n|0;return 357913941}function Gb(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Kb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Xb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Jb(n){n=n|0;$b(n);return}function Zb(n){n=n|0;Qb(n+24|0);return}function Qb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function $b(n){n=n|0;var e=0;e=$a()|0;rf(n,2,3,e,nh()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function nh(){return 1380}function eh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=rh(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];th(e,o,r,t);v=i;return}function rh(n){n=n|0;return(u[(Wb()|0)+24>>2]|0)+(n*12|0)|0}function th(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;Qf(o,r);o=$f(o,r)|0;ih(a,t);a=uh(a,t)|0;PL[i&15](n,o,a);v=f;return}function ih(n,e){n=n|0;e=e|0;return}function uh(n,e){n=n|0;e=e|0;return oh(e)|0}function oh(n){n=n|0;return(n|0)!=0|0}function ah(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=fh()|0;n=ch(r)|0;xa(o,e,i,n,lh(r,t)|0,t);return}function fh(){var n=0,e=0;if(!(t[7864]|0)){bh(10208);xn(51,10208,b|0)|0;e=7864;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10208)|0)){n=10208;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));bh(10208)}return 10208}function ch(n){n=n|0;return n|0}function lh(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=fh()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){sh(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{dh(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function sh(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function dh(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=_h(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;vh(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;sh(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;ph(n,i);mh(i);v=f;return}}function _h(n){n=n|0;return 536870911}function vh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function ph(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function mh(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function bh(n){n=n|0;wh(n);return}function hh(n){n=n|0;yh(n+24|0);return}function yh(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function wh(n){n=n|0;var e=0;e=$a()|0;rf(n,1,24,e,Mh()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Mh(){return 1392}function kh(n,e){n=n|0;e=e|0;Th(u[(gh(n)|0)>>2]|0,e);return}function gh(n){n=n|0;return(u[(fh()|0)+24>>2]|0)+(n<<3)|0}function Th(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;vm(t,e);e=pm(t,e)|0;vL[n&127](e);v=r;return}function Ah(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Sh()|0;n=Eh(r)|0;xa(o,e,i,n,Ch(r,t)|0,t);return}function Sh(){var n=0,e=0;if(!(t[7872]|0)){Ih(10244);xn(52,10244,b|0)|0;e=7872;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10244)|0)){n=10244;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ih(10244)}return 10244}function Eh(n){n=n|0;return n|0}function Ch(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Sh()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Lh(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{Rh(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function Lh(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function Rh(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=Ph(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Bh(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Lh(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Oh(n,i);Nh(i);v=f;return}}function Ph(n){n=n|0;return 536870911}function Bh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Oh(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Nh(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Ih(n){n=n|0;Uh(n);return}function Fh(n){n=n|0;xh(n+24|0);return}function xh(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Uh(n){n=n|0;var e=0;e=$a()|0;rf(n,1,16,e,Hh()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Hh(){return 1400}function Dh(n){n=n|0;return Yh(u[(Wh(n)|0)>>2]|0)|0}function Wh(n){n=n|0;return(u[(Sh()|0)+24>>2]|0)+(n<<3)|0}function Yh(n){n=n|0;return Vh(EL[n&7]()|0)|0}function Vh(n){n=n|0;return n|0}function jh(){var n=0;if(!(t[7880]|0)){Zh(10280);xn(25,10280,b|0)|0;n=7880;u[n>>2]=1;u[n+4>>2]=0}return 10280}function qh(n,e){n=n|0;e=e|0;u[n>>2]=zh()|0;u[n+4>>2]=Gh()|0;u[n+12>>2]=e;u[n+8>>2]=Kh()|0;u[n+32>>2]=4;return}function zh(){return 11711}function Gh(){return 1356}function Kh(){return Ym()|0}function Xh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Jh(r);XE(r)}}else if(e|0){Vi(e);XE(e)}return}function Jh(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Zh(n){n=n|0;Rf(n);return}function Qh(n){n=n|0;$h(n,4920);ny(n)|0;ey(n)|0;return}function $h(n,e){n=n|0;e=e|0;var r=0;r=qd()|0;u[n>>2]=r;Ey(r,e);lM(u[n>>2]|0);return}function ny(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,py()|0);return n|0}function ey(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,ry()|0);return n|0}function ry(){var n=0;if(!(t[7888]|0)){iy(10328);xn(53,10328,b|0)|0;n=7888;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10328)|0))iy(10328);return 10328}function ty(n,e){n=n|0;e=e|0;xa(n,0,e,0,0,0);return}function iy(n){n=n|0;ay(n);cy(n,10);return}function uy(n){n=n|0;oy(n+24|0);return}function oy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function ay(n){n=n|0;var e=0;e=$a()|0;rf(n,5,1,e,dy()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function fy(n,e,r){n=n|0;e=e|0;r=+r;ly(n,e,r);return}function cy(n,e){n=n|0;e=e|0;u[n+20>>2]=e;return}function ly(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;o=t+8|0;f=t+13|0;i=t;a=t+12|0;Qf(f,e);u[o>>2]=$f(f,e)|0;Jf(a,r);l[i>>3]=+Zf(a,r);sy(n,o,i);v=t;return}function sy(n,e,r){n=n|0;e=e|0;r=r|0;Vu(n+8|0,u[e>>2]|0,+l[r>>3]);t[n+24>>0]=1;return}function dy(){return 1404}function _y(n,e){n=n|0;e=+e;return vy(n,e)|0}function vy(n,e){n=n|0;e=+e;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+16|0;o=t+4|0;a=t+8|0;f=t;i=Dg(8)|0;r=i;c=GE(16)|0;Qf(o,n);n=$f(o,n)|0;Jf(a,e);Vu(c,n,+Zf(a,e));a=r+4|0;u[a>>2]=c;n=GE(8)|0;a=u[a>>2]|0;u[f>>2]=0;u[o>>2]=u[f>>2];Kd(n,a,o);u[i>>2]=n;v=t;return r|0}function py(){var n=0;if(!(t[7896]|0)){my(10364);xn(54,10364,b|0)|0;n=7896;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10364)|0))my(10364);return 10364}function my(n){n=n|0;yy(n);cy(n,55);return}function by(n){n=n|0;hy(n+24|0);return}function hy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function yy(n){n=n|0;var e=0;e=$a()|0;rf(n,5,4,e,Ty()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function wy(n){n=n|0;My(n);return}function My(n){n=n|0;ky(n);return}function ky(n){n=n|0;gy(n+8|0);t[n+24>>0]=1;return}function gy(n){n=n|0;u[n>>2]=0;l[n+8>>3]=0.0;return}function Ty(){return 1424}function Ay(){return Sy()|0}function Sy(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;t=GE(16)|0;gy(t);o=n+4|0;u[o>>2]=t;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];Kd(t,o,i);u[r>>2]=t;v=e;return n|0}function Ey(n,e){n=n|0;e=e|0;u[n>>2]=Cy()|0;u[n+4>>2]=Ly()|0;u[n+12>>2]=e;u[n+8>>2]=Ry()|0;u[n+32>>2]=5;return}function Cy(){return 11710}function Ly(){return 1416}function Ry(){return Oy()|0}function Py(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){By(r);XE(r)}}else if(e|0)XE(e);return}function By(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Oy(){var n=0;if(!(t[7904]|0)){u[2600]=Ny()|0;u[2601]=0;n=7904;u[n>>2]=1;u[n+4>>2]=0}return 10400}function Ny(){return u[357]|0}function Iy(n){n=n|0;Fy(n,4926);xy(n)|0;return}function Fy(n,e){n=n|0;e=e|0;var r=0;r=af()|0;u[n>>2]=r;Xy(r,e);lM(u[n>>2]|0);return}function xy(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Uy()|0);return n|0}function Uy(){var n=0;if(!(t[7912]|0)){Hy(10412);xn(56,10412,b|0)|0;n=7912;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10412)|0))Hy(10412);return 10412}function Hy(n){n=n|0;Yy(n);cy(n,57);return}function Dy(n){n=n|0;Wy(n+24|0);return}function Wy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Yy(n){n=n|0;var e=0;e=$a()|0;rf(n,5,5,e,zy()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Vy(n){n=n|0;jy(n);return}function jy(n){n=n|0;qy(n);return}function qy(n){n=n|0;var e=0,r=0;e=n+8|0;r=e+48|0;do{u[e>>2]=0;e=e+4|0}while((e|0)<(r|0));t[n+56>>0]=1;return}function zy(){return 1432}function Gy(){return Ky()|0}function Ky(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0,f=0;a=v;v=v+16|0;n=a+4|0;e=a;r=Dg(8)|0;t=r;i=GE(48)|0;o=i;f=o+48|0;do{u[o>>2]=0;o=o+4|0}while((o|0)<(f|0));o=t+4|0;u[o>>2]=i;f=GE(8)|0;o=u[o>>2]|0;u[e>>2]=0;u[n>>2]=u[e>>2];vf(f,o,n);u[r>>2]=f;v=a;return t|0}function Xy(n,e){n=n|0;e=e|0;u[n>>2]=Jy()|0;u[n+4>>2]=Zy()|0;u[n+12>>2]=e;u[n+8>>2]=Qy()|0;u[n+32>>2]=6;return}function Jy(){return 11704}function Zy(){return 1436}function Qy(){return Oy()|0}function $y(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){nw(r);XE(r)}}else if(e|0)XE(e);return}function nw(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function ew(n){n=n|0;rw(n,4933);tw(n)|0;iw(n)|0;return}function rw(n,e){n=n|0;e=e|0;var r=0;r=Ow()|0;u[n>>2]=r;Nw(r,e);lM(u[n>>2]|0);return}function tw(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Mw()|0);return n|0}function iw(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,uw()|0);return n|0}function uw(){var n=0;if(!(t[7920]|0)){ow(10452);xn(58,10452,b|0)|0;n=7920;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10452)|0))ow(10452);return 10452}function ow(n){n=n|0;cw(n);cy(n,1);return}function aw(n){n=n|0;fw(n+24|0);return}function fw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function cw(n){n=n|0;var e=0;e=$a()|0;rf(n,5,1,e,vw()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function lw(n,e,r){n=n|0;e=+e;r=+r;sw(n,e,r);return}function sw(n,e,r){n=n|0;e=+e;r=+r;var t=0,i=0,u=0,o=0,a=0;t=v;v=v+32|0;u=t+8|0;a=t+17|0;i=t;o=t+16|0;Jf(a,e);l[u>>3]=+Zf(a,e);Jf(o,r);l[i>>3]=+Zf(o,r);dw(n,u,i);v=t;return}function dw(n,e,r){n=n|0;e=e|0;r=r|0;_w(n+8|0,+l[e>>3],+l[r>>3]);t[n+24>>0]=1;return}function _w(n,e,r){n=n|0;e=+e;r=+r;l[n>>3]=e;l[n+8>>3]=r;return}function vw(){return 1472}function pw(n,e){n=+n;e=+e;return mw(n,e)|0}function mw(n,e){n=+n;e=+e;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+16|0;a=t+4|0;f=t+8|0;c=t;i=Dg(8)|0;r=i;o=GE(16)|0;Jf(a,n);n=+Zf(a,n);Jf(f,e);_w(o,n,+Zf(f,e));f=r+4|0;u[f>>2]=o;o=GE(8)|0;f=u[f>>2]|0;u[c>>2]=0;u[a>>2]=u[c>>2];bw(o,f,a);u[i>>2]=o;v=t;return r|0}function bw(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1452;u[r+12>>2]=e;u[n+4>>2]=r;return}function hw(n){n=n|0;WE(n);XE(n);return}function yw(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function ww(n){n=n|0;XE(n);return}function Mw(){var n=0;if(!(t[7928]|0)){kw(10488);xn(59,10488,b|0)|0;n=7928;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10488)|0))kw(10488);return 10488}function kw(n){n=n|0;Aw(n);cy(n,60);return}function gw(n){n=n|0;Tw(n+24|0);return}function Tw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Aw(n){n=n|0;var e=0;e=$a()|0;rf(n,5,6,e,Rw()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Sw(n){n=n|0;Ew(n);return}function Ew(n){n=n|0;Cw(n);return}function Cw(n){n=n|0;Lw(n+8|0);t[n+24>>0]=1;return}function Lw(n){n=n|0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;u[n+12>>2]=0;return}function Rw(){return 1492}function Pw(){return Bw()|0}function Bw(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;t=GE(16)|0;Lw(t);o=n+4|0;u[o>>2]=t;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];bw(t,o,i);u[r>>2]=t;v=e;return n|0}function Ow(){var n=0;if(!(t[7936]|0)){Dw(10524);xn(25,10524,b|0)|0;n=7936;u[n>>2]=1;u[n+4>>2]=0}return 10524}function Nw(n,e){n=n|0;e=e|0;u[n>>2]=Iw()|0;u[n+4>>2]=Fw()|0;u[n+12>>2]=e;u[n+8>>2]=xw()|0;u[n+32>>2]=7;return}function Iw(){return 11700}function Fw(){return 1484}function xw(){return Oy()|0}function Uw(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Hw(r);XE(r)}}else if(e|0)XE(e);return}function Hw(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Dw(n){n=n|0;Rf(n);return}function Ww(n,e,r){n=n|0;e=e|0;r=r|0;n=Ba(e)|0;e=Yw(r)|0;r=Vw(r,0)|0;CM(n,e,r,jw()|0,0);return}function Yw(n){n=n|0;return n|0}function Vw(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=jw()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Qw(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{$w(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function jw(){var n=0,e=0;if(!(t[7944]|0)){qw(10568);xn(61,10568,b|0)|0;e=7944;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10568)|0)){n=10568;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));qw(10568)}return 10568}function qw(n){n=n|0;Kw(n);return}function zw(n){n=n|0;Gw(n+24|0);return}function Gw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Kw(n){n=n|0;var e=0;e=$a()|0;rf(n,1,17,e,Xl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Xw(n){n=n|0;return Zw(u[(Jw(n)|0)>>2]|0)|0}function Jw(n){n=n|0;return(u[(jw()|0)+24>>2]|0)+(n<<3)|0}function Zw(n){n=n|0;return $l(EL[n&7]()|0)|0}function Qw(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function $w(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=nM(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;eM(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Qw(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;rM(n,i);tM(i);v=f;return}}function nM(n){n=n|0;return 536870911}function eM(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function rM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function tM(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function iM(){uM();return}function uM(){oM(10604);return}function oM(n){n=n|0;aM(n,4955);return}function aM(n,e){n=n|0;e=e|0;var r=0;r=fM()|0;u[n>>2]=r;cM(r,e);lM(u[n>>2]|0);return}function fM(){var n=0;if(!(t[7952]|0)){wM(10612);xn(25,10612,b|0)|0;n=7952;u[n>>2]=1;u[n+4>>2]=0}return 10612}function cM(n,e){n=n|0;e=e|0;u[n>>2]=pM()|0;u[n+4>>2]=mM()|0;u[n+12>>2]=e;u[n+8>>2]=bM()|0;u[n+32>>2]=8;return}function lM(n){n=n|0;var e=0,r=0;e=v;v=v+16|0;r=e;sM()|0;u[r>>2]=n;dM(10608,r);v=e;return}function sM(){if(!(t[11714]|0)){u[2652]=0;xn(62,10608,b|0)|0;t[11714]=1}return 10608}function dM(n,e){n=n|0;e=e|0;var r=0;r=GE(8)|0;u[r+4>>2]=u[e>>2];u[r>>2]=u[n>>2];u[n>>2]=r;return}function _M(n){n=n|0;vM(n);return}function vM(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function pM(){return 11715}function mM(){return 1496}function bM(){return Ym()|0}function hM(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){yM(r);XE(r)}}else if(e|0)XE(e);return}function yM(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function wM(n){n=n|0;Rf(n);return}function MM(n,e){n=n|0;e=e|0;var r=0,t=0;sM()|0;r=u[2652]|0;n:do{if(r|0){while(1){t=u[r+4>>2]|0;if(t|0?(tE(kM(t)|0,n)|0)==0:0)break;r=u[r>>2]|0;if(!r)break n}gM(t,e)}}while(0);return}function kM(n){n=n|0;return u[n+12>>2]|0}function gM(n,e){n=n|0;e=e|0;var r=0;n=n+36|0;r=u[n>>2]|0;if(r|0){Qi(r);XE(r)}r=GE(4)|0;ho(r,e);u[n>>2]=r;return}function TM(){if(!(t[11716]|0)){u[2664]=0;xn(63,10656,b|0)|0;t[11716]=1}return 10656}function AM(){var n=0;if(!(t[11717]|0)){SM();u[2665]=1504;t[11717]=1;n=1504}else n=u[2665]|0;return n|0}function SM(){if(!(t[11740]|0)){t[11718]=Wa(Wa(8,0)|0,0)|0;t[11719]=Wa(Wa(0,0)|0,0)|0;t[11720]=Wa(Wa(0,16)|0,0)|0;t[11721]=Wa(Wa(8,0)|0,0)|0;t[11722]=Wa(Wa(0,0)|0,0)|0;t[11723]=Wa(Wa(8,0)|0,0)|0;t[11724]=Wa(Wa(0,0)|0,0)|0;t[11725]=Wa(Wa(8,0)|0,0)|0;t[11726]=Wa(Wa(0,0)|0,0)|0;t[11727]=Wa(Wa(8,0)|0,0)|0;t[11728]=Wa(Wa(0,0)|0,0)|0;t[11729]=Wa(Wa(0,0)|0,32)|0;t[11730]=Wa(Wa(0,0)|0,32)|0;t[11740]=1}return}function EM(){return 1572}function CM(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0;o=v;v=v+32|0;s=o+16|0;l=o+12|0;c=o+8|0;f=o+4|0;a=o;u[s>>2]=n;u[l>>2]=e;u[c>>2]=r;u[f>>2]=t;u[a>>2]=i;TM()|0;LM(10656,s,l,c,f,a);v=o;return}function LM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0;a=GE(24)|0;Da(a+4|0,u[e>>2]|0,u[r>>2]|0,u[t>>2]|0,u[i>>2]|0,u[o>>2]|0);u[a>>2]=u[n>>2];u[n>>2]=a;return}function RM(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0;w=v;v=v+32|0;m=w+20|0;b=w+8|0;h=w+4|0;y=w;e=u[e>>2]|0;if(e|0){p=m+4|0;c=m+8|0;l=b+4|0;s=b+8|0;d=b+8|0;_=m+8|0;do{a=e+4|0;f=PM(a)|0;if(f|0){i=BM(f)|0;u[m>>2]=0;u[p>>2]=0;u[c>>2]=0;t=(OM(f)|0)+1|0;NM(m,t);if(t|0)while(1){t=t+-1|0;bS(b,u[i>>2]|0);o=u[p>>2]|0;if(o>>>0<(u[_>>2]|0)>>>0){u[o>>2]=u[b>>2];u[p>>2]=(u[p>>2]|0)+4}else IM(m,b);if(!t)break;else i=i+4|0}t=FM(f)|0;u[b>>2]=0;u[l>>2]=0;u[s>>2]=0;n:do{if(u[t>>2]|0){i=0;o=0;while(1){if((i|0)==(o|0))xM(b,t);else{u[i>>2]=u[t>>2];u[l>>2]=(u[l>>2]|0)+4}t=t+4|0;if(!(u[t>>2]|0))break n;i=u[l>>2]|0;o=u[d>>2]|0}}}while(0);u[h>>2]=UM(a)|0;u[y>>2]=Ja(f)|0;HM(r,n,h,y,m,b);DM(b);WM(m)}e=u[e>>2]|0}while((e|0)!=0)}v=w;return}function PM(n){n=n|0;return u[n+12>>2]|0}function BM(n){n=n|0;return u[n+12>>2]|0}function OM(n){n=n|0;return u[n+16>>2]|0}function NM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i;t=u[n>>2]|0;if((u[n+8>>2]|0)-t>>2>>>0<e>>>0){wk(r,e,(u[n+4>>2]|0)-t>>2,n+8|0);Mk(n,r);kk(r)}v=i;return}function IM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;a=v;v=v+32|0;r=a;t=n+4|0;i=((u[t>>2]|0)-(u[n>>2]|0)>>2)+1|0;o=mk(n)|0;if(o>>>0<i>>>0)DE(n);else{f=u[n>>2]|0;l=(u[n+8>>2]|0)-f|0;c=l>>1;wk(r,l>>2>>>0<o>>>1>>>0?c>>>0<i>>>0?i:c:o,(u[t>>2]|0)-f>>2,n+8|0);o=r+8|0;u[u[o>>2]>>2]=u[e>>2];u[o>>2]=(u[o>>2]|0)+4;Mk(n,r);kk(r);v=a;return}}function FM(n){n=n|0;return u[n+8>>2]|0}function xM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;a=v;v=v+32|0;r=a;t=n+4|0;i=((u[t>>2]|0)-(u[n>>2]|0)>>2)+1|0;o=_k(n)|0;if(o>>>0<i>>>0)DE(n);else{f=u[n>>2]|0;l=(u[n+8>>2]|0)-f|0;c=l>>1;bk(r,l>>2>>>0<o>>>1>>>0?c>>>0<i>>>0?i:c:o,(u[t>>2]|0)-f>>2,n+8|0);o=r+8|0;u[u[o>>2]>>2]=u[e>>2];u[o>>2]=(u[o>>2]|0)+4;hk(n,r);yk(r);v=a;return}}function UM(n){n=n|0;return u[n>>2]|0}function HM(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;YM(n,e,r,t,i,u);return}function DM(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function WM(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function YM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0;a=v;v=v+48|0;s=a+40|0;f=a+32|0;d=a+24|0;c=a+12|0;l=a;gS(f);n=ko(n)|0;u[d>>2]=u[e>>2];r=u[r>>2]|0;t=u[t>>2]|0;VM(c,i);jM(l,o);u[s>>2]=u[d>>2];qM(n,s,r,t,c,l);DM(l);WM(c);AS(f);v=a;return}function VM(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){vk(n,t);pk(n,u[e>>2]|0,u[r>>2]|0,t)}return}function jM(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){sk(n,t);dk(n,u[e>>2]|0,u[r>>2]|0,t)}return}function qM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0;a=v;v=v+32|0;s=a+28|0;d=a+24|0;f=a+12|0;c=a;l=Ao(zM()|0)|0;u[d>>2]=u[e>>2];u[s>>2]=u[d>>2];e=GM(s)|0;r=KM(r)|0;t=XM(t)|0;u[f>>2]=u[i>>2];s=i+4|0;u[f+4>>2]=u[s>>2];d=i+8|0;u[f+8>>2]=u[d>>2];u[d>>2]=0;u[s>>2]=0;u[i>>2]=0;i=JM(f)|0;u[c>>2]=u[o>>2];s=o+4|0;u[c+4>>2]=u[s>>2];d=o+8|0;u[c+8>>2]=u[d>>2];u[d>>2]=0;u[s>>2]=0;u[o>>2]=0;Pn(0,l|0,n|0,e|0,r|0,t|0,i|0,ZM(c)|0)|0;DM(c);WM(f);v=a;return}function zM(){var n=0;if(!(t[7968]|0)){ck(10708);n=7968;u[n>>2]=1;u[n+4>>2]=0}return 10708}function GM(n){n=n|0;return ek(n)|0}function KM(n){n=n|0;return $M(n)|0}function XM(n){n=n|0;return $l(n)|0}function JM(n){n=n|0;return nk(n)|0}function ZM(n){n=n|0;return QM(n)|0}function QM(n){n=n|0;var e=0,r=0,t=0;t=(u[n+4>>2]|0)-(u[n>>2]|0)|0;r=t>>2;t=Dg(t+4|0)|0;u[t>>2]=r;if(r|0){e=0;do{u[t+4+(e<<2)>>2]=$M(u[(u[n>>2]|0)+(e<<2)>>2]|0)|0;e=e+1|0}while((e|0)!=(r|0))}return t|0}function $M(n){n=n|0;return n|0}function nk(n){n=n|0;var e=0,r=0,t=0;t=(u[n+4>>2]|0)-(u[n>>2]|0)|0;r=t>>2;t=Dg(t+4|0)|0;u[t>>2]=r;if(r|0){e=0;do{u[t+4+(e<<2)>>2]=ek((u[n>>2]|0)+(e<<2)|0)|0;e=e+1|0}while((e|0)!=(r|0))}return t|0}function ek(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(rk()|0)|0;if(!t)n=tk(n)|0;else{cf(e,t);lf(r,e);wS(n,r);n=df(e)|0}v=i;return n|0}function rk(){var n=0;if(!(t[7960]|0)){fk(10664);xn(25,10664,b|0)|0;n=7960;u[n>>2]=1;u[n+4>>2]=0}return 10664}function tk(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(4)|0;u[f>>2]=u[n>>2];o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];ik(n,o,i);u[t>>2]=n;v=r;return e|0}function ik(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1656;u[r+12>>2]=e;u[n+4>>2]=r;return}function uk(n){n=n|0;WE(n);XE(n);return}function ok(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function ak(n){n=n|0;XE(n);return}function fk(n){n=n|0;Rf(n);return}function ck(n){n=n|0;xo(n,lk()|0,5);return}function lk(){return 1676}function sk(n,e){n=n|0;e=e|0;var r=0;if((_k(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function dk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function _k(n){n=n|0;return 1073741823}function vk(n,e){n=n|0;e=e|0;var r=0;if((mk(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function pk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function mk(n){n=n|0;return 1073741823}function bk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function hk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function yk(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function wk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function Mk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function kk(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function gk(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0;b=v;v=v+32|0;s=b+20|0;d=b+12|0;l=b+16|0;_=b+4|0;p=b;m=b+8|0;f=AM()|0;o=u[f>>2]|0;a=u[o>>2]|0;if(a|0){c=u[f+8>>2]|0;f=u[f+4>>2]|0;while(1){bS(s,a);Tk(n,s,f,c);o=o+4|0;a=u[o>>2]|0;if(!a)break;else{c=c+1|0;f=f+1|0}}}o=EM()|0;a=u[o>>2]|0;if(a|0)do{bS(s,a);u[d>>2]=u[o+4>>2];Ak(e,s,d);o=o+8|0;a=u[o>>2]|0}while((a|0)!=0);o=u[(sM()|0)>>2]|0;if(o|0)do{e=u[o+4>>2]|0;bS(s,u[(Sk(e)|0)>>2]|0);u[d>>2]=kM(e)|0;Ek(r,s,d);o=u[o>>2]|0}while((o|0)!=0);bS(l,0);o=TM()|0;u[s>>2]=u[l>>2];RM(s,o,i);o=u[(sM()|0)>>2]|0;if(o|0){n=s+4|0;e=s+8|0;r=s+8|0;do{c=u[o+4>>2]|0;bS(d,u[(Sk(c)|0)>>2]|0);Lk(_,Ck(c)|0);a=u[_>>2]|0;if(a|0){u[s>>2]=0;u[n>>2]=0;u[e>>2]=0;do{bS(p,u[(Sk(u[a+4>>2]|0)|0)>>2]|0);f=u[n>>2]|0;if(f>>>0<(u[r>>2]|0)>>>0){u[f>>2]=u[p>>2];u[n>>2]=(u[n>>2]|0)+4}else IM(s,p);a=u[a>>2]|0}while((a|0)!=0);Rk(t,d,s);WM(s)}u[m>>2]=u[d>>2];l=Pk(c)|0;u[s>>2]=u[m>>2];RM(s,l,i);Ef(_);o=u[o>>2]|0}while((o|0)!=0)}v=b;return}function Tk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;qk(n,e,r,t);return}function Ak(n,e,r){n=n|0;e=e|0;r=r|0;jk(n,e,r);return}function Sk(n){n=n|0;return n|0}function Ek(n,e,r){n=n|0;e=e|0;r=r|0;Hk(n,e,r);return}function Ck(n){n=n|0;return n+16|0}function Lk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;o=v;v=v+16|0;i=o+8|0;r=o;u[n>>2]=0;t=u[e>>2]|0;u[i>>2]=t;u[r>>2]=n;r=xk(r)|0;if(t|0){t=GE(12)|0;a=(Uk(i)|0)+4|0;n=u[a+4>>2]|0;e=t+4|0;u[e>>2]=u[a>>2];u[e+4>>2]=n;e=u[u[i>>2]>>2]|0;u[i>>2]=e;if(!e)n=t;else{e=t;while(1){n=GE(12)|0;c=(Uk(i)|0)+4|0;f=u[c+4>>2]|0;a=n+4|0;u[a>>2]=u[c>>2];u[a+4>>2]=f;u[e>>2]=n;a=u[u[i>>2]>>2]|0;u[i>>2]=a;if(!a)break;else e=n}}u[n>>2]=u[r>>2];u[r>>2]=t}v=o;return}function Rk(n,e,r){n=n|0;e=e|0;r=r|0;Bk(n,e,r);return}function Pk(n){n=n|0;return n+24|0}function Bk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+32|0;a=t+24|0;i=t+16|0;f=t+12|0;o=t;gS(i);n=ko(n)|0;u[f>>2]=u[e>>2];VM(o,r);u[a>>2]=u[f>>2];Ok(n,a,o);WM(o);AS(i);v=t;return}function Ok(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+32|0;a=t+16|0;f=t+12|0;i=t;o=Ao(Nk()|0)|0;u[f>>2]=u[e>>2];u[a>>2]=u[f>>2];e=GM(a)|0;u[i>>2]=u[r>>2];a=r+4|0;u[i+4>>2]=u[a>>2];f=r+8|0;u[i+8>>2]=u[f>>2];u[f>>2]=0;u[a>>2]=0;u[r>>2]=0;En(0,o|0,n|0,e|0,JM(i)|0)|0;WM(i);v=t;return}function Nk(){var n=0;if(!(t[7976]|0)){Ik(10720);n=7976;u[n>>2]=1;u[n+4>>2]=0}return 10720}function Ik(n){n=n|0;xo(n,Fk()|0,2);return}function Fk(){return 1732}function xk(n){n=n|0;return u[n>>2]|0}function Uk(n){n=n|0;return u[n>>2]|0}function Hk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+32|0;o=t+16|0;i=t+8|0;a=t;gS(i);n=ko(n)|0;u[a>>2]=u[e>>2];r=u[r>>2]|0;u[o>>2]=u[a>>2];Dk(n,o,r);AS(i);v=t;return}function Dk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;o=t+4|0;a=t;i=Ao(Wk()|0)|0;u[a>>2]=u[e>>2];u[o>>2]=u[a>>2];e=GM(o)|0;En(0,i|0,n|0,e|0,KM(r)|0)|0;v=t;return}function Wk(){var n=0;if(!(t[7984]|0)){Yk(10732);n=7984;u[n>>2]=1;u[n+4>>2]=0}return 10732}function Yk(n){n=n|0;xo(n,Vk()|0,2);return}function Vk(){return 1744}function jk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+32|0;o=t+16|0;i=t+8|0;a=t;gS(i);n=ko(n)|0;u[a>>2]=u[e>>2];r=u[r>>2]|0;u[o>>2]=u[a>>2];Dk(n,o,r);AS(i);v=t;return}function qk(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+32|0;f=o+16|0;a=o+8|0;c=o;gS(a);n=ko(n)|0;u[c>>2]=u[e>>2];r=t[r>>0]|0;i=t[i>>0]|0;u[f>>2]=u[c>>2];zk(n,f,r,i);AS(a);v=o;return}function zk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;a=i+4|0;f=i;o=Ao(Gk()|0)|0;u[f>>2]=u[e>>2];u[a>>2]=u[f>>2];e=GM(a)|0;r=Kk(r)|0;te(0,o|0,n|0,e|0,r|0,Kk(t)|0)|0;v=i;return}function Gk(){var n=0;if(!(t[7992]|0)){Jk(10744);n=7992;u[n>>2]=1;u[n+4>>2]=0}return 10744}function Kk(n){n=n|0;return Xk(n)|0}function Xk(n){n=n|0;return n&255|0}function Jk(n){n=n|0;xo(n,Zk()|0,3);return}function Zk(){return 1756}function Qk(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;p=v;v=v+32|0;c=p+8|0;l=p+4|0;s=p+20|0;d=p;qc(n,0);i=yS(e)|0;u[c>>2]=0;_=c+4|0;u[_>>2]=0;u[c+8>>2]=0;switch(i<<24>>24){case 0:{t[s>>0]=0;$k(l,r,s);ng(n,l)|0;$i(l);break}case 8:{_=hS(e)|0;t[s>>0]=8;bS(d,u[_+4>>2]|0);eg(l,r,s,d,_+8|0);ng(n,l)|0;$i(l);break}case 9:{a=hS(e)|0;e=u[a+4>>2]|0;if(e|0){f=c+8|0;o=a+12|0;while(1){e=e+-1|0;bS(l,u[o>>2]|0);i=u[_>>2]|0;if(i>>>0<(u[f>>2]|0)>>>0){u[i>>2]=u[l>>2];u[_>>2]=(u[_>>2]|0)+4}else IM(c,l);if(!e)break;else o=o+4|0}}t[s>>0]=9;bS(d,u[a+8>>2]|0);rg(l,r,s,d,c);ng(n,l)|0;$i(l);break}default:{_=hS(e)|0;t[s>>0]=i;bS(d,u[_+4>>2]|0);tg(l,r,s,d);ng(n,l)|0;$i(l)}}WM(c);v=p;return}function $k(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,u=0;i=v;v=v+16|0;u=i;gS(u);e=ko(e)|0;bg(n,e,t[r>>0]|0);AS(u);v=i;return}function ng(n,e){n=n|0;e=e|0;var r=0;r=u[n>>2]|0;if(r|0)ie(r|0);u[n>>2]=u[e>>2];u[e>>2]=0;return n|0}function eg(n,e,r,i,o){n=n|0;e=e|0;r=r|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0;a=v;v=v+32|0;c=a+16|0;f=a+8|0;l=a;gS(f);e=ko(e)|0;r=t[r>>0]|0;u[l>>2]=u[i>>2];o=u[o>>2]|0;u[c>>2]=u[l>>2];_g(n,e,r,c,o);AS(f);v=a;return}function rg(n,e,r,i,o){n=n|0;e=e|0;r=r|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0;a=v;v=v+32|0;l=a+24|0;f=a+16|0;s=a+12|0;c=a;gS(f);e=ko(e)|0;r=t[r>>0]|0;u[s>>2]=u[i>>2];VM(c,o);u[l>>2]=u[s>>2];cg(n,e,r,l,c);WM(c);AS(f);v=a;return}function tg(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+32|0;f=o+16|0;a=o+8|0;c=o;gS(a);e=ko(e)|0;r=t[r>>0]|0;u[c>>2]=u[i>>2];u[f>>2]=u[c>>2];ig(n,e,r,f);AS(a);v=o;return}function ig(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+4|0;f=i;a=Ao(ug()|0)|0;r=Kk(r)|0;u[f>>2]=u[t>>2];u[o>>2]=u[f>>2];og(n,En(0,a|0,e|0,r|0,GM(o)|0)|0);v=i;return}function ug(){var n=0;if(!(t[8e3]|0)){ag(10756);n=8e3;u[n>>2]=1;u[n+4>>2]=0}return 10756}function og(n,e){n=n|0;e=e|0;qc(n,e);return}function ag(n){n=n|0;xo(n,fg()|0,2);return}function fg(){return 1772}function cg(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0;o=v;v=v+32|0;c=o+16|0;l=o+12|0;a=o;f=Ao(lg()|0)|0;r=Kk(r)|0;u[l>>2]=u[t>>2];u[c>>2]=u[l>>2];t=GM(c)|0;u[a>>2]=u[i>>2];c=i+4|0;u[a+4>>2]=u[c>>2];l=i+8|0;u[a+8>>2]=u[l>>2];u[l>>2]=0;u[c>>2]=0;u[i>>2]=0;og(n,te(0,f|0,e|0,r|0,t|0,JM(a)|0)|0);WM(a);v=o;return}function lg(){var n=0;if(!(t[8008]|0)){sg(10768);n=8008;u[n>>2]=1;u[n+4>>2]=0}return 10768}function sg(n){n=n|0;xo(n,dg()|0,3);return}function dg(){return 1784}function _g(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+16|0;f=o+4|0;c=o;a=Ao(vg()|0)|0;r=Kk(r)|0;u[c>>2]=u[t>>2];u[f>>2]=u[c>>2];t=GM(f)|0;og(n,te(0,a|0,e|0,r|0,t|0,XM(i)|0)|0);v=o;return}function vg(){var n=0;if(!(t[8016]|0)){pg(10780);n=8016;u[n>>2]=1;u[n+4>>2]=0}return 10780}function pg(n){n=n|0;xo(n,mg()|0,3);return}function mg(){return 1800}function bg(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=Ao(hg()|0)|0;og(n,ue(0,t|0,e|0,Kk(r)|0)|0);return}function hg(){var n=0;if(!(t[8024]|0)){yg(10792);n=8024;u[n>>2]=1;u[n+4>>2]=0}return 10792}function yg(n){n=n|0;xo(n,wg()|0,1);return}function wg(){return 1816}function Mg(){kg();gg();Tg();return}function kg(){u[2702]=KE(65536)|0;return}function gg(){Gg(10856);return}function Tg(){Ag(10816);return}function Ag(n){n=n|0;Sg(n,5044);Eg(n)|0;return}function Sg(n,e){n=n|0;e=e|0;var r=0;r=rk()|0;u[n>>2]=r;Wg(r,e);lM(u[n>>2]|0);return}function Eg(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Cg()|0);return n|0}function Cg(){var n=0;if(!(t[8032]|0)){Lg(10820);xn(64,10820,b|0)|0;n=8032;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10820)|0))Lg(10820);return 10820}function Lg(n){n=n|0;Bg(n);cy(n,25);return}function Rg(n){n=n|0;Pg(n+24|0);return}function Pg(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Bg(n){n=n|0;var e=0;e=$a()|0;rf(n,5,18,e,xg()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Og(n,e){n=n|0;e=e|0;Ng(n,e);return}function Ng(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;r=v;v=v+16|0;t=r;i=r+4|0;sl(i,e);u[t>>2]=dl(i,e)|0;Ig(n,t);v=r;return}function Ig(n,e){n=n|0;e=e|0;Fg(n+4|0,u[e>>2]|0);t[n+8>>0]=1;return}function Fg(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function xg(){return 1824}function Ug(n){n=n|0;return Hg(n)|0}function Hg(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(4)|0;sl(i,n);Fg(f,dl(i,n)|0);o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];ik(n,o,i);u[t>>2]=n;v=r;return e|0}function Dg(n){n=n|0;var e=0,r=0;n=n+7&-8;if(n>>>0<=32768?(e=u[2701]|0,n>>>0<=(65536-e|0)>>>0):0){r=(u[2702]|0)+e|0;u[2701]=e+n;n=r}else{n=KE(n+8|0)|0;u[n>>2]=u[2703];u[2703]=n;n=n+8|0}return n|0}function Wg(n,e){n=n|0;e=e|0;u[n>>2]=Yg()|0;u[n+4>>2]=Vg()|0;u[n+12>>2]=e;u[n+8>>2]=jg()|0;u[n+32>>2]=9;return}function Yg(){return 11744}function Vg(){return 1832}function jg(){return Oy()|0}function qg(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){zg(r);XE(r)}}else if(e|0)XE(e);return}function zg(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Gg(n){n=n|0;Kg(n,5052);Xg(n)|0;Jg(n,5058,26)|0;Zg(n,5069,1)|0;Qg(n,5077,10)|0;$g(n,5087,19)|0;eT(n,5094,27)|0;return}function Kg(n,e){n=n|0;e=e|0;var r=0;r=cS()|0;u[n>>2]=r;lS(r,e);lM(u[n>>2]|0);return}function Xg(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,KA()|0);return n|0}function Jg(n,e,r){n=n|0;e=e|0;r=r|0;EA(n,Ba(e)|0,r,0);return n|0}function Zg(n,e,r){n=n|0;e=e|0;r=r|0;cA(n,Ba(e)|0,r,0);return n|0}function Qg(n,e,r){n=n|0;e=e|0;r=r|0;UT(n,Ba(e)|0,r,0);return n|0}function $g(n,e,r){n=n|0;e=e|0;r=r|0;wT(n,Ba(e)|0,r,0);return n|0}function nT(n,e){n=n|0;e=e|0;var r=0,t=0;n:while(1){r=u[2703]|0;while(1){if((r|0)==(e|0))break n;t=u[r>>2]|0;u[2703]=t;if(!r)r=t;else break}XE(r)}u[2701]=n;return}function eT(n,e,r){n=n|0;e=e|0;r=r|0;rT(n,Ba(e)|0,r,0);return n|0}function rT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=tT()|0;n=iT(r)|0;xa(o,e,i,n,uT(r,t)|0,t);return}function tT(){var n=0,e=0;if(!(t[8040]|0)){dT(10860);xn(65,10860,b|0)|0;e=8040;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10860)|0)){n=10860;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));dT(10860)}return 10860}function iT(n){n=n|0;return n|0}function uT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=tT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){oT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{aT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function oT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function aT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=fT(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;cT(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;oT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;lT(n,i);sT(i);v=f;return}}function fT(n){n=n|0;return 536870911}function cT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function lT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function sT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function dT(n){n=n|0;pT(n);return}function _T(n){n=n|0;vT(n+24|0);return}function vT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function pT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,11,e,mT()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function mT(){return 1840}function bT(n,e,r){n=n|0;e=e|0;r=r|0;yT(u[(hT(n)|0)>>2]|0,e,r);return}function hT(n){n=n|0;return(u[(tT()|0)+24>>2]|0)+(n<<3)|0}function yT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,u=0;t=v;v=v+16|0;u=t+1|0;i=t;sl(u,e);e=dl(u,e)|0;sl(i,r);r=dl(i,r)|0;pL[n&31](e,r);v=t;return}function wT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=MT()|0;n=kT(r)|0;xa(o,e,i,n,gT(r,t)|0,t);return}function MT(){var n=0,e=0;if(!(t[8048]|0)){RT(10896);xn(66,10896,b|0)|0;e=8048;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10896)|0)){n=10896;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));RT(10896)}return 10896}function kT(n){n=n|0;return n|0}function gT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=MT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){TT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{AT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function TT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function AT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=ST(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;ET(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;TT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;CT(n,i);LT(i);v=f;return}}function ST(n){n=n|0;return 536870911}function ET(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function CT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function LT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function RT(n){n=n|0;OT(n);return}function PT(n){n=n|0;BT(n+24|0);return}function BT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function OT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,11,e,NT()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function NT(){return 1852}function IT(n,e){n=n|0;e=e|0;return xT(u[(FT(n)|0)>>2]|0,e)|0}function FT(n){n=n|0;return(u[(MT()|0)+24>>2]|0)+(n<<3)|0}function xT(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;sl(t,e);e=dl(t,e)|0;e=$l(mL[n&31](e)|0)|0;v=r;return e|0}function UT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=HT()|0;n=DT(r)|0;xa(o,e,i,n,WT(r,t)|0,t);return}function HT(){var n=0,e=0;if(!(t[8056]|0)){KT(10932);xn(67,10932,b|0)|0;e=8056;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10932)|0)){n=10932;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));KT(10932)}return 10932}function DT(n){n=n|0;return n|0}function WT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=HT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){YT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{VT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function YT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function VT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=jT(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;qT(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;YT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;zT(n,i);GT(i);v=f;return}}function jT(n){n=n|0;return 536870911}function qT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function zT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function GT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function KT(n){n=n|0;ZT(n);return}function XT(n){n=n|0;JT(n+24|0);return}function JT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function ZT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,7,e,QT()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function QT(){return 1860}function $T(n,e,r){n=n|0;e=e|0;r=r|0;return eA(u[(nA(n)|0)>>2]|0,e,r)|0}function nA(n){n=n|0;return(u[(HT()|0)+24>>2]|0)+(n<<3)|0}function eA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+32|0;a=t+12|0;o=t+8|0;f=t;c=t+16|0;i=t+4|0;rA(c,e);tA(f,c,e);Wc(i,r);r=Yc(i,r)|0;u[a>>2]=u[f>>2];PL[n&15](o,a,r);r=iA(o)|0;$i(o);Vc(i);v=t;return r|0}function rA(n,e){n=n|0;e=e|0;return}function tA(n,e,r){n=n|0;e=e|0;r=r|0;uA(n,r);return}function iA(n){n=n|0;return ko(n)|0}function uA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+16|0;r=i;t=e;if(!(t&1))u[n>>2]=u[e>>2];else{oA(r,0);Hn(t|0,r|0)|0;aA(n,r);fA(r)}v=i;return}function oA(n,e){n=n|0;e=e|0;Bo(n,e);u[n+4>>2]=0;t[n+8>>0]=0;return}function aA(n,e){n=n|0;e=e|0;u[n>>2]=u[e+4>>2];return}function fA(n){n=n|0;t[n+8>>0]=0;return}function cA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=lA()|0;n=sA(r)|0;xa(o,e,i,n,dA(r,t)|0,t);return}function lA(){var n=0,e=0;if(!(t[8064]|0)){yA(10968);xn(68,10968,b|0)|0;e=8064;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10968)|0)){n=10968;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));yA(10968)}return 10968}function sA(n){n=n|0;return n|0}function dA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=lA()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){_A(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{vA(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function _A(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function vA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=pA(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;mA(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;_A(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;bA(n,i);hA(i);v=f;return}}function pA(n){n=n|0;return 536870911}function mA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function bA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function hA(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function yA(n){n=n|0;kA(n);return}function wA(n){n=n|0;MA(n+24|0);return}function MA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function kA(n){n=n|0;var e=0;e=$a()|0;rf(n,1,1,e,gA()|0,5);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function gA(){return 1872}function TA(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;SA(u[(AA(n)|0)>>2]|0,e,r,t,i,o);return}function AA(n){n=n|0;return(u[(lA()|0)+24>>2]|0)+(n<<3)|0}function SA(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;var o=0,a=0,f=0,c=0,l=0,s=0;o=v;v=v+32|0;a=o+16|0;f=o+12|0;c=o+8|0;l=o+4|0;s=o;Wc(a,e);e=Yc(a,e)|0;Wc(f,r);r=Yc(f,r)|0;Wc(c,t);t=Yc(c,t)|0;Wc(l,i);i=Yc(l,i)|0;Wc(s,u);u=Yc(s,u)|0;lL[n&1](e,r,t,i,u);Vc(s);Vc(l);Vc(c);Vc(f);Vc(a);v=o;return}function EA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=CA()|0;n=LA(r)|0;xa(o,e,i,n,RA(r,t)|0,t);return}function CA(){var n=0,e=0;if(!(t[8072]|0)){xA(11004);xn(69,11004,b|0)|0;e=8072;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(11004)|0)){n=11004;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));xA(11004)}return 11004}function LA(n){n=n|0;return n|0}function RA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=CA()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){PA(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{BA(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function PA(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function BA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=OA(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;NA(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;PA(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;IA(n,i);FA(i);v=f;return}}function OA(n){n=n|0;return 536870911}function NA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function IA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function FA(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function xA(n){n=n|0;DA(n);return}function UA(n){n=n|0;HA(n+24|0);return}function HA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function DA(n){n=n|0;var e=0;e=$a()|0;rf(n,1,12,e,WA()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function WA(){return 1896}function YA(n,e,r){n=n|0;e=e|0;r=r|0;jA(u[(VA(n)|0)>>2]|0,e,r);return}function VA(n){n=n|0;return(u[(CA()|0)+24>>2]|0)+(n<<3)|0}function jA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,u=0;t=v;v=v+16|0;u=t+4|0;i=t;qA(u,e);e=zA(u,e)|0;Wc(i,r);r=Yc(i,r)|0;pL[n&31](e,r);Vc(i);v=t;return}function qA(n,e){n=n|0;e=e|0;return}function zA(n,e){n=n|0;e=e|0;return GA(e)|0}function GA(n){n=n|0;return n|0}function KA(){var n=0;if(!(t[8080]|0)){XA(11040);xn(70,11040,b|0)|0;n=8080;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(11040)|0))XA(11040);return 11040}function XA(n){n=n|0;QA(n);cy(n,71);return}function JA(n){n=n|0;ZA(n+24|0);return}function ZA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function QA(n){n=n|0;var e=0;e=$a()|0;rf(n,5,7,e,rS()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function $A(n){n=n|0;nS(n);return}function nS(n){n=n|0;eS(n);return}function eS(n){n=n|0;t[n+8>>0]=1;return}function rS(){return 1936}function tS(){return iS()|0}function iS(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;o=n+4|0;u[o>>2]=GE(1)|0;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];uS(t,o,i);u[r>>2]=t;v=e;return n|0}function uS(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1916;u[r+12>>2]=e;u[n+4>>2]=r;return}function oS(n){n=n|0;WE(n);XE(n);return}function aS(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function fS(n){n=n|0;XE(n);return}function cS(){var n=0;if(!(t[8088]|0)){mS(11076);xn(25,11076,b|0)|0;n=8088;u[n>>2]=1;u[n+4>>2]=0}return 11076}function lS(n,e){n=n|0;e=e|0;u[n>>2]=sS()|0;u[n+4>>2]=dS()|0;u[n+12>>2]=e;u[n+8>>2]=_S()|0;u[n+32>>2]=10;return}function sS(){return 11745}function dS(){return 1940}function _S(){return Ym()|0}function vS(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){pS(r);XE(r)}}else if(e|0)XE(e);return}function pS(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function mS(n){n=n|0;Rf(n);return}function bS(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function hS(n){n=n|0;return u[n>>2]|0}function yS(n){n=n|0;return t[u[n>>2]>>0]|0}function wS(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;u[t>>2]=u[n>>2];MS(e,t)|0;v=r;return}function MS(n,e){n=n|0;e=e|0;var r=0;r=kS(u[n>>2]|0,e)|0;e=n+4|0;u[(u[e>>2]|0)+8>>2]=r;return u[(u[e>>2]|0)+8>>2]|0}function kS(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;gS(t);n=ko(n)|0;e=TS(n,u[e>>2]|0)|0;AS(t);v=r;return e|0}function gS(n){n=n|0;u[n>>2]=u[2701];u[n+4>>2]=u[2703];return}function TS(n,e){n=n|0;e=e|0;var r=0;r=Ao(SS()|0)|0;return ue(0,r|0,n|0,XM(e)|0)|0}function AS(n){n=n|0;nT(u[n>>2]|0,u[n+4>>2]|0);return}function SS(){var n=0;if(!(t[8096]|0)){ES(11120);n=8096;u[n>>2]=1;u[n+4>>2]=0}return 11120}function ES(n){n=n|0;xo(n,CS()|0,1);return}function CS(){return 1948}function LS(){RS();return}function RS(){var n=0,e=0,r=0,i=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0;h=v;v=v+16|0;_=h+4|0;p=h;Nn(65536,10804,u[2702]|0,10812);r=AM()|0;e=u[r>>2]|0;n=u[e>>2]|0;if(n|0){i=u[r+8>>2]|0;r=u[r+4>>2]|0;while(1){Yn(n|0,o[r>>0]|0|0,t[i>>0]|0);e=e+4|0;n=u[e>>2]|0;if(!n)break;else{i=i+1|0;r=r+1|0}}}n=EM()|0;e=u[n>>2]|0;if(e|0)do{Vn(e|0,u[n+4>>2]|0);n=n+8|0;e=u[n>>2]|0}while((e|0)!=0);Vn(PS()|0,5167);d=sM()|0;n=u[d>>2]|0;n:do{if(n|0){do{BS(u[n+4>>2]|0);n=u[n>>2]|0}while((n|0)!=0);n=u[d>>2]|0;if(n|0){s=d;do{while(1){a=n;n=u[n>>2]|0;a=u[a+4>>2]|0;if(!(OS(a)|0))break;u[p>>2]=s;u[_>>2]=u[p>>2];NS(d,_)|0;if(!n)break n}IS(a);s=u[s>>2]|0;e=FS(a)|0;f=Zn()|0;c=v;v=v+((1*(e<<2)|0)+15&-16)|0;l=v;v=v+((1*(e<<2)|0)+15&-16)|0;e=u[(Ck(a)|0)>>2]|0;if(e|0){r=c;i=l;while(1){u[r>>2]=u[(Sk(u[e+4>>2]|0)|0)>>2];u[i>>2]=u[e+8>>2];e=u[e>>2]|0;if(!e)break;else{r=r+4|0;i=i+4|0}}}y=Sk(a)|0;e=xS(a)|0;r=FS(a)|0;i=US(a)|0;Gn(y|0,e|0,c|0,l|0,r|0,i|0,kM(a)|0);Fn(f|0)}while((n|0)!=0)}}}while(0);n=u[(TM()|0)>>2]|0;if(n|0)do{y=n+4|0;d=PM(y)|0;a=FM(d)|0;f=BM(d)|0;c=(OM(d)|0)+1|0;l=HS(d)|0;s=DS(y)|0;d=Ja(d)|0;_=UM(y)|0;p=WS(y)|0;qn(0,a|0,f|0,c|0,l|0,s|0,d|0,_|0,p|0,YS(y)|0);n=u[n>>2]|0}while((n|0)!=0);n=u[(sM()|0)>>2]|0;n:do{if(n|0){e:while(1){e=u[n+4>>2]|0;if(e|0?(m=u[(Sk(e)|0)>>2]|0,b=u[(Pk(e)|0)>>2]|0,b|0):0){r=b;do{e=r+4|0;i=PM(e)|0;r:do{if(i|0)switch(Ja(i)|0){case 0:break e;case 4:case 3:case 2:{l=FM(i)|0;s=BM(i)|0;d=(OM(i)|0)+1|0;_=HS(i)|0;p=Ja(i)|0;y=UM(e)|0;qn(m|0,l|0,s|0,d|0,_|0,0,p|0,y|0,WS(e)|0,YS(e)|0);break r}case 1:{c=FM(i)|0;l=BM(i)|0;s=(OM(i)|0)+1|0;d=HS(i)|0;_=DS(e)|0;p=Ja(i)|0;y=UM(e)|0;qn(m|0,c|0,l|0,s|0,d|0,_|0,p|0,y|0,WS(e)|0,YS(e)|0);break r}case 5:{d=FM(i)|0;_=BM(i)|0;p=(OM(i)|0)+1|0;y=HS(i)|0;qn(m|0,d|0,_|0,p|0,y|0,VS(i)|0,Ja(i)|0,0,0,0);break r}default:break r}}while(0);r=u[r>>2]|0}while((r|0)!=0)}n=u[n>>2]|0;if(!n)break n}Xn()}}while(0);Kn();v=h;return}function PS(){return 11703}function BS(n){n=n|0;t[n+40>>0]=0;return}function OS(n){n=n|0;return(t[n+40>>0]|0)!=0|0}function NS(n,e){n=n|0;e=e|0;e=jS(e)|0;n=u[e>>2]|0;u[e>>2]=u[n>>2];XE(n);return u[e>>2]|0}function IS(n){n=n|0;t[n+40>>0]=1;return}function FS(n){n=n|0;return u[n+20>>2]|0}function xS(n){n=n|0;return u[n+8>>2]|0}function US(n){n=n|0;return u[n+32>>2]|0}function HS(n){n=n|0;return u[n+4>>2]|0}function DS(n){n=n|0;return u[n+4>>2]|0}function WS(n){n=n|0;return u[n+8>>2]|0}function YS(n){n=n|0;return u[n+16>>2]|0}function VS(n){n=n|0;return u[n+20>>2]|0}function jS(n){n=n|0;return u[n>>2]|0}function qS(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0;g=v;v=v+16|0;_=g;do{if(n>>>0<245){l=n>>>0<11?16:n+11&-8;n=l>>>3;d=u[2783]|0;r=d>>>n;if(r&3|0){e=(r&1^1)+n|0;n=11172+(e<<1<<2)|0;r=n+8|0;t=u[r>>2]|0;i=t+8|0;o=u[i>>2]|0;if((n|0)==(o|0))u[2783]=d&~(1<<e);else{u[o+12>>2]=n;u[r>>2]=o}k=e<<3;u[t+4>>2]=k|3;k=t+k+4|0;u[k>>2]=u[k>>2]|1;k=i;v=g;return k|0}s=u[2785]|0;if(l>>>0>s>>>0){if(r|0){e=2<<n;e=r<<n&(e|0-e);e=(e&0-e)+-1|0;a=e>>>12&16;e=e>>>a;r=e>>>5&8;e=e>>>r;i=e>>>2&4;e=e>>>i;n=e>>>1&2;e=e>>>n;t=e>>>1&1;t=(r|a|i|n|t)+(e>>>t)|0;e=11172+(t<<1<<2)|0;n=e+8|0;i=u[n>>2]|0;a=i+8|0;r=u[a>>2]|0;if((e|0)==(r|0)){n=d&~(1<<t);u[2783]=n}else{u[r+12>>2]=e;u[n>>2]=r;n=d}o=(t<<3)-l|0;u[i+4>>2]=l|3;t=i+l|0;u[t+4>>2]=o|1;u[t+o>>2]=o;if(s|0){i=u[2788]|0;e=s>>>3;r=11172+(e<<1<<2)|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=i;u[e+12>>2]=i;u[i+8>>2]=e;u[i+12>>2]=r}u[2785]=o;u[2788]=t;k=a;v=g;return k|0}f=u[2784]|0;if(f){r=(f&0-f)+-1|0;a=r>>>12&16;r=r>>>a;o=r>>>5&8;r=r>>>o;c=r>>>2&4;r=r>>>c;t=r>>>1&2;r=r>>>t;n=r>>>1&1;n=u[11436+((o|a|c|t|n)+(r>>>n)<<2)>>2]|0;r=(u[n+4>>2]&-8)-l|0;t=u[n+16+(((u[n+16>>2]|0)==0&1)<<2)>>2]|0;if(!t){c=n;o=r}else{do{a=(u[t+4>>2]&-8)-l|0;c=a>>>0<r>>>0;r=c?a:r;n=c?t:n;t=u[t+16+(((u[t+16>>2]|0)==0&1)<<2)>>2]|0}while((t|0)!=0);c=n;o=r}a=c+l|0;if(c>>>0<a>>>0){i=u[c+24>>2]|0;e=u[c+12>>2]|0;do{if((e|0)==(c|0)){n=c+20|0;e=u[n>>2]|0;if(!e){n=c+16|0;e=u[n>>2]|0;if(!e){r=0;break}}while(1){r=e+20|0;t=u[r>>2]|0;if(t|0){e=t;n=r;continue}r=e+16|0;t=u[r>>2]|0;if(!t)break;else{e=t;n=r}}u[n>>2]=0;r=e}else{r=u[c+8>>2]|0;u[r+12>>2]=e;u[e+8>>2]=r;r=e}}while(0);do{if(i|0){e=u[c+28>>2]|0;n=11436+(e<<2)|0;if((c|0)==(u[n>>2]|0)){u[n>>2]=r;if(!r){u[2784]=f&~(1<<e);break}}else{u[i+16+(((u[i+16>>2]|0)!=(c|0)&1)<<2)>>2]=r;if(!r)break}u[r+24>>2]=i;e=u[c+16>>2]|0;if(e|0){u[r+16>>2]=e;u[e+24>>2]=r}e=u[c+20>>2]|0;if(e|0){u[r+20>>2]=e;u[e+24>>2]=r}}}while(0);if(o>>>0<16){k=o+l|0;u[c+4>>2]=k|3;k=c+k+4|0;u[k>>2]=u[k>>2]|1}else{u[c+4>>2]=l|3;u[a+4>>2]=o|1;u[a+o>>2]=o;if(s|0){t=u[2788]|0;e=s>>>3;r=11172+(e<<1<<2)|0;e=1<<e;if(!(d&e)){u[2783]=d|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=t;u[e+12>>2]=t;u[t+8>>2]=e;u[t+12>>2]=r}u[2785]=o;u[2788]=a}k=c+8|0;v=g;return k|0}else d=l}else d=l}else d=l}else if(n>>>0<=4294967231){n=n+11|0;l=n&-8;c=u[2784]|0;if(c){t=0-l|0;n=n>>>8;if(n){if(l>>>0>16777215)f=31;else{d=(n+1048320|0)>>>16&8;M=n<<d;s=(M+520192|0)>>>16&4;M=M<<s;f=(M+245760|0)>>>16&2;f=14-(s|d|f)+(M<<f>>>15)|0;f=l>>>(f+7|0)&1|f<<1}}else f=0;r=u[11436+(f<<2)>>2]|0;n:do{if(!r){r=0;n=0;M=57}else{n=0;a=l<<((f|0)==31?0:25-(f>>>1)|0);o=0;while(1){i=(u[r+4>>2]&-8)-l|0;if(i>>>0<t>>>0)if(!i){n=r;t=0;i=r;M=61;break n}else{n=r;t=i}i=u[r+20>>2]|0;r=u[r+16+(a>>>31<<2)>>2]|0;o=(i|0)==0|(i|0)==(r|0)?o:i;i=(r|0)==0;if(i){r=o;M=57;break}else a=a<<((i^1)&1)}}}while(0);if((M|0)==57){if((r|0)==0&(n|0)==0){n=2<<f;n=c&(n|0-n);if(!n){d=l;break}d=(n&0-n)+-1|0;a=d>>>12&16;d=d>>>a;o=d>>>5&8;d=d>>>o;f=d>>>2&4;d=d>>>f;s=d>>>1&2;d=d>>>s;r=d>>>1&1;n=0;r=u[11436+((o|a|f|s|r)+(d>>>r)<<2)>>2]|0}if(!r){f=n;a=t}else{i=r;M=61}}if((M|0)==61)while(1){M=0;r=(u[i+4>>2]&-8)-l|0;d=r>>>0<t>>>0;r=d?r:t;n=d?i:n;i=u[i+16+(((u[i+16>>2]|0)==0&1)<<2)>>2]|0;if(!i){f=n;a=r;break}else{t=r;M=61}}if((f|0)!=0?a>>>0<((u[2785]|0)-l|0)>>>0:0){o=f+l|0;if(f>>>0>=o>>>0){k=0;v=g;return k|0}i=u[f+24>>2]|0;e=u[f+12>>2]|0;do{if((e|0)==(f|0)){n=f+20|0;e=u[n>>2]|0;if(!e){n=f+16|0;e=u[n>>2]|0;if(!e){e=0;break}}while(1){r=e+20|0;t=u[r>>2]|0;if(t|0){e=t;n=r;continue}r=e+16|0;t=u[r>>2]|0;if(!t)break;else{e=t;n=r}}u[n>>2]=0}else{k=u[f+8>>2]|0;u[k+12>>2]=e;u[e+8>>2]=k}}while(0);do{if(i){n=u[f+28>>2]|0;r=11436+(n<<2)|0;if((f|0)==(u[r>>2]|0)){u[r>>2]=e;if(!e){t=c&~(1<<n);u[2784]=t;break}}else{u[i+16+(((u[i+16>>2]|0)!=(f|0)&1)<<2)>>2]=e;if(!e){t=c;break}}u[e+24>>2]=i;n=u[f+16>>2]|0;if(n|0){u[e+16>>2]=n;u[n+24>>2]=e}n=u[f+20>>2]|0;if(n){u[e+20>>2]=n;u[n+24>>2]=e;t=c}else t=c}else t=c}while(0);do{if(a>>>0>=16){u[f+4>>2]=l|3;u[o+4>>2]=a|1;u[o+a>>2]=a;e=a>>>3;if(a>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=o;u[e+12>>2]=o;u[o+8>>2]=e;u[o+12>>2]=r;break}e=a>>>8;if(e){if(a>>>0>16777215)e=31;else{M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;e=(k+245760|0)>>>16&2;e=14-(w|M|e)+(k<<e>>>15)|0;e=a>>>(e+7|0)&1|e<<1}}else e=0;r=11436+(e<<2)|0;u[o+28>>2]=e;n=o+16|0;u[n+4>>2]=0;u[n>>2]=0;n=1<<e;if(!(t&n)){u[2784]=t|n;u[r>>2]=o;u[o+24>>2]=r;u[o+12>>2]=o;u[o+8>>2]=o;break}n=a<<((e|0)==31?0:25-(e>>>1)|0);r=u[r>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(a|0)){M=97;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=96;break}else{n=n<<1;r=e}}if((M|0)==96){u[t>>2]=o;u[o+24>>2]=r;u[o+12>>2]=o;u[o+8>>2]=o;break}else if((M|0)==97){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=o;u[M>>2]=o;u[o+8>>2]=k;u[o+12>>2]=r;u[o+24>>2]=0;break}}else{k=a+l|0;u[f+4>>2]=k|3;k=f+k+4|0;u[k>>2]=u[k>>2]|1}}while(0);k=f+8|0;v=g;return k|0}else d=l}else d=l}else d=-1}while(0);r=u[2785]|0;if(r>>>0>=d>>>0){e=r-d|0;n=u[2788]|0;if(e>>>0>15){k=n+d|0;u[2788]=k;u[2785]=e;u[k+4>>2]=e|1;u[k+e>>2]=e;u[n+4>>2]=d|3}else{u[2785]=0;u[2788]=0;u[n+4>>2]=r|3;k=n+r+4|0;u[k>>2]=u[k>>2]|1}k=n+8|0;v=g;return k|0}a=u[2786]|0;if(a>>>0>d>>>0){w=a-d|0;u[2786]=w;k=u[2789]|0;M=k+d|0;u[2789]=M;u[M+4>>2]=w|1;u[k+4>>2]=d|3;k=k+8|0;v=g;return k|0}if(!(u[2901]|0)){u[2903]=4096;u[2902]=4096;u[2904]=-1;u[2905]=-1;u[2906]=0;u[2894]=0;n=_&-16^1431655768;u[_>>2]=n;u[2901]=n;n=4096}else n=u[2903]|0;f=d+48|0;c=d+47|0;o=n+c|0;i=0-n|0;l=o&i;if(l>>>0<=d>>>0){k=0;v=g;return k|0}n=u[2893]|0;if(n|0?(s=u[2891]|0,_=s+l|0,_>>>0<=s>>>0|_>>>0>n>>>0):0){k=0;v=g;return k|0}n:do{if(!(u[2894]&4)){r=u[2789]|0;e:do{if(r){t=11580;while(1){n=u[t>>2]|0;if(n>>>0<=r>>>0?(b=t+4|0,(n+(u[b>>2]|0)|0)>>>0>r>>>0):0)break;n=u[t+8>>2]|0;if(!n){M=118;break e}else t=n}e=o-a&i;if(e>>>0<2147483647){n=fC(e|0)|0;if((n|0)==((u[t>>2]|0)+(u[b>>2]|0)|0)){if((n|0)!=(-1|0)){a=e;o=n;M=135;break n}}else{t=n;M=126}}else e=0}else M=118}while(0);do{if((M|0)==118){r=fC(0)|0;if((r|0)!=(-1|0)?(e=r,p=u[2902]|0,m=p+-1|0,e=((m&e|0)==0?0:(m+e&0-p)-e|0)+l|0,p=u[2891]|0,m=e+p|0,e>>>0>d>>>0&e>>>0<2147483647):0){b=u[2893]|0;if(b|0?m>>>0<=p>>>0|m>>>0>b>>>0:0){e=0;break}n=fC(e|0)|0;if((n|0)==(r|0)){a=e;o=r;M=135;break n}else{t=n;M=126}}else e=0}}while(0);do{if((M|0)==126){r=0-e|0;if(!(f>>>0>e>>>0&(e>>>0<2147483647&(t|0)!=(-1|0))))if((t|0)==(-1|0)){e=0;break}else{a=e;o=t;M=135;break n}n=u[2903]|0;n=c-e+n&0-n;if(n>>>0>=2147483647){a=e;o=t;M=135;break n}if((fC(n|0)|0)==(-1|0)){fC(r|0)|0;e=0;break}else{a=n+e|0;o=t;M=135;break n}}}while(0);u[2894]=u[2894]|4;M=133}else{e=0;M=133}}while(0);if(((M|0)==133?l>>>0<2147483647:0)?(w=fC(l|0)|0,b=fC(0)|0,h=b-w|0,y=h>>>0>(d+40|0)>>>0,!((w|0)==(-1|0)|y^1|w>>>0<b>>>0&((w|0)!=(-1|0)&(b|0)!=(-1|0))^1)):0){a=y?h:e;o=w;M=135}if((M|0)==135){e=(u[2891]|0)+a|0;u[2891]=e;if(e>>>0>(u[2892]|0)>>>0)u[2892]=e;c=u[2789]|0;do{if(c){e=11580;while(1){n=u[e>>2]|0;r=e+4|0;t=u[r>>2]|0;if((o|0)==(n+t|0)){M=145;break}i=u[e+8>>2]|0;if(!i)break;else e=i}if(((M|0)==145?(u[e+12>>2]&8|0)==0:0)?c>>>0<o>>>0&c>>>0>=n>>>0:0){u[r>>2]=t+a;k=c+8|0;k=(k&7|0)==0?0:0-k&7;M=c+k|0;k=(u[2786]|0)+(a-k)|0;u[2789]=M;u[2786]=k;u[M+4>>2]=k|1;u[M+k+4>>2]=40;u[2790]=u[2905];break}if(o>>>0<(u[2787]|0)>>>0)u[2787]=o;r=o+a|0;e=11580;while(1){if((u[e>>2]|0)==(r|0)){M=153;break}n=u[e+8>>2]|0;if(!n)break;else e=n}if((M|0)==153?(u[e+12>>2]&8|0)==0:0){u[e>>2]=o;s=e+4|0;u[s>>2]=(u[s>>2]|0)+a;s=o+8|0;s=o+((s&7|0)==0?0:0-s&7)|0;e=r+8|0;e=r+((e&7|0)==0?0:0-e&7)|0;l=s+d|0;f=e-s-d|0;u[s+4>>2]=d|3;do{if((e|0)!=(c|0)){if((e|0)==(u[2788]|0)){k=(u[2785]|0)+f|0;u[2785]=k;u[2788]=l;u[l+4>>2]=k|1;u[l+k>>2]=k;break}n=u[e+4>>2]|0;if((n&3|0)==1){a=n&-8;t=n>>>3;n:do{if(n>>>0<256){n=u[e+8>>2]|0;r=u[e+12>>2]|0;if((r|0)==(n|0)){u[2783]=u[2783]&~(1<<t);break}else{u[n+12>>2]=r;u[r+8>>2]=n;break}}else{o=u[e+24>>2]|0;n=u[e+12>>2]|0;do{if((n|0)==(e|0)){t=e+16|0;r=t+4|0;n=u[r>>2]|0;if(!n){n=u[t>>2]|0;if(!n){n=0;break}else r=t}while(1){t=n+20|0;i=u[t>>2]|0;if(i|0){n=i;r=t;continue}t=n+16|0;i=u[t>>2]|0;if(!i)break;else{n=i;r=t}}u[r>>2]=0}else{k=u[e+8>>2]|0;u[k+12>>2]=n;u[n+8>>2]=k}}while(0);if(!o)break;r=u[e+28>>2]|0;t=11436+(r<<2)|0;do{if((e|0)!=(u[t>>2]|0)){u[o+16+(((u[o+16>>2]|0)!=(e|0)&1)<<2)>>2]=n;if(!n)break n}else{u[t>>2]=n;if(n|0)break;u[2784]=u[2784]&~(1<<r);break n}}while(0);u[n+24>>2]=o;r=e+16|0;t=u[r>>2]|0;if(t|0){u[n+16>>2]=t;u[t+24>>2]=n}r=u[r+4>>2]|0;if(!r)break;u[n+20>>2]=r;u[r+24>>2]=n}}while(0);e=e+a|0;i=a+f|0}else i=f;e=e+4|0;u[e>>2]=u[e>>2]&-2;u[l+4>>2]=i|1;u[l+i>>2]=i;e=i>>>3;if(i>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=l;u[e+12>>2]=l;u[l+8>>2]=e;u[l+12>>2]=r;break}e=i>>>8;do{if(!e)e=0;else{if(i>>>0>16777215){e=31;break}M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;e=(k+245760|0)>>>16&2;e=14-(w|M|e)+(k<<e>>>15)|0;e=i>>>(e+7|0)&1|e<<1}}while(0);t=11436+(e<<2)|0;u[l+28>>2]=e;n=l+16|0;u[n+4>>2]=0;u[n>>2]=0;n=u[2784]|0;r=1<<e;if(!(n&r)){u[2784]=n|r;u[t>>2]=l;u[l+24>>2]=t;u[l+12>>2]=l;u[l+8>>2]=l;break}n=i<<((e|0)==31?0:25-(e>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(i|0)){M=194;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=193;break}else{n=n<<1;r=e}}if((M|0)==193){u[t>>2]=l;u[l+24>>2]=r;u[l+12>>2]=l;u[l+8>>2]=l;break}else if((M|0)==194){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=l;u[M>>2]=l;u[l+8>>2]=k;u[l+12>>2]=r;u[l+24>>2]=0;break}}else{k=(u[2786]|0)+f|0;u[2786]=k;u[2789]=l;u[l+4>>2]=k|1}}while(0);k=s+8|0;v=g;return k|0}e=11580;while(1){n=u[e>>2]|0;if(n>>>0<=c>>>0?(k=n+(u[e+4>>2]|0)|0,k>>>0>c>>>0):0)break;e=u[e+8>>2]|0}i=k+-47|0;n=i+8|0;n=i+((n&7|0)==0?0:0-n&7)|0;i=c+16|0;n=n>>>0<i>>>0?c:n;e=n+8|0;r=o+8|0;r=(r&7|0)==0?0:0-r&7;M=o+r|0;r=a+-40-r|0;u[2789]=M;u[2786]=r;u[M+4>>2]=r|1;u[M+r+4>>2]=40;u[2790]=u[2905];r=n+4|0;u[r>>2]=27;u[e>>2]=u[2895];u[e+4>>2]=u[2896];u[e+8>>2]=u[2897];u[e+12>>2]=u[2898];u[2895]=o;u[2896]=a;u[2898]=0;u[2897]=e;e=n+24|0;do{M=e;e=e+4|0;u[e>>2]=7}while((M+8|0)>>>0<k>>>0);if((n|0)!=(c|0)){o=n-c|0;u[r>>2]=u[r>>2]&-2;u[c+4>>2]=o|1;u[n>>2]=o;e=o>>>3;if(o>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=c;u[e+12>>2]=c;u[c+8>>2]=e;u[c+12>>2]=r;break}e=o>>>8;if(e){if(o>>>0>16777215)r=31;else{M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;r=(k+245760|0)>>>16&2;r=14-(w|M|r)+(k<<r>>>15)|0;r=o>>>(r+7|0)&1|r<<1}}else r=0;t=11436+(r<<2)|0;u[c+28>>2]=r;u[c+20>>2]=0;u[i>>2]=0;e=u[2784]|0;n=1<<r;if(!(e&n)){u[2784]=e|n;u[t>>2]=c;u[c+24>>2]=t;u[c+12>>2]=c;u[c+8>>2]=c;break}n=o<<((r|0)==31?0:25-(r>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(o|0)){M=216;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=215;break}else{n=n<<1;r=e}}if((M|0)==215){u[t>>2]=c;u[c+24>>2]=r;u[c+12>>2]=c;u[c+8>>2]=c;break}else if((M|0)==216){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=c;u[M>>2]=c;u[c+8>>2]=k;u[c+12>>2]=r;u[c+24>>2]=0;break}}}else{k=u[2787]|0;if((k|0)==0|o>>>0<k>>>0)u[2787]=o;u[2895]=o;u[2896]=a;u[2898]=0;u[2792]=u[2901];u[2791]=-1;e=0;do{k=11172+(e<<1<<2)|0;u[k+12>>2]=k;u[k+8>>2]=k;e=e+1|0}while((e|0)!=32);k=o+8|0;k=(k&7|0)==0?0:0-k&7;M=o+k|0;k=a+-40-k|0;u[2789]=M;u[2786]=k;u[M+4>>2]=k|1;u[M+k+4>>2]=40;u[2790]=u[2905]}}while(0);e=u[2786]|0;if(e>>>0>d>>>0){w=e-d|0;u[2786]=w;k=u[2789]|0;M=k+d|0;u[2789]=M;u[M+4>>2]=w|1;u[k+4>>2]=d|3;k=k+8|0;v=g;return k|0}}u[(QS()|0)>>2]=12;k=0;v=g;return k|0}function zS(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0;if(!n)return;r=n+-8|0;i=u[2787]|0;n=u[n+-4>>2]|0;e=n&-8;c=r+e|0;do{if(!(n&1)){t=u[r>>2]|0;if(!(n&3))return;a=r+(0-t)|0;o=t+e|0;if(a>>>0<i>>>0)return;if((a|0)==(u[2788]|0)){n=c+4|0;e=u[n>>2]|0;if((e&3|0)!=3){f=a;e=o;break}u[2785]=o;u[n>>2]=e&-2;u[a+4>>2]=o|1;u[a+o>>2]=o;return}r=t>>>3;if(t>>>0<256){n=u[a+8>>2]|0;e=u[a+12>>2]|0;if((e|0)==(n|0)){u[2783]=u[2783]&~(1<<r);f=a;e=o;break}else{u[n+12>>2]=e;u[e+8>>2]=n;f=a;e=o;break}}i=u[a+24>>2]|0;n=u[a+12>>2]|0;do{if((n|0)==(a|0)){r=a+16|0;e=r+4|0;n=u[e>>2]|0;if(!n){n=u[r>>2]|0;if(!n){n=0;break}else e=r}while(1){r=n+20|0;t=u[r>>2]|0;if(t|0){n=t;e=r;continue}r=n+16|0;t=u[r>>2]|0;if(!t)break;else{n=t;e=r}}u[e>>2]=0}else{f=u[a+8>>2]|0;u[f+12>>2]=n;u[n+8>>2]=f}}while(0);if(i){e=u[a+28>>2]|0;r=11436+(e<<2)|0;if((a|0)==(u[r>>2]|0)){u[r>>2]=n;if(!n){u[2784]=u[2784]&~(1<<e);f=a;e=o;break}}else{u[i+16+(((u[i+16>>2]|0)!=(a|0)&1)<<2)>>2]=n;if(!n){f=a;e=o;break}}u[n+24>>2]=i;e=a+16|0;r=u[e>>2]|0;if(r|0){u[n+16>>2]=r;u[r+24>>2]=n}e=u[e+4>>2]|0;if(e){u[n+20>>2]=e;u[e+24>>2]=n;f=a;e=o}else{f=a;e=o}}else{f=a;e=o}}else{f=r;a=r}}while(0);if(a>>>0>=c>>>0)return;n=c+4|0;t=u[n>>2]|0;if(!(t&1))return;if(!(t&2)){n=u[2788]|0;if((c|0)==(u[2789]|0)){c=(u[2786]|0)+e|0;u[2786]=c;u[2789]=f;u[f+4>>2]=c|1;if((f|0)!=(n|0))return;u[2788]=0;u[2785]=0;return}if((c|0)==(n|0)){c=(u[2785]|0)+e|0;u[2785]=c;u[2788]=a;u[f+4>>2]=c|1;u[a+c>>2]=c;return}i=(t&-8)+e|0;r=t>>>3;do{if(t>>>0<256){e=u[c+8>>2]|0;n=u[c+12>>2]|0;if((n|0)==(e|0)){u[2783]=u[2783]&~(1<<r);break}else{u[e+12>>2]=n;u[n+8>>2]=e;break}}else{o=u[c+24>>2]|0;n=u[c+12>>2]|0;do{if((n|0)==(c|0)){r=c+16|0;e=r+4|0;n=u[e>>2]|0;if(!n){n=u[r>>2]|0;if(!n){r=0;break}else e=r}while(1){r=n+20|0;t=u[r>>2]|0;if(t|0){n=t;e=r;continue}r=n+16|0;t=u[r>>2]|0;if(!t)break;else{n=t;e=r}}u[e>>2]=0;r=n}else{r=u[c+8>>2]|0;u[r+12>>2]=n;u[n+8>>2]=r;r=n}}while(0);if(o|0){n=u[c+28>>2]|0;e=11436+(n<<2)|0;if((c|0)==(u[e>>2]|0)){u[e>>2]=r;if(!r){u[2784]=u[2784]&~(1<<n);break}}else{u[o+16+(((u[o+16>>2]|0)!=(c|0)&1)<<2)>>2]=r;if(!r)break}u[r+24>>2]=o;n=c+16|0;e=u[n>>2]|0;if(e|0){u[r+16>>2]=e;u[e+24>>2]=r}n=u[n+4>>2]|0;if(n|0){u[r+20>>2]=n;u[n+24>>2]=r}}}}while(0);u[f+4>>2]=i|1;u[a+i>>2]=i;if((f|0)==(u[2788]|0)){u[2785]=i;return}}else{u[n>>2]=t&-2;u[f+4>>2]=e|1;u[a+e>>2]=e;i=e}n=i>>>3;if(i>>>0<256){r=11172+(n<<1<<2)|0;e=u[2783]|0;n=1<<n;if(!(e&n)){u[2783]=e|n;n=r;e=r+8|0}else{e=r+8|0;n=u[e>>2]|0}u[e>>2]=f;u[n+12>>2]=f;u[f+8>>2]=n;u[f+12>>2]=r;return}n=i>>>8;if(n){if(i>>>0>16777215)n=31;else{a=(n+1048320|0)>>>16&8;c=n<<a;o=(c+520192|0)>>>16&4;c=c<<o;n=(c+245760|0)>>>16&2;n=14-(o|a|n)+(c<<n>>>15)|0;n=i>>>(n+7|0)&1|n<<1}}else n=0;t=11436+(n<<2)|0;u[f+28>>2]=n;u[f+20>>2]=0;u[f+16>>2]=0;e=u[2784]|0;r=1<<n;do{if(e&r){e=i<<((n|0)==31?0:25-(n>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(i|0)){n=73;break}t=r+16+(e>>>31<<2)|0;n=u[t>>2]|0;if(!n){n=72;break}else{e=e<<1;r=n}}if((n|0)==72){u[t>>2]=f;u[f+24>>2]=r;u[f+12>>2]=f;u[f+8>>2]=f;break}else if((n|0)==73){a=r+8|0;c=u[a>>2]|0;u[c+12>>2]=f;u[a>>2]=f;u[f+8>>2]=c;u[f+12>>2]=r;u[f+24>>2]=0;break}}else{u[2784]=e|r;u[t>>2]=f;u[f+24>>2]=t;u[f+12>>2]=f;u[f+8>>2]=f}}while(0);c=(u[2791]|0)+-1|0;u[2791]=c;if(!c)n=11588;else return;while(1){n=u[n>>2]|0;if(!n)break;else n=n+8|0}u[2791]=-1;return}function GS(){return 11628}function KS(n){n=n|0;var e=0,r=0;e=v;v=v+16|0;r=e;u[r>>2]=eE(u[n+60>>2]|0)|0;n=ZS(ae(6,r|0)|0)|0;v=e;return n|0}function XS(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;d=v;v=v+48|0;l=d+16|0;o=d;i=d+32|0;f=n+28|0;t=u[f>>2]|0;u[i>>2]=t;c=n+20|0;t=(u[c>>2]|0)-t|0;u[i+4>>2]=t;u[i+8>>2]=e;u[i+12>>2]=r;t=t+r|0;a=n+60|0;u[o>>2]=u[a>>2];u[o+4>>2]=i;u[o+8>>2]=2;o=ZS(le(146,o|0)|0)|0;n:do{if((t|0)!=(o|0)){e=2;while(1){if((o|0)<0)break;t=t-o|0;p=u[i+4>>2]|0;_=o>>>0>p>>>0;i=_?i+8|0:i;e=(_<<31>>31)+e|0;p=o-(_?p:0)|0;u[i>>2]=(u[i>>2]|0)+p;_=i+4|0;u[_>>2]=(u[_>>2]|0)-p;u[l>>2]=u[a>>2];u[l+4>>2]=i;u[l+8>>2]=e;o=ZS(le(146,l|0)|0)|0;if((t|0)==(o|0)){s=3;break n}}u[n+16>>2]=0;u[f>>2]=0;u[c>>2]=0;u[n>>2]=u[n>>2]|32;if((e|0)==2)r=0;else r=r-(u[i+4>>2]|0)|0}else s=3}while(0);if((s|0)==3){p=u[n+44>>2]|0;u[n+16>>2]=p+(u[n+48>>2]|0);u[f>>2]=p;u[c>>2]=p}v=d;return r|0}function JS(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;i=v;v=v+32|0;o=i;t=i+20|0;u[o>>2]=u[n+60>>2];u[o+4>>2]=0;u[o+8>>2]=e;u[o+12>>2]=t;u[o+16>>2]=r;if((ZS(ce(140,o|0)|0)|0)<0){u[t>>2]=-1;n=-1}else n=u[t>>2]|0;v=i;return n|0}function ZS(n){n=n|0;if(n>>>0>4294963200){u[(QS()|0)>>2]=0-n;n=-1}return n|0}function QS(){return($S()|0)+64|0}function $S(){return nE()|0}function nE(){return 2084}function eE(n){n=n|0;return n|0}function rE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0;o=v;v=v+32|0;i=o;u[n+36>>2]=1;if((u[n>>2]&64|0)==0?(u[i>>2]=u[n+60>>2],u[i+4>>2]=21523,u[i+8>>2]=o+16,Qn(54,i|0)|0):0)t[n+75>>0]=-1;i=XS(n,e,r)|0;v=o;return i|0}function tE(n,e){n=n|0;e=e|0;var r=0,i=0;r=t[n>>0]|0;i=t[e>>0]|0;if(r<<24>>24==0?1:r<<24>>24!=i<<24>>24)n=i;else{do{n=n+1|0;e=e+1|0;r=t[n>>0]|0;i=t[e>>0]|0}while(!(r<<24>>24==0?1:r<<24>>24!=i<<24>>24));n=i}return(r&255)-(n&255)|0}function iE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,u=0;n:do{if(!r)n=0;else{while(1){i=t[n>>0]|0;u=t[e>>0]|0;if(i<<24>>24!=u<<24>>24)break;r=r+-1|0;if(!r){n=0;break n}else{n=n+1|0;e=e+1|0}}n=(i&255)-(u&255)|0}}while(0);return n|0}function uE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0;h=v;v=v+224|0;d=h+120|0;_=h+80|0;m=h;b=h+136|0;i=_;o=i+40|0;do{u[i>>2]=0;i=i+4|0}while((i|0)<(o|0));u[d>>2]=u[r>>2];if((oE(0,e,d,m,_)|0)<0)r=-1;else{if((u[n+76>>2]|0)>-1)p=aE(n)|0;else p=0;r=u[n>>2]|0;s=r&32;if((t[n+74>>0]|0)<1)u[n>>2]=r&-33;i=n+48|0;if(!(u[i>>2]|0)){o=n+44|0;a=u[o>>2]|0;u[o>>2]=b;f=n+28|0;u[f>>2]=b;c=n+20|0;u[c>>2]=b;u[i>>2]=80;l=n+16|0;u[l>>2]=b+80;r=oE(n,e,d,m,_)|0;if(a){yL[u[n+36>>2]&7](n,0,0)|0;r=(u[c>>2]|0)==0?-1:r;u[o>>2]=a;u[i>>2]=0;u[l>>2]=0;u[f>>2]=0;u[c>>2]=0}}else r=oE(n,e,d,m,_)|0;i=u[n>>2]|0;u[n>>2]=i|s;if(p|0)fE(n);r=(i&32|0)==0?r:-1}v=h;return r|0}function oE(n,e,r,o,a){n=n|0;e=e|0;r=r|0;o=o|0;a=a|0;var f=0,c=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,R=0,P=0,B=0,O=0;O=v;v=v+64|0;C=O+16|0;R=O;S=O+24|0;P=O+8|0;B=O+20|0;u[C>>2]=e;g=(n|0)!=0;T=S+40|0;A=T;S=S+39|0;E=P+4|0;c=0;f=0;p=0;n:while(1){do{if((f|0)>-1)if((c|0)>(2147483647-f|0)){u[(QS()|0)>>2]=75;f=-1;break}else{f=c+f|0;break}}while(0);c=t[e>>0]|0;if(!(c<<24>>24)){k=87;break}else s=e;e:while(1){switch(c<<24>>24){case 37:{c=s;k=9;break e}case 0:{c=s;break e}default:{}}M=s+1|0;u[C>>2]=M;c=t[M>>0]|0;s=M}e:do{if((k|0)==9)while(1){k=0;if((t[s+1>>0]|0)!=37)break e;c=c+1|0;s=s+2|0;u[C>>2]=s;if((t[s>>0]|0)==37)k=9;else break}}while(0);c=c-e|0;if(g)cE(n,e,c);if(c|0){e=s;continue}d=s+1|0;c=(t[d>>0]|0)+-48|0;if(c>>>0<10){M=(t[s+2>>0]|0)==36;w=M?c:-1;p=M?1:p;d=M?s+3|0:d}else w=-1;u[C>>2]=d;c=t[d>>0]|0;s=(c<<24>>24)+-32|0;e:do{if(s>>>0<32){_=0;m=c;while(1){c=1<<s;if(!(c&75913)){c=m;break e}_=c|_;d=d+1|0;u[C>>2]=d;c=t[d>>0]|0;s=(c<<24>>24)+-32|0;if(s>>>0>=32)break;else m=c}}else _=0}while(0);if(c<<24>>24==42){s=d+1|0;c=(t[s>>0]|0)+-48|0;if(c>>>0<10?(t[d+2>>0]|0)==36:0){u[a+(c<<2)>>2]=10;c=u[o+((t[s>>0]|0)+-48<<3)>>2]|0;p=1;d=d+3|0}else{if(p|0){f=-1;break}if(g){p=(u[r>>2]|0)+(4-1)&~(4-1);c=u[p>>2]|0;u[r>>2]=p+4;p=0;d=s}else{c=0;p=0;d=s}}u[C>>2]=d;M=(c|0)<0;c=M?0-c|0:c;_=M?_|8192:_}else{c=lE(C)|0;if((c|0)<0){f=-1;break}d=u[C>>2]|0}do{if((t[d>>0]|0)==46){if((t[d+1>>0]|0)!=42){u[C>>2]=d+1;s=lE(C)|0;d=u[C>>2]|0;break}m=d+2|0;s=(t[m>>0]|0)+-48|0;if(s>>>0<10?(t[d+3>>0]|0)==36:0){u[a+(s<<2)>>2]=10;s=u[o+((t[m>>0]|0)+-48<<3)>>2]|0;d=d+4|0;u[C>>2]=d;break}if(p|0){f=-1;break n}if(g){M=(u[r>>2]|0)+(4-1)&~(4-1);s=u[M>>2]|0;u[r>>2]=M+4}else s=0;u[C>>2]=m;d=m}else s=-1}while(0);y=0;while(1){if(((t[d>>0]|0)+-65|0)>>>0>57){f=-1;break n}M=d+1|0;u[C>>2]=M;m=t[(t[d>>0]|0)+-65+(5178+(y*58|0))>>0]|0;b=m&255;if((b+-1|0)>>>0<8){y=b;d=M}else break}if(!(m<<24>>24)){f=-1;break}h=(w|0)>-1;do{if(m<<24>>24==19){if(h){f=-1;break n}else k=49}else{if(h){u[a+(w<<2)>>2]=b;h=o+(w<<3)|0;w=u[h+4>>2]|0;k=R;u[k>>2]=u[h>>2];u[k+4>>2]=w;k=49;break}if(!g){f=0;break n}sE(R,b,r)}}while(0);if((k|0)==49?(k=0,!g):0){c=0;e=M;continue}d=t[d>>0]|0;d=(y|0)!=0&(d&15|0)==3?d&-33:d;h=_&-65537;w=(_&8192|0)==0?_:h;e:do{switch(d|0){case 110:switch((y&255)<<24>>24){case 0:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 1:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 2:{c=u[R>>2]|0;u[c>>2]=f;u[c+4>>2]=((f|0)<0)<<31>>31;c=0;e=M;continue n}case 3:{i[u[R>>2]>>1]=f;c=0;e=M;continue n}case 4:{t[u[R>>2]>>0]=f;c=0;e=M;continue n}case 6:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 7:{c=u[R>>2]|0;u[c>>2]=f;u[c+4>>2]=((f|0)<0)<<31>>31;c=0;e=M;continue n}default:{c=0;e=M;continue n}}case 112:{d=120;s=s>>>0>8?s:8;e=w|8;k=61;break}case 88:case 120:{e=w;k=61;break}case 111:{d=R;e=u[d>>2]|0;d=u[d+4>>2]|0;b=_E(e,d,T)|0;h=A-b|0;_=0;m=5642;s=(w&8|0)==0|(s|0)>(h|0)?s:h+1|0;h=w;k=67;break}case 105:case 100:{d=R;e=u[d>>2]|0;d=u[d+4>>2]|0;if((d|0)<0){e=$E(0,0,e|0,d|0)|0;d=L;_=R;u[_>>2]=e;u[_+4>>2]=d;_=1;m=5642;k=66;break e}else{_=(w&2049|0)!=0&1;m=(w&2048|0)==0?(w&1|0)==0?5642:5644:5643;k=66;break e}}case 117:{d=R;_=0;m=5642;e=u[d>>2]|0;d=u[d+4>>2]|0;k=66;break}case 99:{t[S>>0]=u[R>>2];e=S;_=0;m=5642;b=T;d=1;s=h;break}case 109:{d=pE(u[(QS()|0)>>2]|0)|0;k=71;break}case 115:{d=u[R>>2]|0;d=d|0?d:5652;k=71;break}case 67:{u[P>>2]=u[R>>2];u[E>>2]=0;u[R>>2]=P;b=-1;d=P;k=75;break}case 83:{e=u[R>>2]|0;if(!s){bE(n,32,c,0,w);e=0;k=84}else{b=s;d=e;k=75}break}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{c=yE(n,+l[R>>3],c,s,w,d)|0;e=M;continue n}default:{_=0;m=5642;b=T;d=s;s=w}}}while(0);e:do{if((k|0)==61){w=R;y=u[w>>2]|0;w=u[w+4>>2]|0;b=dE(y,w,T,d&32)|0;m=(e&8|0)==0|(y|0)==0&(w|0)==0;_=m?0:2;m=m?5642:5642+(d>>4)|0;h=e;e=y;d=w;k=67}else if((k|0)==66){b=vE(e,d,T)|0;h=w;k=67}else if((k|0)==71){k=0;w=mE(d,0,s)|0;y=(w|0)==0;e=d;_=0;m=5642;b=y?d+s|0:w;d=y?s:w-d|0;s=h}else if((k|0)==75){k=0;m=d;e=0;s=0;while(1){_=u[m>>2]|0;if(!_)break;s=hE(B,_)|0;if((s|0)<0|s>>>0>(b-e|0)>>>0)break;e=s+e|0;if(b>>>0>e>>>0)m=m+4|0;else break}if((s|0)<0){f=-1;break n}bE(n,32,c,e,w);if(!e){e=0;k=84}else{_=0;while(1){s=u[d>>2]|0;if(!s){k=84;break e}s=hE(B,s)|0;_=s+_|0;if((_|0)>(e|0)){k=84;break e}cE(n,B,s);if(_>>>0>=e>>>0){k=84;break}else d=d+4|0}}}}while(0);if((k|0)==67){k=0;d=(e|0)!=0|(d|0)!=0;w=(s|0)!=0|d;d=((d^1)&1)+(A-b)|0;e=w?b:T;b=T;d=w?(s|0)>(d|0)?s:d:s;s=(s|0)>-1?h&-65537:h}else if((k|0)==84){k=0;bE(n,32,c,e,w^8192);c=(c|0)>(e|0)?c:e;e=M;continue}y=b-e|0;h=(d|0)<(y|0)?y:d;w=h+_|0;c=(c|0)<(w|0)?w:c;bE(n,32,c,w,s);cE(n,m,_);bE(n,48,c,w,s^65536);bE(n,48,h,y,0);cE(n,e,y);bE(n,32,c,w,s^8192);e=M}n:do{if((k|0)==87)if(!n)if(!p)f=0;else{f=1;while(1){e=u[a+(f<<2)>>2]|0;if(!e)break;sE(o+(f<<3)|0,e,r);f=f+1|0;if((f|0)>=10){f=1;break n}}while(1){if(u[a+(f<<2)>>2]|0){f=-1;break n}f=f+1|0;if((f|0)>=10){f=1;break}}}}while(0);v=O;return f|0}function aE(n){n=n|0;return 0}function fE(n){n=n|0;return}function cE(n,e,r){n=n|0;e=e|0;r=r|0;if(!(u[n>>2]&32))PE(e,r,n)|0;return}function lE(n){n=n|0;var e=0,r=0,i=0;r=u[n>>2]|0;i=(t[r>>0]|0)+-48|0;if(i>>>0<10){e=0;do{e=i+(e*10|0)|0;r=r+1|0;u[n>>2]=r;i=(t[r>>0]|0)+-48|0}while(i>>>0<10)}else e=0;return e|0}function sE(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0.0;n:do{if(e>>>0<=20)do{switch(e|0){case 9:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;u[n>>2]=e;break n}case 10:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;t=n;u[t>>2]=e;u[t+4>>2]=((e|0)<0)<<31>>31;break n}case 11:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;t=n;u[t>>2]=e;u[t+4>>2]=0;break n}case 12:{t=(u[r>>2]|0)+(8-1)&~(8-1);e=t;i=u[e>>2]|0;e=u[e+4>>2]|0;u[r>>2]=t+8;t=n;u[t>>2]=i;u[t+4>>2]=e;break n}case 13:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;t=(t&65535)<<16>>16;i=n;u[i>>2]=t;u[i+4>>2]=((t|0)<0)<<31>>31;break n}case 14:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;i=n;u[i>>2]=t&65535;u[i+4>>2]=0;break n}case 15:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;t=(t&255)<<24>>24;i=n;u[i>>2]=t;u[i+4>>2]=((t|0)<0)<<31>>31;break n}case 16:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;i=n;u[i>>2]=t&255;u[i+4>>2]=0;break n}case 17:{i=(u[r>>2]|0)+(8-1)&~(8-1);o=+l[i>>3];u[r>>2]=i+8;l[n>>3]=o;break n}case 18:{i=(u[r>>2]|0)+(8-1)&~(8-1);o=+l[i>>3];u[r>>2]=i+8;l[n>>3]=o;break n}default:break n}}while(0)}while(0);return}function dE(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;if(!((n|0)==0&(e|0)==0))do{r=r+-1|0;t[r>>0]=o[5694+(n&15)>>0]|0|i;n=tC(n|0,e|0,4)|0;e=L}while(!((n|0)==0&(e|0)==0));return r|0}function _E(n,e,r){n=n|0;e=e|0;r=r|0;if(!((n|0)==0&(e|0)==0))do{r=r+-1|0;t[r>>0]=n&7|48;n=tC(n|0,e|0,3)|0;e=L}while(!((n|0)==0&(e|0)==0));return r|0}function vE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0;if(e>>>0>0|(e|0)==0&n>>>0>4294967295){while(1){i=lC(n|0,e|0,10,0)|0;r=r+-1|0;t[r>>0]=i&255|48;i=n;n=aC(n|0,e|0,10,0)|0;if(!(e>>>0>9|(e|0)==9&i>>>0>4294967295))break;else e=L}e=n}else e=n;if(e)while(1){r=r+-1|0;t[r>>0]=(e>>>0)%10|0|48;if(e>>>0<10)break;else e=(e>>>0)/10|0}return r|0}function pE(n){n=n|0;return SE(n,u[(AE()|0)+188>>2]|0)|0}function mE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0;a=e&255;i=(r|0)!=0;n:do{if(i&(n&3|0)!=0){o=e&255;while(1){if((t[n>>0]|0)==o<<24>>24){f=6;break n}n=n+1|0;r=r+-1|0;i=(r|0)!=0;if(!(i&(n&3|0)!=0)){f=5;break}}}else f=5}while(0);if((f|0)==5)if(i)f=6;else r=0;n:do{if((f|0)==6){o=e&255;if((t[n>>0]|0)!=o<<24>>24){i=j(a,16843009)|0;e:do{if(r>>>0>3)while(1){a=u[n>>2]^i;if((a&-2139062144^-2139062144)&a+-16843009|0)break;n=n+4|0;r=r+-4|0;if(r>>>0<=3){f=11;break e}}else f=11}while(0);if((f|0)==11)if(!r){r=0;break}while(1){if((t[n>>0]|0)==o<<24>>24)break n;n=n+1|0;r=r+-1|0;if(!r){r=0;break}}}}}while(0);return(r|0?n:0)|0}function bE(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var u=0,o=0;o=v;v=v+256|0;u=o;if((r|0)>(t|0)&(i&73728|0)==0){i=r-t|0;eC(u|0,e|0,(i>>>0<256?i:256)|0)|0;if(i>>>0>255){e=r-t|0;do{cE(n,u,256);i=i+-256|0}while(i>>>0>255);i=e&255}cE(n,u,i)}v=o;return}function hE(n,e){n=n|0;e=e|0;if(!n)n=0;else n=gE(n,e,0)|0;return n|0}function yE(n,e,r,i,a,f){n=n|0;e=+e;r=r|0;i=i|0;a=a|0;f=f|0;var c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0.0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,R=0,P=0,B=0,O=0;O=v;v=v+560|0;s=O+8|0;w=O;B=O+524|0;P=B;d=O+512|0;u[w>>2]=0;R=d+12|0;wE(e)|0;if((L|0)<0){e=-e;E=1;S=5659}else{E=(a&2049|0)!=0&1;S=(a&2048|0)==0?(a&1|0)==0?5660:5665:5662}wE(e)|0;C=L&2146435072;do{if(C>>>0<2146435072|(C|0)==2146435072&0<0){b=+ME(e,w)*2.0;c=b!=0.0;if(c)u[w>>2]=(u[w>>2]|0)+-1;k=f|32;if((k|0)==97){h=f&32;m=(h|0)==0?S:S+9|0;p=E|2;c=12-i|0;do{if(!(i>>>0>11|(c|0)==0)){e=8.0;do{c=c+-1|0;e=e*16.0}while((c|0)!=0);if((t[m>>0]|0)==45){e=-(e+(-b-e));break}else{e=b+e-e;break}}else e=b}while(0);l=u[w>>2]|0;c=(l|0)<0?0-l|0:l;c=vE(c,((c|0)<0)<<31>>31,R)|0;if((c|0)==(R|0)){c=d+11|0;t[c>>0]=48}t[c+-1>>0]=(l>>31&2)+43;_=c+-2|0;t[_>>0]=f+15;d=(i|0)<1;s=(a&8|0)==0;c=B;do{C=~~e;l=c+1|0;t[c>>0]=o[5694+C>>0]|h;e=(e-+(C|0))*16.0;if((l-P|0)==1?!(s&(d&e==0.0)):0){t[l>>0]=46;c=c+2|0}else c=l}while(e!=0.0);C=c-P|0;P=R-_|0;R=(i|0)!=0&(C+-2|0)<(i|0)?i+2|0:C;c=P+p+R|0;bE(n,32,r,c,a);cE(n,m,p);bE(n,48,r,c,a^65536);cE(n,B,C);bE(n,48,R-C|0,0,0);cE(n,_,P);bE(n,32,r,c,a^8192);break}l=(i|0)<0?6:i;if(c){c=(u[w>>2]|0)+-28|0;u[w>>2]=c;e=b*268435456.0}else{e=b;c=u[w>>2]|0}C=(c|0)<0?s:s+288|0;s=C;do{T=~~e>>>0;u[s>>2]=T;s=s+4|0;e=(e-+(T>>>0))*1.0e9}while(e!=0.0);if((c|0)>0){d=C;p=s;while(1){_=(c|0)<29?c:29;c=p+-4|0;if(c>>>0>=d>>>0){s=0;do{g=rC(u[c>>2]|0,0,_|0)|0;g=nC(g|0,L|0,s|0,0)|0;T=L;M=lC(g|0,T|0,1e9,0)|0;u[c>>2]=M;s=aC(g|0,T|0,1e9,0)|0;c=c+-4|0}while(c>>>0>=d>>>0);if(s){d=d+-4|0;u[d>>2]=s}}s=p;while(1){if(s>>>0<=d>>>0)break;c=s+-4|0;if(!(u[c>>2]|0))s=c;else break}c=(u[w>>2]|0)-_|0;u[w>>2]=c;if((c|0)>0)p=s;else break}}else d=C;if((c|0)<0){i=((l+25|0)/9|0)+1|0;y=(k|0)==102;do{h=0-c|0;h=(h|0)<9?h:9;if(d>>>0<s>>>0){_=(1<<h)+-1|0;p=1e9>>>h;m=0;c=d;do{T=u[c>>2]|0;u[c>>2]=(T>>>h)+m;m=j(T&_,p)|0;c=c+4|0}while(c>>>0<s>>>0);c=(u[d>>2]|0)==0?d+4|0:d;if(!m){d=c;c=s}else{u[s>>2]=m;d=c;c=s+4|0}}else{d=(u[d>>2]|0)==0?d+4|0:d;c=s}s=y?C:d;s=(c-s>>2|0)>(i|0)?s+(i<<2)|0:c;c=(u[w>>2]|0)+h|0;u[w>>2]=c}while((c|0)<0);c=d;i=s}else{c=d;i=s}T=C;if(c>>>0<i>>>0){s=(T-c>>2)*9|0;_=u[c>>2]|0;if(_>>>0>=10){d=10;do{d=d*10|0;s=s+1|0}while(_>>>0>=d>>>0)}}else s=0;y=(k|0)==103;M=(l|0)!=0;d=l-((k|0)!=102?s:0)+((M&y)<<31>>31)|0;if((d|0)<(((i-T>>2)*9|0)+-9|0)){d=d+9216|0;h=C+4+(((d|0)/9|0)+-1024<<2)|0;d=((d|0)%9|0)+1|0;if((d|0)<9){_=10;do{_=_*10|0;d=d+1|0}while((d|0)!=9)}else _=10;p=u[h>>2]|0;m=(p>>>0)%(_>>>0)|0;d=(h+4|0)==(i|0);if(!(d&(m|0)==0)){b=(((p>>>0)/(_>>>0)|0)&1|0)==0?9007199254740992.0:9007199254740994.0;g=(_|0)/2|0;e=m>>>0<g>>>0?.5:d&(m|0)==(g|0)?1.0:1.5;if(E){g=(t[S>>0]|0)==45;e=g?-e:e;b=g?-b:b}d=p-m|0;u[h>>2]=d;if(b+e!=b){g=d+_|0;u[h>>2]=g;if(g>>>0>999999999){s=h;while(1){d=s+-4|0;u[s>>2]=0;if(d>>>0<c>>>0){c=c+-4|0;u[c>>2]=0}g=(u[d>>2]|0)+1|0;u[d>>2]=g;if(g>>>0>999999999)s=d;else break}}else d=h;s=(T-c>>2)*9|0;p=u[c>>2]|0;if(p>>>0>=10){_=10;do{_=_*10|0;s=s+1|0}while(p>>>0>=_>>>0)}}else d=h}else d=h;d=d+4|0;d=i>>>0>d>>>0?d:i;g=c}else{d=i;g=c}k=d;while(1){if(k>>>0<=g>>>0){w=0;break}c=k+-4|0;if(!(u[c>>2]|0))k=c;else{w=1;break}}i=0-s|0;do{if(y){c=((M^1)&1)+l|0;if((c|0)>(s|0)&(s|0)>-5){_=f+-1|0;l=c+-1-s|0}else{_=f+-2|0;l=c+-1|0}c=a&8;if(!c){if(w?(A=u[k+-4>>2]|0,(A|0)!=0):0){if(!((A>>>0)%10|0)){d=0;c=10;do{c=c*10|0;d=d+1|0}while(!((A>>>0)%(c>>>0)|0|0))}else d=0}else d=9;c=((k-T>>2)*9|0)+-9|0;if((_|32|0)==102){h=c-d|0;h=(h|0)>0?h:0;l=(l|0)<(h|0)?l:h;h=0;break}else{h=c+s-d|0;h=(h|0)>0?h:0;l=(l|0)<(h|0)?l:h;h=0;break}}else h=c}else{_=f;h=a&8}}while(0);y=l|h;p=(y|0)!=0&1;m=(_|32|0)==102;if(m){M=0;c=(s|0)>0?s:0}else{c=(s|0)<0?i:s;c=vE(c,((c|0)<0)<<31>>31,R)|0;d=R;if((d-c|0)<2)do{c=c+-1|0;t[c>>0]=48}while((d-c|0)<2);t[c+-1>>0]=(s>>31&2)+43;c=c+-2|0;t[c>>0]=_;M=c;c=d-c|0}c=E+1+l+p+c|0;bE(n,32,r,c,a);cE(n,S,E);bE(n,48,r,c,a^65536);if(m){_=g>>>0>C>>>0?C:g;h=B+9|0;p=h;m=B+8|0;d=_;do{s=vE(u[d>>2]|0,0,h)|0;if((d|0)==(_|0)){if((s|0)==(h|0)){t[m>>0]=48;s=m}}else if(s>>>0>B>>>0){eC(B|0,48,s-P|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}cE(n,s,p-s|0);d=d+4|0}while(d>>>0<=C>>>0);if(y|0)cE(n,5710,1);if(d>>>0<k>>>0&(l|0)>0)while(1){s=vE(u[d>>2]|0,0,h)|0;if(s>>>0>B>>>0){eC(B|0,48,s-P|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}cE(n,s,(l|0)<9?l:9);d=d+4|0;s=l+-9|0;if(!(d>>>0<k>>>0&(l|0)>9)){l=s;break}else l=s}bE(n,48,l+9|0,9,0)}else{y=w?k:g+4|0;if((l|0)>-1){w=B+9|0;h=(h|0)==0;i=w;p=0-P|0;m=B+8|0;_=g;do{s=vE(u[_>>2]|0,0,w)|0;if((s|0)==(w|0)){t[m>>0]=48;s=m}do{if((_|0)==(g|0)){d=s+1|0;cE(n,s,1);if(h&(l|0)<1){s=d;break}cE(n,5710,1);s=d}else{if(s>>>0<=B>>>0)break;eC(B|0,48,s+p|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}}while(0);P=i-s|0;cE(n,s,(l|0)>(P|0)?P:l);l=l-P|0;_=_+4|0}while(_>>>0<y>>>0&(l|0)>-1)}bE(n,48,l+18|0,18,0);cE(n,M,R-M|0)}bE(n,32,r,c,a^8192)}else{B=(f&32|0)!=0;c=E+3|0;bE(n,32,r,c,a&-65537);cE(n,S,E);cE(n,e!=e|0.0!=0.0?B?5686:5690:B?5678:5682,3);bE(n,32,r,c,a^8192)}}while(0);v=O;return((c|0)<(r|0)?r:c)|0}function wE(n){n=+n;var e=0;l[d>>3]=n;e=u[d>>2]|0;L=u[d+4>>2]|0;return e|0}function ME(n,e){n=+n;e=e|0;return+ +kE(n,e)}function kE(n,e){n=+n;e=e|0;var r=0,t=0,i=0;l[d>>3]=n;r=u[d>>2]|0;t=u[d+4>>2]|0;i=tC(r|0,t|0,52)|0;switch(i&2047){case 0:{if(n!=0.0){n=+kE(n*18446744073709551616.0,e);r=(u[e>>2]|0)+-64|0}else r=0;u[e>>2]=r;break}case 2047:break;default:{u[e>>2]=(i&2047)+-1022;u[d>>2]=r;u[d+4>>2]=t&-2146435073|1071644672;n=+l[d>>3]}}return+n}function gE(n,e,r){n=n|0;e=e|0;r=r|0;do{if(n){if(e>>>0<128){t[n>>0]=e;n=1;break}if(!(u[u[(TE()|0)+188>>2]>>2]|0))if((e&-128|0)==57216){t[n>>0]=e;n=1;break}else{u[(QS()|0)>>2]=84;n=-1;break}if(e>>>0<2048){t[n>>0]=e>>>6|192;t[n+1>>0]=e&63|128;n=2;break}if(e>>>0<55296|(e&-8192|0)==57344){t[n>>0]=e>>>12|224;t[n+1>>0]=e>>>6&63|128;t[n+2>>0]=e&63|128;n=3;break}if((e+-65536|0)>>>0<1048576){t[n>>0]=e>>>18|240;t[n+1>>0]=e>>>12&63|128;t[n+2>>0]=e>>>6&63|128;t[n+3>>0]=e&63|128;n=4;break}else{u[(QS()|0)>>2]=84;n=-1;break}}else n=1}while(0);return n|0}function TE(){return nE()|0}function AE(){return nE()|0}function SE(n,e){n=n|0;e=e|0;var r=0,i=0;i=0;while(1){if((o[5712+i>>0]|0)==(n|0)){n=2;break}r=i+1|0;if((r|0)==87){r=5800;i=87;n=5;break}else i=r}if((n|0)==2)if(!i)r=5800;else{r=5800;n=5}if((n|0)==5)while(1){do{n=r;r=r+1|0}while((t[n>>0]|0)!=0);i=i+-1|0;if(!i)break;else n=5}return EE(r,u[e+20>>2]|0)|0}function EE(n,e){n=n|0;e=e|0;return CE(n,e)|0}function CE(n,e){n=n|0;e=e|0;if(!e)e=0;else e=LE(u[e>>2]|0,u[e+4>>2]|0,n)|0;return(e|0?e:n)|0}function LE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,v=0;v=(u[n>>2]|0)+1794895138|0;a=RE(u[n+8>>2]|0,v)|0;i=RE(u[n+12>>2]|0,v)|0;o=RE(u[n+16>>2]|0,v)|0;n:do{if((a>>>0<e>>>2>>>0?(_=e-(a<<2)|0,i>>>0<_>>>0&o>>>0<_>>>0):0)?((o|i)&3|0)==0:0){_=i>>>2;d=o>>>2;s=0;while(1){c=a>>>1;l=s+c|0;f=l<<1;o=f+_|0;i=RE(u[n+(o<<2)>>2]|0,v)|0;o=RE(u[n+(o+1<<2)>>2]|0,v)|0;if(!(o>>>0<e>>>0&i>>>0<(e-o|0)>>>0)){i=0;break n}if(t[n+(o+i)>>0]|0){i=0;break n}i=tE(r,n+o|0)|0;if(!i)break;i=(i|0)<0;if((a|0)==1){i=0;break n}else{s=i?s:l;a=i?c:a-c|0}}i=f+d|0;o=RE(u[n+(i<<2)>>2]|0,v)|0;i=RE(u[n+(i+1<<2)>>2]|0,v)|0;if(i>>>0<e>>>0&o>>>0<(e-i|0)>>>0)i=(t[n+(i+o)>>0]|0)==0?n+i|0:0;else i=0}else i=0}while(0);return i|0}function RE(n,e){n=n|0;e=e|0;var r=0;r=sC(n|0)|0;return((e|0)==0?n:r)|0}function PE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0;i=r+16|0;o=u[i>>2]|0;if(!o){if(!(BE(r)|0)){o=u[i>>2]|0;a=5}else i=0}else a=5;n:do{if((a|0)==5){c=r+20|0;f=u[c>>2]|0;i=f;if((o-f|0)>>>0<e>>>0){i=yL[u[r+36>>2]&7](r,n,e)|0;break}e:do{if((t[r+75>>0]|0)>-1){f=e;while(1){if(!f){a=0;o=n;break e}o=f+-1|0;if((t[n+o>>0]|0)==10)break;else f=o}i=yL[u[r+36>>2]&7](r,n,f)|0;if(i>>>0<f>>>0)break n;a=f;o=n+f|0;e=e-f|0;i=u[c>>2]|0}else{a=0;o=n}}while(0);iC(i|0,o|0,e|0)|0;u[c>>2]=(u[c>>2]|0)+e;i=a+e|0}}while(0);return i|0}function BE(n){n=n|0;var e=0,r=0;e=n+74|0;r=t[e>>0]|0;t[e>>0]=r+255|r;e=u[n>>2]|0;if(!(e&8)){u[n+8>>2]=0;u[n+4>>2]=0;r=u[n+44>>2]|0;u[n+28>>2]=r;u[n+20>>2]=r;u[n+16>>2]=r+(u[n+48>>2]|0);n=0}else{u[n>>2]=e|32;n=-1}return n|0}function OE(n,e){n=K(n);e=K(e);var r=0,t=0;r=NE(n)|0;do{if((r&2147483647)>>>0<=2139095040){t=NE(e)|0;if((t&2147483647)>>>0<=2139095040)if((t^r|0)<0){n=(r|0)<0?e:n;break}else{n=n<e?e:n;break}}else n=e}while(0);return K(n)}function NE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function IE(n,e){n=K(n);e=K(e);var r=0,t=0;r=FE(n)|0;do{if((r&2147483647)>>>0<=2139095040){t=FE(e)|0;if((t&2147483647)>>>0<=2139095040)if((t^r|0)<0){n=(r|0)<0?n:e;break}else{n=n<e?n:e;break}}else n=e}while(0);return K(n)}function FE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function xE(n,e){n=K(n);e=K(e);var r=0,t=0,i=0,o=0,a=0,f=0,l=0,s=0;o=(c[d>>2]=n,u[d>>2]|0);f=(c[d>>2]=e,u[d>>2]|0);r=o>>>23&255;a=f>>>23&255;l=o&-2147483648;i=f<<1;n:do{if((i|0)!=0?!((r|0)==255|((UE(e)|0)&2147483647)>>>0>2139095040):0){t=o<<1;if(t>>>0<=i>>>0){e=K(n*K(0.0));return K((t|0)==(i|0)?e:n)}if(!r){r=o<<9;if((r|0)>-1){t=r;r=0;do{r=r+-1|0;t=t<<1}while((t|0)>-1)}else r=0;t=o<<1-r}else t=o&8388607|8388608;if(!a){o=f<<9;if((o|0)>-1){i=0;do{i=i+-1|0;o=o<<1}while((o|0)>-1)}else i=0;a=i;f=f<<1-i}else f=f&8388607|8388608;i=t-f|0;o=(i|0)>-1;e:do{if((r|0)>(a|0)){while(1){if(o)if(!i)break;else t=i;t=t<<1;r=r+-1|0;i=t-f|0;o=(i|0)>-1;if((r|0)<=(a|0))break e}e=K(n*K(0.0));break n}}while(0);if(o)if(!i){e=K(n*K(0.0));break}else t=i;if(t>>>0<8388608)do{t=t<<1;r=r+-1|0}while(t>>>0<8388608);if((r|0)>0)r=t+-8388608|r<<23;else r=t>>>(1-r|0);e=(u[d>>2]=r|l,K(c[d>>2]))}else s=3}while(0);if((s|0)==3){e=K(n*e);e=K(e/e)}return K(e)}function UE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function HE(n,e){n=n|0;e=e|0;return uE(u[582]|0,n,e)|0}function DE(n){n=n|0;Xn()}function WE(n){n=n|0;return}function YE(n,e){n=n|0;e=e|0;return 0}function VE(n){n=n|0;if((jE(n+4|0)|0)==-1){vL[u[(u[n>>2]|0)+8>>2]&127](n);n=1}else n=0;return n|0}function jE(n){n=n|0;var e=0;e=u[n>>2]|0;u[n>>2]=e+-1;return e+-1|0}function qE(n){n=n|0;if(VE(n)|0)zE(n);return}function zE(n){n=n|0;var e=0;e=n+8|0;if(!((u[e>>2]|0)!=0?(jE(e)|0)!=-1:0))vL[u[(u[n>>2]|0)+16>>2]&127](n);return}function GE(n){n=n|0;var e=0;e=(n|0)==0?1:n;while(1){n=qS(e)|0;if(n|0)break;n=ZE()|0;if(!n){n=0;break}BL[n&0]()}return n|0}function KE(n){n=n|0;return GE(n)|0}function XE(n){n=n|0;zS(n);return}function JE(n){n=n|0;if((t[n+11>>0]|0)<0)XE(u[n>>2]|0);return}function ZE(){var n=0;n=u[2923]|0;u[2923]=n+0;return n|0}function QE(){}function $E(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=e-t-(r>>>0>n>>>0|0)>>>0;return(L=t,n-r>>>0|0)|0}function nC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;r=n+r>>>0;return(L=e+t+(r>>>0<n>>>0|0)>>>0,r|0)|0}function eC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0;a=n+r|0;e=e&255;if((r|0)>=67){while(n&3){t[n>>0]=e;n=n+1|0}i=a&-4|0;o=i-64|0;f=e|e<<8|e<<16|e<<24;while((n|0)<=(o|0)){u[n>>2]=f;u[n+4>>2]=f;u[n+8>>2]=f;u[n+12>>2]=f;u[n+16>>2]=f;u[n+20>>2]=f;u[n+24>>2]=f;u[n+28>>2]=f;u[n+32>>2]=f;u[n+36>>2]=f;u[n+40>>2]=f;u[n+44>>2]=f;u[n+48>>2]=f;u[n+52>>2]=f;u[n+56>>2]=f;u[n+60>>2]=f;n=n+64|0}while((n|0)<(i|0)){u[n>>2]=f;n=n+4|0}}while((n|0)<(a|0)){t[n>>0]=e;n=n+1|0}return a-r|0}function rC(n,e,r){n=n|0;e=e|0;r=r|0;if((r|0)<32){L=e<<r|(n&(1<<r)-1<<32-r)>>>32-r;return n<<r}L=n<<r-32;return 0}function tC(n,e,r){n=n|0;e=e|0;r=r|0;if((r|0)<32){L=e>>>r;return n>>>r|(e&(1<<r)-1)<<32-r}L=0;return e>>>r-32|0}function iC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0;if((r|0)>=8192)return jn(n|0,e|0,r|0)|0;a=n|0;o=n+r|0;if((n&3)==(e&3)){while(n&3){if(!r)return a|0;t[n>>0]=t[e>>0]|0;n=n+1|0;e=e+1|0;r=r-1|0}r=o&-4|0;i=r-64|0;while((n|0)<=(i|0)){u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2];u[n+16>>2]=u[e+16>>2];u[n+20>>2]=u[e+20>>2];u[n+24>>2]=u[e+24>>2];u[n+28>>2]=u[e+28>>2];u[n+32>>2]=u[e+32>>2];u[n+36>>2]=u[e+36>>2];u[n+40>>2]=u[e+40>>2];u[n+44>>2]=u[e+44>>2];u[n+48>>2]=u[e+48>>2];u[n+52>>2]=u[e+52>>2];u[n+56>>2]=u[e+56>>2];u[n+60>>2]=u[e+60>>2];n=n+64|0;e=e+64|0}while((n|0)<(r|0)){u[n>>2]=u[e>>2];n=n+4|0;e=e+4|0}}else{r=o-4|0;while((n|0)<(r|0)){t[n>>0]=t[e>>0]|0;t[n+1>>0]=t[e+1>>0]|0;t[n+2>>0]=t[e+2>>0]|0;t[n+3>>0]=t[e+3>>0]|0;n=n+4|0;e=e+4|0}}while((n|0)<(o|0)){t[n>>0]=t[e>>0]|0;n=n+1|0;e=e+1|0}return a|0}function uC(n){n=n|0;var e=0;e=t[m+(n&255)>>0]|0;if((e|0)<8)return e|0;e=t[m+(n>>8&255)>>0]|0;if((e|0)<8)return e+8|0;e=t[m+(n>>16&255)>>0]|0;if((e|0)<8)return e+16|0;return(t[m+(n>>>24)>>0]|0)+24|0}function oC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,v=0,p=0;s=n;c=e;l=c;a=r;_=t;f=_;if(!l){o=(i|0)!=0;if(!f){if(o){u[i>>2]=(s>>>0)%(a>>>0);u[i+4>>2]=0}_=0;i=(s>>>0)/(a>>>0)>>>0;return(L=_,i)|0}else{if(!o){_=0;i=0;return(L=_,i)|0}u[i>>2]=n|0;u[i+4>>2]=e&0;_=0;i=0;return(L=_,i)|0}}o=(f|0)==0;do{if(a){if(!o){o=(G(f|0)|0)-(G(l|0)|0)|0;if(o>>>0<=31){d=o+1|0;f=31-o|0;e=o-31>>31;a=d;n=s>>>(d>>>0)&e|l<<f;e=l>>>(d>>>0)&e;o=0;f=s<<f;break}if(!i){_=0;i=0;return(L=_,i)|0}u[i>>2]=n|0;u[i+4>>2]=c|e&0;_=0;i=0;return(L=_,i)|0}o=a-1|0;if(o&a|0){f=(G(a|0)|0)+33-(G(l|0)|0)|0;p=64-f|0;d=32-f|0;c=d>>31;v=f-32|0;e=v>>31;a=f;n=d-1>>31&l>>>(v>>>0)|(l<<d|s>>>(f>>>0))&e;e=e&l>>>(f>>>0);o=s<<p&c;f=(l<<p|s>>>(v>>>0))&c|s<<d&f-33>>31;break}if(i|0){u[i>>2]=o&s;u[i+4>>2]=0}if((a|0)==1){v=c|e&0;p=n|0|0;return(L=v,p)|0}else{p=uC(a|0)|0;v=l>>>(p>>>0)|0;p=l<<32-p|s>>>(p>>>0)|0;return(L=v,p)|0}}else{if(o){if(i|0){u[i>>2]=(l>>>0)%(a>>>0);u[i+4>>2]=0}v=0;p=(l>>>0)/(a>>>0)>>>0;return(L=v,p)|0}if(!s){if(i|0){u[i>>2]=0;u[i+4>>2]=(l>>>0)%(f>>>0)}v=0;p=(l>>>0)/(f>>>0)>>>0;return(L=v,p)|0}o=f-1|0;if(!(o&f)){if(i|0){u[i>>2]=n|0;u[i+4>>2]=o&l|e&0}v=0;p=l>>>((uC(f|0)|0)>>>0);return(L=v,p)|0}o=(G(f|0)|0)-(G(l|0)|0)|0;if(o>>>0<=30){e=o+1|0;f=31-o|0;a=e;n=l<<f|s>>>(e>>>0);e=l>>>(e>>>0);o=0;f=s<<f;break}if(!i){v=0;p=0;return(L=v,p)|0}u[i>>2]=n|0;u[i+4>>2]=c|e&0;v=0;p=0;return(L=v,p)|0}}while(0);if(!a){l=f;c=0;f=0}else{d=r|0|0;s=_|t&0;l=nC(d|0,s|0,-1,-1)|0;r=L;c=f;f=0;do{t=c;c=o>>>31|c<<1;o=f|o<<1;t=n<<1|t>>>31|0;_=n>>>31|e<<1|0;$E(l|0,r|0,t|0,_|0)|0;p=L;v=p>>31|((p|0)<0?-1:0)<<1;f=v&1;n=$E(t|0,_|0,v&d|0,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&s|0)|0;e=L;a=a-1|0}while((a|0)!=0);l=c;c=0}a=0;if(i|0){u[i>>2]=n;u[i+4>>2]=e}v=(o|0)>>>31|(l|a)<<1|(a<<1|o>>>31)&0|c;p=(o<<1|0>>>31)&-2|f;return(L=v,p)|0}function aC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return oC(n,e,r,t,0)|0}function fC(n){n=n|0;var e=0,r=0;r=n+15&-16|0;e=u[s>>2]|0;n=e+r|0;if((r|0)>0&(n|0)<(e|0)|(n|0)<0){$()|0;zn(12);return-1}u[s>>2]=n;if((n|0)>(Q()|0)?(Z()|0)==0:0){u[s>>2]=e;zn(12);return-1}return e|0}function cC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0;if((e|0)<(n|0)&(n|0)<(e+r|0)){i=n;e=e+r|0;n=n+r|0;while((r|0)>0){n=n-1|0;e=e-1|0;r=r-1|0;t[n>>0]=t[e>>0]|0}n=i}else iC(n,e,r)|0;return n|0}function lC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=v;v=v+16|0;i=o|0;oC(n,e,r,t,i)|0;v=o;return(L=u[i+4>>2]|0,u[i>>2]|0)|0}function sC(n){n=n|0;return(n&255)<<24|(n>>8&255)<<16|(n>>16&255)<<8|n>>>24|0}function dC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;lL[n&1](e|0,r|0,t|0,i|0,u|0)}function _C(n,e,r){n=n|0;e=e|0;r=K(r);sL[n&1](e|0,K(r))}function vC(n,e,r){n=n|0;e=e|0;r=+r;dL[n&31](e|0,+r)}function pC(n,e,r,t){n=n|0;e=e|0;r=K(r);t=K(t);return K(_L[n&0](e|0,K(r),K(t)))}function mC(n,e){n=n|0;e=e|0;vL[n&127](e|0)}function bC(n,e,r){n=n|0;e=e|0;r=r|0;pL[n&31](e|0,r|0)}function hC(n,e){n=n|0;e=e|0;return mL[n&31](e|0)|0}function yC(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;bL[n&1](e|0,+r,+t,i|0)}function wC(n,e,r,t){n=n|0;e=e|0;r=+r;t=+t;hL[n&1](e|0,+r,+t)}function MC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return yL[n&7](e|0,r|0,t|0)|0}function kC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return+wL[n&1](e|0,r|0,t|0)}function gC(n,e){n=n|0;e=e|0;return+ML[n&15](e|0)}function TC(n,e,r){n=n|0;e=e|0;r=+r;return kL[n&1](e|0,+r)|0}function AC(n,e,r){n=n|0;e=e|0;r=r|0;return gL[n&15](e|0,r|0)|0}function SC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=+t;i=+i;u=u|0;TL[n&1](e|0,r|0,+t,+i,u|0)}function EC(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;o=o|0;AL[n&1](e|0,r|0,t|0,i|0,u|0,o|0)}function CC(n,e,r){n=n|0;e=e|0;r=r|0;return+SL[n&7](e|0,r|0)}function LC(n){n=n|0;return EL[n&7]()|0}function RC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;return CL[n&1](e|0,r|0,t|0,i|0,u|0)|0}function PC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=+i;LL[n&1](e|0,r|0,t|0,+i)}function BC(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=K(t);i=i|0;u=K(u);o=o|0;RL[n&1](e|0,r|0,K(t),i|0,K(u),o|0)}function OC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;PL[n&15](e|0,r|0,t|0)}function NC(n){n=n|0;BL[n&0]()}function IC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;OL[n&15](e|0,r|0,+t)}function FC(n,e,r){n=n|0;e=+e;r=+r;return NL[n&1](+e,+r)|0}function xC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;IL[n&15](e|0,r|0,t|0,i|0)}function UC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;X(0)}function HC(n,e){n=n|0;e=K(e);X(1)}function DC(n,e){n=n|0;e=+e;X(2)}function WC(n,e,r){n=n|0;e=K(e);r=K(r);X(3);return de}function YC(n){n=n|0;X(4)}function VC(n,e){n=n|0;e=e|0;X(5)}function jC(n){n=n|0;X(6);return 0}function qC(n,e,r,t){n=n|0;e=+e;r=+r;t=t|0;X(7)}function zC(n,e,r){n=n|0;e=+e;r=+r;X(8)}function GC(n,e,r){n=n|0;e=e|0;r=r|0;X(9);return 0}function KC(n,e,r){n=n|0;e=e|0;r=r|0;X(10);return 0.0}function XC(n){n=n|0;X(11);return 0.0}function JC(n,e){n=n|0;e=+e;X(12);return 0}function ZC(n,e){n=n|0;e=e|0;X(13);return 0}function QC(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;X(14)}function $C(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;X(15)}function nL(n,e){n=n|0;e=e|0;X(16);return 0.0}function eL(){X(17);return 0}function rL(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;X(18);return 0}function tL(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;X(19)}function iL(n,e,r,t,i,u){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);u=u|0;X(20)}function uL(n,e,r){n=n|0;e=e|0;r=r|0;X(21)}function oL(){X(22)}function aL(n,e,r){n=n|0;e=e|0;r=+r;X(23)}function fL(n,e){n=+n;e=+e;X(24);return 0}function cL(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;X(25)}var lL=[UC,gk];var sL=[HC,qi];var dL=[DC,bu,hu,yu,wu,Mu,ku,gu,Au,Su,Cu,Lu,Ru,Pu,Bu,Ou,Nu,Iu,Fu,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC];var _L=[WC];var vL=[YC,WE,pf,mf,bf,Xd,Jd,Zd,hw,yw,ww,uk,ok,ak,oS,aS,fS,Me,Ji,eu,Tu,Eu,Ho,Do,Xa,Af,Vf,vc,Nc,il,El,zl,ds,Ns,$s,hd,xd,b_,F_,ev,wv,Hv,ip,Sp,jp,am,Cm,Yi,lb,Lb,Zb,hh,Fh,uy,by,wy,Dy,Vy,aw,gw,Sw,zw,_M,Sf,Rg,_T,PT,XT,wA,UA,JA,$A,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC];var pL=[VC,ru,tu,ou,au,fu,cu,lu,su,vu,pu,mu,$u,ro,to,io,uo,oo,ao,_o,bo,Xo,Rp,Gp,kh,Og,MM,nT,VC,VC,VC,VC];var mL=[jC,KS,Xi,Du,ju,qu,zu,Gu,Ku,Xu,Zu,Qu,vo,po,Wo,Pm,Dh,Xw,Ug,Dg,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC];var bL=[qC,Yo];var hL=[zC,lw];var yL=[GC,XS,JS,rE,fl,M_,vb,$T];var wL=[KC,td];var ML=[XC,no,eo,fo,Vo,jo,qo,zo,Go,Ko,XC,XC,XC,XC,XC,XC];var kL=[JC,_y];var gL=[ZC,YE,mo,ef,hc,Pl,Jl,Wd,D_,sm,zi,IT,ZC,ZC,ZC,ZC];var TL=[QC,Gf];var AL=[$C,TA];var SL=[nL,co,Jo,Zo,Qo,kd,nL,nL];var EL=[eL,$o,Gi,Di,Ay,Gy,Pw,tS];var CL=[rL,Ft];var LL=[tL,Tv];var RL=[iL,yo];var PL=[uL,Wu,Ju,lo,so,Uc,ms,Vv,fp,ji,Qk,bT,YA,uL,uL,uL];var BL=[oL];var OL=[aL,iu,uu,du,_u,xu,Uu,Hu,uv,Ob,fy,aL,aL,aL,aL,aL];var NL=[fL,pw];var IL=[cL,Us,Hm,eh,Xh,Py,$y,Uw,hM,qg,vS,cL,cL,cL,cL,cL];return{_llvm_bswap_i32:sC,dynCall_idd:FC,dynCall_i:LC,_i64Subtract:$E,___udivdi3:aC,dynCall_vif:_C,setThrew:be,dynCall_viii:OC,_bitshift64Lshr:tC,_bitshift64Shl:rC,dynCall_vi:mC,dynCall_viiddi:SC,dynCall_diii:kC,dynCall_iii:AC,_memset:eC,_sbrk:fC,_memcpy:iC,__GLOBAL__sub_I_Yoga_cpp:Hi,dynCall_vii:bC,___uremdi3:lC,dynCall_vid:vC,stackAlloc:_e,_nbind_init:LS,getTempRet0:ye,dynCall_di:gC,dynCall_iid:TC,setTempRet0:he,_i64Add:nC,dynCall_fiff:pC,dynCall_iiii:MC,_emscripten_get_global_libc:GS,dynCall_viid:IC,dynCall_viiid:PC,dynCall_viififi:BC,dynCall_ii:hC,__GLOBAL__sub_I_Binding_cc:Mg,dynCall_viiii:xC,dynCall_iiiiii:RC,stackSave:ve,dynCall_viiiii:dC,__GLOBAL__sub_I_nbind_cc:na,dynCall_vidd:wC,_free:zS,runPostSets:QE,dynCall_viiiiii:EC,establishStackSpace:me,_memmove:cC,stackRestore:pe,_malloc:qS,__GLOBAL__sub_I_common_cc:iM,dynCall_viddi:yC,dynCall_dii:CC,dynCall_v:NC}}(Module.asmGlobalArg,Module.asmLibraryArg,buffer),_llvm_bswap_i32=Module._llvm_bswap_i32=asm._llvm_bswap_i32,getTempRet0=Module.getTempRet0=asm.getTempRet0,___udivdi3=Module.___udivdi3=asm.___udivdi3,setThrew=Module.setThrew=asm.setThrew,_bitshift64Lshr=Module._bitshift64Lshr=asm._bitshift64Lshr,_bitshift64Shl=Module._bitshift64Shl=asm._bitshift64Shl,_memset=Module._memset=asm._memset,_sbrk=Module._sbrk=asm._sbrk,_memcpy=Module._memcpy=asm._memcpy,stackAlloc=Module.stackAlloc=asm.stackAlloc,___uremdi3=Module.___uremdi3=asm.___uremdi3,_nbind_init=Module._nbind_init=asm._nbind_init,_i64Subtract=Module._i64Subtract=asm._i64Subtract,setTempRet0=Module.setTempRet0=asm.setTempRet0,_i64Add=Module._i64Add=asm._i64Add,_emscripten_get_global_libc=Module._emscripten_get_global_libc=asm._emscripten_get_global_libc,__GLOBAL__sub_I_Yoga_cpp=Module.__GLOBAL__sub_I_Yoga_cpp=asm.__GLOBAL__sub_I_Yoga_cpp,__GLOBAL__sub_I_Binding_cc=Module.__GLOBAL__sub_I_Binding_cc=asm.__GLOBAL__sub_I_Binding_cc,stackSave=Module.stackSave=asm.stackSave,__GLOBAL__sub_I_nbind_cc=Module.__GLOBAL__sub_I_nbind_cc=asm.__GLOBAL__sub_I_nbind_cc,_free=Module._free=asm._free,runPostSets=Module.runPostSets=asm.runPostSets,establishStackSpace=Module.establishStackSpace=asm.establishStackSpace,_memmove=Module._memmove=asm._memmove,stackRestore=Module.stackRestore=asm.stackRestore,_malloc=Module._malloc=asm._malloc,__GLOBAL__sub_I_common_cc=Module.__GLOBAL__sub_I_common_cc=asm.__GLOBAL__sub_I_common_cc,dynCall_viiiii=Module.dynCall_viiiii=asm.dynCall_viiiii,dynCall_vif=Module.dynCall_vif=asm.dynCall_vif,dynCall_vid=Module.dynCall_vid=asm.dynCall_vid,dynCall_fiff=Module.dynCall_fiff=asm.dynCall_fiff,dynCall_vi=Module.dynCall_vi=asm.dynCall_vi,dynCall_vii=Module.dynCall_vii=asm.dynCall_vii,dynCall_ii=Module.dynCall_ii=asm.dynCall_ii,dynCall_viddi=Module.dynCall_viddi=asm.dynCall_viddi,dynCall_vidd=Module.dynCall_vidd=asm.dynCall_vidd,dynCall_iiii=Module.dynCall_iiii=asm.dynCall_iiii,dynCall_diii=Module.dynCall_diii=asm.dynCall_diii,dynCall_di=Module.dynCall_di=asm.dynCall_di,dynCall_iid=Module.dynCall_iid=asm.dynCall_iid,dynCall_iii=Module.dynCall_iii=asm.dynCall_iii,dynCall_viiddi=Module.dynCall_viiddi=asm.dynCall_viiddi,dynCall_viiiiii=Module.dynCall_viiiiii=asm.dynCall_viiiiii,dynCall_dii=Module.dynCall_dii=asm.dynCall_dii,dynCall_i=Module.dynCall_i=asm.dynCall_i,dynCall_iiiiii=Module.dynCall_iiiiii=asm.dynCall_iiiiii,dynCall_viiid=Module.dynCall_viiid=asm.dynCall_viiid,dynCall_viififi=Module.dynCall_viififi=asm.dynCall_viififi,dynCall_viii=Module.dynCall_viii=asm.dynCall_viii,dynCall_v=Module.dynCall_v=asm.dynCall_v,dynCall_viid=Module.dynCall_viid=asm.dynCall_viid,dynCall_idd=Module.dynCall_idd=asm.dynCall_idd,dynCall_viiii=Module.dynCall_viiii=asm.dynCall_viiii,initialStackTop;function ExitStatus(n){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+n+\")\",this.status=n}Runtime.stackAlloc=Module.stackAlloc,Runtime.stackSave=Module.stackSave,Runtime.stackRestore=Module.stackRestore,Runtime.establishStackSpace=Module.establishStackSpace,Runtime.setTempRet0=Module.setTempRet0,Runtime.getTempRet0=Module.getTempRet0,Module.asm=asm,ExitStatus.prototype=new Error,ExitStatus.prototype.constructor=ExitStatus;var preloadStartTime=null,calledMain=!1;function run(n){function e(){Module.calledRun||(Module.calledRun=!0,ABORT||(ensureInitRuntime(),preMain(),Module.onRuntimeInitialized&&Module.onRuntimeInitialized(),Module._main&&shouldRunNow&&Module.callMain(n),postRun()))}n=n||Module.arguments,null===preloadStartTime&&(preloadStartTime=Date.now()),runDependencies>0||(preRun(),runDependencies>0||Module.calledRun||(Module.setStatus?(Module.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){Module.setStatus(\"\")}),1),e()}),1)):e()))}function exit(n,e){e&&Module.noExitRuntime||(Module.noExitRuntime||(ABORT=!0,EXITSTATUS=n,STACKTOP=initialStackTop,exitRuntime(),Module.onExit&&Module.onExit(n)),ENVIRONMENT_IS_NODE&&process.exit(n),Module.quit(n,new ExitStatus(n)))}dependenciesFulfilled=function n(){Module.calledRun||run(),Module.calledRun||(dependenciesFulfilled=n)},Module.callMain=Module.callMain=function(n){n=n||[],ensureInitRuntime();var e=n.length+1;function r(){for(var n=0;n<3;n++)t.push(0)}var t=[allocate(intArrayFromString(Module.thisProgram),\"i8\",ALLOC_NORMAL)];r();for(var i=0;i<e-1;i+=1)t.push(allocate(intArrayFromString(n[i]),\"i8\",ALLOC_NORMAL)),r();t.push(0),t=allocate(t,\"i32\",ALLOC_NORMAL);try{exit(Module._main(e,t,0),!0)}catch(n){if(n instanceof ExitStatus)return;if(\"SimulateInfiniteLoop\"==n)return void(Module.noExitRuntime=!0);var u=n;n&&\"object\"==typeof n&&n.stack&&(u=[n,n.stack]),Module.printErr(\"exception thrown: \"+u),Module.quit(1,n)}finally{calledMain=!0}},Module.run=Module.run=run,Module.exit=Module.exit=exit;var abortDecorators=[];function abort(n){Module.onAbort&&Module.onAbort(n),void 0!==n?(Module.print(n),Module.printErr(n),n=JSON.stringify(n)):n=\"\",ABORT=!0,EXITSTATUS=1;var e=\"abort(\"+n+\") at \"+stackTrace()+\"\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.\";throw abortDecorators&&abortDecorators.forEach((function(r){e=r(e,n)})),e}if(Module.abort=Module.abort=abort,Module.preInit)for(\"function\"==typeof Module.preInit&&(Module.preInit=[Module.preInit]);Module.preInit.length>0;)Module.preInit.pop()();var shouldRunNow=!0;Module.noInitialRun&&(shouldRunNow=!1),run()}));"))($module);
	              var nbind = $module.exports;

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */




	  var ran = false;
	  var ret = null;

	  nbind({}, function (err, result) {
	    if (ran) {
	      return;
	    }

	    ran = true;

	    if (err) {
	      throw err;
	    }

	    ret = result;
	  });

	  if (!ran) {
	    throw new Error("Failed to load the yoga module - it needed to be loaded synchronously, but didn't");
	  }

	  // $FlowFixMe ret will not be null here
	  var entryBrowser = entryCommon(ret.bind, ret.lib);

	  return entryBrowser;

	}());


	  return Yoga
	}

	/**
	 * Main entry point. This issues a request to the web worker to perform flexbox layout
	 * on the given `styleTree`, calling the `callback` function with the results when finished.
	 *
	 * @param {FlexLayoutStyleNode} styleTree
	 * @param {function(FlexLayoutResult)} callback
	 */
	function requestFlexLayout(styleTree, callback) {
	  flexLayoutProcessorWorkerModule(styleTree).then(callback);
	}

	/**
	 * @typedef {object<FlexLayoutResultNode>} FlexLayoutResult
	 * Mapping of node ids to layout results.
	 */

	/**
	 * @typedef {object} FlexLayoutResultNode - layout result for a single flex node.
	 * @property {number} left - the node's computed left position
	 * @property {number} top - the node's computed top position
	 * @property {number} width - the node's computed width
	 * @property {number} height - the node's computed height
	 */


	/**
	 * @typedef {object} MeasureFunctionParams - Parameters for the `measureFunction`.
	 * @property {string} text
	 * @property {string} font
	 * @property {number} fontSize
	 * @property {number} lineHeight
	 * @property {number} letterSpacing
	 * @property {string} whiteSpace
	 * @property {string} overflowWrap
	 * @property {number} maxWidth
	 */

	/**
	 * Factory for the flex layout processing function. This is injected into a web worker so it
	 * must be entirely self-contained other than specific dependencies passed in as arguments.
	 * @param {object} Yoga - The yoga-layout implementation object.
	 * @param {function(fontUrl:string, callback:function)} loadFontFn - A function that
	 *        loads a given font URL, invoking a callback when complete.
	 * @param {function(MeasureFunctionParams):{width:number}} measureFunction - A function that
	 *        measures the intrinsic dimensions for a block of text with given styles and
	 *        constraints. The measurement must occur synchronously.
	 * @return {function(FlexLayoutStyleNode):FlexLayoutResult}
	 */
	function createFlexLayoutProcessor(Yoga, loadFontFn, measureFunction) {

	  var YOGA_VALUE_MAPPINGS = {
	    align: {
	      'auto': 'ALIGN_AUTO',
	      'baseline': 'ALIGN_BASELINE',
	      'center': 'ALIGN_CENTER',
	      'flex-end': 'ALIGN_FLEX_END',
	      'flex-start': 'ALIGN_FLEX_START',
	      'stretch': 'ALIGN_STRETCH'
	    },
	    direction: {
	      'column': 'FLEX_DIRECTION_COLUMN',
	      'column-reverse': 'FLEX_DIRECTION_COLUMN_REVERSE',
	      'row': 'FLEX_DIRECTION_ROW',
	      'row-reverse': 'FLEX_DIRECTION_ROW_REVERSE'
	    },
	    edge: {
	      top: 'EDGE_TOP',
	      right: 'EDGE_RIGHT',
	      bottom: 'EDGE_BOTTOM',
	      left: 'EDGE_LEFT',
	    },
	    justify: {
	      'center': 'JUSTIFY_CENTER',
	      'flex-end': 'JUSTIFY_FLEX_END',
	      'flex-start': 'JUSTIFY_FLEX_START',
	      'space-around': 'JUSTIFY_SPACE_AROUND',
	      'space-between': 'JUSTIFY_SPACE_BETWEEN'
	    },
	    position: {
	      'absolute': 'POSITION_TYPE_ABSOLUTE',
	      'relative': 'POSITION_TYPE_RELATIVE'
	    },
	    wrap: {
	      'nowrap': 'WRAP_NO_WRAP',
	      'wrap': 'WRAP_WRAP'
	    }
	  };

	  var sides = ['Top', 'Right', 'Bottom', 'Left'];

	  // Create functions for setting each supported style property on a Yoga node
	  var YOGA_SETTERS = Object.create(null)
	  // Simple properties
	  ;[
	    'width',
	    'height',
	    'minWidth',
	    'minHeight',
	    'maxWidth',
	    'maxHeight',
	    'aspectRatio',
	    ['flexDirection', YOGA_VALUE_MAPPINGS.direction],
	    'flex',
	    ['flexWrap', YOGA_VALUE_MAPPINGS.wrap],
	    'flexBasis',
	    'flexGrow',
	    'flexShrink',
	    ['alignContent', YOGA_VALUE_MAPPINGS.align],
	    ['alignItems', YOGA_VALUE_MAPPINGS.align],
	    ['alignSelf', YOGA_VALUE_MAPPINGS.align],
	    ['justifyContent', YOGA_VALUE_MAPPINGS.justify]
	  ].forEach(function (styleProp) {
	    var mapping = null;
	    if (Array.isArray(styleProp)) {
	      mapping = styleProp[1];
	      styleProp = styleProp[0];
	    }
	    var setter = "set" + (styleProp.charAt(0).toUpperCase()) + (styleProp.substr(1));
	    YOGA_SETTERS[styleProp] = mapping ?
	      function (yogaNode, value) {
	        if (mapping.hasOwnProperty(value)) {
	          value = Yoga[mapping[value]];
	          yogaNode[setter](value);
	        }
	      } :
	      function (yogaNode, value) {
	        yogaNode[setter](value);
	      };
	  });

	  // Position-related properties
	  YOGA_SETTERS.position = function (yogaNode, value) {
	    yogaNode.setPositionType(Yoga[YOGA_VALUE_MAPPINGS.position[value]]);
	  };
	  sides.forEach(function (side) {
	    var edgeConst = YOGA_VALUE_MAPPINGS.edge[side.toLowerCase()];
	    YOGA_SETTERS[side.toLowerCase()] = function (yogaNode, value) {
	      yogaNode.setPosition(Yoga[edgeConst], value);
	    };
	  })

	  // Multi-side properties
	  ;[
	    'margin',
	    'padding',
	    'border'
	  ].forEach(function (styleProp) {
	    sides.forEach(function (side) {
	      var edgeConst = YOGA_VALUE_MAPPINGS.edge[side.toLowerCase()];
	      var setter = "set" + (styleProp.charAt(0).toUpperCase()) + (styleProp.substr(1));
	      YOGA_SETTERS[("" + styleProp + side)] = function (yogaNode, value) {
	        yogaNode[setter](Yoga[edgeConst], value);
	      };
	    });
	  });



	  function ensureAllFontsLoaded(styleTree, callback) {
	    var fonts = [];
	    var loadedCount = 0;
	    walkStyleTree(styleTree, function (node) {
	      if (node.text) { fonts.push(node.font); } //may be undef
	    });
	    if (fonts.length) {
	      for (var i = 0; i < fonts.length; i++) {
	        loadFontFn(fonts[i], function () {
	          loadedCount++;
	          if (loadedCount === fonts.length) {
	            callback();
	          }
	        });
	      }
	    } else {
	      callback();
	    }
	  }

	  function walkStyleTree(styleTree, callback) {
	    callback(styleTree);
	    if (styleTree.children) {
	      for (var i = 0, len = styleTree.children.length; i < len; i++) {
	        walkStyleTree(styleTree.children[i], callback);
	      }
	    }
	  }

	  function process(styleTree, callback) {
	    // Init common node config
	    var yogaConfig = Yoga.Config.create();
	    yogaConfig.setPointScaleFactor(0); //disable value rounding

	    // Ensure all fonts required for measuring text nodes within this layout are pre-loaded,
	    // so that all text measurement calls can happen synchronously
	    ensureAllFontsLoaded(styleTree, function () {
	      // TODO for now, just to keep things simple, we'll rebuild the entire Yoga tree on every
	      // call, but we should look into persisting it across calls for more efficient updates

	      function populateNode(yogaNode, styleNode) {
	        if (!styleNode) {
	          throw new Error('Style node with no id')
	        }

	        for (var prop in styleNode) {
	          if (styleNode.hasOwnProperty(prop)) {
	            // Look for a style setter, and invoke it
	            var setter = YOGA_SETTERS[prop];
	            if (setter) {
	              setter(yogaNode, styleNode[prop]);
	            }
	            // If the node has text, set up its measurement function
	            else if (prop === 'text') {
	              yogaNode.setMeasureFunc(function (innerWidth, widthMeasureMode, innerHeight, heightMeasureMode) {
	                var params = {
	                  text: styleNode.text,
	                  font: styleNode.font,
	                  fontSize: styleNode.fontSize,
	                  lineHeight: styleNode.lineHeight,
	                  letterSpacing: styleNode.letterSpacing,
	                  whiteSpace: styleNode.whiteSpace,
	                  overflowWrap: styleNode.overflowWrap,
	                  maxWidth: isNaN(innerWidth) ? Infinity : innerWidth
	                };
	                // NOTE: this assumes the measureFunction will exec the callback synchronously; this works
	                // with current impl since we preload all needed fonts above, but it would be good to
	                // formalize that contract in the FontProcessor
	                var result = measureFunction(params);
	                if (result) {
	                  // Apply a fudge factor to avoid issues where the flexbox layout result using this
	                  // measurement ends up slightly smaller (due to rounding?) and making text wrap
	                  result.width += styleNode.fontSize * 0.00001;
	                }
	                return result || {width: 0, height: 0}
	              });
	            }
	          }
	        }

	        // Recurse to children
	        if (styleNode.children) {
	          for (var i = 0, len = styleNode.children.length; i < len; i++) {
	            var childYogaNode = Yoga.Node.createWithConfig(yogaConfig);
	            populateNode(childYogaNode, styleNode.children[i]);
	            yogaNode.insertChild(childYogaNode, i);
	          }
	        }

	        // Store the Yoga node on the style object, so we can access each Yoga node's original
	        // context when traversing post-layout
	        styleNode.yogaNode = yogaNode;
	      }
	      var root = Yoga.Node.createWithConfig(yogaConfig);
	      populateNode(root, styleTree);

	      // Perform the layout and collect the results as a flat id-to-computed-layout map
	      root.calculateLayout();
	      var results = Object.create(null);
	      walkStyleTree(styleTree, function (styleNode) {
	        var id = styleNode.id;
	        var yogaNode = styleNode.yogaNode;
	        results[id] = {
	          left: yogaNode.getComputedLeft(),
	          top: yogaNode.getComputedTop(),
	          width: yogaNode.getComputedWidth(),
	          height: yogaNode.getComputedHeight()
	        };
	      });
	      root.freeRecursive();

	      callback(results);
	    });
	  }

	  return process
	}


	var flexLayoutProcessorWorkerModule = defineWorkerModule({
	  name: 'FlexLayoutProcessor',
	  dependencies: [
	    yogaFactory,
	    fontProcessorWorkerModule,
	    createFlexLayoutProcessor,
	    ThenableWorkerModule
	  ],
	  init: function init(yogaFactory, fontProcessor, create, Thenable) {
	    var Yoga = yogaFactory();
	    function measure(params) {
	      var result = null;
	      fontProcessor.measure(params, function (r) {result = r;});
	      return result
	    }
	    var process = create(Yoga, fontProcessor.loadFont, measure);
	    return function(styleTree) {
	      var thenable = new Thenable();
	      process(styleTree, thenable.resolve);
	      return thenable
	    }
	  }
	});

	var assign$7 = assign;
	var createClassExtender$1 = createClassExtender;

	/**
	 * Extends a given Facade class to become a `FlexNode`, giving it the ability to participate
	 * in flexbox layout. The resulting class behaves just like the original facade class, except:
	 *
	 * - It now accepts a full set of flexbox-related input properties, defined below
	 * - Those input properties get evaluated by a flexbox layout algorithm in the background
	 * - The resulting layout metrics get written to the object as properties that the extended
	 *   facade class can use in its `afterUpdate` method to affect its position/size/styling.
	 *
	 * The flexbox layout algorithm is performed asynchronously within a web worker, so the result
	 * metrics will probably not be available the first time `afterUpdate` is called. This can
	 * sometimes cause issues with rendering due to NaNs, so it's good to check first that the
	 * object has a nonzero `offsetWidth` and `offsetHeight` before displaying the node's object(s).
	 *
	 * Currently the flexbox algorithm implementation is Facebook's Yoga. (https://yogalayout.com/)
	 *
	 * *Supported input flexbox style properties:*
	 * - width (number, string percentage, or 'auto')
	 * - height (number, string percentage, or 'auto')
	 * - minWidth (number, string percentage, or 'auto')
	 * - minHeight (number, string percentage, or 'auto')
	 * - maxWidth (number, string percentage, or 'auto')
	 * - maxHeight (number, string percentage, or 'auto')
	 * - aspectRatio (number, as width divided by height, or 'auto')
	 * - flexDirection ('column', 'column-reverse', 'row', or 'row-reverse')
	 * - flexWrap ('wrap' or 'nowrap')
	 * - flex (number, where positive becomes flexGrow and negative becomes flexShrink)
	 * - flexGrow (number)
	 * - flexShrink (number)
	 * - flexBasis (number, string percentage, or 'auto')
	 * - alignContent ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - alignItems ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - alignSelf ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - justifyContent ('center', 'flex-end', 'flex-start', 'space-around', or 'space-between')
	 * - position ('relative' or 'absolute')
	 * - top (number, string percentage, or 'auto')
	 * - right (number, string percentage, or 'auto')
	 * - bottom (number, string percentage, or 'auto')
	 * - left (number, string percentage, or 'auto')
	 * - margin (number, or array of up to four numbers in t-r-b-l order)
	 * - padding (number, or array of up to four numbers in t-r-b-l order)
	 * - borderWidth (number, or array of up to four numbers in t-r-b-l order)
	 * - overflow ('visible', 'hidden', or 'scroll')
	 *
	 * *Computed layout result properties:*
	 * - offsetLeft
	 * - offsetTop
	 * - offsetWidth
	 * - offsetHeight
	 * - clientLeft
	 * - clientTop
	 * - clientWidth
	 * - clientHeight
	 * - scrollLeft
	 * - scrollTop
	 * - scrollWidth
	 * - scrollHeight
	 * - clipLeft
	 * - clipTop
	 * - clipRight
	 * - clipBottom
	 * (All of these are `null` initially and then numbers after the layout completes, except
	 * scrollLeft and scrollTop which are `0` initially.)
	 *
	 * *Additional FlexNode-specific properties:*
	 * - isFlexNode (`true`, can be used to find FlexNodes in the facade tree)
	 * - flexNodeDepth (number, where topmost FlexNode's depth is `0` and children increase by 1)
	 * - parentFlexNode (the nearest parent FlexNode instance, or `null` if this is the root FlexNode)
	 * - needsFlexLayout (boolean, can be set to force a recalculation of the full flexbox layout)
	 *
	 * If the base class implements an `onAfterFlexLayoutApplied`, that will be invoked after the
	 * results of a flex layout pass have been written to the object. This is a good place to put
	 * custom logic that depends on a completed layout, rather than in `afterUpdate` which may have
	 * layout properties queued but not yet evaluated.
	 *
	 * @param {class} BaseFacadeClass
	 * @return {FlexNode} a new class that extends the BaseFacadeClass
	 */
	var extendAsFlexNode = createClassExtender$1('flexNode', function (BaseFacadeClass) {

	  var FlexNode = /*@__PURE__*/(function (BaseFacadeClass) {
	    function FlexNode(parent) {
	      BaseFacadeClass.call(this, parent);
	      this.isFlexNode = true;
	      this.needsFlexLayout = true;

	      // Object holding all input styles for this node in the flex tree; see the style object
	      // format in troika-flex-layout
	      this._flexStyles = {
	        id: this.$facadeId
	      };

	      // Look for the nearest flex layout ancestor; if there is one, add to its layout children,
	      // otherwise we're a flex layout root.
	      var parentFlexFacade = parent;
	      while (parentFlexFacade && !parentFlexFacade.isFlexNode) {parentFlexFacade = parentFlexFacade.parent;}
	      if (parentFlexFacade) {
	        this.parentFlexNode = parentFlexFacade;
	        this.flexNodeDepth = parentFlexFacade.flexNodeDepth + 1;
	      } else {
	        this.flexNodeDepth = 0;
	      }
	    }

	    if ( BaseFacadeClass ) FlexNode.__proto__ = BaseFacadeClass;
	    FlexNode.prototype = Object.create( BaseFacadeClass && BaseFacadeClass.prototype );
	    FlexNode.prototype.constructor = FlexNode;

	    FlexNode.prototype.afterUpdate = function afterUpdate () {
	      // Keep max scroll and clip rects in sync
	      if (this.offsetWidth != null) {
	        this._checkOverscroll();
	        this._updateClipRect();
	      }

	      BaseFacadeClass.prototype.afterUpdate.call(this);

	      // Did something change that requires a layout recalc?
	      if (this.needsFlexLayout) {
	        // If we're managed by an ancestor layout root, let it know
	        if (this.parentFlexNode) {
	          this.notifyWorld('needsFlexLayout');
	          this.needsFlexLayout = false;
	        }
	        // If we're the layout root, perform the layout
	        else {
	          this._performRootLayout();
	        }
	      }
	    };

	    FlexNode.prototype.destructor = function destructor () {
	      if (this.parentFlexNode) {
	        this.notifyWorld('needsFlexLayout');
	      }
	      BaseFacadeClass.prototype.destructor.call(this);
	    };

	    FlexNode.prototype.onNotifyWorld = function onNotifyWorld (source, message, data) {
	      if (message === 'needsFlexLayout' && !this.parentFlexNode) {
	        this.needsFlexLayout = true;
	        if (!this._rootLayoutReq) {
	          this._rootLayoutReq = setTimeout(this._performRootLayout.bind(this), 0);
	        }
	        return
	      }
	      BaseFacadeClass.prototype.onNotifyWorld.call(this, source, message, data);
	    };

	    FlexNode.prototype._performRootLayout = function _performRootLayout () {
	      var this$1 = this;

	      // If there's a request in progress, don't queue another one yet; that will happen
	      // automatically after the current one finishes and it calls afterUpdate again
	      if (this._hasActiveFlexRequest) { return }

	      this._hasActiveFlexRequest = true;
	      this.needsFlexLayout = false;
	      clearTimeout(this._rootLayoutReq);
	      delete this._rootLayoutReq;

	      // Traverse the flex node tree in document order and add the ordered child
	      // relationships to the style nodes at each level
	      this.traverse(function (facade) {
	        if (facade.isFlexNode) {
	          var parent = facade.parentFlexNode;
	          if (parent) {
	            var siblings = parent._flexStyles.children || (parent._flexStyles.children = []);
	            siblings.push(facade._flexStyles);
	          }
	          facade._flexStyles.children = null; //clear own leftover children from last time
	        }
	      });

	      requestFlexLayout(this._flexStyles, function (results) {
	        if (!this$1.isDestroying) {
	          this$1._applyRootLayoutResults(results);

	          // Final afterUpdate on the whole subtree
	          this$1._hasActiveFlexRequest = false;
	          this$1.afterUpdate();
	          this$1.requestRender();
	        }
	      });
	    };

	    FlexNode.prototype._applyRootLayoutResults = function _applyRootLayoutResults (results) {
	      // Results will be a flat map of facade id to computed layout; traverse the tree
	      // and math them up, applying them as `computedXYZ` properties
	      this.traverse(function (facade) {
	        if (facade.isFlexNode) {
	          var computedLayout = results[facade.$facadeId];
	          if (computedLayout) {
	            var left = computedLayout.left;
	            var top = computedLayout.top;
	            var width = computedLayout.width;
	            var height = computedLayout.height;
	            var borderWidth = facade.borderWidth;
	            var padding = facade.padding;

	            // Outer metrics
	            facade.offsetLeft = left;
	            facade.offsetTop = top;
	            facade.offsetWidth = width;
	            facade.offsetHeight = height;

	            // Inner metrics
	            facade.clientLeft = borderWidth[3] + padding[3];
	            facade.clientTop = borderWidth[0] + padding[0];
	            facade.clientWidth = width - borderWidth[1] - borderWidth[3] - padding[1] - padding[3];
	            facade.clientHeight = height - borderWidth[0] - borderWidth[2] - padding[0] - padding[2];

	            // Scrolling metrics
	            facade.scrollHeight = facade.scrollWidth = 0;
	            var parent = facade.parentFlexNode;
	            if (parent) {
	              var w = left + width - parent.clientLeft;
	              var h = top + height - parent.clientTop;
	              // Note: allowing a small tolerance here between scrollWidth/Height and clientWidth/Height,
	              // to account for very slight overflows due to floating point math errors
	              if (w > parent.scrollWidth) {
	                if (Math.abs(w - parent.clientWidth) < w / 10000) {
	                  w = parent.clientWidth;
	                }
	                parent.scrollWidth = w;
	              }
	              if (h > parent.scrollHeight) {
	                if (Math.abs(h - parent.clientHeight) < h / 10000) {
	                  h = parent.clientHeight;
	                }
	                parent.scrollHeight = h;
	              }
	            }

	            if (facade.onAfterFlexLayoutApplied) {
	              facade.onAfterFlexLayoutApplied();
	            }
	          }
	        }
	      });
	    };

	    FlexNode.prototype._checkOverscroll = function _checkOverscroll () {
	      var ref = this;
	      var scrollLeft = ref.scrollLeft;
	      var scrollTop = ref.scrollTop;
	      if (scrollLeft || scrollTop) {
	        var maxScrollLeft = Math.max(0, this.scrollWidth - this.clientWidth);
	        var maxScrollTop = Math.max(0, this.scrollHeight - this.clientHeight);
	        if (maxScrollLeft < scrollLeft) {
	          this.scrollLeft = maxScrollLeft;
	        }
	        if (maxScrollTop < scrollTop) {
	          this.scrollTop = maxScrollTop;
	        }
	      }
	    };

	    FlexNode.prototype._updateClipRect = function _updateClipRect () {
	      var ref = this;
	      var offsetWidth = ref.offsetWidth;
	      var offsetHeight = ref.offsetHeight;
	      var parent = ref.parentFlexNode;
	      var INF = Infinity;
	      var clipLeft, clipTop, clipRight, clipBottom;

	      if (parent && this.position !== 'absolute') {
	        var scrolledLeft = this.offsetLeft - parent.scrollLeft;
	        var scrolledTop = this.offsetTop - parent.scrollTop;
	        var doesParentClip = parent.overflow !== 'visible';
	        clipLeft = Math.max(doesParentClip ? parent.clientLeft : -INF, parent.clipLeft) - scrolledLeft;
	        clipTop = Math.max(doesParentClip ? parent.clientTop : -INF, parent.clipTop) - scrolledTop;
	        clipRight = Math.min(doesParentClip ? parent.clientLeft + parent.clientWidth : INF, parent.clipRight) - scrolledLeft;
	        clipBottom = Math.min(doesParentClip ? parent.clientTop + parent.clientHeight : INF, parent.clipBottom) - scrolledTop;
	      } else {
	        clipLeft = clipTop = -INF;
	        clipRight = clipBottom = INF;
	      }

	      this.clipLeft = clipLeft;
	      this.clipTop = clipTop;
	      this.clipRight = clipRight;
	      this.clipBottom = clipBottom;
	      this.isFullyClipped = clipLeft >= offsetWidth || clipTop >= offsetHeight ||
	        clipRight <= 0 || clipBottom <= 0 ||
	        clipLeft === clipRight || clipTop === clipBottom;
	    };

	    return FlexNode;
	  }(BaseFacadeClass));

	  // Define computed layout properties. Those that depend on a layout computation will be null
	  // initially, and set to numbers after layout calculation is completed. Derived facades should
	  // use these to update their rendering.
	  assign$7(FlexNode.prototype, {
	    offsetLeft: null,
	    offsetTop: null,
	    offsetWidth: null,
	    offsetHeight: null,
	    clientLeft: null,
	    clientTop: null,
	    clientWidth: null,
	    clientHeight: null,
	    scrollLeft: 0,
	    scrollTop: 0,
	    scrollWidth: null,
	    scrollHeight: null,
	    clipLeft: null,
	    clipTop: null,
	    clipRight: null,
	    clipBottom: null,
	    isFullyClipped: false,
	    overflow: 'visible'
	  })

	  // Setters for simple flex layout properties that can be copied directly into the
	  // flex node's style input object
	  ;[
	    'width',
	    'height',
	    'minWidth',
	    'minHeight',
	    'maxWidth',
	    'maxHeight',
	    'aspectRatio',
	    'flexDirection',
	    'flex',
	    'flexWrap',
	    'flexBasis',
	    'flexGrow',
	    'flexShrink',
	    'alignContent',
	    'alignItems',
	    'alignSelf',
	    'justifyContent',
	    'position',
	    'left',
	    'right',
	    'top',
	    'bottom'
	  ].forEach(function (prop) {
	    Object.defineProperty(FlexNode.prototype, prop, {
	      get: function get() {
	        return this._flexStyles[prop]
	      },
	      set: function set(value) {
	        if (value !== this._flexStyles[prop]) {
	          this._flexStyles[prop] = value;
	          this.needsFlexLayout = true;
	        }
	      },
	      configurable: true
	    });
	  })

	  // Add setters to normalize top/right/bottom/left properties which can be a single
	  // number or an array of up to 4 numbers, like their corresponding CSS shorthands
	  ;[
	    'margin',
	    'padding',
	    'borderWidth'
	  ].forEach(function (prop) {
	    var privateProp = "_priv_" + prop;
	    var styleBase = prop === 'borderWidth' ? 'border' : prop;
	    var topStyle = styleBase + 'Top';
	    var rightStyle = styleBase + 'Right';
	    var bottomStyle = styleBase + 'Bottom';
	    var leftStyle = styleBase + 'Left';
	    Object.defineProperty(FlexNode.prototype, prop, {
	      get: function get() {
	        return this[privateProp] || (this[privateProp] = Object.freeze([0, 0, 0, 0]))
	      },
	      set: function set(value) {
	        var t, r, b, l;
	        if (Array.isArray(value)) {
	          var len = value.length;
	          t = value[0] || 0;
	          r = (len > 1 ? value[1] : value[0]) || 0;
	          b = (len > 2 ? value[2] : value[0]) || 0;
	          l = (len > 3 ? value[3] : len > 1 ? value[1] : value[0]) || 0;
	        } else {
	          t = r = b = l = value;
	        }
	        var arr = this[prop];
	        if (t !== arr[0] || r !== arr[1] || b !== arr[2] || l !== arr[3]) {
	          this[privateProp] = Object.freeze([t, r, b, l]);
	          var styles = this._flexStyles;
	          styles[topStyle] = t;
	          styles[rightStyle] = r;
	          styles[bottomStyle] = b;
	          styles[leftStyle] = l;
	          this.needsFlexLayout = true;
	        }
	      }
	    });
	  });

	  return FlexNode
	});

	var tempVec4 = new Vector4();

	function getMeshes() {
	  var material = createDerivedMaterial(
	    new MeshBasicMaterial({
	      transparent: true,
	      opacity: 0.3,
	      depthWrite: false
	    }),
	    {
	      uniforms: {
	        rect: {value: new Vector4()},
	        depthAndCurveRadius: {value: new Vector2()}
	      },
	      vertexDefs: "\nuniform vec4 rect;\nuniform vec2 depthAndCurveRadius;\n",
	      vertexTransform: "\nfloat depth = depthAndCurveRadius.x;\nfloat rad = depthAndCurveRadius.y;\nposition.x = mix(rect.x, rect.z, position.x);\nposition.y = mix(rect.w, rect.y, position.y);\nposition.z = mix(-depth * 0.5, depth * 0.5, position.z);\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * (rad - position.z), rad - cos(angle) * (rad - position.z));\n  // TODO fix normals: normal.xz = vec2(sin(angle), cos(angle));\n}\n"
	    }
	  );
	  var meshes = {
	    normal: new Mesh(
	      new BoxGeometry(1, 1, 1).translate(0.5, 0.5, 0.5),
	      material
	    ),
	    curved: new Mesh(
	      new BoxGeometry(1, 1, 1, 32).translate(0.5, 0.5, 0.5),
	      material
	    )
	  };
	  return (getMeshes = function () { return meshes; })()
	}


	// TODO make instanceable or a single updated geometry to limit to a single draw call

	var RangeRectFacade = /*@__PURE__*/(function (Instanceable3DFacade) {
	  function RangeRectFacade (parent) {
	    Instanceable3DFacade.call(this, parent);
	    this.depth = 0;
	    this.curveRadius = 0;
	    this._color = new Color();
	    this._rect = new Vector4();
	  }

	  if ( Instanceable3DFacade ) RangeRectFacade.__proto__ = Instanceable3DFacade;
	  RangeRectFacade.prototype = Object.create( Instanceable3DFacade && Instanceable3DFacade.prototype );
	  RangeRectFacade.prototype.constructor = RangeRectFacade;

	  RangeRectFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var top = ref.top;
	    var right = ref.right;
	    var bottom = ref.bottom;
	    var left = ref.left;
	    var color = ref.color;
	    var depth = ref.depth;
	    var curveRadius = ref.curveRadius;
	    this.instancedThreeObject = getMeshes()[curveRadius ? 'curved' : 'normal'];

	    if (!this._color.equals(color)) {
	      this.setInstanceUniform('diffuse', this._color = new Color(color));
	    }

	    if (!this._rect.equals(tempVec4.set(left, top, right, bottom))) {
	      this.setInstanceUniform('rect', tempVec4.clone());
	    }
	    if (!depth !== this._depth || curveRadius !== this._curveRadius) {
	      this.setInstanceUniform('depthAndCurveRadius', new Vector2(this._depth = depth, this._curveRadius = curveRadius));
	    }
	    Instanceable3DFacade.prototype.afterUpdate.call(this);
	  };

	  RangeRectFacade.prototype.getBoundingSphere = function getBoundingSphere () {
	    return null
	  };

	  return RangeRectFacade;
	}(Instanceable3DFacade));

	var THICKNESS = 0.25; //rect depth as percentage of height

	var tempMat4$2 = new Matrix4();
	var tempPlane = new Plane();
	var tempVec2$2 = new Vector2();
	var tempVec3$3 = new Vector3();
	var noClip = Object.freeze([-Infinity, -Infinity, Infinity, Infinity]);

	/**
	 * Manager facade for selection rects and user selection behavior
	 */
	var SelectionManagerFacade = /*@__PURE__*/(function (ListFacade) {
	  function SelectionManagerFacade (parent, onSelectionChange) {
	    var this$1 = this;

	    ListFacade.call(this, parent);
	    var textMesh = parent.threeObject;

	    this.rangeColor = 0x00ccff;
	    this.clipRect = noClip;
	    this.curveRadius = 0;

	    this.template = {
	      key: function (d, i) { return ("rect" + i); },
	      facade: RangeRectFacade,
	      top: function (d) { return clamp(d.top, this$1.clipRect[1], this$1.clipRect[3]); },
	      right: function (d) { return clamp(d.right, this$1.clipRect[0], this$1.clipRect[2]); },
	      bottom: function (d) { return clamp(d.bottom, this$1.clipRect[1], this$1.clipRect[3]); },
	      left: function (d) { return clamp(d.left, this$1.clipRect[0], this$1.clipRect[2]); },
	      depth: function (d) { return (d.top - d.bottom) * THICKNESS; },
	      color: function (d) { return this$1.rangeColor; },
	      curveRadius: function (d) { return this$1.curveRadius; },
	      visible: function (d) {
	        var r = this$1.clipRect;
	        return d.right > r[0] && d.top > r[1] && d.left < r[2] && d.bottom < r[3]
	      },
	      renderOrder: function (d) { return this$1.renderOrder || 0; }
	    };

	    var onDragStart = function (e) {
	      var textRenderInfo = textMesh.textRenderInfo;
	      if (textRenderInfo) {
	        var textPos = textMesh.worldPositionToTextCoords(e.intersection.point, tempVec2$2);
	        var caret = getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
	        if (caret) {
	          onSelectionChange(caret.charIndex, caret.charIndex);
	          parent.addEventListener('drag', onDrag);
	          parent.addEventListener('dragend', onDragEnd);
	        }
	        e.preventDefault();
	      }
	    };

	    var onDrag = function (e) {
	      var textRenderInfo = textMesh.textRenderInfo;
	      if (e.ray && textRenderInfo) {
	        // If it's hitting on the Text mesh, do an exact translation; otherwise raycast to an
	        // infinite plane so dragging outside the text bounds will work
	        var textPos;
	        var ix = e.intersection;
	        if (ix && ix.object === textMesh && ix.point) {
	          textPos = textMesh.worldPositionToTextCoords(ix.point, tempVec2$2);
	        } else {
	          var ray = e.ray.clone().applyMatrix4(invertMatrix4(textMesh.matrixWorld, tempMat4$2));
	          textPos = ray.intersectPlane(tempPlane.setComponents(0, 0, 1, 0), tempVec3$3);
	        }
	        if (textPos) {
	          var caret = getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
	          if (caret) {
	            onSelectionChange(this$1.selectionStart, caret.charIndex);
	          }
	        }
	        e.preventDefault();
	      }
	    };

	    var onDragEnd = function (e) {
	      parent.removeEventListener('drag', onDrag);
	      parent.removeEventListener('dragend', onDragEnd);
	    };

	    parent.addEventListener('dragstart', onDragStart);
	    parent.addEventListener('mousedown', onDragStart);

	    this._cleanupEvents = function () {
	      onDragEnd();
	      parent.removeEventListener('dragstart', onDragStart);
	      parent.removeEventListener('mousedown', onDragStart);
	    };
	  }

	  if ( ListFacade ) SelectionManagerFacade.__proto__ = ListFacade;
	  SelectionManagerFacade.prototype = Object.create( ListFacade && ListFacade.prototype );
	  SelectionManagerFacade.prototype.constructor = SelectionManagerFacade;

	  var prototypeAccessors = { clipRect: { configurable: true } };

	  SelectionManagerFacade.prototype.afterUpdate = function afterUpdate () {
	    this.data = getSelectionRects(this.textRenderInfo, this.selectionStart, this.selectionEnd);
	    ListFacade.prototype.afterUpdate.call(this);
	  };

	  // normalize clipRect
	  prototypeAccessors.clipRect.set = function (clipRect) {
	    this._clipRect = (clipRect && Array.isArray(clipRect) && clipRect.length === 4) ? clipRect : noClip;
	  };
	  prototypeAccessors.clipRect.get = function () {
	    return this._clipRect
	  };

	  SelectionManagerFacade.prototype.destructor = function destructor () {
	    this._cleanupEvents();
	    ListFacade.prototype.destructor.call(this);
	  };

	  Object.defineProperties( SelectionManagerFacade.prototype, prototypeAccessors );

	  return SelectionManagerFacade;
	}(List));

	function clamp(val, min, max) {
	  return Math.min(max, Math.max(min, val))
	}

	// Properties that will simply be forwarded to the TextMesh:
	var TEXT_MESH_PROPS = [
	  'text',
	  'anchorX',
	  'anchorY',
	  'font',
	  'fontSize',
	  'letterSpacing',
	  'lineHeight',
	  'maxWidth',
	  'overflowWrap',
	  'direction',
	  'textAlign',
	  'textIndent',
	  'whiteSpace',
	  'material',
	  'color',
	  'colorRanges',
	  'fillOpacity',
	  'outlineOpacity',
	  'outlineColor',
	  'outlineWidth',
	  'outlineOffsetX',
	  'outlineOffsetY',
	  'outlineBlur',
	  'strokeColor',
	  'strokeWidth',
	  'strokeOpacity',
	  'curveRadius',
	  'depthOffset',
	  'clipRect',
	  'orientation',
	  'glyphGeometryDetail',
	  'sdfGlyphSize',
	  'debugSDF'
	];


	/**
	 * Facade wrapper for a TextMesh. All configuration properties of TextMesh
	 * are accepted and proxied through directly.
	 */
	var Text3DFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function Text3DFacade(parent) {
	    var this$1 = this;

	    var mesh = new Text();
	    mesh.geometry.boundingSphere.version = 0;
	    Object3DFacade.call(this, parent, mesh);

	    /* TODO mirroring to DOM...?
	    const el = this._domEl = document.createElement('section')
	    el.style = 'position:fixed;left:-99px;overflow:hidden;width:10px;height:10px;'
	    document.body.appendChild(el) //should insert into local element
	    */

	    this.selectable = false;
	    this.selectionStart = this.selectionEnd = -1;
	    this.onSyncStart = null;
	    this.onSyncComplete = null;

	    mesh.addEventListener('syncstart', function (e) {
	      this$1.notifyWorld('text3DSyncStart');
	      if (this$1.onSyncStart) {
	        this$1.onSyncStart();
	      }
	    });
	    mesh.addEventListener('synccomplete', function (e) {
	      if (!this$1.isDestroying) {
	        mesh.geometry.boundingSphere.version++;
	        this$1.afterUpdate();
	        this$1.notifyWorld('text3DSyncComplete');
	        this$1.requestRender();
	        if (this$1.onSyncComplete) {
	          this$1.onSyncComplete();
	        }
	      }
	    });
	  }

	  if ( Object3DFacade ) Text3DFacade.__proto__ = Object3DFacade;
	  Text3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Text3DFacade.prototype.constructor = Text3DFacade;

	  var prototypeAccessors = { textRenderInfo: { configurable: true } };

	  prototypeAccessors.textRenderInfo.get = function () {
	    return this.threeObject.textRenderInfo
	  };

	  Text3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var this$1 = this;

	    var textMesh = this.threeObject;
	    TEXT_MESH_PROPS.forEach(function (prop) {
	      textMesh[prop] = this$1[prop];
	    });
	    textMesh.sync();

	    Object3DFacade.prototype.afterUpdate.call(this);

	    if (this.text !== this._prevText) {
	      // TODO mirror to DOM... this._domEl.textContent = this.text
	      // Clear selection when text changes
	      this.selectionStart = this.selectionEnd = -1;
	      this._prevText = this.text;
	    }

	    this._updateSelection();
	  };

	  Text3DFacade.prototype._updateSelection = function _updateSelection () {
	    var this$1 = this;

	    var ref = this;
	    var selectable = ref.selectable;
	    var selectionStart = ref.selectionStart;
	    var selectionEnd = ref.selectionEnd;
	    var selFacade = this._selectionFacade;
	    if (selectable !== this._selectable) {
	      this._selectable = selectable;
	      if (selectable) {
	        selFacade = this._selectionFacade = new SelectionManagerFacade(this, function (start, end) {
	          this$1.selectionStart = start;
	          this$1.selectionEnd = end;
	          this$1._updateSelection();
	          this$1.requestRender();
	        });
	      } else {
	        if (selFacade) {
	          selFacade.destructor();
	          selFacade = this._selectionFacade = null;
	        }
	        this.selectionStart = this.selectionEnd = -1;
	      }
	    }
	    if (selFacade) {
	      selFacade.textRenderInfo = this.threeObject.textRenderInfo;
	      selFacade.selectionStart = selectionStart;
	      selFacade.selectionEnd = selectionEnd;
	      selFacade.curveRadius = this.curveRadius || 0;
	      selFacade.clipRect = this.clipRect;
	      selFacade.renderOrder = this.renderOrder;
	      selFacade.afterUpdate();
	    }

	    /* TODO update selection in DOM...
	    const {selectionStart, selectionEnd} = this
	    if (selectionStart !== this._prevSelStart || selectionEnd !== this._prevSelEnd) {
	      this._prevSelStart = selectionStart
	      this._prevSelEnd = selectionEnd
	      const sel = document.getSelection()
	      sel.removeAllRanges()
	      if (this.selectable && selectionStart > -1 && selectionEnd > selectionStart) {
	        const range = document.createRange()
	        range.setStart(this._domEl.firstChild, this.selectionStart)
	        range.setEnd(this._domEl.firstChild, this.selectionEnd)
	        sel.addRange(range)
	      }
	    }
	    */
	  };

	  Text3DFacade.prototype.destructor = function destructor () {
	    this.threeObject.dispose();
	    //this._domEl.parentNode.removeChild(this._domEl)
	    if (this._selectionFacade) {
	      this._selectionFacade.destructor();
	    }
	    Object3DFacade.prototype.destructor.call(this);
	  };

	  Object.defineProperties( Text3DFacade.prototype, prototypeAccessors );

	  return Text3DFacade;
	}(Object3DFacade));

	var UNDEF = undefined;

	// List of UI flex node properties that should be inherited by default:
	var INHERITABLES = [
	  'font',
	  'fontSize',
	  'textAlign',
	  'textIndent',
	  'lineHeight',
	  'letterSpacing',
	  'whiteSpace',
	  'overflowWrap',
	  'color'
	];

	function getInheritable(owner, prop, defaultValue) {
	  var val;
	  while (owner && (val = owner[prop]) === 'inherit') {
	    owner = owner.parentFlexNode;
	    val = UNDEF;
	  }
	  if (val === UNDEF) {
	    val = defaultValue;
	  }
	  return val
	}

	function getComputedFontSize(owner, defaultFontSize) {
	  var val;
	  while (owner && typeof (val = owner.fontSize) === 'string') {
	    if (val === 'inherit') {
	      owner = owner.parentFlexNode;
	      val = UNDEF;
	    } else if (/%$/.test(val)) {
	      var multiplier = parseFloat(val) / 100;
	      val = getComputedFontSize(owner.parentFlexNode, defaultFontSize);
	      if (val !== UNDEF) {
	        val *= multiplier;
	      }
	      break
	    } else {
	      console.warn(("Unknown fontSize: " + val));
	      val = UNDEF;
	      break
	    }
	  }
	  if (val === UNDEF) {
	    val = defaultFontSize;
	  }
	  return val
	}

	var flexLayoutTextProps = ['text', 'textIndent', 'font', 'fontSize', 'lineHeight', 'letterSpacing', 'whiteSpace', 'overflowWrap'];
	var noop$2 = function () {};

	/**
	 * Wrapper for Text3DFacade that lets it act as a flex layout node. This shouldn't be used
	 * directly, but will be created as an implicit child by {@link UIBlock3DFacade} when
	 * configured with a `text` property.
	 */
	var UITextNode3DFacade = /*@__PURE__*/(function (Text3DFacade) {
	  function UITextNode3DFacade (props) {
	    Text3DFacade.call(this, props);

	    // Override the sync method so we can have control over when it's called
	    var mesh = this.threeObject;
	    mesh._actuallySync = mesh.sync;
	    mesh.sync = noop$2;
	  }

	  if ( Text3DFacade ) UITextNode3DFacade.__proto__ = Text3DFacade;
	  UITextNode3DFacade.prototype = Object.create( Text3DFacade && Text3DFacade.prototype );
	  UITextNode3DFacade.prototype.constructor = UITextNode3DFacade;

	  UITextNode3DFacade.prototype.afterUpdate = function afterUpdate () {
	    // Read computed layout
	    var ref = this;
	    var offsetLeft = ref.offsetLeft;
	    var offsetTop = ref.offsetTop;
	    var offsetWidth = ref.offsetWidth;

	    // Update position and size if flex layout has been completed
	    var hasLayout = offsetWidth !== null;
	    if (hasLayout) {
	      var parent = this.parentFlexNode;
	      this.x = offsetLeft - parent.scrollLeft;
	      this.y = -(offsetTop - parent.scrollTop);

	      // Update clip rect based on parent
	      var clipRect = this.clipRect || (this.clipRect = [0, 0, 0, 0]);
	      clipRect[0] = this.clipLeft;
	      clipRect[1] = -this.clipBottom;
	      clipRect[2] = this.clipRight;
	      clipRect[3] = -this.clipTop;

	      // If fully hidden by parent clipping rect, cull this object out of the scene
	      this.threeObject.visible = !this.isFullyClipped;
	    }

	    // Check text props that could affect flex layout
	    // TODO seems odd that this happens here rather than FlexLayoutNode
	    var flexStyles = this._flexStyles;
	    for (var i = 0, len = flexLayoutTextProps.length; i < len; i++) {
	      var prop = flexLayoutTextProps[i];
	      var val = prop === 'text' ? this.text : getInheritable(this, prop);
	      if (val !== flexStyles[prop]) {
	        flexStyles[prop] = this[prop];
	        this.needsFlexLayout = true;
	      }
	    }

	    Text3DFacade.prototype.afterUpdate.call(this);
	  };

	  UITextNode3DFacade.prototype.onAfterFlexLayoutApplied = function onAfterFlexLayoutApplied () {
	    this.threeObject.maxWidth = this.offsetWidth;
	    this.threeObject._actuallySync(this._afterSync);
	  };

	  UITextNode3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
	    return null //parent UIBlock3DFacade will handle bounding sphere and raycasting
	  };

	  return UITextNode3DFacade;
	}(Text3DFacade));

	// Extend as FlexNode
	UITextNode3DFacade = extendAsFlexNode(UITextNode3DFacade);

	INHERITABLES.forEach(function (prop) {
	  UITextNode3DFacade.prototype[prop] = 'inherit';
	});

	// Redefine the maxWidth property so it's not treated as a setter that affects flexbox layout
	Object.defineProperty(UITextNode3DFacade.prototype, 'maxWidth', {
	  value: Infinity,
	  enumerable: true,
	  writable: true
	});

	var UITextNode3DFacade$1 = UITextNode3DFacade;

	// language=GLSL
	var VERTEX_DEFS$1 = "\nuniform vec2 uTroikaBlockSize;\nuniform vec4 uTroikaClipRect;\nvarying vec2 vTroikaPosInBlock;\n";

	// language=GLSL prefix="void main() {" suffix="}"
	var VERTEX_TRANSFORM$1 = "\nvec2 xy = position.xy * uTroikaBlockSize;\nxy.y *= -1.0;\nxy = clamp(xy, uTroikaClipRect.xy, uTroikaClipRect.zw);\nvTroikaPosInBlock = xy;\nxy.y *= -1.0;\nposition.xy = xy;\n";

	// language=GLSL
	var FRAGMENT_DEFS$1 = "\nuniform vec2 uTroikaBlockSize;\nuniform vec4 uTroikaCornerRadii;\nuniform vec4 uTroikaBorderWidth;\nvarying vec2 vTroikaPosInBlock;\nconst vec4 NO_BORDER = vec4(0.,0.,0.,0.);\n\nfloat troikaEllipseRadiusAtAngle(in float angle, in float rx, in float ry) {\n  if (rx == ry) {return rx;}\n  float _cos = cos(angle);\n  float _sin = sin(angle);\n  return 1.0 / sqrt((_cos*_cos)/(rx*rx) + (_sin*_sin)/(ry*ry));\n}\n\nvoid troikaGetCurveDists(\n  in vec2 pos, in vec2 radCenter, in float outerR, in float xBorder, in float yBorder, \n  out float dOuter, out float dInner\n) {\n  vec2 adjPos = pos - radCenter;\n  float angle = atan(adjPos.y, adjPos.x);\n  dOuter = troikaEllipseRadiusAtAngle(angle, outerR, outerR) - length(adjPos);\n  dInner = uTroikaBorderWidth == NO_BORDER ? dInner : \n    troikaEllipseRadiusAtAngle(angle, max(0.0, outerR - xBorder), max(0.0, outerR - yBorder)) - length(adjPos);\n}\n\nfloat troikaGetAlphaMultiplier() {\n  // Short aliases\n  vec2 dim = uTroikaBlockSize;\n  vec4 rad = uTroikaCornerRadii;\n  vec4 bdr = uTroikaBorderWidth;\n  vec2 pos = vTroikaPosInBlock;\n\n  float dOuter;\n  float dInner;\n  bool isOnCurve = true;\n  bool isBorder = uTroikaBorderWidth != NO_BORDER;\n\n  // Top left\n  if (pos.x < rad[0] && pos.y < rad[0]) {\n    troikaGetCurveDists(pos, vec2(rad[0], rad[0]), rad[0], bdr[3], bdr[0], dOuter, dInner);\n  }\n  // Top Right\n  else if (pos.x > dim.x - rad[1] && pos.y < rad[1]) {\n    troikaGetCurveDists(pos, vec2(dim.x - rad[1], rad[1]), rad[1], bdr[1], bdr[0], dOuter, dInner);\n  }\n  // Bottom Right\n  else if (pos.x > dim.x - rad[2] && pos.y > dim.y - rad[2]) {\n    troikaGetCurveDists(pos, vec2(dim.x - rad[2], dim.y - rad[2]), rad[2], bdr[1], bdr[2], dOuter, dInner);\n  }\n  // Bottom Left\n  else if (pos.x < rad[3] && pos.y > dim.y - rad[3]) {\n    troikaGetCurveDists(pos, vec2(rad[3], dim.y - rad[3]), rad[3], bdr[3], bdr[2], dOuter, dInner);\n  }\n  // Not on a curve, use closest side\n  else {\n    isOnCurve = false;\n    dOuter = min(min(pos.x, pos.y), min(dim.x - pos.x, dim.y - pos.y));\n    dInner = isBorder ? min(min(pos.x - bdr[3], pos.y - bdr[0]), min(dim.x - pos.x - bdr[1], dim.y - pos.y - bdr[2])) : dInner;\n  }\n\n  float alpha;\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n    float aa = length(fwidth(pos)) * 0.5;\n    alpha = isOnCurve ? smoothstep(-aa, aa, dOuter) : 1.0;\n    alpha = isBorder ? min(alpha, (dOuter == dInner) ? 0.0 : smoothstep(aa, -aa, dInner)) : alpha;\n    return alpha;\n  #else\n    alpha = step(0.0, dOuter);\n    alpha = isBorder ? min(alpha, step(0.0, -dInner)) : alpha;\n  #endif\n  return alpha;\n}\n";

	// language=GLSL prefix="void main() {" suffix="}"
	var FRAGMENT_COLOR_TRANSFORM = "\nfloat troikaAlphaMult = troikaGetAlphaMultiplier();\nif (troikaAlphaMult == 0.0) {\n  discard;\n} else {\n  gl_FragColor.a *= troikaAlphaMult;\n}\n";


	function createUIBlockLayerDerivedMaterial(baseMaterial) {
	  var material = createDerivedMaterial(baseMaterial, {
	    defines: {
	      TROIKA_UI_BLOCK: ''
	    },
	    extensions: {
	      derivatives: true
	    },
	    uniforms: {
	      uTroikaBlockSize: {value: new Vector2()},
	      uTroikaClipRect: {value: new Vector4(0,0,0,0)},
	      uTroikaCornerRadii: {value: new Vector4(0,0,0,0)},
	      uTroikaBorderWidth: {value: new Vector4(0,0,0,0)}
	    },
	    vertexDefs: VERTEX_DEFS$1,
	    vertexTransform: VERTEX_TRANSFORM$1,
	    fragmentDefs: FRAGMENT_DEFS$1,
	    fragmentColorTransform: FRAGMENT_COLOR_TRANSFORM
	  });

	  // WebGLShadowMap reverses the side of the shadow material by default, which fails
	  // for planes, so here we force the `shadowSide` to always match the main side.
	  Object.defineProperty(material, 'shadowSide', {
	    get: function get() {
	      return this.side
	    },
	    set: function set() {
	      //no-op
	    }
	  });

	  //force transparency - TODO is this reasonable?
	  material.transparent = true;

	  return material
	}

	var geometry$2 = new PlaneGeometry(1, 1).translate(0.5, -0.5, 0);
	var defaultMaterial = new MeshBasicMaterial({color: 0});
	var emptyVec2 = Object.freeze(new Vector2());
	var emptyVec4 = Object.freeze(new Vector4(0,0,0,0));

	var shadowMaterialPropDefs = {
	  // Create and update materials for shadows upon request:
	  customDepthMaterial: {
	    get: function get() {
	      return this.material.getDepthMaterial()
	    }
	  },
	  customDistanceMaterial: {
	    get: function get() {
	      return this.material.getDistanceMaterial()
	    }
	  }
	};

	var instanceMeshesByKey = new Map();

	/**
	 * A single layer in a UI Block's rendering, e.g. background or border. All layers honor
	 * border radius, which is calculated shader-side for perfectly smooth curves at any scale,
	 * with antialiasing.
	 *
	 * Layer meshes are rendered via GPU instancing when possible -- specifically when they share
	 * the same Material instance, layering depth, and shadow behavior.
	 *
	 * You shouldn't have to use this directly; UIBlock3DFacade will create these as needed
	 * based on background/border styles.
	 */
	var UIBlockLayer3DFacade = /*@__PURE__*/(function (Instanceable3DFacade) {
	  function UIBlockLayer3DFacade(parent) {
	    Instanceable3DFacade.call(this, parent);

	    this._colorObj = new Color();

	    // Properties
	    this.size = emptyVec2;
	    this.borderRadius = emptyVec4;
	    this.borderWidth = emptyVec4;
	    this.color = 0;
	    this.isBorder = false;
	    this.material = defaultMaterial;
	  }

	  if ( Instanceable3DFacade ) UIBlockLayer3DFacade.__proto__ = Instanceable3DFacade;
	  UIBlockLayer3DFacade.prototype = Object.create( Instanceable3DFacade && Instanceable3DFacade.prototype );
	  UIBlockLayer3DFacade.prototype.constructor = UIBlockLayer3DFacade;

	  UIBlockLayer3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var material = ref.material;
	    var depthOffset = ref.depthOffset;
	    var castShadow = ref.castShadow;
	    var receiveShadow = ref.receiveShadow;
	    var color = ref.color;
	    var renderOrder = ref.renderOrder;
	    if (!material) { material = defaultMaterial; }

	    // Find or create the instanced mesh
	    var meshKey = (material.id) + "|" + renderOrder + "|" + depthOffset + "|" + castShadow + "|" + receiveShadow;
	    if (meshKey !== this._prevMeshKey) {
	      var mesh = instanceMeshesByKey.get(meshKey);
	      if (!mesh) {
	        var derivedMaterial = createUIBlockLayerDerivedMaterial(material);
	        derivedMaterial.polygonOffset = !!this.depthOffset;
	        derivedMaterial.polygonOffsetFactor = derivedMaterial.polygonOffsetUnits = this.depthOffset || 0;
	        // dispose the derived material when its base material is disposed:
	        material.addEventListener('dispose', function onDispose() {
	          material.removeEventListener('dispose', onDispose);
	          derivedMaterial.dispose();
	        });

	        mesh = new Mesh(geometry$2, derivedMaterial);
	        mesh._instanceKey = meshKey;
	        mesh.castShadow = castShadow;
	        mesh.receiveShadow = receiveShadow;
	        mesh.renderOrder = renderOrder;
	        Object.defineProperties(mesh, shadowMaterialPropDefs);
	        instanceMeshesByKey.set(meshKey, mesh);
	      }
	      this.instancedThreeObject = mesh;
	      this._prevMeshKey = meshKey;
	    }

	    // Set material uniform values
	    this.setInstanceUniform('uTroikaBlockSize', this.size);
	    this.setInstanceUniform('uTroikaCornerRadii', this.borderRadius);
	    this.setInstanceUniform('uTroikaClipRect', this.clipRect);
	    this.setInstanceUniform('uTroikaBorderWidth', this.isBorder ? this.borderWidth : emptyVec4);
	    if (color !== this._lastColor) {
	      this._lastColor = color;
	      this.setInstanceUniform('diffuse', new Color(color));
	    }

	    Instanceable3DFacade.prototype.afterUpdate.call(this);
	  };

	  UIBlockLayer3DFacade.prototype.getBoundingSphere = function getBoundingSphere () {
	    return null //parent will handle bounding sphere and raycasting
	  };

	  return UIBlockLayer3DFacade;
	}(Instanceable3DFacade));

	var barGeometry;


	var ScrollbarBarFacade = /*@__PURE__*/(function (Object3DFacade) {
	  function ScrollbarBarFacade(parent) {
	    var mesh = new Mesh(
	      barGeometry || (barGeometry =
	        new CylinderGeometry(0.5, 0.5, 1, 8).translate(0, -0.5, 0)
	      ),
	      // TODO allow overriding material
	      new MeshBasicMaterial({
	        color: 0xffffff,
	        transparent: true,
	        opacity: 0
	      })
	    );
	    Object3DFacade.call(this, parent, mesh);
	    this.girth = 0;
	    this.length = 0;
	  }

	  if ( Object3DFacade ) ScrollbarBarFacade.__proto__ = Object3DFacade;
	  ScrollbarBarFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  ScrollbarBarFacade.prototype.constructor = ScrollbarBarFacade;

	  ScrollbarBarFacade.prototype.afterUpdate = function afterUpdate () {
	    this.scaleX = this.scaleZ = this.girth;
	    this.scaleY = this.length;
	    this.rotateZ = this.horizontal ? Math.PI / 2 : 0;
	    this.threeObject.material.opacity = this.opacity;
	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  return ScrollbarBarFacade;
	}(Object3DFacade));

	var targets = new WeakMap();

	var opacityTransition = {
	  opacity: {duration: 300}
	};

	var ScrollbarsFacade = /*@__PURE__*/(function (ParentFacade) {
	  function ScrollbarsFacade(parent) {
	    var this$1 = this;

	    ParentFacade.call(this, parent);
	    this._onOver = function (e) {
	      this$1.hovering = true;
	      this$1.afterUpdate();
	    };
	    this._onOut = function (e) {
	      this$1.hovering = false;
	      this$1.afterUpdate();
	    };
	  }

	  if ( ParentFacade ) ScrollbarsFacade.__proto__ = ParentFacade;
	  ScrollbarsFacade.prototype = Object.create( ParentFacade && ParentFacade.prototype );
	  ScrollbarsFacade.prototype.constructor = ScrollbarsFacade;

	  var prototypeAccessors = { target: { configurable: true } };

	  prototypeAccessors.target.set = function (target) {
	    var oldTarget = targets.get(this);
	    if (target !== oldTarget) {
	      if (oldTarget) {
	        oldTarget.removeEventListener('mouseover', this._onOver);
	        oldTarget.removeEventListener('mouseout', this._onOut);
	      }
	      if (target) {
	        target.addEventListener('mouseover', this._onOver);
	        target.addEventListener('mouseout', this._onOut);
	      }
	      targets.set(this, target);
	    }
	  };
	  prototypeAccessors.target.get = function () {
	    return targets.get(this)
	  };

	  ScrollbarsFacade.prototype.describeChildren = function describeChildren () {
	    var ref = this;
	    var target = ref.target;
	    var children = this._childArr || (this._childArr = []);
	    children.length = 0;
	    if (target) {
	      var offsetWidth = target.offsetWidth;
	      var offsetHeight = target.offsetHeight;
	      var scrollHeight = target.scrollHeight;
	      var scrollWidth = target.scrollWidth;
	      var clientWidth = target.clientWidth;
	      var clientHeight = target.clientHeight;
	      var fontSize = target.getComputedFontSize();

	      if (scrollWidth > clientWidth) {
	        var hScrollbar = this._hDef || (this._hDef = {
	          key: 'h',
	          facade: ScrollbarBarFacade,
	          horizontal: true,
	          transition: opacityTransition
	        });
	        hScrollbar.girth = Math.min( fontSize / 4, offsetHeight / 10);
	        hScrollbar.length = Math.max(clientWidth * clientWidth / scrollWidth, fontSize);
	        hScrollbar.x = target.clientLeft + (clientWidth - hScrollbar.length) * (target.scrollLeft / (scrollWidth - clientWidth));
	        hScrollbar.y = -offsetHeight;
	        hScrollbar.opacity = this.hovering ? 0.5 : 0;
	        hScrollbar.renderOrder = this.renderOrder;
	        children.push(hScrollbar);
	      }
	      if (scrollHeight > clientHeight) {
	        var vScrollbar = this._vDef || (this._vDef = {
	          key: 'v',
	          facade: ScrollbarBarFacade,
	          transition: opacityTransition
	        });
	        vScrollbar.girth = Math.min( fontSize / 4, offsetWidth / 10);
	        vScrollbar.length = Math.max(clientHeight * clientHeight / scrollHeight, fontSize);
	        vScrollbar.x = offsetWidth;
	        vScrollbar.y = -(target.clientTop + (clientHeight - vScrollbar.length) * (target.scrollTop / (scrollHeight - clientHeight)));
	        vScrollbar.opacity = this.hovering ? 0.5 : 0;
	        vScrollbar.renderOrder = this.renderOrder;
	        children.push(vScrollbar);
	      }
	    }
	    return children
	  };

	  ScrollbarsFacade.prototype.destructor = function destructor () {
	    this.target = null;
	    ParentFacade.prototype.destructor.call(this);
	  };

	  Object.defineProperties( ScrollbarsFacade.prototype, prototypeAccessors );

	  return ScrollbarsFacade;
	}(ParentFacade));

	var raycastMesh = new Mesh(new PlaneGeometry(1, 1).translate(0.5, -0.5, 0));
	var tempMat4$3 = new Matrix4();
	var tempVec4$1 = new Vector4(0,0,0,0);
	var emptyVec4$1 = Object.freeze(new Vector4(0,0,0,0));
	var tempPlane$1 = new Plane();
	var DEFAULT_FONT_SIZE = 16;
	var DEFAULT_LINE_HEIGHT = 'normal';

	var groupVisiblePropDef = {
	  get: function get() {
	    return !this._priv_hidden && !this.$facade.isFullyClipped
	  },
	  set: function set(value) {
	    this._priv_hidden = !value;
	  }
	};

	/**
	 * Represents a single block UI element, essentially just a 2D rectangular block that
	 * can contain text, be styled with background/border, and participate in flexbox layout.
	 * Its behavior and styling is very much like an HTML element using flexbox.
	 */
	var UIBlock3DFacade = /*@__PURE__*/(function (Group3DFacade) {
	  function UIBlock3DFacade(parent) {
	    Group3DFacade.call(this, parent);

	    // If fully hidden by parent clipping rect, cull the whole Group out of the scene
	    Object.defineProperty(this.threeObject, 'visible', groupVisiblePropDef);

	    // Anonymous container for bg/border/scrollbar child objects; these live separate
	    // from the main `children` tree
	    this.layers = new Group3DFacade(this);
	    this.layers.children = [null, null, null];

	    // Shared objects for passing down to layers - treated as immutable
	    this._sizeVec2 = Object.freeze(new Vector2());
	    this._clipRectVec4 = emptyVec4$1;
	    this._borderWidthVec4 = emptyVec4$1;
	    this._borderRadiiVec4 = emptyVec4$1

	    ;(this._geomBoundingSphere = new Sphere()).version = 0;
	    this._wasFullyClipped = true;
	  }

	  if ( Group3DFacade ) UIBlock3DFacade.__proto__ = Group3DFacade;
	  UIBlock3DFacade.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  UIBlock3DFacade.prototype.constructor = UIBlock3DFacade;

	  /**
	   * @override When fully clipped out of view, skip updating children entirely. We do this by
	   * overriding `updateChildren` instead of using the `shouldUpdateChildren` hook, because the
	   * latter would still traverse the child tree to sync matrices, which we don't need here.
	   * TODO this doesn't work so well when descendants are absolutely positioned or overflow outside our bounds
	   */
	  UIBlock3DFacade.prototype.updateChildren = function updateChildren (children) {
	    if (!this.isFullyClipped || !this._wasFullyClipped) {
	      Group3DFacade.prototype.updateChildren.call(this, children);
	    }
	  };

	  UIBlock3DFacade.prototype.updateMatrices = function updateMatrices$1 () {
	    Group3DFacade.prototype.updateMatrices.call(this);
	    this.layers.traverse(updateMatrices);
	  };

	  UIBlock3DFacade.prototype.afterUpdate = function afterUpdate () {
	    var ref = this;
	    var layers = ref.layers;
	    var backgroundColor = ref.backgroundColor;
	    var backgroundMaterial = ref.backgroundMaterial;
	    var borderWidth = ref.borderWidth;
	    var borderColor = ref.borderColor;
	    var borderMaterial = ref.borderMaterial;
	    var text = ref.text;
	    var offsetLeft = ref.offsetLeft;
	    var offsetTop = ref.offsetTop;
	    var offsetWidth = ref.offsetWidth;
	    var offsetHeight = ref.offsetHeight;
	    var parentFlexNode = ref.parentFlexNode;
	    var flexNodeDepth = ref.flexNodeDepth;
	    var isFullyClipped = ref.isFullyClipped;
	    var _wasFullyClipped = ref._wasFullyClipped;
	    var _borderWidthVec4 = ref._borderWidthVec4;
	    var _clipRectVec4 = ref._clipRectVec4;
	    var _sizeVec2 = ref._sizeVec2;
	    var hasLayout = offsetWidth !== null;
	    var hasNonZeroSize = !!(offsetWidth && offsetHeight);
	    var hasBg = hasNonZeroSize && !isFullyClipped && (backgroundColor != null || backgroundMaterial != null);
	    var hasBorder = hasNonZeroSize && !isFullyClipped && (borderColor != null || borderMaterial != null) && Math.max.apply(Math, borderWidth) > 0;
	    var canScroll = hasNonZeroSize && (this.overflow === 'scroll' || this.overflow === 'auto') && (
	      this.scrollHeight > this.clientHeight || this.scrollWidth > this.clientWidth
	    );

	    // Update the block's element and size from flexbox computed values
	    if (hasLayout) {
	      if (parentFlexNode) {
	        var isAbsPos = this.position === 'absolute';
	        this.x = offsetLeft - (isAbsPos ? 0 : parentFlexNode.scrollLeft);
	        this.y = -(offsetTop - (isAbsPos ? 0 : parentFlexNode.scrollTop));
	      }
	      if (offsetWidth !== _sizeVec2.x || offsetHeight !== _sizeVec2.y) {
	        _sizeVec2 = this._sizeVec2 = Object.freeze(new Vector2(offsetWidth, offsetHeight));

	        // Update pre-worldmatrix bounding sphere
	        var sphere = this._geomBoundingSphere;
	        sphere.radius = Math.sqrt(offsetWidth * offsetWidth / 4 + offsetHeight * offsetHeight / 4);
	        sphere.center.set(offsetWidth / 2, -offsetHeight / 2, 0);
	        sphere.version++;
	      }
	    }

	    if (!isFullyClipped || !_wasFullyClipped) {
	      // Update shared vector objects for the sublayers
	      var radii = (hasBg || hasBorder) ? this._normalizeBorderRadius() : null;

	      tempVec4$1.fromArray(borderWidth);
	      if (!tempVec4$1.equals(_borderWidthVec4)) {
	        _borderWidthVec4 = this._borderWidthVec4 = Object.freeze(tempVec4$1.clone());
	      }
	      tempVec4$1.set(
	        Math.max(this.clipLeft, 0),
	        Math.max(this.clipTop, 0),
	        Math.min(this.clipRight, offsetWidth),
	        Math.min(this.clipBottom, offsetHeight)
	      );
	      if (!tempVec4$1.equals(_clipRectVec4)) {
	        _clipRectVec4 = this._clipRectVec4 = Object.freeze(tempVec4$1.clone());
	      }

	      // Update rendering layers...
	      var bgLayer = null;
	      if (hasBg) {
	        bgLayer = this._bgLayerDef || (this._bgLayerDef = {
	          key: 'bg',
	          facade: UIBlockLayer3DFacade
	        });
	        bgLayer.size = _sizeVec2;
	        bgLayer.color = backgroundColor;
	        bgLayer.borderRadius = radii;
	        bgLayer.material = backgroundMaterial;
	        bgLayer.clipRect = _clipRectVec4;
	        bgLayer.depthOffset = -flexNodeDepth;
	        bgLayer.renderOrder = flexNodeDepth; //TODO how can we make this play with the rest of the scene?
	        bgLayer.castShadow = this.castShadow;
	        bgLayer.receiveShadow = this.receiveShadow;
	      }
	      layers.children[0] = bgLayer;

	      var borderLayer = null;
	      if (hasBorder) {
	        borderLayer = this._borderLayerDef || (this._borderLayerDef = {
	          key: 'border',
	          facade: UIBlockLayer3DFacade,
	          isBorder: true
	        });
	        borderLayer.size = _sizeVec2;
	        borderLayer.color = borderColor;
	        borderLayer.borderWidth = _borderWidthVec4;
	        borderLayer.borderRadius = radii;
	        borderLayer.material = borderMaterial;
	        borderLayer.clipRect = _clipRectVec4;
	        borderLayer.depthOffset = -flexNodeDepth - 1;
	        borderLayer.renderOrder = flexNodeDepth + 1; //TODO how can we make this play with the rest of the scene?
	        borderLayer.castShadow = this.castShadow;
	        borderLayer.receiveShadow = this.receiveShadow;
	      }
	      layers.children[1] = borderLayer;

	      // Scrollbars if scrollable:
	      var scrollbarsLayer = null;
	      if (canScroll) {
	        scrollbarsLayer = this._scrollbarsDef || (this._scrollbarsDef = {
	          key: 'sb',
	          facade: ScrollbarsFacade,
	          target: this
	        });
	        scrollbarsLayer.renderOrder = flexNodeDepth + 2; //TODO how can we make this play with the rest of the scene?
	      }
	      layers.children[2] = scrollbarsLayer;

	      // Allow text to be specified as a single string child
	      if (!text && isTextNodeChild(this.children)) {
	        text = '' + this.children;
	      }
	      // Update text child...
	      if (text) {
	        var textChild = this._textChildDef || (this._textChildDef = {
	          key: 'text',
	          facade: UITextNode3DFacade$1
	        });
	        textChild.text = text;
	        textChild.font = getInheritable(this, 'font');
	        textChild.fontSize = this.getComputedFontSize();
	        textChild.textAlign = getInheritable(this, 'textAlign');
	        textChild.textIndent = getInheritable(this, 'textIndent');
	        textChild.lineHeight = getInheritable(this, 'lineHeight', DEFAULT_LINE_HEIGHT);
	        textChild.letterSpacing = getInheritable(this, 'letterSpacing', 0);
	        textChild.whiteSpace = getInheritable(this, 'whiteSpace');
	        textChild.overflowWrap = getInheritable(this, 'overflowWrap');
	        textChild.color = getInheritable(this, 'color');
	        textChild.colorRanges = this.colorRanges;
	        textChild.outlineWidth = this.textOutlineWidth || 0;
	        textChild.outlineColor = this.textOutlineColor;
	        textChild.outlineOpacity = this.textOutlineOpacity;
	        textChild.outlineBlur = this.textOutlineBlur || 0;
	        textChild.outlineOffsetX = this.textOutlineOffsetX || 0;
	        textChild.outlineOffsetY = this.textOutlineOffsetY || 0;
	        textChild.strokeWidth = this.textStrokeWidth || 0;
	        textChild.strokeColor = this.textStrokeColor;
	        textChild.strokeOpacity = this.textStrokeOpacity;
	        textChild.fillOpacity = this.textFillOpacity;
	        textChild.material = this.textMaterial;
	        textChild.depthOffset = -flexNodeDepth - 1;
	        textChild.renderOrder = flexNodeDepth + 1;
	        textChild.castShadow = this.castShadow;
	        textChild.receiveShadow = this.receiveShadow;
	        this._actualChildren = textChild; //NOTE: text content will clobber any other defined children
	      } else {
	        // Convert any children specified as plain strings to nested text blocks; handy for JSX style
	        var children = this.children;
	        if (Array.isArray(children)) {
	          for (var i = 0, len = children.length; i < len; i++) {
	            if (isTextNodeChild(children[i])) {
	              children = children.slice();
	              for (; i < len; i++) { //continue from here
	                if (isTextNodeChild(children[i])) {
	                  children[i] = {
	                    facade: UIBlock3DFacade$FlexNode,
	                    text: '' + children[i],
	                    textMaterial: this.textMaterial
	                  };
	                }
	              }
	              break
	            }
	          }
	        }
	        this._actualChildren = children;
	      }
	    }

	    // Add mousewheel and drag listeners if scrollable
	    if (canScroll !== this._couldScroll) {
	      this._couldScroll = canScroll;
	      this[((canScroll ? 'add' : 'remove') + "EventListener")]('wheel', wheelHandler);
	      this[((canScroll ? 'add' : 'remove') + "EventListener")]('dragstart', dragHandler);
	      this[((canScroll ? 'add' : 'remove') + "EventListener")]('drag', dragHandler);
	    }

	    Group3DFacade.prototype.afterUpdate.call(this);
	    if (!isFullyClipped || !_wasFullyClipped) {
	      layers.afterUpdate();
	    }
	    this._wasFullyClipped = isFullyClipped;
	  };

	  UIBlock3DFacade.prototype.describeChildren = function describeChildren () {
	    return this._actualChildren
	  };

	  UIBlock3DFacade.prototype.getComputedFontSize = function getComputedFontSize$1 () {
	    return getComputedFontSize(this, DEFAULT_FONT_SIZE)
	  };

	  UIBlock3DFacade.prototype._normalizeBorderRadius = function _normalizeBorderRadius () {
	    var ref = this;
	    var input = ref.borderRadius;
	    var offsetWidth = ref.offsetWidth; if ( offsetWidth === void 0 ) offsetWidth = 0;
	    var offsetHeight = ref.offsetHeight; if ( offsetHeight === void 0 ) offsetHeight = 0;
	    var prevVec4 = ref._borderRadiiVec4;

	    // Normalize to four corner values
	    var tl, tr, br, bl;
	    if (Array.isArray(input)) {
	      var len = input.length;
	      tl = input[0] || 0;
	      tr = (len > 1 ? input[1] : input[0]) || 0;
	      br = (len > 2 ? input[2] : input[0]) || 0;
	      bl = (len > 3 ? input[3] : len > 1 ? input[1] : input[0]) || 0;
	    } else {
	      tl = tr = br = bl = input || 0;
	    }

	    if (tl !== 0 || tr !== 0 || br !== 0 || bl !== 0) { //avoid work for common no-radius case
	      // Resolve percentages
	      var minDimension = Math.min(offsetWidth, offsetHeight);
	      if (typeof tl === 'string' && /%$/.test(tl)) {
	        tl = parseInt(tl, 10) / 100 * minDimension;
	      }
	      if (typeof tr === 'string' && /%$/.test(tr)) {
	        tr = parseInt(tr, 10) / 100 * minDimension;
	      }
	      if (typeof bl === 'string' && /%$/.test(bl)) {
	        bl = parseInt(bl, 10) / 100 * minDimension;
	      }
	      if (typeof br === 'string' && /%$/.test(br)) {
	        br = parseInt(br, 10) / 100 * minDimension;
	      }

	      // If any radii overlap based on the block's current size, reduce them all by the same ratio, ala CSS3.
	      var radiiAdjRatio = Math.min(
	        offsetWidth / (tl + tr),
	        offsetHeight / (tr + br),
	        offsetWidth / (br + bl),
	        offsetHeight / (bl + tl)
	      );
	      if (radiiAdjRatio < 1) {
	        tl *= radiiAdjRatio;
	        tr *= radiiAdjRatio;
	        bl *= radiiAdjRatio;
	        br *= radiiAdjRatio;
	      }
	    }

	    // Update the Vector4 if anything changed
	    tempVec4$1.set(tl, tr, br, bl);
	    if (!tempVec4$1.equals(prevVec4)) {
	      prevVec4 = this._borderRadiiVec4 = Object.freeze(tempVec4$1.clone());
	    }
	    return prevVec4
	  };

	  /**
	   * @override Use our private boundingSphere which we keep updated as we get new
	   * layout metrics.
	   */
	  UIBlock3DFacade.prototype._getGeometryBoundingSphere = function _getGeometryBoundingSphere () {
	    return this._geomBoundingSphere.radius && !this.isFullyClipped ? this._geomBoundingSphere : null
	  };

	  /**
	   * @override Custom raycaster to test against the layout block
	   */
	  UIBlock3DFacade.prototype.raycast = function raycast (raycaster) {
	    var this$1 = this;

	    var ref = this;
	    var offsetWidth = ref.offsetWidth;
	    var offsetHeight = ref.offsetHeight;
	    var clipTop = ref.clipTop;
	    var clipRight = ref.clipRight;
	    var clipBottom = ref.clipBottom;
	    var clipLeft = ref.clipLeft;
	    var hits = null;
	    if (offsetWidth && offsetHeight) {
	      raycastMesh.matrixWorld.multiplyMatrices(
	        this.threeObject.matrixWorld,
	        tempMat4$3.makeScale(offsetWidth, offsetHeight, 1)
	      );
	      hits = this._raycastObject(raycastMesh, raycaster);
	      if (hits) {
	        // Filter out hits that occurred on clipped areas
	        hits = hits.filter(function (hit) {
	          var x = hit.uv.x * offsetWidth;
	          var y = (1 - hit.uv.y) * offsetHeight;
	          return x > clipLeft && x < clipRight && y > clipTop && y < clipBottom
	        });

	        // Add a distance bias (used as secondary sort for equidistant intersections) to prevent
	        // container blocks from intercepting pointer events for their children. Also apply a
	        // slight rounding prevent floating point precision irregularities from reporting different
	        // distances for coplanar blocks.
	        hits.forEach(function (hit) {
	          hit.distance = parseFloat(hit.distance.toFixed(12));
	          hit.distanceBias = -this$1.flexNodeDepth;
	        });
	      }
	    }
	    return hits && hits.length ? hits : null
	  };


	  UIBlock3DFacade.prototype.destructor = function destructor () {
	    this.layers.destructor();
	    Group3DFacade.prototype.destructor.call(this);
	  };

	  return UIBlock3DFacade;
	}(Group3DFacade));

	// Extend as FlexNode
	var UIBlock3DFacade$FlexNode = UIBlock3DFacade = extendAsFlexNode(UIBlock3DFacade);

	INHERITABLES.forEach(function (prop) {
	  UIBlock3DFacade.prototype[prop] = 'inherit';
	});



	function wheelHandler(e) {
	  if (!e._didScroll) {
	    var facade = e.currentTarget;
	    var ref = e.nativeEvent;
	    var deltaX = ref.deltaX;
	    var deltaY = ref.deltaY;
	    var deltaMode = ref.deltaMode;
	    var deltaMultiplier;
	    if (deltaMode === 0x01) { //line mode
	      deltaMultiplier = getComputedFontSize(facade, DEFAULT_FONT_SIZE) *
	        getInheritable(facade, 'lineHeight', 1.2); //Note: fixed default since we can't resolve 'normal' here
	    } else { //pixel mode
	      //TODO can we more accurately scale to visual expectation?
	      deltaMultiplier = getComputedFontSize(facade, DEFAULT_FONT_SIZE) / 12;
	    }
	    deltaX *= deltaMultiplier;
	    deltaY *= deltaMultiplier;

	    var scrollLeft = Math.max(0, Math.min(
	      facade.scrollWidth - facade.clientWidth,
	      facade.scrollLeft + deltaX
	    ));
	    var scrollTop = Math.max(0, Math.min(
	      facade.scrollHeight - facade.clientHeight,
	      facade.scrollTop + deltaY
	    ));

	    // Only scroll if the major scroll direction would actually result in a scroll change
	    var abs = Math.abs;
	    if (
	      (scrollLeft !== facade.scrollLeft && abs(deltaX) > abs(deltaY)) ||
	      (scrollTop !== facade.scrollTop && abs(deltaY) > abs(deltaX))
	    ) {
	      facade.scrollLeft = scrollLeft;
	      facade.scrollTop = scrollTop;
	      facade.afterUpdate();
	      facade.requestRender();
	      e._didScroll = true;
	    }
	    e.preventDefault();
	  }
	}

	function dragHandler(e) {
	  if (!e._didScroll && !e.defaultPrevented) {
	    var facade = e.currentTarget;
	    var ray = e.ray.clone().applyMatrix4(invertMatrix4(facade.threeObject.matrixWorld, tempMat4$3));
	    var localPos = ray.intersectPlane(tempPlane$1.setComponents(0, 0, 1, 0), new Vector3());
	    var prevPos = facade._prevDragPos;
	    if (localPos && prevPos && e.type === 'drag') {
	      var deltaX = localPos.x - prevPos.x;
	      var deltaY = localPos.y - prevPos.y;
	      if (deltaX || deltaY) {
	        var scrollLeft = Math.max(0, Math.min(
	          facade.scrollWidth - facade.clientWidth,
	          facade.scrollLeft + deltaX
	        ));
	        var scrollTop = Math.max(0, Math.min(
	          facade.scrollHeight - facade.clientHeight,
	          facade.scrollTop + deltaY
	        ));
	        if (scrollLeft !== facade.scrollLeft || scrollTop !== facade.scrollTop) {
	          facade.scrollLeft = scrollLeft;
	          facade.scrollTop = scrollTop;
	          facade.afterUpdate();
	          facade.requestRender();
	          e._didScroll = true;
	        }
	      }
	    }
	    facade._prevDragPos = localPos;
	  }
	}


	function isTextNodeChild(child) {
	  return typeof child === 'string' || typeof child === 'number'
	}

	function updateMatrices(obj) {
	  if (obj.updateMatrices) {
	    obj.updateMatrices();
	  }
	}



	var Block = UIBlock3DFacade;

	var paleBlueDot = "\"From this distant vantage point, the Earth might not seem of any particular interest. But for us, it's different. Consider again that dot. That's here. That's home. That's us.\n\nOn it everyone you love, everyone you know, everyone you ever heard of, every human being who ever was, lived out their lives.\n\nThe aggregate of our joy and suffering, thousands of confident religions, ideologies, and economic doctrines, every hunter and forager, every hero and coward, every creator and destroyer of civilization, every king and peasant, every young couple in love, every mother and father, hopeful child, inventor and explorer, every teacher of morals, every corrupt politician, every 'superstar,' every 'supreme leader,' every saint and sinner in the history of our species lived there - on a mote of dust suspended in a sunbeam.\"\n\n- Carl Sagan";

	var cubeMaterial = new MeshStandardMaterial({roughness: 0.7, metalness: 0.7});
	var cubeMesh = new Mesh(
	  new BoxGeometry(1, 1, 1),
	  cubeMaterial
	);
	var Cube = /*@__PURE__*/(function (Instanceable3DFacade) {
	  function Cube(parent) {
	    Instanceable3DFacade.call(this, parent);
	    this.color = 0x3ba7db;
	  }

	  if ( Instanceable3DFacade ) Cube.__proto__ = Instanceable3DFacade;
	  Cube.prototype = Object.create( Instanceable3DFacade && Instanceable3DFacade.prototype );
	  Cube.prototype.constructor = Cube;

	  var prototypeAccessors = { color: { configurable: true } };
	  prototypeAccessors.color.set = function (c) {
	    this.setInstanceUniform('diffuse', new Color(c));
	    this._color = c;
	  };
	  prototypeAccessors.color.get = function () {
	    return this._color
	  };

	  Object.defineProperties( Cube.prototype, prototypeAccessors );

	  return Cube;
	}(Instanceable3DFacade));
	Cube.prototype.instancedThreeObject = cubeMesh;


	var anim = {
	  from: {rotateX: -Math.PI, rotateY: -Math.PI, rotateZ: -Math.PI},
	  to: {rotateX: Math.PI, rotateY: Math.PI, rotateZ: Math.PI},
	  duration: 10000,
	  iterations: Infinity
	};
	var animPaused = Object.assign({paused: true}, anim);


	var CubeOfCubes = /*@__PURE__*/(function (Group3DFacade) {
	  function CubeOfCubes(parent) {
	    var this$1 = this;

	    Group3DFacade.call(this, parent);
	    this.selectedColor = null;

	    var count = 4;
	    var cubesData = [];
	    for (var x = 0; x < count; x++) {
	      for (var y = 0; y < count; y++) {
	        for (var z = 0; z < count; z++) {
	          if (x*y*z === 0 || x === count-1 || y === count-1 || z === count-1) {
	            cubesData.push({
	              color: ((64 + x / count * 128) << 16) | ((64 + y / count * 128) << 8) | (64 + z / count * 128),
	              x: -0.5 + x / (count - 1),
	              y: -0.5 + y / (count - 1),
	              z: -0.5 + z / (count - 1)
	            });
	          }
	        }
	      }
	    }
	    this.children = this._childDef = {
	      facade: Group3DFacade,
	      animation: anim,
	      children: {
	        facade: List,
	        data: cubesData,
	        template: {
	          key: function (d) { return d.color; },
	          facade: Cube,
	          color: function (d) { return d.color; },
	          x: function (d) { return this$1.selectedColor === d.color ? 0 : d.x; },
	          y: function (d) { return this$1.selectedColor === d.color ? 0 : d.y; },
	          z: function (d) { return this$1.selectedColor === d.color ? 0 : d.z; },
	          scale: function (d) { return this$1.selectedColor === d.color ? 1.3 : 1 / (count - 1) / 2; },
	          pointerStates: function (d) { return this$1.selectedColor ? {} : {
	            hover: {
	              //color: 0xffffff,
	              scale: 1 / (count - 1) / 1.6
	            }
	          }; },
	          pointerEvents: true,
	          transition: {
	            x: {duration: 500, easing: 'easeOutBounce'},
	            y: {duration: 500, easing: 'easeOutBounce'},
	            z: {duration: 500, easing: 'easeOutBounce'},
	            scale: {duration: 500, easing: 'easeOutBounce'}
	          }
	        }
	      }
	    };

	    this.onMouseOver = function (e) {
	      this$1.hovering = true;
	      this$1.afterUpdate();
	    };
	    this.onMouseOut = function (e) {
	      this$1.hovering = false;
	      this$1.afterUpdate();
	    };
	    this.onClick = function (e) {
	      this$1.onSelectColor(this$1.selectedColor == null ? e.target.color : null);
	    };
	  }

	  if ( Group3DFacade ) CubeOfCubes.__proto__ = Group3DFacade;
	  CubeOfCubes.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  CubeOfCubes.prototype.constructor = CubeOfCubes;

	  CubeOfCubes.prototype.afterUpdate = function afterUpdate () {
	    var childDef = this._childDef;
	    this.threeObject.visible = this.offsetWidth != null;
	    childDef.animation = (this.hovering) ? animPaused : anim;

	    // Center within the layed out box
	    this.x = this.offsetLeft + this.offsetWidth / 2;
	    this.y = -(this.offsetTop + this.offsetHeight / 2);
	    childDef.scale = Math.min(this.clientWidth, this.clientHeight) / Math.sqrt(2);
	    Group3DFacade.prototype.afterUpdate.call(this);
	  };

	  return CubeOfCubes;
	}(Group3DFacade));

	var ColorCubes = extendAsFlexNode(CubeOfCubes);

	var geom;


	var Globe = /*@__PURE__*/(function (Object3DFacade) {
	  function Globe () {
	    Object3DFacade.apply(this, arguments);
	  }

	  if ( Object3DFacade ) Globe.__proto__ = Object3DFacade;
	  Globe.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  Globe.prototype.constructor = Globe;

	  var prototypeAccessors = { texture: { configurable: true } };

	  Globe.prototype.initThreeObject = function initThreeObject () {
	    return new Mesh(
	      geom || (geom = new SphereGeometry(0.5, 64, 64)),
	      new MeshStandardMaterial({
	        roughness: 0.5,
	        metalness: 0.5
	      })
	    )
	  };

	  prototypeAccessors.texture.set = function (val) {
	    if (val !== this._texture) {
	      this._texture = val;
	      var material = this.threeObject.material;
	      if (material.map) {
	        material.map.dispose();
	      }
	      material.map = val;
	    }
	  };

	  Object.defineProperties( Globe.prototype, prototypeAccessors );

	  return Globe;
	}(Object3DFacade));


	var FlexboxGlobe = /*@__PURE__*/(function (Group3DFacade) {
	  function FlexboxGlobe(parent) {
	    Group3DFacade.call(this, parent);
	    this._childDef = {
	      facade: Globe
	    };
	  }

	  if ( Group3DFacade ) FlexboxGlobe.__proto__ = Group3DFacade;
	  FlexboxGlobe.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  FlexboxGlobe.prototype.constructor = FlexboxGlobe;

	  FlexboxGlobe.prototype.afterUpdate = function afterUpdate () {
	    var childDef = this._childDef;
	    this.children = this.offsetWidth == null ? null : childDef;

	    // Center the globe within the layed out box
	    this.x = this.offsetLeft + this.offsetWidth / 2;
	    this.y = -(this.offsetTop + this.offsetHeight / 2);
	    childDef.scale = Math.min(this.clientWidth, this.clientHeight);
	    childDef.texture = this.texture;
	    Group3DFacade.prototype.afterUpdate.call(this);
	  };

	  return FlexboxGlobe;
	}(Group3DFacade));

	var FlexboxGlobe$1 = extendAsFlexNode(FlexboxGlobe);

	function clone(point) { //TODO: use gl-vec2 for this
	    return [point[0], point[1]]
	}

	function vec2(x, y) {
	    return [x, y]
	}

	var _function = function createBezierBuilder(opt) {
	    opt = opt||{};

	    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8;
	    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7;
	    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0;

	    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01;
	    var m_angle_tolerance = opt.angleTolerance || 0;
	    var m_cusp_limit = opt.cuspLimit || 0;

	    return function bezierCurve(start, c1, c2, end, scale, points) {
	        if (!points)
	            { points = []; }

	        scale = typeof scale === 'number' ? scale : 1.0;
	        var distanceTolerance = PATH_DISTANCE_EPSILON / scale;
	        distanceTolerance *= distanceTolerance;
	        begin(start, c1, c2, end, points, distanceTolerance);
	        return points
	    }


	    ////// Based on:
	    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

	    function begin(start, c1, c2, end, points, distanceTolerance) {
	        points.push(clone(start));
	        var x1 = start[0],
	            y1 = start[1],
	            x2 = c1[0],
	            y2 = c1[1],
	            x3 = c2[0],
	            y3 = c2[1],
	            x4 = end[0],
	            y4 = end[1];
	        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0);
	        points.push(clone(end));
	    }

	    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
	        if(level > RECURSION_LIMIT) 
	            { return }

	        var pi = Math.PI;

	        // Calculate all the mid-points of the line segments
	        //----------------------
	        var x12   = (x1 + x2) / 2;
	        var y12   = (y1 + y2) / 2;
	        var x23   = (x2 + x3) / 2;
	        var y23   = (y2 + y3) / 2;
	        var x34   = (x3 + x4) / 2;
	        var y34   = (y3 + y4) / 2;
	        var x123  = (x12 + x23) / 2;
	        var y123  = (y12 + y23) / 2;
	        var x234  = (x23 + x34) / 2;
	        var y234  = (y23 + y34) / 2;
	        var x1234 = (x123 + x234) / 2;
	        var y1234 = (y123 + y234) / 2;

	        if(level > 0) { // Enforce subdivision first time
	            // Try to approximate the full cubic curve by a single straight line
	            //------------------
	            var dx = x4-x1;
	            var dy = y4-y1;

	            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
	            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);

	            var da1, da2;

	            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
	                // Regular care
	                //-----------------
	                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
	                    // If the curvature doesn't exceed the distanceTolerance value
	                    // we tend to finish subdivisions.
	                    //----------------------
	                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
	                        points.push(vec2(x1234, y1234));
	                        return
	                    }

	                    // Angle & Cusp Condition
	                    //----------------------
	                    var a23 = Math.atan2(y3 - y2, x3 - x2);
	                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
	                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
	                    if(da1 >= pi) { da1 = 2*pi - da1; }
	                    if(da2 >= pi) { da2 = 2*pi - da2; }

	                    if(da1 + da2 < m_angle_tolerance) {
	                        // Finally we can stop the recursion
	                        //----------------------
	                        points.push(vec2(x1234, y1234));
	                        return
	                    }

	                    if(m_cusp_limit !== 0.0) {
	                        if(da1 > m_cusp_limit) {
	                            points.push(vec2(x2, y2));
	                            return
	                        }

	                        if(da2 > m_cusp_limit) {
	                            points.push(vec2(x3, y3));
	                            return
	                        }
	                    }
	                }
	            }
	            else {
	                if(d2 > FLT_EPSILON) {
	                    // p1,p3,p4 are collinear, p2 is considerable
	                    //----------------------
	                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
	                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
	                            points.push(vec2(x1234, y1234));
	                            return
	                        }

	                        // Angle Condition
	                        //----------------------
	                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
	                        if(da1 >= pi) { da1 = 2*pi - da1; }

	                        if(da1 < m_angle_tolerance) {
	                            points.push(vec2(x2, y2));
	                            points.push(vec2(x3, y3));
	                            return
	                        }

	                        if(m_cusp_limit !== 0.0) {
	                            if(da1 > m_cusp_limit) {
	                                points.push(vec2(x2, y2));
	                                return
	                            }
	                        }
	                    }
	                }
	                else if(d3 > FLT_EPSILON) {
	                    // p1,p2,p4 are collinear, p3 is considerable
	                    //----------------------
	                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
	                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
	                            points.push(vec2(x1234, y1234));
	                            return
	                        }

	                        // Angle Condition
	                        //----------------------
	                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
	                        if(da1 >= pi) { da1 = 2*pi - da1; }

	                        if(da1 < m_angle_tolerance) {
	                            points.push(vec2(x2, y2));
	                            points.push(vec2(x3, y3));
	                            return
	                        }

	                        if(m_cusp_limit !== 0.0) {
	                            if(da1 > m_cusp_limit)
	                            {
	                                points.push(vec2(x3, y3));
	                                return
	                            }
	                        }
	                    }
	                }
	                else {
	                    // Collinear case
	                    //-----------------
	                    dx = x1234 - (x1 + x4) / 2;
	                    dy = y1234 - (y1 + y4) / 2;
	                    if(dx*dx + dy*dy <= distanceTolerance) {
	                        points.push(vec2(x1234, y1234));
	                        return
	                    }
	                }
	            }
	        }

	        // Continue subdivision
	        //----------------------
	        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1); 
	        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1); 
	    }
	};

	var adaptiveBezierCurve = _function();

	var inherits_browser = createCommonjsModule(function (module) {
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	});

	var add_1 = add;

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function add(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    return out
	}

	var set_1 = set;

	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	function set(out, x, y) {
	    out[0] = x;
	    out[1] = y;
	    return out
	}

	var normalize_1 = normalize;

	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	function normalize(out, a) {
	    var x = a[0],
	        y = a[1];
	    var len = x*x + y*y;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	    }
	    return out
	}

	var subtract_1 = subtract;

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    return out
	}

	var dot_1 = dot;

	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1]
	}

	var tmp$1 = [0, 0];

	var computeMiter = function computeMiter(tangent, miter, lineA, lineB, halfThick) {
	    //get tangent line
	    add_1(tangent, lineA, lineB);
	    normalize_1(tangent, tangent);

	    //get miter as a unit vector
	    set_1(miter, -tangent[1], tangent[0]);
	    set_1(tmp$1, -lineA[1], lineA[0]);

	    //get the necessary length of our miter
	    return halfThick / dot_1(miter, tmp$1)
	};

	var normal = function normal(out, dir) {
	    //get perpendicular
	    set_1(out, -dir[1], dir[0]);
	    return out
	};

	var direction = function direction(out, a, b) {
	    //get unit dir of two lines
	    subtract_1(out, a, b);
	    normalize_1(out, out);
	    return out
	};

	var polylineMiterUtil = {
		computeMiter: computeMiter,
		normal: normal,
		direction: direction
	};

	var lineA = [0, 0];
	var lineB = [0, 0];
	var tangent = [0, 0];
	var miter = [0, 0];

	var polylineNormals = function(points, closed) {
	    var curNormal = null;
	    var out = [];
	    if (closed) {
	        points = points.slice();
	        points.push(points[0]);
	    }

	    var total = points.length;
	    for (var i=1; i<total; i++) {
	        var last = points[i-1];
	        var cur = points[i];
	        var next = i<points.length-1 ? points[i+1] : null;

	        polylineMiterUtil.direction(lineA, cur, last);
	        if (!curNormal)  {
	            curNormal = [0, 0];
	            polylineMiterUtil.normal(curNormal, lineA);
	        }

	        if (i === 1) //add initial normals
	            { addNext(out, curNormal, 1); }

	        if (!next) { //no miter, simple segment
	            polylineMiterUtil.normal(curNormal, lineA); //reset normal
	            addNext(out, curNormal, 1);
	        } else { //miter with last
	            //get unit dir of next line
	            polylineMiterUtil.direction(lineB, next, cur);

	            //stores tangent & miter
	            var miterLen = polylineMiterUtil.computeMiter(tangent, miter, lineA, lineB, 1);
	            addNext(out, miter, miterLen);
	        }
	    }

	    //if the polyline is a closed loop, clean up the last normal
	    if (points.length > 2 && closed) {
	        var last2 = points[total-2];
	        var cur2 = points[0];
	        var next2 = points[1];

	        polylineMiterUtil.direction(lineA, cur2, last2);
	        polylineMiterUtil.direction(lineB, next2, cur2);
	        polylineMiterUtil.normal(curNormal, lineA);
	        
	        var miterLen2 = polylineMiterUtil.computeMiter(tangent, miter, lineA, lineB, 1);
	        out[0][0] = miter.slice();
	        out[total-1][0] = miter.slice();
	        out[0][1] = miterLen2;
	        out[total-1][1] = miterLen2;
	        out.pop();
	    }

	    return out
	};

	function addNext(out, normal, length) {
	    out.push([[normal[0], normal[1]], length]);
	}

	var VERTS_PER_POINT = 2;

	var threeLine2d = function createLineMesh (THREE) {
	  function LineMesh (path, opt) {
	    if (!(this instanceof LineMesh)) {
	      return new LineMesh(path, opt);
	    }
	    THREE.BufferGeometry.call(this);

	    if (Array.isArray(path)) {
	      opt = opt || {};
	    } else if (typeof path === 'object') {
	      opt = path;
	      path = [];
	    }

	    opt = opt || {};

	    this.addAttribute('position', new THREE.BufferAttribute(undefined, 3));
	    this.addAttribute('lineNormal', new THREE.BufferAttribute(undefined, 2));
	    this.addAttribute('lineMiter', new THREE.BufferAttribute(undefined, 1));
	    if (opt.distances) {
	      this.addAttribute('lineDistance', new THREE.BufferAttribute(undefined, 1));
	    }
	    if (typeof this.setIndex === 'function') {
	      this.setIndex(new THREE.BufferAttribute(undefined, 1));
	    } else {
	      this.addAttribute('index', new THREE.BufferAttribute(undefined, 1));
	    }
	    this.update(path, opt.closed);
	  }

	  inherits_browser(LineMesh, THREE.BufferGeometry);

	  LineMesh.prototype.update = function (path, closed) {
	    path = path || [];
	    var normals = polylineNormals(path, closed);

	    if (closed) {
	      path = path.slice();
	      path.push(path[0]);
	      normals.push(normals[0]);
	    }

	    var attrPosition = this.getAttribute('position');
	    var attrNormal = this.getAttribute('lineNormal');
	    var attrMiter = this.getAttribute('lineMiter');
	    var attrDistance = this.getAttribute('lineDistance');
	    var attrIndex = typeof this.getIndex === 'function' ? this.getIndex() : this.getAttribute('index');

	    var indexCount = Math.max(0, (path.length - 1) * 6);
	    if (!attrPosition.array ||
	        (path.length !== attrPosition.array.length / 3 / VERTS_PER_POINT)) {
	      var count = path.length * VERTS_PER_POINT;
	      attrPosition.array = new Float32Array(count * 3);
	      attrNormal.array = new Float32Array(count * 2);
	      attrMiter.array = new Float32Array(count);
	      attrIndex.array = new Uint16Array(indexCount);

	      if (attrDistance) {
	        attrDistance.array = new Float32Array(count);
	      }
	    }

	    if (undefined !== attrPosition.count) {
	      attrPosition.count = count;
	    }
	    attrPosition.needsUpdate = true;

	    if (undefined !== attrNormal.count) {
	      attrNormal.count = count;
	    }
	    attrNormal.needsUpdate = true;

	    if (undefined !== attrMiter.count) {
	      attrMiter.count = count;
	    }
	    attrMiter.needsUpdate = true;

	    if (undefined !== attrIndex.count) {
	      attrIndex.count = indexCount;
	    }
	    attrIndex.needsUpdate = true;

	    if (attrDistance) {
	      if (undefined !== attrDistance.count) {
	        attrDistance.count = count;
	      }
	      attrDistance.needsUpdate = true;
	    }

	    var index = 0;
	    var c = 0;
	    var dIndex = 0;
	    var indexArray = attrIndex.array;

	    path.forEach(function (point, pointIndex, list) {
	      var i = index;
	      indexArray[c++] = i + 0;
	      indexArray[c++] = i + 1;
	      indexArray[c++] = i + 2;
	      indexArray[c++] = i + 2;
	      indexArray[c++] = i + 1;
	      indexArray[c++] = i + 3;

	      attrPosition.setXYZ(index++, point[0], point[1], 0);
	      attrPosition.setXYZ(index++, point[0], point[1], 0);

	      if (attrDistance) {
	        var d = pointIndex / (list.length - 1);
	        attrDistance.setX(dIndex++, d);
	        attrDistance.setX(dIndex++, d);
	      }
	    });

	    var nIndex = 0;
	    var mIndex = 0;
	    normals.forEach(function (n) {
	      var norm = n[0];
	      var miter = n[1];
	      attrNormal.setXY(nIndex++, norm[0], norm[1]);
	      attrNormal.setXY(nIndex++, norm[0], norm[1]);

	      attrMiter.setX(mIndex++, -miter);
	      attrMiter.setX(mIndex++, miter);
	    });
	  };

	  return LineMesh;
	};

	var Line2DGeometry = threeLine2d({BufferAttribute: BufferAttribute, BufferGeometry: BufferGeometry});

	var PatchedLine2DGeometry = /*@__PURE__*/(function (Line2DGeometry) {
	  function PatchedLine2DGeometry () {
	    Line2DGeometry.apply(this, arguments);
	  }

	  if ( Line2DGeometry ) PatchedLine2DGeometry.__proto__ = Line2DGeometry;
	  PatchedLine2DGeometry.prototype = Object.create( Line2DGeometry && Line2DGeometry.prototype );
	  PatchedLine2DGeometry.prototype.constructor = PatchedLine2DGeometry;

	  PatchedLine2DGeometry.prototype.addAttribute = function addAttribute () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (this.setAttribute) {
	      return (ref = this).setAttribute.apply(ref, args)
	    } else {
	      return Line2DGeometry.prototype.setAttribute.apply(this, args)
	    }
	  };

	  // Patch overwriting of BufferAttribute.array, which is no longer supported and causes errors:
	  PatchedLine2DGeometry.prototype.update = function update () {
	    var this$1 = this;
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    // Store previous arrays:
	    var indexArray = this.getIndex().array;
	    var attrArrays = {};
	    Object.keys(this.attributes).forEach(function (name) {
	      attrArrays[name] = this$1.getAttribute(name).array;
	    });

	    var result = Line2DGeometry.prototype.update.apply(this, args);

	    // If any attribute's array was changed, replace that whole attribute:
	    Object.keys(this.attributes).forEach(function (name) {
	      if (attrArrays[name] && attrArrays[name] !== this$1.getAttribute(name).array) {
	        this$1.setAttribute(name, this$1.getAttribute(name).clone());
	      }
	    });
	    if (indexArray && indexArray !== this.getIndex().array) {
	      this.setIndex(this.getIndex().clone());
	    }

	    return result
	  };

	  return PatchedLine2DGeometry;
	}(Line2DGeometry));

	var strokeVertexShader = "\n// Basic three-line-2d vertex shader for the line stroke\n\nuniform float thickness;\nattribute float lineMiter;\nattribute vec2 lineNormal;\n\nvoid main() {\n  vec3 pointPos = position.xyz + vec3(lineNormal * thickness / 2.0 * lineMiter, 0.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pointPos, 1.0);\n}\n";

	var strokeFragmentShader = "\n// Basic three-line-2d fragment shader for the line stroke\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main() {\n  gl_FragColor = vec4(color, opacity);\n}\n";

	var fillVertexShader = "\n// Vertex shader for the three-line-2d geometry that drops its down-facing vertices\n// to the bottom line, thereby creating a mesh covering the curve's fill area\n\nuniform int gradientScale; //0 = per value, 1 = max value\nuniform float maxY;\n\nattribute float lineMiter;\n\nvarying float varGradientTopY;\nvarying float varY;\n\nvoid main() {\n  // Drop all vertexes forming the bottom of triangles down to y:0\n  float y = lineMiter < 0.0 ? 0.0 : position.y;\n\n  // Pass along values for gradient distance calculation\n  varGradientTopY = gradientScale == 1 ? maxY : position.y;\n  varY = y;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, y, 0.0, 1.0);\n}\n";

	var fillFragmentShader = "\n// Fragment shader for the curve's fill area. Handles both solid color and gradient fill styles.\n\nuniform vec3 color;\nuniform float opacity;\nuniform float gradientPercent;\nuniform float gradientExp;\n\nvarying float varGradientTopY;\nvarying float varY;\n\nvoid main() {\n  float alpha = opacity;\n\n  // If a gradient is defined, calculate the varying opacity for the current y value\n  if (gradientPercent > 0.0) {\n    float gradPos = smoothstep(varGradientTopY - varGradientTopY * gradientPercent, varGradientTopY, varY);\n    alpha = opacity * pow(gradPos, max(gradientExp, 1.0));\n  }\n\n  gl_FragColor = vec4(color, alpha);\n}\n";

	// Given an array of y values, construct a smooth curve connecting those points.
	function valuesToCurvePoints(values, totalWidth, totalHeight) {
	  var p1 = [];
	  var c1 = [];
	  var c2 = [];
	  var p2 = [];
	  var maxValue = Math.max.apply(Math, values);
	  var curveValues = [];
	  for (var i = 1; i < values.length; i++) {
	    var xMult = totalWidth / (values.length - 1);
	    var yMult = totalHeight / maxValue;
	    p1[0] = (i - 1) * xMult;
	    p1[1] = c1[1] = values[i - 1] * yMult;
	    c1[0] = c2[0] = (i - 0.5) * xMult;
	    c2[1] = p2[1] = values[i] * yMult;
	    p2[0] = i * xMult;
	    var segmentPoints = adaptiveBezierCurve(p1, c1, c2, p2);
	    for (var j = i === 1 ? 0 : 1; j < segmentPoints.length; j++) {
	      curveValues.push(segmentPoints[j]);
	    }
	  }
	  return curveValues;
	}

	// Given an array of y values, construct a step path connecting those points.
	function valuesToSquarePoints(values, totalWidth, totalHeight) {
	  var maxValue = Math.max.apply(Math, values);
	  var curveValues = [];
	  for (var i = 0; i < values.length; i++) {
	    var xMult = totalWidth / (values.length - 1);
	    var yMult = totalHeight / maxValue;
	    if (i > 0) {
	      curveValues.push([i * xMult, values[i - 1] * yMult]);
	    }
	    curveValues.push([i * xMult, values[i] * yMult]);
	  }
	  return curveValues;
	}

	// Facade for the curve.
	var LineGraph = /*@__PURE__*/(function (Object3DFacade) {
	  function LineGraph(parent) {
	    Object3DFacade.call(this, parent, new Group());

	    // Use a single Line2D buffer geometry for both stroke and fill meshes
	    var geometry = new PatchedLine2DGeometry();

	    // Stroke mesh with custom shader material
	    this.strokeMesh = new Mesh(
	      geometry,
	      new ShaderMaterial({
	        uniforms: {
	          thickness: { value: 1 },
	          color: { value: new Color() },
	          opacity: { value: 1 }
	        },
	        transparent: true,
	        vertexShader: strokeVertexShader,
	        fragmentShader: strokeFragmentShader,
	        //depthTest: false,
	        side: DoubleSide
	      })
	    );

	    // Fill mesh with custom shader material
	    this.fillMesh = new Mesh(
	      geometry,
	      new ShaderMaterial({
	        uniforms: {
	          color: { value: new Color() },
	          opacity: { value: 1 },
	          gradientScale: { value: 1 },
	          gradientPercent: { value: 1 },
	          gradientExp: { value: 1 },
	          maxY: { value: 1 }
	        },
	        transparent: true,
	        vertexShader: fillVertexShader,
	        fragmentShader: fillFragmentShader,
	        //depthTest: false,
	        side: DoubleSide
	      })
	    );
	    this.strokeMesh.frustumCulled = this.fillMesh.frustumCulled = false;

	    // Add both meshes to the Group
	    this.threeObject.add(this.strokeMesh, this.fillMesh);
	  }

	  if ( Object3DFacade ) LineGraph.__proto__ = Object3DFacade;
	  LineGraph.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
	  LineGraph.prototype.constructor = LineGraph;

	  LineGraph.prototype.afterUpdate = function afterUpdate () {
	    // Update the shared geometry
	    var geometry = this.strokeMesh.geometry;
	    geometry.update(
	      this.pathShape === "step"
	        ? valuesToSquarePoints(this.values, this.width, this.height)
	        : valuesToCurvePoints(this.values, this.width, this.height)
	    );

	    // Update the stroke mesh
	    var hasStroke =
	      this.strokeWidth && this.strokeColor && this.strokeOpacity > 0;
	    if (hasStroke) {
	      var strokeUniforms = this.strokeMesh.material.uniforms;
	      strokeUniforms.color.value.set(this.strokeColor);
	      strokeUniforms.opacity.value = this.strokeOpacity;
	      strokeUniforms.thickness.value = this.strokeWidth;
	    }
	    this.strokeMesh.visible = !!hasStroke;

	    // Update the fill mesh
	    var hasFill = this.fillColor && this.fillOpacity > 0;
	    if (hasFill) {
	      var fillUniforms = this.fillMesh.material.uniforms;
	      fillUniforms.color.value.set(this.fillColor);
	      fillUniforms.opacity.value = this.fillOpacity;
	      fillUniforms.gradientScale.value =
	        this.fillGradientScale === "max-value" ? 1 : 0;
	      fillUniforms.maxY.value = this.height;
	      fillUniforms.gradientPercent.value = this.fillGradientPercent || 0;
	      fillUniforms.gradientExp.value = this.fillGradientExp || 1;
	    }
	    this.fillMesh.visible = !!hasFill;

	    this.fillMesh.renderOrder = this.strokeMesh.renderOrder =
	      this.renderOrder || 0;

	    Object3DFacade.prototype.afterUpdate.call(this);
	  };

	  return LineGraph;
	}(Object3DFacade));

	// defaults
	Object.assign(LineGraph.prototype, {
	  width: 500,
	  height: 100,
	  strokeWidth: 2,
	  strokeColor: 0xffffff,
	  strokeOpacity: 1,
	  fillColor: 0xffffff,
	  fillOpacity: 0.5,
	  fillGradientScale: "per-value", //or 'max-value'
	  fillGradientPercent: 1,
	  fillGradientExp: 3,
	  pathShape: "curve" //or 'step'
	});

	function interpolateArray(fromValue, toValue, progress) {
	  var interpolated = new Float32Array(toValue.length);
	  for (var i = interpolated.length; i--; ) {
	    var from = i < fromValue.length ? fromValue[i] : 0;
	    interpolated[i] = from + (toValue[i] - from) * progress;
	  }
	  return interpolated
	}



	var FlexboxLineGraph = /*@__PURE__*/(function (Group3DFacade) {
	  function FlexboxLineGraph(parent) {
	    Group3DFacade.call(this, parent);

	    this.curveChildDef = {
	      key: 'curve',
	      facade: LineGraph,
	      values: [],
	      transition: {
	        values: {
	          duration: 1000,
	          easing: 'easeInOutCubic',
	          interpolate: interpolateArray
	        }
	      }
	    };
	  }

	  if ( Group3DFacade ) FlexboxLineGraph.__proto__ = Group3DFacade;
	  FlexboxLineGraph.prototype = Object.create( Group3DFacade && Group3DFacade.prototype );
	  FlexboxLineGraph.prototype.constructor = FlexboxLineGraph;

	  FlexboxLineGraph.prototype.afterUpdate = function afterUpdate () {
	    if (this.offsetWidth) {
	      var childDef = this.curveChildDef;
	      childDef.values = this.values;
	      this.x = this.offsetLeft + this.clientLeft;
	      this.y = -(this.offsetTop + this.clientTop + this.clientHeight);
	      childDef.width = this.clientWidth;
	      childDef.height = this.clientHeight;
	      childDef.strokeColor = childDef.fillColor = this.color;
	      childDef.renderOrder = this.flexNodeDepth;
	      this.children = childDef;
	    }
	    Group3DFacade.prototype.afterUpdate.call(this);
	  };

	  return FlexboxLineGraph;
	}(Group3DFacade));

	var FlexboxLineGraph$1 = extendAsFlexNode(FlexboxLineGraph);

	/**
	 * Convenience class for displaying icons using the Material Icons library. See https://material.io/icons/
	 *
	 * Use this just like any other UIBlock3DFacade, but set its `icon` property to the name of the icon
	 * you wish to display.
	 *
	 * Note: internally this simply sets the 'text' property, using the Material Icons web font. Since that
	 * font utilizes ligatures to alias each icon's full name to its glyph, and Troika's text rendering engine
	 * has support for ligatures, this just works without having to deal with obscure character codes.
	 */
	var MaterialIconFacade = /*@__PURE__*/(function (UIBlock3DFacade) {
	  function MaterialIconFacade(parent) {
	    UIBlock3DFacade.call(this, parent);

	    // Material Icons font URL
	    this.font = 'https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNa.woff';
	  }

	  if ( UIBlock3DFacade ) MaterialIconFacade.__proto__ = UIBlock3DFacade;
	  MaterialIconFacade.prototype = Object.create( UIBlock3DFacade && UIBlock3DFacade.prototype );
	  MaterialIconFacade.prototype.constructor = MaterialIconFacade;

	  var prototypeAccessors = { icon: { configurable: true },size: { configurable: true } };

	  prototypeAccessors.icon.set = function (val) {
	    this.text = val;
	  };
	  prototypeAccessors.size.set = function (val) {
	    this.fontSize = val;
	  };

	  Object.defineProperties( MaterialIconFacade.prototype, prototypeAccessors );

	  return MaterialIconFacade;
	}(Block));

	var INIT_ORIGIN = {
	  x: 0,
	  y: 0,
	  z: 0,
	  rotateY: 0
	};

	var TABS = [
	  {
	    key: 'colors',
	    title: 'Colors',
	    desc: 'Select a color from the cubes to show its value.'
	  },
	  {
	    key: 'globe',
	    title: 'Globes',
	    desc: paleBlueDot
	  },
	  {
	    key: 'graph',
	    title: 'Graphs',
	    desc: 'Line graphs stacked in the depth dimension'
	  }
	];

	var GLOBE_TEXTURES = [
	  {
	    title: 'Day',
	    url: 'globe/texture_day.jpg'
	  },
	  {
	    title: 'Night',
	    url: 'globe/texture_night.jpg'
	  },
	  {
	    title: 'Blue Marble',
	    url: 'globe/texture_bluemarble.jpg'
	  },
	  {
	    title: 'Pumpkin',
	    url: 'globe/texture_pumpkin.jpg'
	  }
	];



	var GRAPH_COLORS = [0x996600, 0x009966, 0x006699, 0x669900, 0x660099];
	var GRAPH_POINTS = 36;

	var globeAnim = [
	  {
	    from: {scale: 0.001},
	    to: {scale: 1},
	    easing: 'easeOutExpo'
	  },
	  {
	    from: {rotateY: 0},
	    to: {rotateY: Math.PI * 2},
	    duration: 20000,
	    iterations: Infinity
	  }
	];

	var mainStageAngle = -Math.PI / 2.2;

	var backdropMaterial = new MeshStandardMaterial({roughness: 0.6, metalness: 0.8});

	var texLoader = new TextureLoader();

	function loadTextures() {
	  GLOBE_TEXTURES.forEach(function (d) {
	    if (!d.texture) {
	      d.texture = texLoader.load(d.url);
	    }
	  });
	}




	var UIExample = /*@__PURE__*/(function (superclass) {
	  function UIExample(props) {
	    var this$1 = this;

	    superclass.call(this, props);

	    loadTextures();

	    this.state = {
	      tab: 'colors',
	      globeTexture: GLOBE_TEXTURES[0],
	      cameraVrOrigin: INIT_ORIGIN
	    };

	    this._onTabClick = function (e) {
	      this$1.setState({
	        tab: e.target.id,
	        selectedColor: null
	      });
	    };
	    this._onSelectColor = function (selectedColor) {
	      this$1.setState({selectedColor: selectedColor});
	    };
	    this._onSelectGlobeTexture = function (globeTexture) {
	      this$1.setState({globeTexture: globeTexture});
	    };
	    this._randomizeGraphData = function () {
	      this$1.setState({
	        graphData: GRAPH_COLORS.map(function (color) {
	          var values = [];
	          for (var i = GRAPH_POINTS; i--;) {
	            values[i] = Math.random() * 10 + 5;
	          }
	          return {color: color, values: values}
	        })
	      });
	    };
	    this._onRecenterViewClick = function (e) {
	      var matrix = e.target.getCameraFacade().threeObject.matrixWorld;
	      var pos = new Vector3();
	      var quat = new Quaternion();
	      var euler = new Euler();
	      matrix.decompose(pos, quat, new Vector3());
	      euler.setFromQuaternion(quat);
	      this$1.setState({
	        cameraVrOrigin: {
	          x: pos.x,
	          y: pos.y,
	          z: pos.z,
	          rotateY: euler.y
	        }
	      });
	    };
	  }

	  if ( superclass ) UIExample.__proto__ = superclass;
	  UIExample.prototype = Object.create( superclass && superclass.prototype );
	  UIExample.prototype.constructor = UIExample;

	  UIExample.prototype.componentDidMount = function componentDidMount () {
	    this._randomizeGraphData();
	  };

	  UIExample.prototype.render = function render () {
	    var this$1 = this;

	    var ref = this;
	    var props = ref.props;
	    var state = ref.state;
	    var vr = props.vr;
	    var rootTransform = vr ? state.cameraVrOrigin : INIT_ORIGIN;
	    var tab = TABS.find(function (d) { return d.key === state.tab; });

	    return react.createElement( 'div', null, 
	      react.createElement( Canvas3D, {
	        antialias: true, backgroundColor: 0, stats: props.stats, width: props.width, height: props.height, camera: {
	          z: vr ? 0 : 0.5
	        }, lights: [
	          {type: 'point', x: 1},
	          {type: 'point', x: -1}
	        ], objects: [
	          Object.assign({}, rootTransform, {
	            key: 'root',
	            facade: Group3DFacade,
	            children: [
	              react.createElement( Block, {
	                key: "uiRoot", flexDirection: "column", alignItems: "center", fontSize: 20, width: 1280, scale: 1 / 640, x: -1, y: 0.3, z: -1.4 }, 
	                react.createElement( Block, {
	                  key: "topRow", height: 320, flexDirection: "row" }, 
	                  react.createElement( Block, {
	                    key: "titleAndDesc", backgroundMaterial: backdropMaterial, backgroundColor: 0x333333, flexDirection: "column", alignItems: "stretch", width: 320, rotateY: Math.PI / 8, z: 320 * Math.sin(Math.PI / 8), left: 320 - 320 * Math.cos(Math.PI / 8) }, 
	                    react.createElement( Block, {
	                      backgroundMaterial: backdropMaterial, backgroundColor: 0x444444, fontSize: 30, padding: [10, 20] }, tab.title), 
	                    react.createElement( Block, { padding: 20, flex: 1, overflow: "scroll" }, 
	                      tab.desc
	                    )
	                  ), 

	                  react.createElement( Block, {
	                    key: "backdrop", width: 640, backgroundMaterial: backdropMaterial, backgroundColor: 0x333333 }), 

	                  react.createElement( Block, {
	                    key: "options", backgroundMaterial: backdropMaterial, backgroundColor: 0x333333, flexDirection: "column", width: 320, rotateY: -Math.PI / 8, padding: 20 }, 
	                    tab.key === 'colors' ? (
	                        state.selectedColor == null ? null : [
	                          react.createElement( Block, { key: "title", margin: [20, 0] }, "Selected Color:"),
	                          react.createElement( Block, { key: "info", flex: 1, flexDirection: "row", alignItems: "center" }, 
	                            react.createElement( Block, {
	                              key: "swatch", width: 64, height: 64, backgroundColor: state.selectedColor, borderWidth: 2, borderColor: 0xffffff, margin: [0, 10, 0, 0], z: 50 }), 
	                            react.createElement( Block, { fontSize: 30 }, '#' + new Color(state.selectedColor).getHexString())
	                          ),
	                          buttonDef({
	                            key: 'back',
	                            onClick: this._onSelectColor.bind(this, null),
	                            margin: [10, 5],
	                            alignSelf: "flex-start",
	                            fontSize: 24,
	                            icon: 'arrow_back',
	                            text: 'Back'
	                          })
	                        ]
	                      ) : tab.key === 'globe' ? (
	                        [
	                          react.createElement( Block, { key: "title", margin: [20, 0] }, "Choose a Texture:")
	                        ].concat(GLOBE_TEXTURES.map(function (d, i) { return react.createElement( Block, {
	                            key: i, flexDirection: "row", alignItems: "center", padding: [4, 0], color: 0xffffff, pointerStates: {hover: {color: 0x00ccff}}, onClick: this$1._onSelectGlobeTexture.bind(this$1, d) }, 
	                            react.createElement( MaterialIconFacade, { icon: 'radio_button_' + (d === state.globeTexture ? 'checked' : 'unchecked') }), " ", d.title
	                          ); }
	                        ))
	                      ) : tab.key === 'graph' ? (
	                        buttonDef({
	                          onClick: this._randomizeGraphData,
	                          fontSize: 24,
	                          text: 'Randomize Data'
	                        })
	                      ) : ''
	                  )

	                ), 

	                react.createElement( Block, {
	                  key: "mainStage", width: 640, height: 640, rotateX: mainStageAngle, borderWidth: 3, borderColor: 0x999999, borderRadius: [0, 0, 10, 10] }
	                  /*<Block
	                    key={tab.key}
	                    flex={1}
	                    animation={stageEnterAnim}
	                    exitAnimation={stageExitAnim}
	                  >*/, 
	                    tab.key === 'colors' ? (
	                        react.createElement( ColorCubes, {
	                          flex: 1, margin: 180, z: 120, selectedColor: state.selectedColor, onSelectColor: this._onSelectColor, animation: {
	                            from: {scale: 0.001},
	                            to: {scale: 1},
	                            easing: 'easeOutExpo'
	                          } })
	                      ) : tab.key === 'globe' ? (
	                        react.createElement( FlexboxGlobe$1, {
	                          flex: 1, margin: 150, z: 120, rotateX: -mainStageAngle, scaleX: 1, scaleZ: 1, scaleY: state.globeTexture.url.indexOf('pumpkin') > -1 ? 0.6 : 1, texture: state.globeTexture.texture, animation: globeAnim, transition: {scaleY: true, scaleX: true, scaleZ: true} })
	                      ) : tab.key === 'graph' ? (
	                        state.graphData.map(function (d, i, all) { return react.createElement( FlexboxLineGraph$1, {
	                            key: i, flex: 1, margin: [10, 0], color: d.color, values: d.values, animation: {
	                              from: {rotateX: 0, z: 0},
	                              to: {rotateX: -mainStageAngle, z: (all.length - i - 1) * 20},
	                              duration: 750,
	                              delay: (all.length - i - 1) * 100,
	                              easing: 'easeOutExpo'
	                            } }); }
	                        )
	                      ) : ''
	                  /*</Block>*/
	                ), 

	                react.createElement( Block, {
	                  key: "tabs", flexDirection: "row", justifyContent: "center", width: 640, z: -Math.sin(mainStageAngle) * 640, top: -640 + 640 * Math.cos(mainStageAngle), rotateX: -Math.PI / 4 }, 
	                  TABS.map(function (d) {
	                      var active = state.tab === d.key;
	                      return buttonDef({
	                        key: d.key,
	                        id: d.key,
	                        onClick: this$1._onTabClick,
	                        margin: [10, 5],
	                        fontSize: 15,
	                        backgroundColor: active ? 0x00ccff : 0x666666,
	                        pointerEvents: !active,
	                        z: active ? 10 : 0,
	                        text: d.title
	                      })
	                    })
	                ), 

	                vr ? buttonDef({
	                  onClick: this._onRecenterViewClick,
	                  icon: 'sync',
	                  text: 'Recenter View',
	                  alignSelf: 'center',
	                  backgroundColor: 0,
	                  color: 0x333333,
	                  fontSize: 24,
	                  rotateX: -Math.PI / 4,
	                  pointerStates: {
	                    hover: {
	                      backgroundColor: 0x666666,
	                      color: 0xffffff
	                    }
	                  }
	                }) : null
	              )
	            ]
	          })
	        ] })
	    )
	  };

	  return UIExample;
	}(react.Component));


	function buttonDef(props) {
	  return Object.assign({
	    facade: Block,
	    padding: [5, 10],
	    borderRadius: 5,
	    flexDirection: "row",
	    alignItems: "center",
	    justifyContent: 'center',
	    backgroundColor: 0x00ccff,
	    pointerStates: {
	      hover: {
	        backgroundColor: 0x0099cc
	      }
	    },
	    transition: {
	      z: true,
	      color: {interpolate: 'color'},
	      backgroundColor: {interpolate: 'color'}
	    },
	    children: [
	      props.icon ? react.createElement( MaterialIconFacade, { icon: props.icon }) : null,
	      props.text
	    ]
	  }, props, {text: null, icon: null})
	}

	function styleInject(css, ref) {
	  if ( ref === void 0 ) { ref = {}; }
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') { return; }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = ".react-dat-gui{position:fixed;right:16px;top:0;width:280px;font-size:12px;font-family:Lucida Grande,sans-serif;box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent}.react-dat-gui *,.react-dat-gui :after,.react-dat-gui :before{box-sizing:inherit}.react-dat-gui .dg{margin:0;padding:0;color:#eee;overflow:hidden}.react-dat-gui .dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.react-dat-gui .dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.react-dat-gui .dg.main::-webkit-scrollbar-corner{height:0;display:none}.react-dat-gui .dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.react-dat-gui .cr{display:block;background-color:#1a1a1a;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.react-dat-gui .cr:not(:last-child){border-bottom:1px solid #272727}.react-dat-gui .cr label{display:flex;align-items:center;justify-content:flex-start;width:100%;padding:1px 2px 1px 8px}.react-dat-gui .cr .label-text{width:40%;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.react-dat-gui .cr input[type=number],.react-dat-gui .cr input[type=text]{background:#303030;border:3px solid #1a1a1a;border-radius:0;margin:0;outline:none;font-size:inherit}.react-dat-gui .cr input[type=number]:hover,.react-dat-gui .cr input[type=text]:hover{background:#3c3c3c}.react-dat-gui .cr input[type=number]:focus,.react-dat-gui .cr input[type=text]:focus{background:#494949;color:#fff}.react-dat-gui .cr input[type=number]::-ms-clear,.react-dat-gui .cr input[type=text]::-ms-clear{display:none}.react-dat-gui .cr.boolean{position:relative;border-left:5px solid #806787}.react-dat-gui .cr.boolean label{cursor:pointer}.react-dat-gui .cr.boolean .label-text{display:block;padding:5px 0}.react-dat-gui .cr.boolean .checkbox-container{width:100%}.react-dat-gui .cr.boolean input[type=checkbox]{margin:0;vertical-align:middle}.react-dat-gui .cr.button{border-left:5px solid #e61d5f}.react-dat-gui .cr.button:hover{background:#111}.react-dat-gui .cr.button .label-text{display:block;width:100%;padding:6px 2px 6px 8px;cursor:pointer}.react-dat-gui li.folder{display:block;padding:0}.react-dat-gui li.folder .title{font-weight:700;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;cursor:pointer;padding:5px 5px 5px 16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 48% no-repeat}.react-dat-gui li.folder ul{margin-left:4px;width:calc(100% - 4px)}.react-dat-gui li.folder.closed .title{background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==) 6px 48% no-repeat}.react-dat-gui li.folder.closed ul{display:none}.react-dat-gui .cr.number{border-left:5px solid #2fa1d6}.react-dat-gui .cr.number input[type=number],.react-dat-gui .cr.number input[type=text]{color:#2fa1d6;height:25px}.react-dat-gui .cr.number .slider{display:block;position:relative;border:3px solid #1a1a1a;border-right-width:1px;background-color:#303030;background-image:linear-gradient(90deg,#2fa1d6,#2fa1d6);background-size:0 100%;background-repeat:no-repeat;cursor:ew-resize;height:25px}.react-dat-gui .cr.string{border-left:5px solid #1ed36f}.react-dat-gui .cr.string input[type=text]{color:#1ed36f;padding:2px 5px;width:100%}.react-dat-gui .cr.select{border-left:5px solid #f4d450}.react-dat-gui .cr.select label{padding:6px 2px 6px 8px}.react-dat-gui .cr.color{border-left:5px solid #1a1a1a}.react-dat-gui .cr.color .swatch{text-align:center;font-weight:700;color:#fff;text-shadow:rgba(0,0,0,.7) 0 1px 1px;padding:2px 5px;border:3px solid #1a1a1a;cursor:pointer}.react-dat-gui .cr.color .popover{position:absolute;z-index:2;right:5px}.react-dat-gui .cr.color .cover{position:fixed;top:0;right:0;bottom:0;left:0}.react-dat-gui .cr.color .picker{background:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 4px 8px rgba(0,0,0,.3);box-sizing:initial;width:auto;font-family:Menlo,sans-serif;margin-top:-3px}.react-dat-gui .cr.color .picker .body{padding:0}.react-dat-gui .cr.color .picker .body .controls{display:flex}.react-dat-gui .cr.color .picker .body .controls .toggles{flex:1}.react-dat-gui .cr.color .picker .body .controls .toggles .hue-wrap{height:10px;position:relative}.react-dat-gui .cr.color .picker .saturation-wrap{width:100%;padding-bottom:55%;position:relative;overflow:hidden}.react-dat-gui .cr.color .fields-wrap{display:flex}.react-dat-gui .cr.color .fields-wrap .fields{flex:1;display:flex;margin-left:-6px}.react-dat-gui .cr.color .fields-wrap .fields .field{padding-left:6px;width:100%}.react-dat-gui .cr.color .fields-wrap .fields .field input{font-size:11px;color:#333;border-radius:2px;border:none;box-shadow:inset 0 0 0 1px #dadada;height:21px;text-align:center}.react-dat-gui .cr.color .fields-wrap .fields .field input:focus{outline:none}.react-dat-gui .cr.color .fields-wrap .fields .field label{text-transform:uppercase;font-size:11px;line-height:11px;color:#969696;text-align:center;display:block;margin-top:12px}.react-dat-gui .cr.color .pointer{width:12px;height:12px;border-radius:6px;transform:translate(-6px,-1px);background-color:#f8f8f8;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);position:absolute;z-index:3}.react-dat-gui .cr.color .pointer-circle{width:12px;height:12px;border-radius:6px;box-shadow:inset 0 0 0 1px #fff;transform:translate(-6px,-6px)}.react-dat-gui .cr.presets{border-left:5px solid #dad5cb}.react-dat-gui .cr.presets label{padding:6px 2px 6px 8px}.react-dat-gui .cr.presets label select{width:100%}";
	styleInject(css_248z);

	var css_248z$1 = "\r\nhtml, body {\r\n  background: #222;\r\n  color: #FFF;\r\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\r\n  font-size: 14px;\r\n}\r\n\r\n.examples {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.examples_header {\r\n  background: #666;\r\n  padding: 10px 20px;\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.stats_toggle {\r\n  margin-left: auto;\r\n}\r\n\r\n.vr_button {\r\n  margin-left: 20px;\r\n}\r\n\r\n.examples_header h1 {\r\n  font-size: 16px;\r\n  margin: 0 20px 0 0;\r\n}\r\n\r\n.examples_header .repo_link {\r\n  margin-left: 30px;\r\n  text-decoration: none;\r\n}\r\n.examples_header .repo_link > img {\r\n  vertical-align: bottom;\r\n}\r\n\r\n\r\na {\r\n  color: #00b3ee;\r\n}\r\n\r\n.examples_body {\r\n  position: relative;\r\n  flex: 1;\r\n  overflow: hidden;\r\n}\r\n\r\n.example_controls {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  padding: 10px;\r\n  z-index: 10;\r\n  display: flex;\r\n  flex-direction: column;\r\n  background: rgba(34, 34, 34, 0.8);\r\n}\r\n\r\n.example_desc {\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  padding: 10px 20px;\r\n  background: rgba(255,255,255,.1);\r\n}\r\n\r\n.react-dat-gui {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  max-height: 80%;\r\n  overflow: auto;\r\n}";
	styleInject(css_248z$1);

	var EXAMPLES = [
	  { id: 'ui', name: 'User Interface', component: UIExample } ];

	var ExamplesApp = /*@__PURE__*/(function (superclass) {
	  function ExamplesApp(props) {
	    superclass.call(this, props);
	    this.state = {
	      selectedExampleId: (location.hash && location.hash.replace(/^#/, '')) || EXAMPLES[0].id,
	      bodyWidth: null,
	      bodyHeight: null,
	      stats: true
	    };
	    this._onBodyElRef = this._onBodyElRef.bind(this);
	    this._onWindowResize = this._onWindowResize.bind(this);
	    this._onHashChange = this._onHashChange.bind(this);
	    this._onExampleSelect = this._onExampleSelect.bind(this);
	    this._onToggleStats = this._onToggleStats.bind(this);
	  }

	  if ( superclass ) ExamplesApp.__proto__ = superclass;
	  ExamplesApp.prototype = Object.create( superclass && superclass.prototype );
	  ExamplesApp.prototype.constructor = ExamplesApp;
	  ExamplesApp.prototype.componentWillMount = function componentWillMount () {
	    window.addEventListener('hashchange', this._onHashChange, false);
	    window.addEventListener('resize', this._onWindowResize, false);
	  };

	  ExamplesApp.prototype.componentWillUnmount = function componentWillUnmount () {
	    window.removeEventListener('hashchange', this._onHashChange, false);
	    window.removeEventListener('resize', this._onWindowResize, false);
	  };

	  ExamplesApp.prototype._onBodyElRef = function _onBodyElRef (el) {
	    this._bodyEl = el;
	    if (el) {
	      this._onWindowResize();
	    }
	  };

	  ExamplesApp.prototype._onWindowResize = function _onWindowResize () {
	    var box = this._bodyEl.getBoundingClientRect();
	    this.setState({ bodyWidth: box.width, bodyHeight: box.height });
	  };

	  ExamplesApp.prototype._onHashChange = function _onHashChange () {
	    var this$1 = this;

	    var selectedExampleId = location.hash.replace(/^#/, '');
	    var exampleObj = EXAMPLES.filter(function (ref) {
	      var id = ref.id;

	      return id === selectedExampleId;
	    })[0];
	    if (exampleObj) {
	      if (exampleObj.disableXR && this.props.xrSession) {
	        this.props.xrSession.end().then(function () {
	          this$1.setState({ selectedExampleId: selectedExampleId });
	        });
	      } else {
	        this.setState({ selectedExampleId: selectedExampleId });
	      }
	    }
	  };

	  ExamplesApp.prototype._onExampleSelect = function _onExampleSelect (e) {
	    location.hash = e.target.value;
	  };

	  ExamplesApp.prototype._onToggleStats = function _onToggleStats () {
	    this.setState({ stats: !this.state.stats });
	  };

	  ExamplesApp.prototype.render = function render () {
	    var ref = this.state;
	    var selectedExampleId = ref.selectedExampleId;
	    var bodyWidth = ref.bodyWidth;
	    var bodyHeight = ref.bodyHeight;
	    ref.stats;
	    var example = EXAMPLES.filter(function (ref) {
	      var id = ref.id;

	      return id === 'ui';
	    })[0];
	    var ExampleCmp = example && example.component;

	    return (
	      react.createElement( 'div', { className: "examples" }, 
	        react.createElement( 'section', { className: "examples_body", ref: this._onBodyElRef }, 
	          ExampleCmp ?
	            (bodyWidth && bodyHeight ? react.createElement( ExampleCmp, {
	              width: bodyWidth, height: bodyHeight, vr: !!this.props.xrSession && !example.disableXR }) : null) :
	            ("Unknown example: " + selectedExampleId), 
	          react.createElement( 'div', { id: "react-dat-gui-portal" })
	        )
	      )
	    )
	  };

	  return ExamplesApp;
	}(react.Component));

	ExamplesApp = ReactXRAware(ExamplesApp, {
	  // For now, none of the examples make use of floor-relative tracking, so let's just
	  // limit it to a 'local' space to make it easier to keep things at eye height.
	  // TODO: figure out a good approach for floor-relative tracking for any future
	  //  examples that make use of it.
	  referenceSpaces: ['local']
	});

	reactDom.render(react.createElement( ExamplesApp, null ), document.getElementById('app'));

}());
